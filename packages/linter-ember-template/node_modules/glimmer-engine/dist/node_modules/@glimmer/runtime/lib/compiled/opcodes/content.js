"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var upsert_1 = require("../../upsert");
var interfaces_1 = require("../../component/interfaces");
var opcodes_1 = require("../../opcodes");
var expressions_1 = require("../expressions");
var update_1 = require("../../vm/update");
var reference_1 = require("@glimmer/reference");
var util_1 = require("@glimmer/util");
var bounds_1 = require("../../bounds");
var builder_1 = require("../../builder");
var builder_2 = require("./builder");
var references_1 = require("../../references");
var builder_3 = require("../../builder");
var opcodes_2 = require("../../opcodes");
opcodes_2.APPEND_OPCODES.add(opcodes_2.OpcodeName.DynamicContent, function (vm, _a) {
    var append = _a.op1;
    var opcode = vm.constants.getOther(append);
    opcode.evaluate(vm);
});
function isEmpty(value) {
    return value === null || value === undefined || typeof value['toString'] !== 'function';
}
function normalizeTextValue(value) {
    if (isEmpty(value)) {
        return '';
    }
    return String(value);
}
exports.normalizeTextValue = normalizeTextValue;
function normalizeTrustedValue(value) {
    if (isEmpty(value)) {
        return '';
    }
    if (upsert_1.isString(value)) {
        return value;
    }
    if (upsert_1.isSafeString(value)) {
        return value.toHTML();
    }
    if (upsert_1.isNode(value)) {
        return value;
    }
    return String(value);
}
function normalizeValue(value) {
    if (isEmpty(value)) {
        return '';
    }
    if (upsert_1.isString(value)) {
        return value;
    }
    if (upsert_1.isSafeString(value) || upsert_1.isNode(value)) {
        return value;
    }
    return String(value);
}
var AppendDynamicOpcode = (function () {
    function AppendDynamicOpcode() {
    }
    AppendDynamicOpcode.prototype.evaluate = function (vm) {
        var reference = vm.frame.getOperand();
        var normalized = this.normalize(reference);
        var value, cache;
        if (reference_1.isConst(reference)) {
            value = normalized.value();
        }
        else {
            cache = new reference_1.ReferenceCache(normalized);
            value = cache.peek();
        }
        var stack = vm.stack();
        var upsert = this.insert(vm.env.getAppendOperations(), stack, value);
        var bounds = new builder_1.Fragment(upsert.bounds);
        stack.newBounds(bounds);
        if (cache /* i.e. !isConst(reference) */) {
            vm.updateWith(this.updateWith(vm, reference, cache, bounds, upsert));
        }
    };
    return AppendDynamicOpcode;
}());
exports.AppendDynamicOpcode = AppendDynamicOpcode;
var GuardedAppendOpcode = (function (_super) {
    __extends(GuardedAppendOpcode, _super);
    function GuardedAppendOpcode(expression, symbolTable) {
        var _this = _super.call(this) || this;
        _this.expression = expression;
        _this.symbolTable = symbolTable;
        _this.deopted = null;
        return _this;
    }
    GuardedAppendOpcode.prototype.evaluate = function (vm) {
        if (this.deopted) {
            vm.pushEvalFrame(this.deopted);
        }
        else {
            vm.evaluateOperand(this.expression);
            var value = vm.frame.getOperand().value();
            if (interfaces_1.isComponentDefinition(value)) {
                vm.pushEvalFrame(this.deopt(vm.env));
            }
            else {
                _super.prototype.evaluate.call(this, vm);
            }
        }
    };
    GuardedAppendOpcode.prototype.deopt = function (env) {
        // At compile time, we determined that this append callsite might refer
        // to a local variable/property lookup that resolves to a component
        // definition at runtime.
        //
        // We could have eagerly compiled this callsite into something like this:
        //
        //   {{#if (is-component-definition foo)}}
        //     {{component foo}}
        //   {{else}}
        //     {{foo}}
        //   {{/if}}
        //
        // However, in practice, there might be a large amout of these callsites
        // and most of them would resolve to a simple value lookup. Therefore, we
        // tried to be optimistic and assumed that the callsite will resolve to
        // appending a simple value.
        //
        // However, we have reached here because at runtime, the guard conditional
        // have detected that this callsite is indeed referring to a component
        // definition object. Since this is likely going to be true for other
        // instances of the same callsite, it is now appropiate to deopt into the
        // expanded version that handles both cases. The compilation would look
        // like this:
        //
        //               PutValue(expression)
        //               Test(is-component-definition)
        //               Enter(BEGIN, END)
        //   BEGIN:      Noop
        //               JumpUnless(VALUE)
        //               PutDynamicComponentDefinitionOpcode
        //               OpenComponent
        //               CloseComponent
        //               Jump(END)
        //   VALUE:      Noop
        //               OptimizedAppend
        //   END:        Noop
        //               Exit
        //
        // Keep in mind that even if we *don't* reach here at initial render time,
        // it is still possible (although quite rare) that the simple value we
        // encounter during initial render could later change into a component
        // definition object at update time. That is handled by the "lazy deopt"
        // code on the update side (scroll down for the next big block of comment).
        var _this = this;
        var dsl = new builder_2.default(this.symbolTable, env);
        dsl.putValue(this.expression);
        dsl.test(IsComponentDefinitionReference.create);
        dsl.labelled(null, function (dsl, _BEGIN, END) {
            dsl.jumpUnless('VALUE');
            dsl.putDynamicComponentDefinition();
            dsl.openComponent(expressions_1.CompiledArgs.empty());
            dsl.closeComponent();
            dsl.jump(END);
            dsl.label('VALUE');
            dsl.dynamicContent(new _this.AppendOpcode());
        });
        var deopted = this.deopted = dsl.toSlice();
        // From this point on, we have essentially replaced ourselves with a new set
        // of opcodes. Since we will always be executing the new/deopted code, it's
        // a good idea (as a pattern) to null out any unneeded fields here to avoid
        // holding on to unneeded/stale objects:
        // QUESTION: Shouldn't this whole object be GCed? If not, why not?
        this.expression = null;
        return deopted;
    };
    return GuardedAppendOpcode;
}(AppendDynamicOpcode));
exports.GuardedAppendOpcode = GuardedAppendOpcode;
var IsComponentDefinitionReference = (function (_super) {
    __extends(IsComponentDefinitionReference, _super);
    function IsComponentDefinitionReference() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IsComponentDefinitionReference.create = function (inner) {
        return new IsComponentDefinitionReference(inner);
    };
    IsComponentDefinitionReference.prototype.toBool = function (value) {
        return interfaces_1.isComponentDefinition(value);
    };
    return IsComponentDefinitionReference;
}(references_1.ConditionalReference));
var UpdateOpcode = (function (_super) {
    __extends(UpdateOpcode, _super);
    function UpdateOpcode(cache, bounds, upsert) {
        var _this = _super.call(this) || this;
        _this.cache = cache;
        _this.bounds = bounds;
        _this.upsert = upsert;
        _this.tag = cache.tag;
        return _this;
    }
    UpdateOpcode.prototype.evaluate = function (vm) {
        var value = this.cache.revalidate();
        if (reference_1.isModified(value)) {
            var _a = this, bounds = _a.bounds, upsert = _a.upsert;
            var dom = vm.dom;
            if (!this.upsert.update(dom, value)) {
                var cursor = new bounds_1.Cursor(bounds.parentElement(), bounds_1.clear(bounds));
                upsert = this.upsert = this.insert(vm.env.getAppendOperations(), cursor, value);
            }
            bounds.update(upsert.bounds);
        }
    };
    UpdateOpcode.prototype.toJSON = function () {
        var _a = this, guid = _a._guid, type = _a.type, cache = _a.cache;
        return {
            guid: guid,
            type: type,
            details: { lastValue: JSON.stringify(cache.peek()) }
        };
    };
    return UpdateOpcode;
}(opcodes_1.UpdatingOpcode));
var GuardedUpdateOpcode = (function (_super) {
    __extends(GuardedUpdateOpcode, _super);
    function GuardedUpdateOpcode(reference, cache, bounds, upsert, appendOpcode, state) {
        var _this = _super.call(this, cache, bounds, upsert) || this;
        _this.reference = reference;
        _this.appendOpcode = appendOpcode;
        _this.state = state;
        _this.deopted = null;
        _this.tag = _this._tag = new reference_1.UpdatableTag(_this.tag);
        return _this;
    }
    GuardedUpdateOpcode.prototype.evaluate = function (vm) {
        if (this.deopted) {
            vm.evaluateOpcode(this.deopted);
        }
        else {
            if (interfaces_1.isComponentDefinition(this.reference.value())) {
                this.lazyDeopt(vm);
            }
            else {
                _super.prototype.evaluate.call(this, vm);
            }
        }
    };
    GuardedUpdateOpcode.prototype.lazyDeopt = function (vm) {
        // Durign initial render, we know that the reference does not contain a
        // component definition, so we optimistically assumed that this append
        // is just a normal append. However, at update time, we discovered that
        // the reference has switched into containing a component definition, so
        // we need to do a "lazy deopt", simulating what would have happened if
        // we had decided to perform the deopt in the first place during initial
        // render.
        //
        // More concretely, we would have expanded the curly into a if/else, and
        // based on whether the value is a component definition or not, we would
        // have entered either the dynamic component branch or the simple value
        // branch.
        //
        // Since we rendered a simple value during initial render (and all the
        // updates up until this point), we need to pretend that the result is
        // produced by the "VALUE" branch of the deopted append opcode:
        //
        //   Try(BEGIN, END)
        //     Assert(IsComponentDefinition, expected=false)
        //     OptimizedUpdate
        //
        // In this case, because the reference has switched from being a simple
        // value into a component definition, what would have happened is that
        // the assert would throw, causing the Try opcode to teardown the bounds
        // and rerun the original append opcode.
        //
        // Since the Try opcode would have nuked the updating opcodes anyway, we
        // wouldn't have to worry about simulating those. All we have to do is to
        // execute the Try opcode and immediately throw.
        var _a = this, bounds = _a.bounds, appendOpcode = _a.appendOpcode, state = _a.state;
        var env = vm.env;
        var slice = appendOpcode.deopt(env);
        var enter = util_1.expect(env.program.opcode(slice[0] + 8), 'hardcoded deopt location');
        var ops = vm.constants.getSlice(enter.op1);
        var tracker = new builder_3.UpdatableBlockTracker(bounds.parentElement());
        tracker.newBounds(this.bounds);
        var children = new util_1.LinkedList();
        state.frame['condition'] = IsComponentDefinitionReference.create(util_1.expect(state.frame['operand'], 'operand should be populated'));
        var deopted = this.deopted = new update_1.TryOpcode(ops, state, tracker, children);
        this._tag.update(deopted.tag);
        vm.evaluateOpcode(deopted);
        vm.throw();
        // From this point on, we have essentially replaced ourselve with a new
        // opcode. Since we will always be executing the new/deopted code, it's a
        // good idea (as a pattern) to null out any unneeded fields here to avoid
        // holding on to unneeded/stale objects:
        // QUESTION: Shouldn't this whole object be GCed? If not, why not?
        this._tag = null;
        this.reference = null;
        this.cache = null;
        this.bounds = null;
        this.upsert = null;
        this.appendOpcode = null;
        this.state = null;
    };
    GuardedUpdateOpcode.prototype.toJSON = function () {
        var _a = this, guid = _a._guid, type = _a.type, deopted = _a.deopted;
        if (deopted) {
            return {
                guid: guid,
                type: type,
                deopted: true,
                children: [deopted.toJSON()]
            };
        }
        else {
            return _super.prototype.toJSON.call(this);
        }
    };
    return GuardedUpdateOpcode;
}(UpdateOpcode));
var OptimizedCautiousAppendOpcode = (function (_super) {
    __extends(OptimizedCautiousAppendOpcode, _super);
    function OptimizedCautiousAppendOpcode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'optimized-cautious-append';
        return _this;
    }
    OptimizedCautiousAppendOpcode.prototype.normalize = function (reference) {
        return reference_1.map(reference, normalizeValue);
    };
    OptimizedCautiousAppendOpcode.prototype.insert = function (dom, cursor, value) {
        return upsert_1.cautiousInsert(dom, cursor, value);
    };
    OptimizedCautiousAppendOpcode.prototype.updateWith = function (_vm, _reference, cache, bounds, upsert) {
        return new OptimizedCautiousUpdateOpcode(cache, bounds, upsert);
    };
    return OptimizedCautiousAppendOpcode;
}(AppendDynamicOpcode));
exports.OptimizedCautiousAppendOpcode = OptimizedCautiousAppendOpcode;
var OptimizedCautiousUpdateOpcode = (function (_super) {
    __extends(OptimizedCautiousUpdateOpcode, _super);
    function OptimizedCautiousUpdateOpcode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'optimized-cautious-update';
        return _this;
    }
    OptimizedCautiousUpdateOpcode.prototype.insert = function (dom, cursor, value) {
        return upsert_1.cautiousInsert(dom, cursor, value);
    };
    return OptimizedCautiousUpdateOpcode;
}(UpdateOpcode));
var GuardedCautiousAppendOpcode = (function (_super) {
    __extends(GuardedCautiousAppendOpcode, _super);
    function GuardedCautiousAppendOpcode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'guarded-cautious-append';
        _this.AppendOpcode = OptimizedCautiousAppendOpcode;
        return _this;
    }
    GuardedCautiousAppendOpcode.prototype.normalize = function (reference) {
        return reference_1.map(reference, normalizeValue);
    };
    GuardedCautiousAppendOpcode.prototype.insert = function (dom, cursor, value) {
        return upsert_1.cautiousInsert(dom, cursor, value);
    };
    GuardedCautiousAppendOpcode.prototype.updateWith = function (vm, reference, cache, bounds, upsert) {
        return new GuardedCautiousUpdateOpcode(reference, cache, bounds, upsert, this, vm.capture());
    };
    return GuardedCautiousAppendOpcode;
}(GuardedAppendOpcode));
exports.GuardedCautiousAppendOpcode = GuardedCautiousAppendOpcode;
var GuardedCautiousUpdateOpcode = (function (_super) {
    __extends(GuardedCautiousUpdateOpcode, _super);
    function GuardedCautiousUpdateOpcode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'guarded-cautious-update';
        return _this;
    }
    GuardedCautiousUpdateOpcode.prototype.insert = function (dom, cursor, value) {
        return upsert_1.cautiousInsert(dom, cursor, value);
    };
    return GuardedCautiousUpdateOpcode;
}(GuardedUpdateOpcode));
var OptimizedTrustingAppendOpcode = (function (_super) {
    __extends(OptimizedTrustingAppendOpcode, _super);
    function OptimizedTrustingAppendOpcode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'optimized-trusting-append';
        return _this;
    }
    OptimizedTrustingAppendOpcode.prototype.normalize = function (reference) {
        return reference_1.map(reference, normalizeTrustedValue);
    };
    OptimizedTrustingAppendOpcode.prototype.insert = function (dom, cursor, value) {
        return upsert_1.trustingInsert(dom, cursor, value);
    };
    OptimizedTrustingAppendOpcode.prototype.updateWith = function (_vm, _reference, cache, bounds, upsert) {
        return new OptimizedTrustingUpdateOpcode(cache, bounds, upsert);
    };
    return OptimizedTrustingAppendOpcode;
}(AppendDynamicOpcode));
exports.OptimizedTrustingAppendOpcode = OptimizedTrustingAppendOpcode;
var OptimizedTrustingUpdateOpcode = (function (_super) {
    __extends(OptimizedTrustingUpdateOpcode, _super);
    function OptimizedTrustingUpdateOpcode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'optimized-trusting-update';
        return _this;
    }
    OptimizedTrustingUpdateOpcode.prototype.insert = function (dom, cursor, value) {
        return upsert_1.trustingInsert(dom, cursor, value);
    };
    return OptimizedTrustingUpdateOpcode;
}(UpdateOpcode));
var GuardedTrustingAppendOpcode = (function (_super) {
    __extends(GuardedTrustingAppendOpcode, _super);
    function GuardedTrustingAppendOpcode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'guarded-trusting-append';
        _this.AppendOpcode = OptimizedTrustingAppendOpcode;
        return _this;
    }
    GuardedTrustingAppendOpcode.prototype.normalize = function (reference) {
        return reference_1.map(reference, normalizeTrustedValue);
    };
    GuardedTrustingAppendOpcode.prototype.insert = function (dom, cursor, value) {
        return upsert_1.trustingInsert(dom, cursor, value);
    };
    GuardedTrustingAppendOpcode.prototype.updateWith = function (vm, reference, cache, bounds, upsert) {
        return new GuardedTrustingUpdateOpcode(reference, cache, bounds, upsert, this, vm.capture());
    };
    return GuardedTrustingAppendOpcode;
}(GuardedAppendOpcode));
exports.GuardedTrustingAppendOpcode = GuardedTrustingAppendOpcode;
var GuardedTrustingUpdateOpcode = (function (_super) {
    __extends(GuardedTrustingUpdateOpcode, _super);
    function GuardedTrustingUpdateOpcode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'trusting-update';
        return _this;
    }
    GuardedTrustingUpdateOpcode.prototype.insert = function (dom, cursor, value) {
        return upsert_1.trustingInsert(dom, cursor, value);
    };
    return GuardedTrustingUpdateOpcode;
}(GuardedUpdateOpcode));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIkBnbGltbWVyL3J1bnRpbWUvbGliL2NvbXBpbGVkL29wY29kZXMvY29udGVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSx1Q0FXc0I7QUFDdEIseURBQW1FO0FBRW5FLHlDQUEyRDtBQUMzRCw4Q0FBa0U7QUFFbEUsMENBQXFEO0FBQ3JELGdEQUF1RztBQUN2RyxzQ0FBMEU7QUFDMUUsdUNBQTZDO0FBQzdDLHlDQUF5QztBQUN6QyxxQ0FBeUM7QUFDekMsK0NBQXdEO0FBRXhELHlDQUFzRDtBQUV0RCx5Q0FBd0U7QUFFeEUsd0JBQWMsQ0FBQyxHQUFHLENBQUMsb0JBQUUsQ0FBQyxjQUFjLEVBQUUsVUFBQyxFQUFFLEVBQUUsRUFBZTtRQUFiLGVBQVc7SUFDdEQsSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFtQyxDQUFDO0lBQzdFLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDdEIsQ0FBQyxDQUFDLENBQUM7QUFFSCxpQkFBaUIsS0FBYTtJQUM1QixNQUFNLENBQUMsS0FBSyxLQUFLLElBQUksSUFBSSxLQUFLLEtBQUssU0FBUyxJQUFJLE9BQU8sS0FBSyxDQUFDLFVBQVUsQ0FBQyxLQUFLLFVBQVUsQ0FBQztBQUMxRixDQUFDO0FBRUQsNEJBQW1DLEtBQWE7SUFDOUMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuQixNQUFNLENBQUMsRUFBRSxDQUFDO0lBQ1osQ0FBQztJQUNELE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDdkIsQ0FBQztBQUxELGdEQUtDO0FBRUQsK0JBQStCLEtBQWE7SUFDMUMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuQixNQUFNLENBQUMs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QyxBQU5ELENBQTBDLG1CQUFtQixHQU01RCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBVcHNlcnQsIHtcbiAgSW5zZXJ0aW9uLFxuICBDYXV0aW91c0luc2VydGlvbixcbiAgVHJ1c3RpbmdJbnNlcnRpb24sXG5cbiAgaXNTYWZlU3RyaW5nLFxuICBpc05vZGUsXG4gIGlzU3RyaW5nLFxuXG4gIGNhdXRpb3VzSW5zZXJ0LFxuICB0cnVzdGluZ0luc2VydFxufSBmcm9tICcuLi8uLi91cHNlcnQnO1xuaW1wb3J0IHsgaXNDb21wb25lbnREZWZpbml0aW9uIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50L2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgRE9NVHJlZUNvbnN0cnVjdGlvbiB9IGZyb20gJy4uLy4uL2RvbS9oZWxwZXInO1xuaW1wb3J0IHsgT3Bjb2RlSlNPTiwgVXBkYXRpbmdPcGNvZGUgfSBmcm9tICcuLi8uLi9vcGNvZGVzJztcbmltcG9ydCB7IENvbXBpbGVkRXhwcmVzc2lvbiwgQ29tcGlsZWRBcmdzIH0gZnJvbSAnLi4vZXhwcmVzc2lvbnMnO1xuaW1wb3J0IHsgVk0sIFVwZGF0aW5nVk0gfSBmcm9tICcuLi8uLi92bSc7XG5pbXBvcnQgeyBUcnlPcGNvZGUsIFZNU3RhdGUgfSBmcm9tICcuLi8uLi92bS91cGRhdGUnO1xuaW1wb3J0IHsgUmVmZXJlbmNlLCBSZWZlcmVuY2VDYWNoZSwgVXBkYXRhYmxlVGFnLCBpc01vZGlmaWVkLCBpc0NvbnN0LCBtYXAgfSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuaW1wb3J0IHsgRklYTUUsIE9wdGlvbiwgT3BhcXVlLCBMaW5rZWRMaXN0LCBleHBlY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IEN1cnNvciwgY2xlYXIgfSBmcm9tICcuLi8uLi9ib3VuZHMnO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tICcuLi8uLi9idWlsZGVyJztcbmltcG9ydCBPcGNvZGVCdWlsZGVyRFNMIGZyb20gJy4vYnVpbGRlcic7XG5pbXBvcnQgeyBDb25kaXRpb25hbFJlZmVyZW5jZSB9IGZyb20gJy4uLy4uL3JlZmVyZW5jZXMnO1xuaW1wb3J0IHsgRW52aXJvbm1lbnQgfSBmcm9tICcuLi8uLi9lbnZpcm9ubWVudCc7XG5pbXBvcnQgeyBVcGRhdGFibGVCbG9ja1RyYWNrZXIgfSBmcm9tICcuLi8uLi9idWlsZGVyJztcbmltcG9ydCB7IFN5bWJvbFRhYmxlIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBBUFBFTkRfT1BDT0RFUywgT3Bjb2RlTmFtZSBhcyBPcCwgU2xpY2UgfSBmcm9tICcuLi8uLi9vcGNvZGVzJztcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkR5bmFtaWNDb250ZW50LCAodm0sIHsgb3AxOiBhcHBlbmQgfSkgPT4ge1xuICBsZXQgb3Bjb2RlID0gdm0uY29uc3RhbnRzLmdldE90aGVyKGFwcGVuZCkgYXMgQXBwZW5kRHluYW1pY09wY29kZTxJbnNlcnRpb24+O1xuICBvcGNvZGUuZXZhbHVhdGUodm0pO1xufSk7XG5cbmZ1bmN0aW9uIGlzRW1wdHkodmFsdWU6IE9wYXF1ZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdmFsdWVbJ3RvU3RyaW5nJ10gIT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVUZXh0VmFsdWUodmFsdWU6IE9wYXF1ZSk6IHN0cmluZyB7XG4gIGlmIChpc0VtcHR5KHZhbHVlKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVHJ1c3RlZFZhbHVlKHZhbHVlOiBPcGFxdWUpOiBUcnVzdGluZ0luc2VydGlvbiB7XG4gIGlmIChpc0VtcHR5KHZhbHVlKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1NhZmVTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvSFRNTCgpO1xuICB9XG4gIGlmIChpc05vZGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZTogT3BhcXVlKTogQ2F1dGlvdXNJbnNlcnRpb24ge1xuICBpZiAoaXNFbXB0eSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTYWZlU3RyaW5nKHZhbHVlKSB8fCBpc05vZGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUpO1xufVxuXG5leHBvcnQgdHlwZSBBcHBlbmREeW5hbWljT3Bjb2RlQ29uc3RydWN0b3IgPSAgdHlwZW9mIE9wdGltaXplZENhdXRpb3VzQXBwZW5kT3Bjb2RlIHwgdHlwZW9mIE9wdGltaXplZFRydXN0aW5nQXBwZW5kT3Bjb2RlO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQXBwZW5kRHluYW1pY09wY29kZTxUIGV4dGVuZHMgSW5zZXJ0aW9uPiB7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBub3JtYWxpemUocmVmZXJlbmNlOiBSZWZlcmVuY2U8T3BhcXVlPik6IFJlZmVyZW5jZTxUPjtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IGluc2VydChkb206IERPTVRyZWVDb25zdHJ1Y3Rpb24sIGN1cnNvcjogQ3Vyc29yLCB2YWx1ZTogVCk6IFVwc2VydDtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IHVwZGF0ZVdpdGgodm06IFZNLCByZWZlcmVuY2U6IFJlZmVyZW5jZTxPcGFxdWU+LCBjYWNoZTogUmVmZXJlbmNlQ2FjaGU8VD4sIGJvdW5kczogRnJhZ21lbnQsIHVwc2VydDogVXBzZXJ0KTogVXBkYXRpbmdPcGNvZGU7XG5cbiAgZXZhbHVhdGUodm06IFZNKSB7XG4gICAgbGV0IHJlZmVyZW5jZSA9IHZtLmZyYW1lLmdldE9wZXJhbmQoKTtcbiAgICBsZXQgbm9ybWFsaXplZCA9IHRoaXMubm9ybWFsaXplKHJlZmVyZW5jZSk7XG5cbiAgICBsZXQgdmFsdWUsIGNhY2hlO1xuXG4gICAgaWYgKGlzQ29uc3QocmVmZXJlbmNlKSkge1xuICAgICAgdmFsdWUgPSBub3JtYWxpemVkLnZhbHVlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlID0gbmV3IFJlZmVyZW5jZUNhY2hlKG5vcm1hbGl6ZWQpO1xuICAgICAgdmFsdWUgPSBjYWNoZS5wZWVrKCk7XG4gICAgfVxuXG4gICAgbGV0IHN0YWNrID0gdm0uc3RhY2soKTtcbiAgICBsZXQgdXBzZXJ0ID0gdGhpcy5pbnNlcnQodm0uZW52LmdldEFwcGVuZE9wZXJhdGlvbnMoKSwgc3RhY2ssIHZhbHVlKTtcbiAgICBsZXQgYm91bmRzID0gbmV3IEZyYWdtZW50KHVwc2VydC5ib3VuZHMpO1xuXG4gICAgc3RhY2submV3Qm91bmRzKGJvdW5kcyk7XG5cbiAgICBpZiAoY2FjaGUgLyogaS5lLiAhaXNDb25zdChyZWZlcmVuY2UpICovKSB7XG4gICAgICB2bS51cGRhdGVXaXRoKHRoaXMudXBkYXRlV2l0aCh2bSwgcmVmZXJlbmNlLCBjYWNoZSwgYm91bmRzLCB1cHNlcnQpKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEd1YXJkZWRBcHBlbmRPcGNvZGU8VCBleHRlbmRzIEluc2VydGlvbj4gZXh0ZW5kcyBBcHBlbmREeW5hbWljT3Bjb2RlPFQ+IHtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IEFwcGVuZE9wY29kZTogdHlwZW9mIE9wdGltaXplZENhdXRpb3VzQXBwZW5kT3Bjb2RlIHwgdHlwZW9mIE9wdGltaXplZFRydXN0aW5nQXBwZW5kT3Bjb2RlO1xuICBwcml2YXRlIGRlb3B0ZWQ6IE9wdGlvbjxTbGljZT4gPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZXhwcmVzc2lvbjogQ29tcGlsZWRFeHByZXNzaW9uPGFueT4sIHByaXZhdGUgc3ltYm9sVGFibGU6IFN5bWJvbFRhYmxlKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIGV2YWx1YXRlKHZtOiBWTSkge1xuICAgIGlmICh0aGlzLmRlb3B0ZWQpIHtcbiAgICAgIHZtLnB1c2hFdmFsRnJhbWUodGhpcy5kZW9wdGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uZXZhbHVhdGVPcGVyYW5kKHRoaXMuZXhwcmVzc2lvbik7XG5cbiAgICAgIGxldCB2YWx1ZSA9IHZtLmZyYW1lLmdldE9wZXJhbmQoKS52YWx1ZSgpO1xuXG4gICAgICBpZihpc0NvbXBvbmVudERlZmluaXRpb24odmFsdWUpKSB7XG4gICAgICAgIHZtLnB1c2hFdmFsRnJhbWUodGhpcy5kZW9wdCh2bS5lbnYpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1cGVyLmV2YWx1YXRlKHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZGVvcHQoZW52OiBFbnZpcm9ubWVudCk6IFNsaWNlIHsgLy8gUHVibGljIGJlY2F1c2UgaXQncyB1c2VkIGluIHRoZSBsYXp5IGRlb3B0XG4gICAgLy8gQXQgY29tcGlsZSB0aW1lLCB3ZSBkZXRlcm1pbmVkIHRoYXQgdGhpcyBhcHBlbmQgY2FsbHNpdGUgbWlnaHQgcmVmZXJcbiAgICAvLyB0byBhIGxvY2FsIHZhcmlhYmxlL3Byb3BlcnR5IGxvb2t1cCB0aGF0IHJlc29sdmVzIHRvIGEgY29tcG9uZW50XG4gICAgLy8gZGVmaW5pdGlvbiBhdCBydW50aW1lLlxuICAgIC8vXG4gICAgLy8gV2UgY291bGQgaGF2ZSBlYWdlcmx5IGNvbXBpbGVkIHRoaXMgY2FsbHNpdGUgaW50byBzb21ldGhpbmcgbGlrZSB0aGlzOlxuICAgIC8vXG4gICAgLy8gICB7eyNpZiAoaXMtY29tcG9uZW50LWRlZmluaXRpb24gZm9vKX19XG4gICAgLy8gICAgIHt7Y29tcG9uZW50IGZvb319XG4gICAgLy8gICB7e2Vsc2V9fVxuICAgIC8vICAgICB7e2Zvb319XG4gICAgLy8gICB7ey9pZn19XG4gICAgLy9cbiAgICAvLyBIb3dldmVyLCBpbiBwcmFjdGljZSwgdGhlcmUgbWlnaHQgYmUgYSBsYXJnZSBhbW91dCBvZiB0aGVzZSBjYWxsc2l0ZXNcbiAgICAvLyBhbmQgbW9zdCBvZiB0aGVtIHdvdWxkIHJlc29sdmUgdG8gYSBzaW1wbGUgdmFsdWUgbG9va3VwLiBUaGVyZWZvcmUsIHdlXG4gICAgLy8gdHJpZWQgdG8gYmUgb3B0aW1pc3RpYyBhbmQgYXNzdW1lZCB0aGF0IHRoZSBjYWxsc2l0ZSB3aWxsIHJlc29sdmUgdG9cbiAgICAvLyBhcHBlbmRpbmcgYSBzaW1wbGUgdmFsdWUuXG4gICAgLy9cbiAgICAvLyBIb3dldmVyLCB3ZSBoYXZlIHJlYWNoZWQgaGVyZSBiZWNhdXNlIGF0IHJ1bnRpbWUsIHRoZSBndWFyZCBjb25kaXRpb25hbFxuICAgIC8vIGhhdmUgZGV0ZWN0ZWQgdGhhdCB0aGlzIGNhbGxzaXRlIGlzIGluZGVlZCByZWZlcnJpbmcgdG8gYSBjb21wb25lbnRcbiAgICAvLyBkZWZpbml0aW9uIG9iamVjdC4gU2luY2UgdGhpcyBpcyBsaWtlbHkgZ29pbmcgdG8gYmUgdHJ1ZSBmb3Igb3RoZXJcbiAgICAvLyBpbnN0YW5jZXMgb2YgdGhlIHNhbWUgY2FsbHNpdGUsIGl0IGlzIG5vdyBhcHByb3BpYXRlIHRvIGRlb3B0IGludG8gdGhlXG4gICAgLy8gZXhwYW5kZWQgdmVyc2lvbiB0aGF0IGhhbmRsZXMgYm90aCBjYXNlcy4gVGhlIGNvbXBpbGF0aW9uIHdvdWxkIGxvb2tcbiAgICAvLyBsaWtlIHRoaXM6XG4gICAgLy9cbiAgICAvLyAgICAgICAgICAgICAgIFB1dFZhbHVlKGV4cHJlc3Npb24pXG4gICAgLy8gICAgICAgICAgICAgICBUZXN0KGlzLWNvbXBvbmVudC1kZWZpbml0aW9uKVxuICAgIC8vICAgICAgICAgICAgICAgRW50ZXIoQkVHSU4sIEVORClcbiAgICAvLyAgIEJFR0lOOiAgICAgIE5vb3BcbiAgICAvLyAgICAgICAgICAgICAgIEp1bXBVbmxlc3MoVkFMVUUpXG4gICAgLy8gICAgICAgICAgICAgICBQdXREeW5hbWljQ29tcG9uZW50RGVmaW5pdGlvbk9wY29kZVxuICAgIC8vICAgICAgICAgICAgICAgT3BlbkNvbXBvbmVudFxuICAgIC8vICAgICAgICAgICAgICAgQ2xvc2VDb21wb25lbnRcbiAgICAvLyAgICAgICAgICAgICAgIEp1bXAoRU5EKVxuICAgIC8vICAgVkFMVUU6ICAgICAgTm9vcFxuICAgIC8vICAgICAgICAgICAgICAgT3B0aW1pemVkQXBwZW5kXG4gICAgLy8gICBFTkQ6ICAgICAgICBOb29wXG4gICAgLy8gICAgICAgICAgICAgICBFeGl0XG4gICAgLy9cbiAgICAvLyBLZWVwIGluIG1pbmQgdGhhdCBldmVuIGlmIHdlICpkb24ndCogcmVhY2ggaGVyZSBhdCBpbml0aWFsIHJlbmRlciB0aW1lLFxuICAgIC8vIGl0IGlzIHN0aWxsIHBvc3NpYmxlIChhbHRob3VnaCBxdWl0ZSByYXJlKSB0aGF0IHRoZSBzaW1wbGUgdmFsdWUgd2VcbiAgICAvLyBlbmNvdW50ZXIgZHVyaW5nIGluaXRpYWwgcmVuZGVyIGNvdWxkIGxhdGVyIGNoYW5nZSBpbnRvIGEgY29tcG9uZW50XG4gICAgLy8gZGVmaW5pdGlvbiBvYmplY3QgYXQgdXBkYXRlIHRpbWUuIFRoYXQgaXMgaGFuZGxlZCBieSB0aGUgXCJsYXp5IGRlb3B0XCJcbiAgICAvLyBjb2RlIG9uIHRoZSB1cGRhdGUgc2lkZSAoc2Nyb2xsIGRvd24gZm9yIHRoZSBuZXh0IGJpZyBibG9jayBvZiBjb21tZW50KS5cblxuICAgIGxldCBkc2wgPSBuZXcgT3Bjb2RlQnVpbGRlckRTTCh0aGlzLnN5bWJvbFRhYmxlLCBlbnYpO1xuXG4gICAgZHNsLnB1dFZhbHVlKHRoaXMuZXhwcmVzc2lvbik7XG4gICAgZHNsLnRlc3QoSXNDb21wb25lbnREZWZpbml0aW9uUmVmZXJlbmNlLmNyZWF0ZSk7XG5cbiAgICBkc2wubGFiZWxsZWQobnVsbCwgKGRzbCwgX0JFR0lOLCBFTkQpID0+IHtcbiAgICAgIGRzbC5qdW1wVW5sZXNzKCdWQUxVRScpO1xuICAgICAgZHNsLnB1dER5bmFtaWNDb21wb25lbnREZWZpbml0aW9uKCk7XG4gICAgICBkc2wub3BlbkNvbXBvbmVudChDb21waWxlZEFyZ3MuZW1wdHkoKSk7XG4gICAgICBkc2wuY2xvc2VDb21wb25lbnQoKTtcbiAgICAgIGRzbC5qdW1wKEVORCk7XG4gICAgICBkc2wubGFiZWwoJ1ZBTFVFJyk7XG4gICAgICBkc2wuZHluYW1pY0NvbnRlbnQobmV3IHRoaXMuQXBwZW5kT3Bjb2RlKCkpO1xuICAgIH0pO1xuXG4gICAgbGV0IGRlb3B0ZWQgPSB0aGlzLmRlb3B0ZWQgPSBkc2wudG9TbGljZSgpO1xuXG4gICAgLy8gRnJvbSB0aGlzIHBvaW50IG9uLCB3ZSBoYXZlIGVzc2VudGlhbGx5IHJlcGxhY2VkIG91cnNlbHZlcyB3aXRoIGEgbmV3IHNldFxuICAgIC8vIG9mIG9wY29kZXMuIFNpbmNlIHdlIHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGluZyB0aGUgbmV3L2Rlb3B0ZWQgY29kZSwgaXQnc1xuICAgIC8vIGEgZ29vZCBpZGVhIChhcyBhIHBhdHRlcm4pIHRvIG51bGwgb3V0IGFueSB1bm5lZWRlZCBmaWVsZHMgaGVyZSB0byBhdm9pZFxuICAgIC8vIGhvbGRpbmcgb24gdG8gdW5uZWVkZWQvc3RhbGUgb2JqZWN0czpcblxuICAgIC8vIFFVRVNUSU9OOiBTaG91bGRuJ3QgdGhpcyB3aG9sZSBvYmplY3QgYmUgR0NlZD8gSWYgbm90LCB3aHkgbm90P1xuXG4gICAgdGhpcy5leHByZXNzaW9uID0gbnVsbCBhcyBGSVhNRTxhbnksICdRVUVTVElPTic+O1xuXG4gICAgcmV0dXJuIGRlb3B0ZWQ7XG4gIH1cbn1cblxuY2xhc3MgSXNDb21wb25lbnREZWZpbml0aW9uUmVmZXJlbmNlIGV4dGVuZHMgQ29uZGl0aW9uYWxSZWZlcmVuY2Uge1xuICBzdGF0aWMgY3JlYXRlKGlubmVyOiBSZWZlcmVuY2U8T3BhcXVlPik6IElzQ29tcG9uZW50RGVmaW5pdGlvblJlZmVyZW5jZSB7XG4gICAgcmV0dXJuIG5ldyBJc0NvbXBvbmVudERlZmluaXRpb25SZWZlcmVuY2UoaW5uZXIpO1xuICB9XG5cbiAgdG9Cb29sKHZhbHVlOiBPcGFxdWUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNDb21wb25lbnREZWZpbml0aW9uKHZhbHVlKTtcbiAgfVxufVxuXG5hYnN0cmFjdCBjbGFzcyBVcGRhdGVPcGNvZGU8VCBleHRlbmRzIEluc2VydGlvbj4gZXh0ZW5kcyBVcGRhdGluZ09wY29kZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBjYWNoZTogUmVmZXJlbmNlQ2FjaGU8VD4sXG4gICAgcHJvdGVjdGVkIGJvdW5kczogRnJhZ21lbnQsXG4gICAgcHJvdGVjdGVkIHVwc2VydDogVXBzZXJ0XG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50YWcgPSBjYWNoZS50YWc7XG4gIH1cblxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgaW5zZXJ0KGRvbTogRE9NVHJlZUNvbnN0cnVjdGlvbiwgY3Vyc29yOiBDdXJzb3IsIHZhbHVlOiBUKTogVXBzZXJ0O1xuXG4gIGV2YWx1YXRlKHZtOiBVcGRhdGluZ1ZNKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5jYWNoZS5yZXZhbGlkYXRlKCk7XG5cbiAgICBpZiAoaXNNb2RpZmllZCh2YWx1ZSkpIHtcbiAgICAgIGxldCB7IGJvdW5kcywgdXBzZXJ0IH0gPSB0aGlzO1xuICAgICAgbGV0IHsgZG9tIH0gPSB2bTtcblxuICAgICAgaWYoIXRoaXMudXBzZXJ0LnVwZGF0ZShkb20sIHZhbHVlKSkge1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IEN1cnNvcihib3VuZHMucGFyZW50RWxlbWVudCgpLCBjbGVhcihib3VuZHMpKTtcbiAgICAgICAgdXBzZXJ0ID0gdGhpcy51cHNlcnQgPSB0aGlzLmluc2VydCh2bS5lbnYuZ2V0QXBwZW5kT3BlcmF0aW9ucygpLCBjdXJzb3IsIHZhbHVlIGFzIFQpO1xuICAgICAgfVxuXG4gICAgICBib3VuZHMudXBkYXRlKHVwc2VydC5ib3VuZHMpO1xuICAgIH1cbiAgfVxuXG4gIHRvSlNPTigpOiBPcGNvZGVKU09OIHtcbiAgICBsZXQgeyBfZ3VpZDogZ3VpZCwgdHlwZSwgY2FjaGUgfSA9IHRoaXM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ3VpZCxcbiAgICAgIHR5cGUsXG4gICAgICBkZXRhaWxzOiB7IGxhc3RWYWx1ZTogSlNPTi5zdHJpbmdpZnkoY2FjaGUucGVlaygpKSB9XG4gICAgfTtcbiAgfVxufVxuXG5hYnN0cmFjdCBjbGFzcyBHdWFyZGVkVXBkYXRlT3Bjb2RlPFQgZXh0ZW5kcyBJbnNlcnRpb24+IGV4dGVuZHMgVXBkYXRlT3Bjb2RlPFQ+IHtcbiAgcHJpdmF0ZSBfdGFnOiBVcGRhdGFibGVUYWc7XG4gIHByaXZhdGUgZGVvcHRlZDogT3B0aW9uPFRyeU9wY29kZT4gPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVmZXJlbmNlOiBSZWZlcmVuY2U8T3BhcXVlPixcbiAgICBjYWNoZTogUmVmZXJlbmNlQ2FjaGU8VD4sXG4gICAgYm91bmRzOiBGcmFnbWVudCxcbiAgICB1cHNlcnQ6IFVwc2VydCxcbiAgICBwcml2YXRlIGFwcGVuZE9wY29kZTogR3VhcmRlZEFwcGVuZE9wY29kZTxUPixcbiAgICBwcml2YXRlIHN0YXRlOiBWTVN0YXRlXG4gICkge1xuICAgIHN1cGVyKGNhY2hlLCBib3VuZHMsIHVwc2VydCk7XG4gICAgdGhpcy50YWcgPSB0aGlzLl90YWcgPSBuZXcgVXBkYXRhYmxlVGFnKHRoaXMudGFnKTtcbiAgfVxuXG4gIGV2YWx1YXRlKHZtOiBVcGRhdGluZ1ZNKSB7XG4gICAgaWYgKHRoaXMuZGVvcHRlZCkge1xuICAgICAgdm0uZXZhbHVhdGVPcGNvZGUodGhpcy5kZW9wdGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzQ29tcG9uZW50RGVmaW5pdGlvbih0aGlzLnJlZmVyZW5jZS52YWx1ZSgpKSkge1xuICAgICAgICB0aGlzLmxhenlEZW9wdCh2bSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdXBlci5ldmFsdWF0ZSh2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBsYXp5RGVvcHQodm06IFVwZGF0aW5nVk0pIHtcbiAgICAvLyBEdXJpZ24gaW5pdGlhbCByZW5kZXIsIHdlIGtub3cgdGhhdCB0aGUgcmVmZXJlbmNlIGRvZXMgbm90IGNvbnRhaW4gYVxuICAgIC8vIGNvbXBvbmVudCBkZWZpbml0aW9uLCBzbyB3ZSBvcHRpbWlzdGljYWxseSBhc3N1bWVkIHRoYXQgdGhpcyBhcHBlbmRcbiAgICAvLyBpcyBqdXN0IGEgbm9ybWFsIGFwcGVuZC4gSG93ZXZlciwgYXQgdXBkYXRlIHRpbWUsIHdlIGRpc2NvdmVyZWQgdGhhdFxuICAgIC8vIHRoZSByZWZlcmVuY2UgaGFzIHN3aXRjaGVkIGludG8gY29udGFpbmluZyBhIGNvbXBvbmVudCBkZWZpbml0aW9uLCBzb1xuICAgIC8vIHdlIG5lZWQgdG8gZG8gYSBcImxhenkgZGVvcHRcIiwgc2ltdWxhdGluZyB3aGF0IHdvdWxkIGhhdmUgaGFwcGVuZWQgaWZcbiAgICAvLyB3ZSBoYWQgZGVjaWRlZCB0byBwZXJmb3JtIHRoZSBkZW9wdCBpbiB0aGUgZmlyc3QgcGxhY2UgZHVyaW5nIGluaXRpYWxcbiAgICAvLyByZW5kZXIuXG4gICAgLy9cbiAgICAvLyBNb3JlIGNvbmNyZXRlbHksIHdlIHdvdWxkIGhhdmUgZXhwYW5kZWQgdGhlIGN1cmx5IGludG8gYSBpZi9lbHNlLCBhbmRcbiAgICAvLyBiYXNlZCBvbiB3aGV0aGVyIHRoZSB2YWx1ZSBpcyBhIGNvbXBvbmVudCBkZWZpbml0aW9uIG9yIG5vdCwgd2Ugd291bGRcbiAgICAvLyBoYXZlIGVudGVyZWQgZWl0aGVyIHRoZSBkeW5hbWljIGNvbXBvbmVudCBicmFuY2ggb3IgdGhlIHNpbXBsZSB2YWx1ZVxuICAgIC8vIGJyYW5jaC5cbiAgICAvL1xuICAgIC8vIFNpbmNlIHdlIHJlbmRlcmVkIGEgc2ltcGxlIHZhbHVlIGR1cmluZyBpbml0aWFsIHJlbmRlciAoYW5kIGFsbCB0aGVcbiAgICAvLyB1cGRhdGVzIHVwIHVudGlsIHRoaXMgcG9pbnQpLCB3ZSBuZWVkIHRvIHByZXRlbmQgdGhhdCB0aGUgcmVzdWx0IGlzXG4gICAgLy8gcHJvZHVjZWQgYnkgdGhlIFwiVkFMVUVcIiBicmFuY2ggb2YgdGhlIGRlb3B0ZWQgYXBwZW5kIG9wY29kZTpcbiAgICAvL1xuICAgIC8vICAgVHJ5KEJFR0lOLCBFTkQpXG4gICAgLy8gICAgIEFzc2VydChJc0NvbXBvbmVudERlZmluaXRpb24sIGV4cGVjdGVkPWZhbHNlKVxuICAgIC8vICAgICBPcHRpbWl6ZWRVcGRhdGVcbiAgICAvL1xuICAgIC8vIEluIHRoaXMgY2FzZSwgYmVjYXVzZSB0aGUgcmVmZXJlbmNlIGhhcyBzd2l0Y2hlZCBmcm9tIGJlaW5nIGEgc2ltcGxlXG4gICAgLy8gdmFsdWUgaW50byBhIGNvbXBvbmVudCBkZWZpbml0aW9uLCB3aGF0IHdvdWxkIGhhdmUgaGFwcGVuZWQgaXMgdGhhdFxuICAgIC8vIHRoZSBhc3NlcnQgd291bGQgdGhyb3csIGNhdXNpbmcgdGhlIFRyeSBvcGNvZGUgdG8gdGVhcmRvd24gdGhlIGJvdW5kc1xuICAgIC8vIGFuZCByZXJ1biB0aGUgb3JpZ2luYWwgYXBwZW5kIG9wY29kZS5cbiAgICAvL1xuICAgIC8vIFNpbmNlIHRoZSBUcnkgb3Bjb2RlIHdvdWxkIGhhdmUgbnVrZWQgdGhlIHVwZGF0aW5nIG9wY29kZXMgYW55d2F5LCB3ZVxuICAgIC8vIHdvdWxkbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgc2ltdWxhdGluZyB0aG9zZS4gQWxsIHdlIGhhdmUgdG8gZG8gaXMgdG9cbiAgICAvLyBleGVjdXRlIHRoZSBUcnkgb3Bjb2RlIGFuZCBpbW1lZGlhdGVseSB0aHJvdy5cblxuICAgIGxldCB7IGJvdW5kcywgYXBwZW5kT3Bjb2RlLCBzdGF0ZSB9ID0gdGhpcztcbiAgICBsZXQgZW52ID0gdm0uZW52O1xuXG4gICAgbGV0IHNsaWNlICAgICA9IGFwcGVuZE9wY29kZS5kZW9wdChlbnYpO1xuICAgIGxldCBlbnRlciAgICAgPSBleHBlY3QoZW52LnByb2dyYW0ub3Bjb2RlKHNsaWNlWzBdICsgOCksICdoYXJkY29kZWQgZGVvcHQgbG9jYXRpb24nKTtcbiAgICBsZXQgb3BzICAgICAgID0gdm0uY29uc3RhbnRzLmdldFNsaWNlKGVudGVyLm9wMSk7XG5cbiAgICBsZXQgdHJhY2tlciA9IG5ldyBVcGRhdGFibGVCbG9ja1RyYWNrZXIoYm91bmRzLnBhcmVudEVsZW1lbnQoKSk7XG4gICAgdHJhY2tlci5uZXdCb3VuZHModGhpcy5ib3VuZHMpO1xuXG4gICAgbGV0IGNoaWxkcmVuID0gbmV3IExpbmtlZExpc3Q8VXBkYXRpbmdPcGNvZGU+KCk7XG5cbiAgICBzdGF0ZS5mcmFtZVsnY29uZGl0aW9uJ10gPSBJc0NvbXBvbmVudERlZmluaXRpb25SZWZlcmVuY2UuY3JlYXRlKGV4cGVjdChzdGF0ZS5mcmFtZVsnb3BlcmFuZCddLCAnb3BlcmFuZCBzaG91bGQgYmUgcG9wdWxhdGVkJykpO1xuXG4gICAgbGV0IGRlb3B0ZWQgPSB0aGlzLmRlb3B0ZWQgPSBuZXcgVHJ5T3Bjb2RlKG9wcywgc3RhdGUsIHRyYWNrZXIsIGNoaWxkcmVuKTtcblxuICAgIHRoaXMuX3RhZy51cGRhdGUoZGVvcHRlZC50YWcpO1xuXG4gICAgdm0uZXZhbHVhdGVPcGNvZGUoZGVvcHRlZCk7XG4gICAgdm0udGhyb3coKTtcblxuICAgIC8vIEZyb20gdGhpcyBwb2ludCBvbiwgd2UgaGF2ZSBlc3NlbnRpYWxseSByZXBsYWNlZCBvdXJzZWx2ZSB3aXRoIGEgbmV3XG4gICAgLy8gb3Bjb2RlLiBTaW5jZSB3ZSB3aWxsIGFsd2F5cyBiZSBleGVjdXRpbmcgdGhlIG5ldy9kZW9wdGVkIGNvZGUsIGl0J3MgYVxuICAgIC8vIGdvb2QgaWRlYSAoYXMgYSBwYXR0ZXJuKSB0byBudWxsIG91dCBhbnkgdW5uZWVkZWQgZmllbGRzIGhlcmUgdG8gYXZvaWRcbiAgICAvLyBob2xkaW5nIG9uIHRvIHVubmVlZGVkL3N0YWxlIG9iamVjdHM6XG5cbiAgICAvLyBRVUVTVElPTjogU2hvdWxkbid0IHRoaXMgd2hvbGUgb2JqZWN0IGJlIEdDZWQ/IElmIG5vdCwgd2h5IG5vdD9cblxuICAgIHRoaXMuX3RhZyAgICAgICAgID0gbnVsbCBhcyBGSVhNRTxhbnksICdRVUVTVElPTic+O1xuICAgIHRoaXMucmVmZXJlbmNlICAgID0gbnVsbCBhcyBGSVhNRTxhbnksICdRVUVTVElPTic+O1xuICAgIHRoaXMuY2FjaGUgICAgICAgID0gbnVsbCBhcyBGSVhNRTxhbnksICdRVUVTVElPTic+O1xuICAgIHRoaXMuYm91bmRzICAgICAgID0gbnVsbCBhcyBGSVhNRTxhbnksICdRVUVTVElPTic+O1xuICAgIHRoaXMudXBzZXJ0ICAgICAgID0gbnVsbCBhcyBGSVhNRTxhbnksICdRVUVTVElPTic+O1xuICAgIHRoaXMuYXBwZW5kT3Bjb2RlID0gbnVsbCBhcyBGSVhNRTxhbnksICdRVUVTVElPTic+O1xuICAgIHRoaXMuc3RhdGUgICAgICAgID0gbnVsbCBhcyBGSVhNRTxhbnksICdRVUVTVElPTic+O1xuICB9XG5cbiAgdG9KU09OKCk6IE9wY29kZUpTT04ge1xuICAgIGxldCB7IF9ndWlkOiBndWlkLCB0eXBlLCBkZW9wdGVkIH0gPSB0aGlzO1xuXG4gICAgaWYgKGRlb3B0ZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGd1aWQsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGRlb3B0ZWQ6IHRydWUsXG4gICAgICAgIGNoaWxkcmVuOiBbZGVvcHRlZC50b0pTT04oKV1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdXBlci50b0pTT04oKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE9wdGltaXplZENhdXRpb3VzQXBwZW5kT3Bjb2RlIGV4dGVuZHMgQXBwZW5kRHluYW1pY09wY29kZTxDYXV0aW91c0luc2VydGlvbj4ge1xuICB0eXBlID0gJ29wdGltaXplZC1jYXV0aW91cy1hcHBlbmQnO1xuXG4gIHByb3RlY3RlZCBub3JtYWxpemUocmVmZXJlbmNlOiBSZWZlcmVuY2U8T3BhcXVlPik6IFJlZmVyZW5jZTxDYXV0aW91c0luc2VydGlvbj4ge1xuICAgIHJldHVybiBtYXAocmVmZXJlbmNlLCBub3JtYWxpemVWYWx1ZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgaW5zZXJ0KGRvbTogRE9NVHJlZUNvbnN0cnVjdGlvbiwgY3Vyc29yOiBDdXJzb3IsIHZhbHVlOiBDYXV0aW91c0luc2VydGlvbik6IFVwc2VydCB7XG4gICAgcmV0dXJuIGNhdXRpb3VzSW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgdXBkYXRlV2l0aChfdm06IFZNLCBfcmVmZXJlbmNlOiBSZWZlcmVuY2U8T3BhcXVlPiwgY2FjaGU6IFJlZmVyZW5jZUNhY2hlPENhdXRpb3VzSW5zZXJ0aW9uPiwgYm91bmRzOiBGcmFnbWVudCwgdXBzZXJ0OiBVcHNlcnQpOiBVcGRhdGluZ09wY29kZSB7XG4gICAgcmV0dXJuIG5ldyBPcHRpbWl6ZWRDYXV0aW91c1VwZGF0ZU9wY29kZShjYWNoZSwgYm91bmRzLCB1cHNlcnQpO1xuICB9XG59XG5cbmNsYXNzIE9wdGltaXplZENhdXRpb3VzVXBkYXRlT3Bjb2RlIGV4dGVuZHMgVXBkYXRlT3Bjb2RlPENhdXRpb3VzSW5zZXJ0aW9uPiB7XG4gIHR5cGUgPSAnb3B0aW1pemVkLWNhdXRpb3VzLXVwZGF0ZSc7XG5cbiAgcHJvdGVjdGVkIGluc2VydChkb206IERPTVRyZWVDb25zdHJ1Y3Rpb24sIGN1cnNvcjogQ3Vyc29yLCB2YWx1ZTogQ2F1dGlvdXNJbnNlcnRpb24pOiBVcHNlcnQge1xuICAgIHJldHVybiBjYXV0aW91c0luc2VydChkb20sIGN1cnNvciwgdmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBHdWFyZGVkQ2F1dGlvdXNBcHBlbmRPcGNvZGUgZXh0ZW5kcyBHdWFyZGVkQXBwZW5kT3Bjb2RlPENhdXRpb3VzSW5zZXJ0aW9uPiB7XG4gIHR5cGUgPSAnZ3VhcmRlZC1jYXV0aW91cy1hcHBlbmQnO1xuXG4gIHByb3RlY3RlZCBBcHBlbmRPcGNvZGUgPSBPcHRpbWl6ZWRDYXV0aW91c0FwcGVuZE9wY29kZTtcblxuICBwcm90ZWN0ZWQgbm9ybWFsaXplKHJlZmVyZW5jZTogUmVmZXJlbmNlPE9wYXF1ZT4pOiBSZWZlcmVuY2U8Q2F1dGlvdXNJbnNlcnRpb24+IHtcbiAgICByZXR1cm4gbWFwKHJlZmVyZW5jZSwgbm9ybWFsaXplVmFsdWUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGluc2VydChkb206IERPTVRyZWVDb25zdHJ1Y3Rpb24sIGN1cnNvcjogQ3Vyc29yLCB2YWx1ZTogQ2F1dGlvdXNJbnNlcnRpb24pOiBVcHNlcnQge1xuICAgIHJldHVybiBjYXV0aW91c0luc2VydChkb20sIGN1cnNvciwgdmFsdWUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHVwZGF0ZVdpdGgodm06IFZNLCByZWZlcmVuY2U6IFJlZmVyZW5jZTxPcGFxdWU+LCBjYWNoZTogUmVmZXJlbmNlQ2FjaGU8Q2F1dGlvdXNJbnNlcnRpb24+LCBib3VuZHM6IEZyYWdtZW50LCB1cHNlcnQ6IFVwc2VydCk6IFVwZGF0aW5nT3Bjb2RlIHtcbiAgICByZXR1cm4gbmV3IEd1YXJkZWRDYXV0aW91c1VwZGF0ZU9wY29kZShyZWZlcmVuY2UsIGNhY2hlLCBib3VuZHMsIHVwc2VydCwgdGhpcywgdm0uY2FwdHVyZSgpKTtcbiAgfVxufVxuXG5jbGFzcyBHdWFyZGVkQ2F1dGlvdXNVcGRhdGVPcGNvZGUgZXh0ZW5kcyBHdWFyZGVkVXBkYXRlT3Bjb2RlPENhdXRpb3VzSW5zZXJ0aW9uPiB7XG4gIHR5cGUgPSAnZ3VhcmRlZC1jYXV0aW91cy11cGRhdGUnO1xuXG4gIHByb3RlY3RlZCBpbnNlcnQoZG9tOiBET01UcmVlQ29uc3RydWN0aW9uLCBjdXJzb3I6IEN1cnNvciwgdmFsdWU6IENhdXRpb3VzSW5zZXJ0aW9uKTogVXBzZXJ0IHtcbiAgICByZXR1cm4gY2F1dGlvdXNJbnNlcnQoZG9tLCBjdXJzb3IsIHZhbHVlKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgT3B0aW1pemVkVHJ1c3RpbmdBcHBlbmRPcGNvZGUgZXh0ZW5kcyBBcHBlbmREeW5hbWljT3Bjb2RlPFRydXN0aW5nSW5zZXJ0aW9uPiB7XG4gIHR5cGUgPSAnb3B0aW1pemVkLXRydXN0aW5nLWFwcGVuZCc7XG5cbiAgcHJvdGVjdGVkIG5vcm1hbGl6ZShyZWZlcmVuY2U6IFJlZmVyZW5jZTxPcGFxdWU+KTogUmVmZXJlbmNlPFRydXN0aW5nSW5zZXJ0aW9uPiB7XG4gICAgcmV0dXJuIG1hcChyZWZlcmVuY2UsIG5vcm1hbGl6ZVRydXN0ZWRWYWx1ZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgaW5zZXJ0KGRvbTogRE9NVHJlZUNvbnN0cnVjdGlvbiwgY3Vyc29yOiBDdXJzb3IsIHZhbHVlOiBUcnVzdGluZ0luc2VydGlvbik6IFVwc2VydCB7XG4gICAgcmV0dXJuIHRydXN0aW5nSW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgdXBkYXRlV2l0aChfdm06IFZNLCBfcmVmZXJlbmNlOiBSZWZlcmVuY2U8T3BhcXVlPiwgY2FjaGU6IFJlZmVyZW5jZUNhY2hlPFRydXN0aW5nSW5zZXJ0aW9uPiwgYm91bmRzOiBGcmFnbWVudCwgdXBzZXJ0OiBVcHNlcnQpOiBVcGRhdGluZ09wY29kZSB7XG4gICAgcmV0dXJuIG5ldyBPcHRpbWl6ZWRUcnVzdGluZ1VwZGF0ZU9wY29kZShjYWNoZSwgYm91bmRzLCB1cHNlcnQpO1xuICB9XG59XG5cbmNsYXNzIE9wdGltaXplZFRydXN0aW5nVXBkYXRlT3Bjb2RlIGV4dGVuZHMgVXBkYXRlT3Bjb2RlPFRydXN0aW5nSW5zZXJ0aW9uPiB7XG4gIHR5cGUgPSAnb3B0aW1pemVkLXRydXN0aW5nLXVwZGF0ZSc7XG5cbiAgcHJvdGVjdGVkIGluc2VydChkb206IERPTVRyZWVDb25zdHJ1Y3Rpb24sIGN1cnNvcjogQ3Vyc29yLCB2YWx1ZTogVHJ1c3RpbmdJbnNlcnRpb24pOiBVcHNlcnQge1xuICAgIHJldHVybiB0cnVzdGluZ0luc2VydChkb20sIGN1cnNvciwgdmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBHdWFyZGVkVHJ1c3RpbmdBcHBlbmRPcGNvZGUgZXh0ZW5kcyBHdWFyZGVkQXBwZW5kT3Bjb2RlPFRydXN0aW5nSW5zZXJ0aW9uPiB7XG4gIHR5cGUgPSAnZ3VhcmRlZC10cnVzdGluZy1hcHBlbmQnO1xuXG4gIHByb3RlY3RlZCBBcHBlbmRPcGNvZGUgPSBPcHRpbWl6ZWRUcnVzdGluZ0FwcGVuZE9wY29kZTtcblxuICBwcm90ZWN0ZWQgbm9ybWFsaXplKHJlZmVyZW5jZTogUmVmZXJlbmNlPE9wYXF1ZT4pOiBSZWZlcmVuY2U8VHJ1c3RpbmdJbnNlcnRpb24+IHtcbiAgICByZXR1cm4gbWFwKHJlZmVyZW5jZSwgbm9ybWFsaXplVHJ1c3RlZFZhbHVlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBpbnNlcnQoZG9tOiBET01UcmVlQ29uc3RydWN0aW9uLCBjdXJzb3I6IEN1cnNvciwgdmFsdWU6IFRydXN0aW5nSW5zZXJ0aW9uKTogVXBzZXJ0IHtcbiAgICByZXR1cm4gdHJ1c3RpbmdJbnNlcnQoZG9tLCBjdXJzb3IsIHZhbHVlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCB1cGRhdGVXaXRoKHZtOiBWTSwgcmVmZXJlbmNlOiBSZWZlcmVuY2U8T3BhcXVlPiwgY2FjaGU6IFJlZmVyZW5jZUNhY2hlPFRydXN0aW5nSW5zZXJ0aW9uPiwgYm91bmRzOiBGcmFnbWVudCwgdXBzZXJ0OiBVcHNlcnQpOiBVcGRhdGluZ09wY29kZSB7XG4gICAgcmV0dXJuIG5ldyBHdWFyZGVkVHJ1c3RpbmdVcGRhdGVPcGNvZGUocmVmZXJlbmNlLCBjYWNoZSwgYm91bmRzLCB1cHNlcnQsIHRoaXMsIHZtLmNhcHR1cmUoKSk7XG4gIH1cbn1cblxuY2xhc3MgR3VhcmRlZFRydXN0aW5nVXBkYXRlT3Bjb2RlIGV4dGVuZHMgR3VhcmRlZFVwZGF0ZU9wY29kZTxUcnVzdGluZ0luc2VydGlvbj4ge1xuICB0eXBlID0gJ3RydXN0aW5nLXVwZGF0ZSc7XG5cbiAgcHJvdGVjdGVkIGluc2VydChkb206IERPTVRyZWVDb25zdHJ1Y3Rpb24sIGN1cnNvcjogQ3Vyc29yLCB2YWx1ZTogVHJ1c3RpbmdJbnNlcnRpb24pOiBVcHNlcnQge1xuICAgIHJldHVybiB0cnVzdGluZ0luc2VydChkb20sIGN1cnNvciwgdmFsdWUpO1xuICB9XG59XG4iXX0=