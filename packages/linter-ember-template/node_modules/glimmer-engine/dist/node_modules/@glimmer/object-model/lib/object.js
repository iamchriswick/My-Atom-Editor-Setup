"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var blueprint_1 = require("./blueprint");
var GlimmerObjectBase = (function () {
    function GlimmerObjectBase() {
    }
    return GlimmerObjectBase;
}());
exports.GlimmerObjectBase = GlimmerObjectBase;
var GlimmerObject = (function () {
    function GlimmerObject(properties) {
        if (properties !== undefined) {
            Object.assign(this, properties);
        }
    }
    GlimmerObject.create = function (properties) {
        return new this(properties);
    };
    GlimmerObject.extend = function (extensions) {
        // This method intentionally uses internal typecasts to convince TypeScript
        // that what we're doing is legitimate. The real action of this method is in
        // its signature (and the signature of GlimmerClass).
        var sub = (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return class_1;
        }(this));
        if (extensions !== undefined) {
            var blueprints = Object.keys(extensions).map(function (k) {
                var extension = extensions[k];
                if (extension instanceof blueprint_1.GlimmerDescriptor) {
                    return extension.blueprint(k);
                }
                else {
                    return new blueprint_1.ValueBlueprint(k, extensions[k]);
                }
            });
            blueprints.forEach(function (b) { return b.define(sub.prototype); });
        }
        return sub;
    };
    return GlimmerObject;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = GlimmerObject;
/**
 * Adapter for TypeScript.
 *
 * A shim library could just declare the variable as the type
 * GlimmerClass<FirstInstance>. The key point is that shimming
 * between the two worlds requires writing a static interface
 * definition, as TypeScript isn't willing to treat the dynamic
 * intersection as a valid constructor return type.
 *
 * This function is a noop and is used like this:
 *
 * ```ts
 * // in one file
 * let Person = GlimmerObject.extend({
 *   named: 'Dan'
 * });
 *
 *
 * // in a TypeScript wrapper file
 * import { Person as OriginalPerson } from 'original-definition';
 *
 * interface PersonInstance {
 *   named: string
 * }
 *
 * export let Person = classof<PersonInstance>(OriginalPerson);
 *
 * // in a subclassing file
 * import { Person } from 'wrapped-definition';
 *
 * class FancyPerson extends Person {
 *   salutation: string;
 *
 *   fullName() {
 *     return `${this.salutation} ${this.named}`;
 *   }
 * }
 *
 * FancyPerson.create({ name: 'Tom Dale', salutation: 'Mr.' }).fullName();
 * // typechecks and returns 'Mr. Tom Dale'
 * ```
*/
function classof(klass) {
    return klass;
}
exports.classof = classof;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2JqZWN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiQGdsaW1tZXIvb2JqZWN0LW1vZGVsL2xpYi9vYmplY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEseUNBQWdFO0FBY2hFO0lBQUE7SUFFQSxDQUFDO0lBQUQsd0JBQUM7QUFBRCxDQUFDLEFBRkQsSUFFQztBQUZxQiw4Q0FBaUI7QUFJdkM7SUE0QkUsdUJBQVksVUFBbUI7UUFDN0IsRUFBRSxDQUFDLENBQUMsVUFBVSxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDN0IsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDbEMsQ0FBQztJQUNILENBQUM7SUEvQk0sb0JBQU0sR0FBYixVQUFxSixVQUEwQjtRQUM3SyxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUErQyxDQUFDO0lBQzVFLENBQUM7SUFFTSxvQkFBTSxHQUFiLFVBQThHLFVBQXVCO1FBQ25JLDJFQUEyRTtRQUMzRSw0RUFBNEU7UUFDNUUscURBQXFEO1FBRXJELElBQUksR0FBRztZQUFpQiwyQkFBa0M7WUFBaEQ7O1lBQWtELENBQUM7WUFBRCxjQUFDO1FBQUQsQ0FBQyxBQUFuRCxDQUFlLElBQWlDLEVBQUcsQ0FBQztRQUU5RCxFQUFFLENBQUMsQ0FBQyxVQUFVLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQztZQUM3QixJQUFJLFVBQVUsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFBLENBQUM7Z0JBQzVDLElBQUksU0FBUyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDOUIsRUFBRSxDQUFDLENBQUMsU0FBUyxZQUFZLDZCQUFpQixDQUFDLENBQUMsQ0FBQztvQkFDM0MsTUFBTSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hDLENBQUM7Z0JBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ04sTUFBTSxDQUFDLElBQUksMEJBQWMsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzlDLENBQUM7WUFDSCxDQUFDLENBQUMsQ0FBQztZQUVILFVBQVUsQ0FBQyxPQUFPLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsRUFBdkIsQ0FBdUIsQ0FBQyxDQUFDO1FBQ25ELENBQUM7UUFFRCxNQUFNLENBQUMsR0FBVSxDQUFDO0lBQ3BCLENBQUM7SUFPSCxvQkFBQztBQUFELENBQUMsQUFqQ0QsSUFpQ0M7OztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXlDRTtBQUNGLGlCQUEyQixLQUFVO0lBQ25DLE1BQU0sQ0FBQyxLQUFZLENBQUM7QUFDdEIsQ0FBQztBQUZELDBCQUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR2xpbW1lckRlc2NyaXB0b3IsIFZhbHVlQmx1ZXByaW50IH0gZnJvbSAnLi9ibHVlcHJpbnQnO1xyXG5leHBvcnQgdHlwZSBHbGltbWVyT2JqZWN0Q2xhc3MgPSB0eXBlb2YgR2xpbW1lck9iamVjdDtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29uc3RydWN0b3I8VCBleHRlbmRzIEdsaW1tZXJPYmplY3Q+IHtcclxuICBuZXcoLi4uYXJncyk6IFQ7XHJcbiAgcHJvdG90eXBlOiBUO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEdsaW1tZXJDbGFzczxFeHRlbnNpb25zIGV4dGVuZHMgR2xpbW1lck9iamVjdD4gZXh0ZW5kcyBDb25zdHJ1Y3RvcjxFeHRlbnNpb25zPiB7XHJcbiAgbmV3KC4uLmFyZ3MpOiBFeHRlbnNpb25zO1xyXG4gIGNyZWF0ZTxFeHRlbnNpb25zLCBDcmVhdGVPcHRpb25zLCBUIGV4dGVuZHMgdHlwZW9mIEdsaW1tZXJPYmplY3Q+KHRoaXM6IFQgJiBHbGltbWVyQ2xhc3M8RXh0ZW5zaW9ucz4sIHByb3BlcnRpZXM/OiBDcmVhdGVPcHRpb25zKTogRXh0ZW5zaW9ucyAmIENyZWF0ZU9wdGlvbnMgJiBHbGltbWVyT2JqZWN0O1xyXG4gIGV4dGVuZDxPcmlnaW5hbCBleHRlbmRzIEdsaW1tZXJPYmplY3QsIEV4dGVuc2lvbnMgZXh0ZW5kcyBHbGltbWVyT2JqZWN0Pih0aGlzOiBHbGltbWVyQ2xhc3M8T3JpZ2luYWw+LCBleHRlbnNpb25zPzogRXh0ZW5zaW9ucyk6IEdsaW1tZXJDbGFzczxPcmlnaW5hbCAmIEV4dGVuc2lvbnM+O1xyXG59XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgR2xpbW1lck9iamVjdEJhc2U8RXh0ZW5zaW9ucz4ge1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2xpbW1lck9iamVjdCB7XHJcbiAgc3RhdGljIGNyZWF0ZTxFeHRlbnNpb25zIGV4dGVuZHMgR2xpbW1lck9iamVjdCwgQ3JlYXRlT3B0aW9ucyBleHRlbmRzIEdsaW1tZXJPYmplY3QsIFQgZXh0ZW5kcyB0eXBlb2YgR2xpbW1lck9iamVjdD4odGhpczogR2xpbW1lckNsYXNzPEV4dGVuc2lvbnM+LCBwcm9wZXJ0aWVzPzogQ3JlYXRlT3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHByb3BlcnRpZXMpIGFzIEV4dGVuc2lvbnMgJiBDcmVhdGVPcHRpb25zICYgR2xpbW1lck9iamVjdDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBleHRlbmQ8T3JpZ2luYWwgZXh0ZW5kcyBHbGltbWVyT2JqZWN0LCBFeHRlbnNpb25zIGV4dGVuZHMgR2xpbW1lck9iamVjdD4odGhpczogR2xpbW1lckNsYXNzPE9yaWdpbmFsPiwgZXh0ZW5zaW9ucz86IEV4dGVuc2lvbnMpOiBHbGltbWVyQ2xhc3M8T3JpZ2luYWwgJiBFeHRlbnNpb25zICYgR2xpbW1lck9iamVjdD4ge1xyXG4gICAgLy8gVGhpcyBtZXRob2QgaW50ZW50aW9uYWxseSB1c2VzIGludGVybmFsIHR5cGVjYXN0cyB0byBjb252aW5jZSBUeXBlU2NyaXB0XHJcbiAgICAvLyB0aGF0IHdoYXQgd2UncmUgZG9pbmcgaXMgbGVnaXRpbWF0ZS4gVGhlIHJlYWwgYWN0aW9uIG9mIHRoaXMgbWV0aG9kIGlzIGluXHJcbiAgICAvLyBpdHMgc2lnbmF0dXJlIChhbmQgdGhlIHNpZ25hdHVyZSBvZiBHbGltbWVyQ2xhc3MpLlxyXG5cclxuICAgIGxldCBzdWIgPSBjbGFzcyBleHRlbmRzICh0aGlzIGFzIGFueSBhcyBPYmplY3RDb25zdHJ1Y3Rvcikge307XHJcblxyXG4gICAgaWYgKGV4dGVuc2lvbnMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBsZXQgYmx1ZXByaW50cyA9IE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpLm1hcChrID0+IHtcclxuICAgICAgICBsZXQgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uc1trXTtcclxuICAgICAgICBpZiAoZXh0ZW5zaW9uIGluc3RhbmNlb2YgR2xpbW1lckRlc2NyaXB0b3IpIHtcclxuICAgICAgICAgIHJldHVybiBleHRlbnNpb24uYmx1ZXByaW50KGspO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gbmV3IFZhbHVlQmx1ZXByaW50KGssIGV4dGVuc2lvbnNba10pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBibHVlcHJpbnRzLmZvckVhY2goYiA9PiBiLmRlZmluZShzdWIucHJvdG90eXBlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN1YiBhcyBhbnk7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0aWVzPzogT2JqZWN0KSB7XHJcbiAgICBpZiAocHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcHJvcGVydGllcyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQWRhcHRlciBmb3IgVHlwZVNjcmlwdC5cclxuICpcclxuICogQSBzaGltIGxpYnJhcnkgY291bGQganVzdCBkZWNsYXJlIHRoZSB2YXJpYWJsZSBhcyB0aGUgdHlwZVxyXG4gKiBHbGltbWVyQ2xhc3M8Rmlyc3RJbnN0YW5jZT4uIFRoZSBrZXkgcG9pbnQgaXMgdGhhdCBzaGltbWluZ1xyXG4gKiBiZXR3ZWVuIHRoZSB0d28gd29ybGRzIHJlcXVpcmVzIHdyaXRpbmcgYSBzdGF0aWMgaW50ZXJmYWNlXHJcbiAqIGRlZmluaXRpb24sIGFzIFR5cGVTY3JpcHQgaXNuJ3Qgd2lsbGluZyB0byB0cmVhdCB0aGUgZHluYW1pY1xyXG4gKiBpbnRlcnNlY3Rpb24gYXMgYSB2YWxpZCBjb25zdHJ1Y3RvciByZXR1cm4gdHlwZS5cclxuICpcclxuICogVGhpcyBmdW5jdGlvbiBpcyBhIG5vb3AgYW5kIGlzIHVzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGB0c1xyXG4gKiAvLyBpbiBvbmUgZmlsZVxyXG4gKiBsZXQgUGVyc29uID0gR2xpbW1lck9iamVjdC5leHRlbmQoe1xyXG4gKiAgIG5hbWVkOiAnRGFuJ1xyXG4gKiB9KTtcclxuICpcclxuICpcclxuICogLy8gaW4gYSBUeXBlU2NyaXB0IHdyYXBwZXIgZmlsZVxyXG4gKiBpbXBvcnQgeyBQZXJzb24gYXMgT3JpZ2luYWxQZXJzb24gfSBmcm9tICdvcmlnaW5hbC1kZWZpbml0aW9uJztcclxuICpcclxuICogaW50ZXJmYWNlIFBlcnNvbkluc3RhbmNlIHtcclxuICogICBuYW1lZDogc3RyaW5nXHJcbiAqIH1cclxuICpcclxuICogZXhwb3J0IGxldCBQZXJzb24gPSBjbGFzc29mPFBlcnNvbkluc3RhbmNlPihPcmlnaW5hbFBlcnNvbik7XHJcbiAqXHJcbiAqIC8vIGluIGEgc3ViY2xhc3NpbmcgZmlsZVxyXG4gKiBpbXBvcnQgeyBQZXJzb24gfSBmcm9tICd3cmFwcGVkLWRlZmluaXRpb24nO1xyXG4gKlxyXG4gKiBjbGFzcyBGYW5jeVBlcnNvbiBleHRlbmRzIFBlcnNvbiB7XHJcbiAqICAgc2FsdXRhdGlvbjogc3RyaW5nO1xyXG4gKlxyXG4gKiAgIGZ1bGxOYW1lKCkge1xyXG4gKiAgICAgcmV0dXJuIGAke3RoaXMuc2FsdXRhdGlvbn0gJHt0aGlzLm5hbWVkfWA7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqXHJcbiAqIEZhbmN5UGVyc29uLmNyZWF0ZSh7IG5hbWU6ICdUb20gRGFsZScsIHNhbHV0YXRpb246ICdNci4nIH0pLmZ1bGxOYW1lKCk7XHJcbiAqIC8vIHR5cGVjaGVja3MgYW5kIHJldHVybnMgJ01yLiBUb20gRGFsZSdcclxuICogYGBgXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGFzc29mPFQ+KGtsYXNzOiBhbnkpOiBHbGltbWVyQ2xhc3M8VD4ge1xyXG4gIHJldHVybiBrbGFzcyBhcyBhbnk7XHJcbn1cclxuIl19