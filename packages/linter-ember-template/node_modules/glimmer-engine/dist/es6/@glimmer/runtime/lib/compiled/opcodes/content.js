import { isSafeString, isNode, isString, cautiousInsert, trustingInsert } from '../../upsert';
import { isComponentDefinition } from '../../component/interfaces';
import { UpdatingOpcode } from '../../opcodes';
import { CompiledArgs } from '../expressions';
import { TryOpcode } from '../../vm/update';
import { ReferenceCache, UpdatableTag, isModified, isConst, map } from '@glimmer/reference';
import { LinkedList, expect } from '@glimmer/util';
import { Cursor, clear } from '../../bounds';
import { Fragment } from '../../builder';
import OpcodeBuilderDSL from './builder';
import { ConditionalReference } from '../../references';
import { UpdatableBlockTracker } from '../../builder';
import { APPEND_OPCODES, OpcodeName as Op } from '../../opcodes';
APPEND_OPCODES.add(Op.DynamicContent, (vm, { op1: append }) => {
    let opcode = vm.constants.getOther(append);
    opcode.evaluate(vm);
});
function isEmpty(value) {
    return value === null || value === undefined || typeof value['toString'] !== 'function';
}
export function normalizeTextValue(value) {
    if (isEmpty(value)) {
        return '';
    }
    return String(value);
}
function normalizeTrustedValue(value) {
    if (isEmpty(value)) {
        return '';
    }
    if (isString(value)) {
        return value;
    }
    if (isSafeString(value)) {
        return value.toHTML();
    }
    if (isNode(value)) {
        return value;
    }
    return String(value);
}
function normalizeValue(value) {
    if (isEmpty(value)) {
        return '';
    }
    if (isString(value)) {
        return value;
    }
    if (isSafeString(value) || isNode(value)) {
        return value;
    }
    return String(value);
}
export class AppendDynamicOpcode {
    evaluate(vm) {
        let reference = vm.frame.getOperand();
        let normalized = this.normalize(reference);
        let value, cache;
        if (isConst(reference)) {
            value = normalized.value();
        }
        else {
            cache = new ReferenceCache(normalized);
            value = cache.peek();
        }
        let stack = vm.stack();
        let upsert = this.insert(vm.env.getAppendOperations(), stack, value);
        let bounds = new Fragment(upsert.bounds);
        stack.newBounds(bounds);
        if (cache /* i.e. !isConst(reference) */) {
            vm.updateWith(this.updateWith(vm, reference, cache, bounds, upsert));
        }
    }
}
export class GuardedAppendOpcode extends AppendDynamicOpcode {
    constructor(expression, symbolTable) {
        super();
        this.expression = expression;
        this.symbolTable = symbolTable;
        this.deopted = null;
    }
    evaluate(vm) {
        if (this.deopted) {
            vm.pushEvalFrame(this.deopted);
        }
        else {
            vm.evaluateOperand(this.expression);
            let value = vm.frame.getOperand().value();
            if (isComponentDefinition(value)) {
                vm.pushEvalFrame(this.deopt(vm.env));
            }
            else {
                super.evaluate(vm);
            }
        }
    }
    deopt(env) {
        // At compile time, we determined that this append callsite might refer
        // to a local variable/property lookup that resolves to a component
        // definition at runtime.
        //
        // We could have eagerly compiled this callsite into something like this:
        //
        //   {{#if (is-component-definition foo)}}
        //     {{component foo}}
        //   {{else}}
        //     {{foo}}
        //   {{/if}}
        //
        // However, in practice, there might be a large amout of these callsites
        // and most of them would resolve to a simple value lookup. Therefore, we
        // tried to be optimistic and assumed that the callsite will resolve to
        // appending a simple value.
        //
        // However, we have reached here because at runtime, the guard conditional
        // have detected that this callsite is indeed referring to a component
        // definition object. Since this is likely going to be true for other
        // instances of the same callsite, it is now appropiate to deopt into the
        // expanded version that handles both cases. The compilation would look
        // like this:
        //
        //               PutValue(expression)
        //               Test(is-component-definition)
        //               Enter(BEGIN, END)
        //   BEGIN:      Noop
        //               JumpUnless(VALUE)
        //               PutDynamicComponentDefinitionOpcode
        //               OpenComponent
        //               CloseComponent
        //               Jump(END)
        //   VALUE:      Noop
        //               OptimizedAppend
        //   END:        Noop
        //               Exit
        //
        // Keep in mind that even if we *don't* reach here at initial render time,
        // it is still possible (although quite rare) that the simple value we
        // encounter during initial render could later change into a component
        // definition object at update time. That is handled by the "lazy deopt"
        // code on the update side (scroll down for the next big block of comment).
        let dsl = new OpcodeBuilderDSL(this.symbolTable, env);
        dsl.putValue(this.expression);
        dsl.test(IsComponentDefinitionReference.create);
        dsl.labelled(null, (dsl, _BEGIN, END) => {
            dsl.jumpUnless('VALUE');
            dsl.putDynamicComponentDefinition();
            dsl.openComponent(CompiledArgs.empty());
            dsl.closeComponent();
            dsl.jump(END);
            dsl.label('VALUE');
            dsl.dynamicContent(new this.AppendOpcode());
        });
        let deopted = this.deopted = dsl.toSlice();
        // From this point on, we have essentially replaced ourselves with a new set
        // of opcodes. Since we will always be executing the new/deopted code, it's
        // a good idea (as a pattern) to null out any unneeded fields here to avoid
        // holding on to unneeded/stale objects:
        // QUESTION: Shouldn't this whole object be GCed? If not, why not?
        this.expression = null;
        return deopted;
    }
}
class IsComponentDefinitionReference extends ConditionalReference {
    static create(inner) {
        return new IsComponentDefinitionReference(inner);
    }
    toBool(value) {
        return isComponentDefinition(value);
    }
}
class UpdateOpcode extends UpdatingOpcode {
    constructor(cache, bounds, upsert) {
        super();
        this.cache = cache;
        this.bounds = bounds;
        this.upsert = upsert;
        this.tag = cache.tag;
    }
    evaluate(vm) {
        let value = this.cache.revalidate();
        if (isModified(value)) {
            let { bounds, upsert } = this;
            let { dom } = vm;
            if (!this.upsert.update(dom, value)) {
                let cursor = new Cursor(bounds.parentElement(), clear(bounds));
                upsert = this.upsert = this.insert(vm.env.getAppendOperations(), cursor, value);
            }
            bounds.update(upsert.bounds);
        }
    }
    toJSON() {
        let { _guid: guid, type, cache } = this;
        return {
            guid,
            type,
            details: { lastValue: JSON.stringify(cache.peek()) }
        };
    }
}
class GuardedUpdateOpcode extends UpdateOpcode {
    constructor(reference, cache, bounds, upsert, appendOpcode, state) {
        super(cache, bounds, upsert);
        this.reference = reference;
        this.appendOpcode = appendOpcode;
        this.state = state;
        this.deopted = null;
        this.tag = this._tag = new UpdatableTag(this.tag);
    }
    evaluate(vm) {
        if (this.deopted) {
            vm.evaluateOpcode(this.deopted);
        }
        else {
            if (isComponentDefinition(this.reference.value())) {
                this.lazyDeopt(vm);
            }
            else {
                super.evaluate(vm);
            }
        }
    }
    lazyDeopt(vm) {
        // Durign initial render, we know that the reference does not contain a
        // component definition, so we optimistically assumed that this append
        // is just a normal append. However, at update time, we discovered that
        // the reference has switched into containing a component definition, so
        // we need to do a "lazy deopt", simulating what would have happened if
        // we had decided to perform the deopt in the first place during initial
        // render.
        //
        // More concretely, we would have expanded the curly into a if/else, and
        // based on whether the value is a component definition or not, we would
        // have entered either the dynamic component branch or the simple value
        // branch.
        //
        // Since we rendered a simple value during initial render (and all the
        // updates up until this point), we need to pretend that the result is
        // produced by the "VALUE" branch of the deopted append opcode:
        //
        //   Try(BEGIN, END)
        //     Assert(IsComponentDefinition, expected=false)
        //     OptimizedUpdate
        //
        // In this case, because the reference has switched from being a simple
        // value into a component definition, what would have happened is that
        // the assert would throw, causing the Try opcode to teardown the bounds
        // and rerun the original append opcode.
        //
        // Since the Try opcode would have nuked the updating opcodes anyway, we
        // wouldn't have to worry about simulating those. All we have to do is to
        // execute the Try opcode and immediately throw.
        let { bounds, appendOpcode, state } = this;
        let env = vm.env;
        let slice = appendOpcode.deopt(env);
        let enter = expect(env.program.opcode(slice[0] + 8), 'hardcoded deopt location');
        let ops = vm.constants.getSlice(enter.op1);
        let tracker = new UpdatableBlockTracker(bounds.parentElement());
        tracker.newBounds(this.bounds);
        let children = new LinkedList();
        state.frame['condition'] = IsComponentDefinitionReference.create(expect(state.frame['operand'], 'operand should be populated'));
        let deopted = this.deopted = new TryOpcode(ops, state, tracker, children);
        this._tag.update(deopted.tag);
        vm.evaluateOpcode(deopted);
        vm.throw();
        // From this point on, we have essentially replaced ourselve with a new
        // opcode. Since we will always be executing the new/deopted code, it's a
        // good idea (as a pattern) to null out any unneeded fields here to avoid
        // holding on to unneeded/stale objects:
        // QUESTION: Shouldn't this whole object be GCed? If not, why not?
        this._tag = null;
        this.reference = null;
        this.cache = null;
        this.bounds = null;
        this.upsert = null;
        this.appendOpcode = null;
        this.state = null;
    }
    toJSON() {
        let { _guid: guid, type, deopted } = this;
        if (deopted) {
            return {
                guid,
                type,
                deopted: true,
                children: [deopted.toJSON()]
            };
        }
        else {
            return super.toJSON();
        }
    }
}
export class OptimizedCautiousAppendOpcode extends AppendDynamicOpcode {
    constructor() {
        super(...arguments);
        this.type = 'optimized-cautious-append';
    }
    normalize(reference) {
        return map(reference, normalizeValue);
    }
    insert(dom, cursor, value) {
        return cautiousInsert(dom, cursor, value);
    }
    updateWith(_vm, _reference, cache, bounds, upsert) {
        return new OptimizedCautiousUpdateOpcode(cache, bounds, upsert);
    }
}
class OptimizedCautiousUpdateOpcode extends UpdateOpcode {
    constructor() {
        super(...arguments);
        this.type = 'optimized-cautious-update';
    }
    insert(dom, cursor, value) {
        return cautiousInsert(dom, cursor, value);
    }
}
export class GuardedCautiousAppendOpcode extends GuardedAppendOpcode {
    constructor() {
        super(...arguments);
        this.type = 'guarded-cautious-append';
        this.AppendOpcode = OptimizedCautiousAppendOpcode;
    }
    normalize(reference) {
        return map(reference, normalizeValue);
    }
    insert(dom, cursor, value) {
        return cautiousInsert(dom, cursor, value);
    }
    updateWith(vm, reference, cache, bounds, upsert) {
        return new GuardedCautiousUpdateOpcode(reference, cache, bounds, upsert, this, vm.capture());
    }
}
class GuardedCautiousUpdateOpcode extends GuardedUpdateOpcode {
    constructor() {
        super(...arguments);
        this.type = 'guarded-cautious-update';
    }
    insert(dom, cursor, value) {
        return cautiousInsert(dom, cursor, value);
    }
}
export class OptimizedTrustingAppendOpcode extends AppendDynamicOpcode {
    constructor() {
        super(...arguments);
        this.type = 'optimized-trusting-append';
    }
    normalize(reference) {
        return map(reference, normalizeTrustedValue);
    }
    insert(dom, cursor, value) {
        return trustingInsert(dom, cursor, value);
    }
    updateWith(_vm, _reference, cache, bounds, upsert) {
        return new OptimizedTrustingUpdateOpcode(cache, bounds, upsert);
    }
}
class OptimizedTrustingUpdateOpcode extends UpdateOpcode {
    constructor() {
        super(...arguments);
        this.type = 'optimized-trusting-update';
    }
    insert(dom, cursor, value) {
        return trustingInsert(dom, cursor, value);
    }
}
export class GuardedTrustingAppendOpcode extends GuardedAppendOpcode {
    constructor() {
        super(...arguments);
        this.type = 'guarded-trusting-append';
        this.AppendOpcode = OptimizedTrustingAppendOpcode;
    }
    normalize(reference) {
        return map(reference, normalizeTrustedValue);
    }
    insert(dom, cursor, value) {
        return trustingInsert(dom, cursor, value);
    }
    updateWith(vm, reference, cache, bounds, upsert) {
        return new GuardedTrustingUpdateOpcode(reference, cache, bounds, upsert, this, vm.capture());
    }
}
class GuardedTrustingUpdateOpcode extends GuardedUpdateOpcode {
    constructor() {
        super(...arguments);
        this.type = 'trusting-update';
    }
    insert(dom, cursor, value) {
        return trustingInsert(dom, cursor, value);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIkBnbGltbWVyL3J1bnRpbWUvbGliL2NvbXBpbGVkL29wY29kZXMvY29udGVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFlLEVBS2IsWUFBWSxFQUNaLE1BQU0sRUFDTixRQUFRLEVBRVIsY0FBYyxFQUNkLGNBQWMsRUFDZixNQUFNLGNBQWMsQ0FBQztBQUN0QixPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUVuRSxPQUFPLEVBQWMsY0FBYyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNELE9BQU8sRUFBc0IsWUFBWSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFbEUsT0FBTyxFQUFFLFNBQVMsRUFBVyxNQUFNLGlCQUFpQixDQUFDO0FBQ3JELE9BQU8sRUFBYSxjQUFjLEVBQUUsWUFBWSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDdkcsT0FBTyxFQUF5QixVQUFVLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQzdDLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDekMsT0FBTyxnQkFBZ0IsTUFBTSxXQUFXLENBQUM7QUFDekMsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFFeEQsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRXRELE9BQU8sRUFBRSxjQUFjLEVBQUUsVUFBVSxJQUFJLEVBQUUsRUFBUyxNQUFNLGVBQWUsQ0FBQztBQUV4RSxjQUFjLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFO0lBQ3hELElBQUksTUFBTSxH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QUM7UUFFdkIsaUJBQVksR0FBRyw2QkFBNkIsQ0FBQztJQWF6RCxDQUFDO0lBWFcsU0FBUyxDQUFDLFNBQTRCO1FBQzlDLE1BQU0sQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLHFCQUFxQixDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVTLE1BQU0sQ0FBQyxHQUF3QixFQUFFLE1BQWMsRUFBRSxLQUF3QjtRQUNqRixNQUFNLENBQUMsY0FBYyxDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVTLFVBQVUsQ0FBQyxFQUFNLEVBQUUsU0FBNEIsRUFBRSxLQUF3QyxFQUFFLE1BQWdCLEVBQUUsTUFBYztRQUNuSSxNQUFNLENBQUMsSUFBSSwyQkFBMkIsQ0FBQyxTQUFTLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO0lBQy9GLENBQUM7Q0FDRjtBQUVELGlDQUFrQyxTQUFRLG1CQUFzQztJQUFoRjs7UUFDRSxTQUFJLEdBQUcsaUJBQWlCLENBQUM7SUFLM0IsQ0FBQztJQUhXLE1BQU0sQ0FBQyxHQUF3QixFQUFFLE1BQWMsRUFBRSxLQUF3QjtRQUNqRixNQUFNLENBQUMsY0FBYyxDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDNUMsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFVwc2VydCwge1xuICBJbnNlcnRpb24sXG4gIENhdXRpb3VzSW5zZXJ0aW9uLFxuICBUcnVzdGluZ0luc2VydGlvbixcblxuICBpc1NhZmVTdHJpbmcsXG4gIGlzTm9kZSxcbiAgaXNTdHJpbmcsXG5cbiAgY2F1dGlvdXNJbnNlcnQsXG4gIHRydXN0aW5nSW5zZXJ0XG59IGZyb20gJy4uLy4uL3Vwc2VydCc7XG5pbXBvcnQgeyBpc0NvbXBvbmVudERlZmluaXRpb24gfSBmcm9tICcuLi8uLi9jb21wb25lbnQvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBET01UcmVlQ29uc3RydWN0aW9uIH0gZnJvbSAnLi4vLi4vZG9tL2hlbHBlcic7XG5pbXBvcnQgeyBPcGNvZGVKU09OLCBVcGRhdGluZ09wY29kZSB9IGZyb20gJy4uLy4uL29wY29kZXMnO1xuaW1wb3J0IHsgQ29tcGlsZWRFeHByZXNzaW9uLCBDb21waWxlZEFyZ3MgfSBmcm9tICcuLi9leHByZXNzaW9ucyc7XG5pbXBvcnQgeyBWTSwgVXBkYXRpbmdWTSB9IGZyb20gJy4uLy4uL3ZtJztcbmltcG9ydCB7IFRyeU9wY29kZSwgVk1TdGF0ZSB9IGZyb20gJy4uLy4uL3ZtL3VwZGF0ZSc7XG5pbXBvcnQgeyBSZWZlcmVuY2UsIFJlZmVyZW5jZUNhY2hlLCBVcGRhdGFibGVUYWcsIGlzTW9kaWZpZWQsIGlzQ29uc3QsIG1hcCB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBGSVhNRSwgT3B0aW9uLCBPcGFxdWUsIExpbmtlZExpc3QsIGV4cGVjdCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgQ3Vyc29yLCBjbGVhciB9IGZyb20gJy4uLy4uL2JvdW5kcyc7XG5pbXBvcnQgeyBGcmFnbWVudCB9IGZyb20gJy4uLy4uL2J1aWxkZXInO1xuaW1wb3J0IE9wY29kZUJ1aWxkZXJEU0wgZnJvbSAnLi9idWlsZGVyJztcbmltcG9ydCB7IENvbmRpdGlvbmFsUmVmZXJlbmNlIH0gZnJvbSAnLi4vLi4vcmVmZXJlbmNlcyc7XG5pbXBvcnQgeyBFbnZpcm9ubWVudCB9IGZyb20gJy4uLy4uL2Vudmlyb25tZW50JztcbmltcG9ydCB7IFVwZGF0YWJsZUJsb2NrVHJhY2tlciB9IGZyb20gJy4uLy4uL2J1aWxkZXInO1xuaW1wb3J0IHsgU3ltYm9sVGFibGUgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IEFQUEVORF9PUENPREVTLCBPcGNvZGVOYW1lIGFzIE9wLCBTbGljZSB9IGZyb20gJy4uLy4uL29wY29kZXMnO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuRHluYW1pY0NvbnRlbnQsICh2bSwgeyBvcDE6IGFwcGVuZCB9KSA9PiB7XG4gIGxldCBvcGNvZGUgPSB2bS5jb25zdGFudHMuZ2V0T3RoZXIoYXBwZW5kKSBhcyBBcHBlbmREeW5hbWljT3Bjb2RlPEluc2VydGlvbj47XG4gIG9wY29kZS5ldmFsdWF0ZSh2bSk7XG59KTtcblxuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZTogT3BhcXVlKTogYm9vbGVhbiB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2YWx1ZVsndG9TdHJpbmcnXSAhPT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVRleHRWYWx1ZSh2YWx1ZTogT3BhcXVlKTogc3RyaW5nIHtcbiAgaWYgKGlzRW1wdHkodmFsdWUpKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVUcnVzdGVkVmFsdWUodmFsdWU6IE9wYXF1ZSk6IFRydXN0aW5nSW5zZXJ0aW9uIHtcbiAgaWYgKGlzRW1wdHkodmFsdWUpKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU2FmZVN0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9IVE1MKCk7XG4gIH1cbiAgaWYgKGlzTm9kZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlOiBPcGFxdWUpOiBDYXV0aW91c0luc2VydGlvbiB7XG4gIGlmIChpc0VtcHR5KHZhbHVlKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1NhZmVTdHJpbmcodmFsdWUpIHx8IGlzTm9kZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCB0eXBlIEFwcGVuZER5bmFtaWNPcGNvZGVDb25zdHJ1Y3RvciA9ICB0eXBlb2YgT3B0aW1pemVkQ2F1dGlvdXNBcHBlbmRPcGNvZGUgfCB0eXBlb2YgT3B0aW1pemVkVHJ1c3RpbmdBcHBlbmRPcGNvZGU7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBcHBlbmREeW5hbWljT3Bjb2RlPFQgZXh0ZW5kcyBJbnNlcnRpb24+IHtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IG5vcm1hbGl6ZShyZWZlcmVuY2U6IFJlZmVyZW5jZTxPcGFxdWU+KTogUmVmZXJlbmNlPFQ+O1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgaW5zZXJ0KGRvbTogRE9NVHJlZUNvbnN0cnVjdGlvbiwgY3Vyc29yOiBDdXJzb3IsIHZhbHVlOiBUKTogVXBzZXJ0O1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgdXBkYXRlV2l0aCh2bTogVk0sIHJlZmVyZW5jZTogUmVmZXJlbmNlPE9wYXF1ZT4sIGNhY2hlOiBSZWZlcmVuY2VDYWNoZTxUPiwgYm91bmRzOiBGcmFnbWVudCwgdXBzZXJ0OiBVcHNlcnQpOiBVcGRhdGluZ09wY29kZTtcblxuICBldmFsdWF0ZSh2bTogVk0pIHtcbiAgICBsZXQgcmVmZXJlbmNlID0gdm0uZnJhbWUuZ2V0T3BlcmFuZCgpO1xuICAgIGxldCBub3JtYWxpemVkID0gdGhpcy5ub3JtYWxpemUocmVmZXJlbmNlKTtcblxuICAgIGxldCB2YWx1ZSwgY2FjaGU7XG5cbiAgICBpZiAoaXNDb25zdChyZWZlcmVuY2UpKSB7XG4gICAgICB2YWx1ZSA9IG5vcm1hbGl6ZWQudmFsdWUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGUgPSBuZXcgUmVmZXJlbmNlQ2FjaGUobm9ybWFsaXplZCk7XG4gICAgICB2YWx1ZSA9IGNhY2hlLnBlZWsoKTtcbiAgICB9XG5cbiAgICBsZXQgc3RhY2sgPSB2bS5zdGFjaygpO1xuICAgIGxldCB1cHNlcnQgPSB0aGlzLmluc2VydCh2bS5lbnYuZ2V0QXBwZW5kT3BlcmF0aW9ucygpLCBzdGFjaywgdmFsdWUpO1xuICAgIGxldCBib3VuZHMgPSBuZXcgRnJhZ21lbnQodXBzZXJ0LmJvdW5kcyk7XG5cbiAgICBzdGFjay5uZXdCb3VuZHMoYm91bmRzKTtcblxuICAgIGlmIChjYWNoZSAvKiBpLmUuICFpc0NvbnN0KHJlZmVyZW5jZSkgKi8pIHtcbiAgICAgIHZtLnVwZGF0ZVdpdGgodGhpcy51cGRhdGVXaXRoKHZtLCByZWZlcmVuY2UsIGNhY2hlLCBib3VuZHMsIHVwc2VydCkpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgR3VhcmRlZEFwcGVuZE9wY29kZTxUIGV4dGVuZHMgSW5zZXJ0aW9uPiBleHRlbmRzIEFwcGVuZER5bmFtaWNPcGNvZGU8VD4ge1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgQXBwZW5kT3Bjb2RlOiB0eXBlb2YgT3B0aW1pemVkQ2F1dGlvdXNBcHBlbmRPcGNvZGUgfCB0eXBlb2YgT3B0aW1pemVkVHJ1c3RpbmdBcHBlbmRPcGNvZGU7XG4gIHByaXZhdGUgZGVvcHRlZDogT3B0aW9uPFNsaWNlPiA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBleHByZXNzaW9uOiBDb21waWxlZEV4cHJlc3Npb248YW55PiwgcHJpdmF0ZSBzeW1ib2xUYWJsZTogU3ltYm9sVGFibGUpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgZXZhbHVhdGUodm06IFZNKSB7XG4gICAgaWYgKHRoaXMuZGVvcHRlZCkge1xuICAgICAgdm0ucHVzaEV2YWxGcmFtZSh0aGlzLmRlb3B0ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5ldmFsdWF0ZU9wZXJhbmQodGhpcy5leHByZXNzaW9uKTtcblxuICAgICAgbGV0IHZhbHVlID0gdm0uZnJhbWUuZ2V0T3BlcmFuZCgpLnZhbHVlKCk7XG5cbiAgICAgIGlmKGlzQ29tcG9uZW50RGVmaW5pdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgdm0ucHVzaEV2YWxGcmFtZSh0aGlzLmRlb3B0KHZtLmVudikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VwZXIuZXZhbHVhdGUodm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkZW9wdChlbnY6IEVudmlyb25tZW50KTogU2xpY2UgeyAvLyBQdWJsaWMgYmVjYXVzZSBpdCdzIHVzZWQgaW4gdGhlIGxhenkgZGVvcHRcbiAgICAvLyBBdCBjb21waWxlIHRpbWUsIHdlIGRldGVybWluZWQgdGhhdCB0aGlzIGFwcGVuZCBjYWxsc2l0ZSBtaWdodCByZWZlclxuICAgIC8vIHRvIGEgbG9jYWwgdmFyaWFibGUvcHJvcGVydHkgbG9va3VwIHRoYXQgcmVzb2x2ZXMgdG8gYSBjb21wb25lbnRcbiAgICAvLyBkZWZpbml0aW9uIGF0IHJ1bnRpbWUuXG4gICAgLy9cbiAgICAvLyBXZSBjb3VsZCBoYXZlIGVhZ2VybHkgY29tcGlsZWQgdGhpcyBjYWxsc2l0ZSBpbnRvIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4gICAgLy9cbiAgICAvLyAgIHt7I2lmIChpcy1jb21wb25lbnQtZGVmaW5pdGlvbiBmb28pfX1cbiAgICAvLyAgICAge3tjb21wb25lbnQgZm9vfX1cbiAgICAvLyAgIHt7ZWxzZX19XG4gICAgLy8gICAgIHt7Zm9vfX1cbiAgICAvLyAgIHt7L2lmfX1cbiAgICAvL1xuICAgIC8vIEhvd2V2ZXIsIGluIHByYWN0aWNlLCB0aGVyZSBtaWdodCBiZSBhIGxhcmdlIGFtb3V0IG9mIHRoZXNlIGNhbGxzaXRlc1xuICAgIC8vIGFuZCBtb3N0IG9mIHRoZW0gd291bGQgcmVzb2x2ZSB0byBhIHNpbXBsZSB2YWx1ZSBsb29rdXAuIFRoZXJlZm9yZSwgd2VcbiAgICAvLyB0cmllZCB0byBiZSBvcHRpbWlzdGljIGFuZCBhc3N1bWVkIHRoYXQgdGhlIGNhbGxzaXRlIHdpbGwgcmVzb2x2ZSB0b1xuICAgIC8vIGFwcGVuZGluZyBhIHNpbXBsZSB2YWx1ZS5cbiAgICAvL1xuICAgIC8vIEhvd2V2ZXIsIHdlIGhhdmUgcmVhY2hlZCBoZXJlIGJlY2F1c2UgYXQgcnVudGltZSwgdGhlIGd1YXJkIGNvbmRpdGlvbmFsXG4gICAgLy8gaGF2ZSBkZXRlY3RlZCB0aGF0IHRoaXMgY2FsbHNpdGUgaXMgaW5kZWVkIHJlZmVycmluZyB0byBhIGNvbXBvbmVudFxuICAgIC8vIGRlZmluaXRpb24gb2JqZWN0LiBTaW5jZSB0aGlzIGlzIGxpa2VseSBnb2luZyB0byBiZSB0cnVlIGZvciBvdGhlclxuICAgIC8vIGluc3RhbmNlcyBvZiB0aGUgc2FtZSBjYWxsc2l0ZSwgaXQgaXMgbm93IGFwcHJvcGlhdGUgdG8gZGVvcHQgaW50byB0aGVcbiAgICAvLyBleHBhbmRlZCB2ZXJzaW9uIHRoYXQgaGFuZGxlcyBib3RoIGNhc2VzLiBUaGUgY29tcGlsYXRpb24gd291bGQgbG9va1xuICAgIC8vIGxpa2UgdGhpczpcbiAgICAvL1xuICAgIC8vICAgICAgICAgICAgICAgUHV0VmFsdWUoZXhwcmVzc2lvbilcbiAgICAvLyAgICAgICAgICAgICAgIFRlc3QoaXMtY29tcG9uZW50LWRlZmluaXRpb24pXG4gICAgLy8gICAgICAgICAgICAgICBFbnRlcihCRUdJTiwgRU5EKVxuICAgIC8vICAgQkVHSU46ICAgICAgTm9vcFxuICAgIC8vICAgICAgICAgICAgICAgSnVtcFVubGVzcyhWQUxVRSlcbiAgICAvLyAgICAgICAgICAgICAgIFB1dER5bmFtaWNDb21wb25lbnREZWZpbml0aW9uT3Bjb2RlXG4gICAgLy8gICAgICAgICAgICAgICBPcGVuQ29tcG9uZW50XG4gICAgLy8gICAgICAgICAgICAgICBDbG9zZUNvbXBvbmVudFxuICAgIC8vICAgICAgICAgICAgICAgSnVtcChFTkQpXG4gICAgLy8gICBWQUxVRTogICAgICBOb29wXG4gICAgLy8gICAgICAgICAgICAgICBPcHRpbWl6ZWRBcHBlbmRcbiAgICAvLyAgIEVORDogICAgICAgIE5vb3BcbiAgICAvLyAgICAgICAgICAgICAgIEV4aXRcbiAgICAvL1xuICAgIC8vIEtlZXAgaW4gbWluZCB0aGF0IGV2ZW4gaWYgd2UgKmRvbid0KiByZWFjaCBoZXJlIGF0IGluaXRpYWwgcmVuZGVyIHRpbWUsXG4gICAgLy8gaXQgaXMgc3RpbGwgcG9zc2libGUgKGFsdGhvdWdoIHF1aXRlIHJhcmUpIHRoYXQgdGhlIHNpbXBsZSB2YWx1ZSB3ZVxuICAgIC8vIGVuY291bnRlciBkdXJpbmcgaW5pdGlhbCByZW5kZXIgY291bGQgbGF0ZXIgY2hhbmdlIGludG8gYSBjb21wb25lbnRcbiAgICAvLyBkZWZpbml0aW9uIG9iamVjdCBhdCB1cGRhdGUgdGltZS4gVGhhdCBpcyBoYW5kbGVkIGJ5IHRoZSBcImxhenkgZGVvcHRcIlxuICAgIC8vIGNvZGUgb24gdGhlIHVwZGF0ZSBzaWRlIChzY3JvbGwgZG93biBmb3IgdGhlIG5leHQgYmlnIGJsb2NrIG9mIGNvbW1lbnQpLlxuXG4gICAgbGV0IGRzbCA9IG5ldyBPcGNvZGVCdWlsZGVyRFNMKHRoaXMuc3ltYm9sVGFibGUsIGVudik7XG5cbiAgICBkc2wucHV0VmFsdWUodGhpcy5leHByZXNzaW9uKTtcbiAgICBkc2wudGVzdChJc0NvbXBvbmVudERlZmluaXRpb25SZWZlcmVuY2UuY3JlYXRlKTtcblxuICAgIGRzbC5sYWJlbGxlZChudWxsLCAoZHNsLCBfQkVHSU4sIEVORCkgPT4ge1xuICAgICAgZHNsLmp1bXBVbmxlc3MoJ1ZBTFVFJyk7XG4gICAgICBkc2wucHV0RHluYW1pY0NvbXBvbmVudERlZmluaXRpb24oKTtcbiAgICAgIGRzbC5vcGVuQ29tcG9uZW50KENvbXBpbGVkQXJncy5lbXB0eSgpKTtcbiAgICAgIGRzbC5jbG9zZUNvbXBvbmVudCgpO1xuICAgICAgZHNsLmp1bXAoRU5EKTtcbiAgICAgIGRzbC5sYWJlbCgnVkFMVUUnKTtcbiAgICAgIGRzbC5keW5hbWljQ29udGVudChuZXcgdGhpcy5BcHBlbmRPcGNvZGUoKSk7XG4gICAgfSk7XG5cbiAgICBsZXQgZGVvcHRlZCA9IHRoaXMuZGVvcHRlZCA9IGRzbC50b1NsaWNlKCk7XG5cbiAgICAvLyBGcm9tIHRoaXMgcG9pbnQgb24sIHdlIGhhdmUgZXNzZW50aWFsbHkgcmVwbGFjZWQgb3Vyc2VsdmVzIHdpdGggYSBuZXcgc2V0XG4gICAgLy8gb2Ygb3Bjb2Rlcy4gU2luY2Ugd2Ugd2lsbCBhbHdheXMgYmUgZXhlY3V0aW5nIHRoZSBuZXcvZGVvcHRlZCBjb2RlLCBpdCdzXG4gICAgLy8gYSBnb29kIGlkZWEgKGFzIGEgcGF0dGVybikgdG8gbnVsbCBvdXQgYW55IHVubmVlZGVkIGZpZWxkcyBoZXJlIHRvIGF2b2lkXG4gICAgLy8gaG9sZGluZyBvbiB0byB1bm5lZWRlZC9zdGFsZSBvYmplY3RzOlxuXG4gICAgLy8gUVVFU1RJT046IFNob3VsZG4ndCB0aGlzIHdob2xlIG9iamVjdCBiZSBHQ2VkPyBJZiBub3QsIHdoeSBub3Q/XG5cbiAgICB0aGlzLmV4cHJlc3Npb24gPSBudWxsIGFzIEZJWE1FPGFueSwgJ1FVRVNUSU9OJz47XG5cbiAgICByZXR1cm4gZGVvcHRlZDtcbiAgfVxufVxuXG5jbGFzcyBJc0NvbXBvbmVudERlZmluaXRpb25SZWZlcmVuY2UgZXh0ZW5kcyBDb25kaXRpb25hbFJlZmVyZW5jZSB7XG4gIHN0YXRpYyBjcmVhdGUoaW5uZXI6IFJlZmVyZW5jZTxPcGFxdWU+KTogSXNDb21wb25lbnREZWZpbml0aW9uUmVmZXJlbmNlIHtcbiAgICByZXR1cm4gbmV3IElzQ29tcG9uZW50RGVmaW5pdGlvblJlZmVyZW5jZShpbm5lcik7XG4gIH1cblxuICB0b0Jvb2wodmFsdWU6IE9wYXF1ZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc0NvbXBvbmVudERlZmluaXRpb24odmFsdWUpO1xuICB9XG59XG5cbmFic3RyYWN0IGNsYXNzIFVwZGF0ZU9wY29kZTxUIGV4dGVuZHMgSW5zZXJ0aW9uPiBleHRlbmRzIFVwZGF0aW5nT3Bjb2RlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIGNhY2hlOiBSZWZlcmVuY2VDYWNoZTxUPixcbiAgICBwcm90ZWN0ZWQgYm91bmRzOiBGcmFnbWVudCxcbiAgICBwcm90ZWN0ZWQgdXBzZXJ0OiBVcHNlcnRcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnRhZyA9IGNhY2hlLnRhZztcbiAgfVxuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBpbnNlcnQoZG9tOiBET01UcmVlQ29uc3RydWN0aW9uLCBjdXJzb3I6IEN1cnNvciwgdmFsdWU6IFQpOiBVcHNlcnQ7XG5cbiAgZXZhbHVhdGUodm06IFVwZGF0aW5nVk0pIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLmNhY2hlLnJldmFsaWRhdGUoKTtcblxuICAgIGlmIChpc01vZGlmaWVkKHZhbHVlKSkge1xuICAgICAgbGV0IHsgYm91bmRzLCB1cHNlcnQgfSA9IHRoaXM7XG4gICAgICBsZXQgeyBkb20gfSA9IHZtO1xuXG4gICAgICBpZighdGhpcy51cHNlcnQudXBkYXRlKGRvbSwgdmFsdWUpKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgQ3Vyc29yKGJvdW5kcy5wYXJlbnRFbGVtZW50KCksIGNsZWFyKGJvdW5kcykpO1xuICAgICAgICB1cHNlcnQgPSB0aGlzLnVwc2VydCA9IHRoaXMuaW5zZXJ0KHZtLmVudi5nZXRBcHBlbmRPcGVyYXRpb25zKCksIGN1cnNvciwgdmFsdWUgYXMgVCk7XG4gICAgICB9XG5cbiAgICAgIGJvdW5kcy51cGRhdGUodXBzZXJ0LmJvdW5kcyk7XG4gICAgfVxuICB9XG5cbiAgdG9KU09OKCk6IE9wY29kZUpTT04ge1xuICAgIGxldCB7IF9ndWlkOiBndWlkLCB0eXBlLCBjYWNoZSB9ID0gdGhpcztcblxuICAgIHJldHVybiB7XG4gICAgICBndWlkLFxuICAgICAgdHlwZSxcbiAgICAgIGRldGFpbHM6IHsgbGFzdFZhbHVlOiBKU09OLnN0cmluZ2lmeShjYWNoZS5wZWVrKCkpIH1cbiAgICB9O1xuICB9XG59XG5cbmFic3RyYWN0IGNsYXNzIEd1YXJkZWRVcGRhdGVPcGNvZGU8VCBleHRlbmRzIEluc2VydGlvbj4gZXh0ZW5kcyBVcGRhdGVPcGNvZGU8VD4ge1xuICBwcml2YXRlIF90YWc6IFVwZGF0YWJsZVRhZztcbiAgcHJpdmF0ZSBkZW9wdGVkOiBPcHRpb248VHJ5T3Bjb2RlPiA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWZlcmVuY2U6IFJlZmVyZW5jZTxPcGFxdWU+LFxuICAgIGNhY2hlOiBSZWZlcmVuY2VDYWNoZTxUPixcbiAgICBib3VuZHM6IEZyYWdtZW50LFxuICAgIHVwc2VydDogVXBzZXJ0LFxuICAgIHByaXZhdGUgYXBwZW5kT3Bjb2RlOiBHdWFyZGVkQXBwZW5kT3Bjb2RlPFQ+LFxuICAgIHByaXZhdGUgc3RhdGU6IFZNU3RhdGVcbiAgKSB7XG4gICAgc3VwZXIoY2FjaGUsIGJvdW5kcywgdXBzZXJ0KTtcbiAgICB0aGlzLnRhZyA9IHRoaXMuX3RhZyA9IG5ldyBVcGRhdGFibGVUYWcodGhpcy50YWcpO1xuICB9XG5cbiAgZXZhbHVhdGUodm06IFVwZGF0aW5nVk0pIHtcbiAgICBpZiAodGhpcy5kZW9wdGVkKSB7XG4gICAgICB2bS5ldmFsdWF0ZU9wY29kZSh0aGlzLmRlb3B0ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNDb21wb25lbnREZWZpbml0aW9uKHRoaXMucmVmZXJlbmNlLnZhbHVlKCkpKSB7XG4gICAgICAgIHRoaXMubGF6eURlb3B0KHZtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1cGVyLmV2YWx1YXRlKHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGxhenlEZW9wdCh2bTogVXBkYXRpbmdWTSkge1xuICAgIC8vIER1cmlnbiBpbml0aWFsIHJlbmRlciwgd2Uga25vdyB0aGF0IHRoZSByZWZlcmVuY2UgZG9lcyBub3QgY29udGFpbiBhXG4gICAgLy8gY29tcG9uZW50IGRlZmluaXRpb24sIHNvIHdlIG9wdGltaXN0aWNhbGx5IGFzc3VtZWQgdGhhdCB0aGlzIGFwcGVuZFxuICAgIC8vIGlzIGp1c3QgYSBub3JtYWwgYXBwZW5kLiBIb3dldmVyLCBhdCB1cGRhdGUgdGltZSwgd2UgZGlzY292ZXJlZCB0aGF0XG4gICAgLy8gdGhlIHJlZmVyZW5jZSBoYXMgc3dpdGNoZWQgaW50byBjb250YWluaW5nIGEgY29tcG9uZW50IGRlZmluaXRpb24sIHNvXG4gICAgLy8gd2UgbmVlZCB0byBkbyBhIFwibGF6eSBkZW9wdFwiLCBzaW11bGF0aW5nIHdoYXQgd291bGQgaGF2ZSBoYXBwZW5lZCBpZlxuICAgIC8vIHdlIGhhZCBkZWNpZGVkIHRvIHBlcmZvcm0gdGhlIGRlb3B0IGluIHRoZSBmaXJzdCBwbGFjZSBkdXJpbmcgaW5pdGlhbFxuICAgIC8vIHJlbmRlci5cbiAgICAvL1xuICAgIC8vIE1vcmUgY29uY3JldGVseSwgd2Ugd291bGQgaGF2ZSBleHBhbmRlZCB0aGUgY3VybHkgaW50byBhIGlmL2Vsc2UsIGFuZFxuICAgIC8vIGJhc2VkIG9uIHdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgY29tcG9uZW50IGRlZmluaXRpb24gb3Igbm90LCB3ZSB3b3VsZFxuICAgIC8vIGhhdmUgZW50ZXJlZCBlaXRoZXIgdGhlIGR5bmFtaWMgY29tcG9uZW50IGJyYW5jaCBvciB0aGUgc2ltcGxlIHZhbHVlXG4gICAgLy8gYnJhbmNoLlxuICAgIC8vXG4gICAgLy8gU2luY2Ugd2UgcmVuZGVyZWQgYSBzaW1wbGUgdmFsdWUgZHVyaW5nIGluaXRpYWwgcmVuZGVyIChhbmQgYWxsIHRoZVxuICAgIC8vIHVwZGF0ZXMgdXAgdW50aWwgdGhpcyBwb2ludCksIHdlIG5lZWQgdG8gcHJldGVuZCB0aGF0IHRoZSByZXN1bHQgaXNcbiAgICAvLyBwcm9kdWNlZCBieSB0aGUgXCJWQUxVRVwiIGJyYW5jaCBvZiB0aGUgZGVvcHRlZCBhcHBlbmQgb3Bjb2RlOlxuICAgIC8vXG4gICAgLy8gICBUcnkoQkVHSU4sIEVORClcbiAgICAvLyAgICAgQXNzZXJ0KElzQ29tcG9uZW50RGVmaW5pdGlvbiwgZXhwZWN0ZWQ9ZmFsc2UpXG4gICAgLy8gICAgIE9wdGltaXplZFVwZGF0ZVxuICAgIC8vXG4gICAgLy8gSW4gdGhpcyBjYXNlLCBiZWNhdXNlIHRoZSByZWZlcmVuY2UgaGFzIHN3aXRjaGVkIGZyb20gYmVpbmcgYSBzaW1wbGVcbiAgICAvLyB2YWx1ZSBpbnRvIGEgY29tcG9uZW50IGRlZmluaXRpb24sIHdoYXQgd291bGQgaGF2ZSBoYXBwZW5lZCBpcyB0aGF0XG4gICAgLy8gdGhlIGFzc2VydCB3b3VsZCB0aHJvdywgY2F1c2luZyB0aGUgVHJ5IG9wY29kZSB0byB0ZWFyZG93biB0aGUgYm91bmRzXG4gICAgLy8gYW5kIHJlcnVuIHRoZSBvcmlnaW5hbCBhcHBlbmQgb3Bjb2RlLlxuICAgIC8vXG4gICAgLy8gU2luY2UgdGhlIFRyeSBvcGNvZGUgd291bGQgaGF2ZSBudWtlZCB0aGUgdXBkYXRpbmcgb3Bjb2RlcyBhbnl3YXksIHdlXG4gICAgLy8gd291bGRuJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCBzaW11bGF0aW5nIHRob3NlLiBBbGwgd2UgaGF2ZSB0byBkbyBpcyB0b1xuICAgIC8vIGV4ZWN1dGUgdGhlIFRyeSBvcGNvZGUgYW5kIGltbWVkaWF0ZWx5IHRocm93LlxuXG4gICAgbGV0IHsgYm91bmRzLCBhcHBlbmRPcGNvZGUsIHN0YXRlIH0gPSB0aGlzO1xuICAgIGxldCBlbnYgPSB2bS5lbnY7XG5cbiAgICBsZXQgc2xpY2UgICAgID0gYXBwZW5kT3Bjb2RlLmRlb3B0KGVudik7XG4gICAgbGV0IGVudGVyICAgICA9IGV4cGVjdChlbnYucHJvZ3JhbS5vcGNvZGUoc2xpY2VbMF0gKyA4KSwgJ2hhcmRjb2RlZCBkZW9wdCBsb2NhdGlvbicpO1xuICAgIGxldCBvcHMgICAgICAgPSB2bS5jb25zdGFudHMuZ2V0U2xpY2UoZW50ZXIub3AxKTtcblxuICAgIGxldCB0cmFja2VyID0gbmV3IFVwZGF0YWJsZUJsb2NrVHJhY2tlcihib3VuZHMucGFyZW50RWxlbWVudCgpKTtcbiAgICB0cmFja2VyLm5ld0JvdW5kcyh0aGlzLmJvdW5kcyk7XG5cbiAgICBsZXQgY2hpbGRyZW4gPSBuZXcgTGlua2VkTGlzdDxVcGRhdGluZ09wY29kZT4oKTtcblxuICAgIHN0YXRlLmZyYW1lWydjb25kaXRpb24nXSA9IElzQ29tcG9uZW50RGVmaW5pdGlvblJlZmVyZW5jZS5jcmVhdGUoZXhwZWN0KHN0YXRlLmZyYW1lWydvcGVyYW5kJ10sICdvcGVyYW5kIHNob3VsZCBiZSBwb3B1bGF0ZWQnKSk7XG5cbiAgICBsZXQgZGVvcHRlZCA9IHRoaXMuZGVvcHRlZCA9IG5ldyBUcnlPcGNvZGUob3BzLCBzdGF0ZSwgdHJhY2tlciwgY2hpbGRyZW4pO1xuXG4gICAgdGhpcy5fdGFnLnVwZGF0ZShkZW9wdGVkLnRhZyk7XG5cbiAgICB2bS5ldmFsdWF0ZU9wY29kZShkZW9wdGVkKTtcbiAgICB2bS50aHJvdygpO1xuXG4gICAgLy8gRnJvbSB0aGlzIHBvaW50IG9uLCB3ZSBoYXZlIGVzc2VudGlhbGx5IHJlcGxhY2VkIG91cnNlbHZlIHdpdGggYSBuZXdcbiAgICAvLyBvcGNvZGUuIFNpbmNlIHdlIHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGluZyB0aGUgbmV3L2Rlb3B0ZWQgY29kZSwgaXQncyBhXG4gICAgLy8gZ29vZCBpZGVhIChhcyBhIHBhdHRlcm4pIHRvIG51bGwgb3V0IGFueSB1bm5lZWRlZCBmaWVsZHMgaGVyZSB0byBhdm9pZFxuICAgIC8vIGhvbGRpbmcgb24gdG8gdW5uZWVkZWQvc3RhbGUgb2JqZWN0czpcblxuICAgIC8vIFFVRVNUSU9OOiBTaG91bGRuJ3QgdGhpcyB3aG9sZSBvYmplY3QgYmUgR0NlZD8gSWYgbm90LCB3aHkgbm90P1xuXG4gICAgdGhpcy5fdGFnICAgICAgICAgPSBudWxsIGFzIEZJWE1FPGFueSwgJ1FVRVNUSU9OJz47XG4gICAgdGhpcy5yZWZlcmVuY2UgICAgPSBudWxsIGFzIEZJWE1FPGFueSwgJ1FVRVNUSU9OJz47XG4gICAgdGhpcy5jYWNoZSAgICAgICAgPSBudWxsIGFzIEZJWE1FPGFueSwgJ1FVRVNUSU9OJz47XG4gICAgdGhpcy5ib3VuZHMgICAgICAgPSBudWxsIGFzIEZJWE1FPGFueSwgJ1FVRVNUSU9OJz47XG4gICAgdGhpcy51cHNlcnQgICAgICAgPSBudWxsIGFzIEZJWE1FPGFueSwgJ1FVRVNUSU9OJz47XG4gICAgdGhpcy5hcHBlbmRPcGNvZGUgPSBudWxsIGFzIEZJWE1FPGFueSwgJ1FVRVNUSU9OJz47XG4gICAgdGhpcy5zdGF0ZSAgICAgICAgPSBudWxsIGFzIEZJWE1FPGFueSwgJ1FVRVNUSU9OJz47XG4gIH1cblxuICB0b0pTT04oKTogT3Bjb2RlSlNPTiB7XG4gICAgbGV0IHsgX2d1aWQ6IGd1aWQsIHR5cGUsIGRlb3B0ZWQgfSA9IHRoaXM7XG5cbiAgICBpZiAoZGVvcHRlZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ3VpZCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgZGVvcHRlZDogdHJ1ZSxcbiAgICAgICAgY2hpbGRyZW46IFtkZW9wdGVkLnRvSlNPTigpXVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN1cGVyLnRvSlNPTigpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgT3B0aW1pemVkQ2F1dGlvdXNBcHBlbmRPcGNvZGUgZXh0ZW5kcyBBcHBlbmREeW5hbWljT3Bjb2RlPENhdXRpb3VzSW5zZXJ0aW9uPiB7XG4gIHR5cGUgPSAnb3B0aW1pemVkLWNhdXRpb3VzLWFwcGVuZCc7XG5cbiAgcHJvdGVjdGVkIG5vcm1hbGl6ZShyZWZlcmVuY2U6IFJlZmVyZW5jZTxPcGFxdWU+KTogUmVmZXJlbmNlPENhdXRpb3VzSW5zZXJ0aW9uPiB7XG4gICAgcmV0dXJuIG1hcChyZWZlcmVuY2UsIG5vcm1hbGl6ZVZhbHVlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBpbnNlcnQoZG9tOiBET01UcmVlQ29uc3RydWN0aW9uLCBjdXJzb3I6IEN1cnNvciwgdmFsdWU6IENhdXRpb3VzSW5zZXJ0aW9uKTogVXBzZXJ0IHtcbiAgICByZXR1cm4gY2F1dGlvdXNJbnNlcnQoZG9tLCBjdXJzb3IsIHZhbHVlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCB1cGRhdGVXaXRoKF92bTogVk0sIF9yZWZlcmVuY2U6IFJlZmVyZW5jZTxPcGFxdWU+LCBjYWNoZTogUmVmZXJlbmNlQ2FjaGU8Q2F1dGlvdXNJbnNlcnRpb24+LCBib3VuZHM6IEZyYWdtZW50LCB1cHNlcnQ6IFVwc2VydCk6IFVwZGF0aW5nT3Bjb2RlIHtcbiAgICByZXR1cm4gbmV3IE9wdGltaXplZENhdXRpb3VzVXBkYXRlT3Bjb2RlKGNhY2hlLCBib3VuZHMsIHVwc2VydCk7XG4gIH1cbn1cblxuY2xhc3MgT3B0aW1pemVkQ2F1dGlvdXNVcGRhdGVPcGNvZGUgZXh0ZW5kcyBVcGRhdGVPcGNvZGU8Q2F1dGlvdXNJbnNlcnRpb24+IHtcbiAgdHlwZSA9ICdvcHRpbWl6ZWQtY2F1dGlvdXMtdXBkYXRlJztcblxuICBwcm90ZWN0ZWQgaW5zZXJ0KGRvbTogRE9NVHJlZUNvbnN0cnVjdGlvbiwgY3Vyc29yOiBDdXJzb3IsIHZhbHVlOiBDYXV0aW91c0luc2VydGlvbik6IFVwc2VydCB7XG4gICAgcmV0dXJuIGNhdXRpb3VzSW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEd1YXJkZWRDYXV0aW91c0FwcGVuZE9wY29kZSBleHRlbmRzIEd1YXJkZWRBcHBlbmRPcGNvZGU8Q2F1dGlvdXNJbnNlcnRpb24+IHtcbiAgdHlwZSA9ICdndWFyZGVkLWNhdXRpb3VzLWFwcGVuZCc7XG5cbiAgcHJvdGVjdGVkIEFwcGVuZE9wY29kZSA9IE9wdGltaXplZENhdXRpb3VzQXBwZW5kT3Bjb2RlO1xuXG4gIHByb3RlY3RlZCBub3JtYWxpemUocmVmZXJlbmNlOiBSZWZlcmVuY2U8T3BhcXVlPik6IFJlZmVyZW5jZTxDYXV0aW91c0luc2VydGlvbj4ge1xuICAgIHJldHVybiBtYXAocmVmZXJlbmNlLCBub3JtYWxpemVWYWx1ZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgaW5zZXJ0KGRvbTogRE9NVHJlZUNvbnN0cnVjdGlvbiwgY3Vyc29yOiBDdXJzb3IsIHZhbHVlOiBDYXV0aW91c0luc2VydGlvbik6IFVwc2VydCB7XG4gICAgcmV0dXJuIGNhdXRpb3VzSW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgdXBkYXRlV2l0aCh2bTogVk0sIHJlZmVyZW5jZTogUmVmZXJlbmNlPE9wYXF1ZT4sIGNhY2hlOiBSZWZlcmVuY2VDYWNoZTxDYXV0aW91c0luc2VydGlvbj4sIGJvdW5kczogRnJhZ21lbnQsIHVwc2VydDogVXBzZXJ0KTogVXBkYXRpbmdPcGNvZGUge1xuICAgIHJldHVybiBuZXcgR3VhcmRlZENhdXRpb3VzVXBkYXRlT3Bjb2RlKHJlZmVyZW5jZSwgY2FjaGUsIGJvdW5kcywgdXBzZXJ0LCB0aGlzLCB2bS5jYXB0dXJlKCkpO1xuICB9XG59XG5cbmNsYXNzIEd1YXJkZWRDYXV0aW91c1VwZGF0ZU9wY29kZSBleHRlbmRzIEd1YXJkZWRVcGRhdGVPcGNvZGU8Q2F1dGlvdXNJbnNlcnRpb24+IHtcbiAgdHlwZSA9ICdndWFyZGVkLWNhdXRpb3VzLXVwZGF0ZSc7XG5cbiAgcHJvdGVjdGVkIGluc2VydChkb206IERPTVRyZWVDb25zdHJ1Y3Rpb24sIGN1cnNvcjogQ3Vyc29yLCB2YWx1ZTogQ2F1dGlvdXNJbnNlcnRpb24pOiBVcHNlcnQge1xuICAgIHJldHVybiBjYXV0aW91c0luc2VydChkb20sIGN1cnNvciwgdmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBPcHRpbWl6ZWRUcnVzdGluZ0FwcGVuZE9wY29kZSBleHRlbmRzIEFwcGVuZER5bmFtaWNPcGNvZGU8VHJ1c3RpbmdJbnNlcnRpb24+IHtcbiAgdHlwZSA9ICdvcHRpbWl6ZWQtdHJ1c3RpbmctYXBwZW5kJztcblxuICBwcm90ZWN0ZWQgbm9ybWFsaXplKHJlZmVyZW5jZTogUmVmZXJlbmNlPE9wYXF1ZT4pOiBSZWZlcmVuY2U8VHJ1c3RpbmdJbnNlcnRpb24+IHtcbiAgICByZXR1cm4gbWFwKHJlZmVyZW5jZSwgbm9ybWFsaXplVHJ1c3RlZFZhbHVlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBpbnNlcnQoZG9tOiBET01UcmVlQ29uc3RydWN0aW9uLCBjdXJzb3I6IEN1cnNvciwgdmFsdWU6IFRydXN0aW5nSW5zZXJ0aW9uKTogVXBzZXJ0IHtcbiAgICByZXR1cm4gdHJ1c3RpbmdJbnNlcnQoZG9tLCBjdXJzb3IsIHZhbHVlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCB1cGRhdGVXaXRoKF92bTogVk0sIF9yZWZlcmVuY2U6IFJlZmVyZW5jZTxPcGFxdWU+LCBjYWNoZTogUmVmZXJlbmNlQ2FjaGU8VHJ1c3RpbmdJbnNlcnRpb24+LCBib3VuZHM6IEZyYWdtZW50LCB1cHNlcnQ6IFVwc2VydCk6IFVwZGF0aW5nT3Bjb2RlIHtcbiAgICByZXR1cm4gbmV3IE9wdGltaXplZFRydXN0aW5nVXBkYXRlT3Bjb2RlKGNhY2hlLCBib3VuZHMsIHVwc2VydCk7XG4gIH1cbn1cblxuY2xhc3MgT3B0aW1pemVkVHJ1c3RpbmdVcGRhdGVPcGNvZGUgZXh0ZW5kcyBVcGRhdGVPcGNvZGU8VHJ1c3RpbmdJbnNlcnRpb24+IHtcbiAgdHlwZSA9ICdvcHRpbWl6ZWQtdHJ1c3RpbmctdXBkYXRlJztcblxuICBwcm90ZWN0ZWQgaW5zZXJ0KGRvbTogRE9NVHJlZUNvbnN0cnVjdGlvbiwgY3Vyc29yOiBDdXJzb3IsIHZhbHVlOiBUcnVzdGluZ0luc2VydGlvbik6IFVwc2VydCB7XG4gICAgcmV0dXJuIHRydXN0aW5nSW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEd1YXJkZWRUcnVzdGluZ0FwcGVuZE9wY29kZSBleHRlbmRzIEd1YXJkZWRBcHBlbmRPcGNvZGU8VHJ1c3RpbmdJbnNlcnRpb24+IHtcbiAgdHlwZSA9ICdndWFyZGVkLXRydXN0aW5nLWFwcGVuZCc7XG5cbiAgcHJvdGVjdGVkIEFwcGVuZE9wY29kZSA9IE9wdGltaXplZFRydXN0aW5nQXBwZW5kT3Bjb2RlO1xuXG4gIHByb3RlY3RlZCBub3JtYWxpemUocmVmZXJlbmNlOiBSZWZlcmVuY2U8T3BhcXVlPik6IFJlZmVyZW5jZTxUcnVzdGluZ0luc2VydGlvbj4ge1xuICAgIHJldHVybiBtYXAocmVmZXJlbmNlLCBub3JtYWxpemVUcnVzdGVkVmFsdWUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGluc2VydChkb206IERPTVRyZWVDb25zdHJ1Y3Rpb24sIGN1cnNvcjogQ3Vyc29yLCB2YWx1ZTogVHJ1c3RpbmdJbnNlcnRpb24pOiBVcHNlcnQge1xuICAgIHJldHVybiB0cnVzdGluZ0luc2VydChkb20sIGN1cnNvciwgdmFsdWUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHVwZGF0ZVdpdGgodm06IFZNLCByZWZlcmVuY2U6IFJlZmVyZW5jZTxPcGFxdWU+LCBjYWNoZTogUmVmZXJlbmNlQ2FjaGU8VHJ1c3RpbmdJbnNlcnRpb24+LCBib3VuZHM6IEZyYWdtZW50LCB1cHNlcnQ6IFVwc2VydCk6IFVwZGF0aW5nT3Bjb2RlIHtcbiAgICByZXR1cm4gbmV3IEd1YXJkZWRUcnVzdGluZ1VwZGF0ZU9wY29kZShyZWZlcmVuY2UsIGNhY2hlLCBib3VuZHMsIHVwc2VydCwgdGhpcywgdm0uY2FwdHVyZSgpKTtcbiAgfVxufVxuXG5jbGFzcyBHdWFyZGVkVHJ1c3RpbmdVcGRhdGVPcGNvZGUgZXh0ZW5kcyBHdWFyZGVkVXBkYXRlT3Bjb2RlPFRydXN0aW5nSW5zZXJ0aW9uPiB7XG4gIHR5cGUgPSAndHJ1c3RpbmctdXBkYXRlJztcblxuICBwcm90ZWN0ZWQgaW5zZXJ0KGRvbTogRE9NVHJlZUNvbnN0cnVjdGlvbiwgY3Vyc29yOiBDdXJzb3IsIHZhbHVlOiBUcnVzdGluZ0luc2VydGlvbik6IFVwc2VydCB7XG4gICAgcmV0dXJuIHRydXN0aW5nSW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSk7XG4gIH1cbn1cbiJdfQ==