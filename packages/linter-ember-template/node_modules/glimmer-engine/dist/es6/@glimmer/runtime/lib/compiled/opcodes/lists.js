import { EvaluatedArgs } from '../expressions/args';
import { expect } from '@glimmer/util';
import { ConstReference, ReferenceIterator } from '@glimmer/reference';
import { APPEND_OPCODES, OpcodeName as Op } from '../../opcodes';
class IterablePresenceReference {
    constructor(artifacts) {
        this.tag = artifacts.tag;
        this.artifacts = artifacts;
    }
    value() {
        return !this.artifacts.isEmpty();
    }
}
APPEND_OPCODES.add(Op.PutIterator, vm => {
    let listRef = vm.frame.getOperand();
    let args = expect(vm.frame.getArgs(), 'PutIteratorOpcode expects a populated args register');
    let iterable = vm.env.iterableFor(listRef, args);
    let iterator = new ReferenceIterator(iterable);
    vm.frame.setIterator(iterator);
    vm.frame.setCondition(new IterablePresenceReference(iterator.artifacts));
});
APPEND_OPCODES.add(Op.EnterList, (vm, { op1: _slice }) => {
    vm.enterList(vm.constants.getSlice(_slice));
});
APPEND_OPCODES.add(Op.ExitList, vm => vm.exitList());
APPEND_OPCODES.add(Op.EnterWithKey, (vm, { op2: _slice }) => {
    let key = expect(vm.frame.getKey(), 'EnterWithKeyOpcode expects a populated key register');
    let slice = vm.constants.getSlice(_slice);
    vm.enterWithKey(key, slice);
});
const TRUE_REF = new ConstReference(true);
const FALSE_REF = new ConstReference(false);
APPEND_OPCODES.add(Op.NextIter, (vm, { op1: end }) => {
    let item = vm.frame.getIterator().next();
    if (item) {
        vm.frame.setCondition(TRUE_REF);
        vm.frame.setKey(item.key);
        vm.frame.setOperand(item.value);
        vm.frame.setArgs(EvaluatedArgs.positional([item.value, item.memo]));
    }
    else {
        vm.frame.setCondition(FALSE_REF);
        vm.goto(end);
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGlzdHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJAZ2xpbW1lci9ydW50aW1lL2xpYi9jb21waWxlZC9vcGNvZGVzL2xpc3RzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3ZDLE9BQU8sRUFBMEIsY0FBYyxFQUFFLGlCQUFpQixFQUFzQixNQUFNLG9CQUFvQixDQUFDO0FBQ25ILE9BQU8sRUFBRSxjQUFjLEVBQUUsVUFBVSxJQUFJLEVBQUUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVqRTtJQUlFLFlBQVksU0FBNkI7UUFDdkMsSUFBSSxDQUFDLEdBQUcsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDO1FBQ3pCLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0lBQzdCLENBQUM7SUFFRCxLQUFLO1FBQ0gsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUNuQyxDQUFDO0NBQ0Y7QUFFRCxjQUFjLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxXQUFXLEVBQUUsRUFBRTtJQUNuQyxJQUFJLE9BQU8sR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQ3BDLElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxFQUFFLHFEQUFxRCxDQUFDLENBQUM7SUFDN0YsSUFBSSxRQUFRLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2pELElBQUksUUFBUSxHQUFHLElBQUksaUJBQWlCLENBQUMsUUFBUSxDQUFDLENBQUM7SUFFL0MsRUFBRSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDL0IsRUFBRSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsSUFBSSx5QkFBeUIsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztBQUMzRSxDQUFDLENBQUMsQ0FBQztBQUVILGNBQWMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUU7SUFDbkQsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQzlDLENBQUMsQ0FBQyxDQUFDO0FBRUgsY0FBYyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLEVBQUUsSUFBSSxFQUFFLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztBQUVyRCxjQUFjLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFO0lBQ3RELElBQUksR0FBRyxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxFQUFFLHFEQUFxRCxDQUFDLENBQUM7SUFDM0YsSUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDMUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDOUIsQ0FBQyxDQUFDLENBQUM7QUFFSCxNQUFNLFFBQVEsR0FBRyxJQUFJLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUMxQyxNQUFNLFNBQVMsR0FBRyxJQUFJLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUU1QyxjQUFjLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFO0lBQy9DLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7SUFFekMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNULEVBQUUsQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2hDLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUMxQixFQUFFLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDaEMsRUFBRSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN0RSxDQUFDO0lBQUMsSUFBSSxDQUFDLENBQUM7UUFDTixFQUFFLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNqQyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2YsQ0FBQztBQUNILENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZhbHVhdGVkQXJncyB9IGZyb20gJy4uL2V4cHJlc3Npb25zL2FyZ3MnO1xuaW1wb3J0IHsgZXhwZWN0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBSZXZpc2lvblRhZywgUmVmZXJlbmNlLCBDb25zdFJlZmVyZW5jZSwgUmVmZXJlbmNlSXRlcmF0b3IsIEl0ZXJhdGlvbkFydGlmYWN0cyB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBBUFBFTkRfT1BDT0RFUywgT3Bjb2RlTmFtZSBhcyBPcCB9IGZyb20gJy4uLy4uL29wY29kZXMnO1xuXG5jbGFzcyBJdGVyYWJsZVByZXNlbmNlUmVmZXJlbmNlIGltcGxlbWVudHMgUmVmZXJlbmNlPGJvb2xlYW4+IHtcbiAgcHVibGljIHRhZzogUmV2aXNpb25UYWc7XG4gIHByaXZhdGUgYXJ0aWZhY3RzOiBJdGVyYXRpb25BcnRpZmFjdHM7XG5cbiAgY29uc3RydWN0b3IoYXJ0aWZhY3RzOiBJdGVyYXRpb25BcnRpZmFjdHMpIHtcbiAgICB0aGlzLnRhZyA9IGFydGlmYWN0cy50YWc7XG4gICAgdGhpcy5hcnRpZmFjdHMgPSBhcnRpZmFjdHM7XG4gIH1cblxuICB2YWx1ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuYXJ0aWZhY3RzLmlzRW1wdHkoKTtcbiAgfVxufVxuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuUHV0SXRlcmF0b3IsIHZtID0+IHtcbiAgbGV0IGxpc3RSZWYgPSB2bS5mcmFtZS5nZXRPcGVyYW5kKCk7XG4gIGxldCBhcmdzID0gZXhwZWN0KHZtLmZyYW1lLmdldEFyZ3MoKSwgJ1B1dEl0ZXJhdG9yT3Bjb2RlIGV4cGVjdHMgYSBwb3B1bGF0ZWQgYXJncyByZWdpc3RlcicpO1xuICBsZXQgaXRlcmFibGUgPSB2bS5lbnYuaXRlcmFibGVGb3IobGlzdFJlZiwgYXJncyk7XG4gIGxldCBpdGVyYXRvciA9IG5ldyBSZWZlcmVuY2VJdGVyYXRvcihpdGVyYWJsZSk7XG5cbiAgdm0uZnJhbWUuc2V0SXRlcmF0b3IoaXRlcmF0b3IpO1xuICB2bS5mcmFtZS5zZXRDb25kaXRpb24obmV3IEl0ZXJhYmxlUHJlc2VuY2VSZWZlcmVuY2UoaXRlcmF0b3IuYXJ0aWZhY3RzKSk7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkVudGVyTGlzdCwgKHZtLCB7IG9wMTogX3NsaWNlIH0pID0+IHtcbiAgdm0uZW50ZXJMaXN0KHZtLmNvbnN0YW50cy5nZXRTbGljZShfc2xpY2UpKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuRXhpdExpc3QsIHZtID0+IHZtLmV4aXRMaXN0KCkpO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuRW50ZXJXaXRoS2V5LCAodm0sIHsgb3AyOiBfc2xpY2UgfSkgPT4ge1xuICBsZXQga2V5ID0gZXhwZWN0KHZtLmZyYW1lLmdldEtleSgpLCAnRW50ZXJXaXRoS2V5T3Bjb2RlIGV4cGVjdHMgYSBwb3B1bGF0ZWQga2V5IHJlZ2lzdGVyJyk7XG4gIGxldCBzbGljZSA9IHZtLmNvbnN0YW50cy5nZXRTbGljZShfc2xpY2UpO1xuICB2bS5lbnRlcldpdGhLZXkoa2V5LCBzbGljZSk7XG59KTtcblxuY29uc3QgVFJVRV9SRUYgPSBuZXcgQ29uc3RSZWZlcmVuY2UodHJ1ZSk7XG5jb25zdCBGQUxTRV9SRUYgPSBuZXcgQ29uc3RSZWZlcmVuY2UoZmFsc2UpO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuTmV4dEl0ZXIsICh2bSwgeyBvcDE6IGVuZCB9KSA9PiB7XG4gIGxldCBpdGVtID0gdm0uZnJhbWUuZ2V0SXRlcmF0b3IoKS5uZXh0KCk7XG5cbiAgaWYgKGl0ZW0pIHtcbiAgICB2bS5mcmFtZS5zZXRDb25kaXRpb24oVFJVRV9SRUYpO1xuICAgIHZtLmZyYW1lLnNldEtleShpdGVtLmtleSk7XG4gICAgdm0uZnJhbWUuc2V0T3BlcmFuZChpdGVtLnZhbHVlKTtcbiAgICB2bS5mcmFtZS5zZXRBcmdzKEV2YWx1YXRlZEFyZ3MucG9zaXRpb25hbChbaXRlbS52YWx1ZSwgaXRlbS5tZW1vXSkpO1xuICB9IGVsc2Uge1xuICAgIHZtLmZyYW1lLnNldENvbmRpdGlvbihGQUxTRV9SRUYpO1xuICAgIHZtLmdvdG8oZW5kKTtcbiAgfVxufSk7XG4iXX0=