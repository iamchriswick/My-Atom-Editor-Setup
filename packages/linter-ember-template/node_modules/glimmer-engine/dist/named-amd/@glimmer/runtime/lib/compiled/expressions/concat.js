enifed("@glimmer/runtime/lib/compiled/expressions/concat", ["exports", "@glimmer/reference"], function (exports, _glimmerReference) {
    "use strict";

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var CompiledConcat = (function () {
        function CompiledConcat(parts) {
            _classCallCheck(this, CompiledConcat);

            this.parts = parts;
            this.type = "concat";
        }

        CompiledConcat.prototype.evaluate = function evaluate(vm) {
            var parts = new Array(this.parts.length);
            for (var i = 0; i < this.parts.length; i++) {
                parts[i] = this.parts[i].evaluate(vm);
            }
            return new ConcatReference(parts);
        };

        CompiledConcat.prototype.toJSON = function toJSON() {
            return "concat(" + this.parts.map(function (expr) {
                return expr.toJSON();
            }).join(", ") + ")";
        };

        return CompiledConcat;
    })();

    exports.default = CompiledConcat;

    var ConcatReference = (function (_CachedReference) {
        _inherits(ConcatReference, _CachedReference);

        function ConcatReference(parts) {
            _classCallCheck(this, ConcatReference);

            _CachedReference.call(this);
            this.parts = parts;
            this.tag = _glimmerReference.combineTagged(parts);
        }

        ConcatReference.prototype.compute = function compute() {
            var parts = new Array();
            for (var i = 0; i < this.parts.length; i++) {
                var value = this.parts[i].value();
                if (value !== null && value !== undefined) {
                    parts[i] = castToString(value);
                }
            }
            if (parts.length > 0) {
                return parts.join('');
            }
            return null;
        };

        return ConcatReference;
    })(_glimmerReference.CachedReference);

    exports.ConcatReference = ConcatReference;

    function castToString(value) {
        if (typeof value['toString'] !== 'function') {
            return '';
        }
        return String(value);
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkBnbGltbWVyL3J1bnRpbWUvbGliL2NvbXBpbGVkL2V4cHJlc3Npb25zL2NvbmNhdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7UUFNYyxjQUFBO0FBR1osaUJBSFksY0FBQSxDQUdRLEtBQW1DLEVBQUE7a0NBSDNDLGNBQUE7O0FBR1EsZ0JBQUEsQ0FBQSxLQUFLLEdBQUwsS0FBSyxDQUE4QjtBQUZoRCxnQkFBQSxDQUFBLElBQUksR0FBRyxRQUFRLENBQUM7U0FFb0M7O0FBSC9DLHNCQUFBLFdBS1osUUFBUSxHQUFBLGtCQUFDLEVBQU0sRUFBQTtBQUNiLGdCQUFJLEtBQUssR0FBNEIsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNsRSxpQkFBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzFDLHFCQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7YUFDdkM7QUFDRCxtQkFBTyxJQUFJLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNuQzs7QUFYVyxzQkFBQSxXQWFaLE1BQU0sR0FBQSxrQkFBQTtBQUNKLCtCQUFpQixJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxVQUFBLElBQUk7dUJBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTthQUFBLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQUk7U0FDdEU7O2VBZlcsY0FBQTs7O3NCQUFBLGNBQUE7O1FBa0JSLGVBQXVCO2tCQUF2QixlQUF1Qjs7QUFHM0IsaUJBSEksZUFBdUIsQ0FHUCxLQUE4QixFQUFBO2tDQUg5QyxlQUF1Qjs7QUFJekIsdUNBQU8sQ0FBQztBQURVLGdCQUFBLENBQUEsS0FBSyxHQUFMLEtBQUssQ0FBeUI7QUFFaEQsZ0JBQUksQ0FBQyxHQUFHLEdBQUcsa0JBMUJ1QyxhQUFhLENBMEJ0QyxLQUFLLENBQUMsQ0FBQztTQUNqQzs7QUFORyx1QkFBdUIsV0FRakIsT0FBTyxHQUFBLG1CQUFBO0FBQ2YsZ0JBQUksS0FBSyxHQUFHLElBQUksS0FBSyxFQUFVLENBQUM7QUFFaEMsaUJBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUMxQyxvQkFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztBQUVsQyxvQkFBSSxLQUFLLEtBQUssSUFBSSxJQUFJLEtBQUssS0FBSyxTQUFTLEVBQUU7QUFDekMseUJBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxZQUFZLENBQUMsS0FBeUQsQ0FBb0QsQ0FBQztpQkFDdkk7YUFDRjtBQUVELGdCQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO0FBQ3BCLHVCQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7YUFDdkI7QUFFRCxtQkFBTyxJQUFJLENBQUM7U0FDYjs7ZUF4QkcsZUFBdUI7eUJBckJMLGVBQWU7Ozs7QUFnRHZDLGFBQUEsWUFBQSxDQUFzQixLQUFhLEVBQUE7QUFDakMsWUFBSSxPQUFPLEtBQUssQ0FBQyxVQUFVLENBQUMsS0FBSyxVQUFVLEVBQUU7QUFDM0MsbUJBQU8sRUFBRSxDQUFDO1NBQ1g7QUFFRCxlQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUN0QiIsImZpbGUiOiJjb25jYXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21waWxlZEV4cHJlc3Npb24gfSBmcm9tICcuLi9leHByZXNzaW9ucyc7XG5pbXBvcnQgeyBGSVhNRSB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IFZNIGZyb20gJy4uLy4uL3ZtL2FwcGVuZCc7XG5pbXBvcnQgeyBQYXRoUmVmZXJlbmNlLCBDYWNoZWRSZWZlcmVuY2UsIFJldmlzaW9uVGFnLCBjb21iaW5lVGFnZ2VkIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7IE9wdGlvbiwgT3BhcXVlIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBpbGVkQ29uY2F0IHtcbiAgcHVibGljIHR5cGUgPSBcImNvbmNhdFwiO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcGFydHM6IENvbXBpbGVkRXhwcmVzc2lvbjxPcGFxdWU+W10pIHt9XG5cbiAgZXZhbHVhdGUodm06IFZNKTogQ2FjaGVkUmVmZXJlbmNlPE9wdGlvbjxzdHJpbmc+PiB7XG4gICAgbGV0IHBhcnRzOiBQYXRoUmVmZXJlbmNlPE9wYXF1ZT5bXSA9IG5ldyBBcnJheSh0aGlzLnBhcnRzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJ0c1tpXSA9IHRoaXMucGFydHNbaV0uZXZhbHVhdGUodm0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENvbmNhdFJlZmVyZW5jZShwYXJ0cyk7XG4gIH1cblxuICB0b0pTT04oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYGNvbmNhdCgke3RoaXMucGFydHMubWFwKGV4cHIgPT4gZXhwci50b0pTT04oKSkuam9pbihcIiwgXCIpfSlgO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDb25jYXRSZWZlcmVuY2UgZXh0ZW5kcyBDYWNoZWRSZWZlcmVuY2U8T3B0aW9uPHN0cmluZz4+IHtcbiAgcHVibGljIHRhZzogUmV2aXNpb25UYWc7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwYXJ0czogUGF0aFJlZmVyZW5jZTxPcGFxdWU+W10pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudGFnID0gY29tYmluZVRhZ2dlZChwYXJ0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY29tcHV0ZSgpOiBPcHRpb248c3RyaW5nPiB7XG4gICAgbGV0IHBhcnRzID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHZhbHVlID0gdGhpcy5wYXJ0c1tpXS52YWx1ZSgpO1xuXG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJ0c1tpXSA9IGNhc3RUb1N0cmluZyh2YWx1ZSBhcyBGSVhNRTxhbnksICdUaGlzIHdvcmtzIHdpdGggc3RyaWN0IG51bGwgY2hlY2tzJz4pIGFzIEZJWE1FPHN0cmluZywgJ0NvZXJjZSBmYWxzeSB2YWx1ZXMgdG8gc3RyaW5ncyc+O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gcGFydHMuam9pbignJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FzdFRvU3RyaW5nKHZhbHVlOiBPYmplY3QpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZVsndG9TdHJpbmcnXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiBTdHJpbmcodmFsdWUpO1xufVxuIl19