enifed('@glimmer/runtime/lib/compiled/opcodes/content', ['exports', '@glimmer/runtime/lib/upsert', '@glimmer/runtime/lib/component/interfaces', '@glimmer/runtime/lib/opcodes', '@glimmer/runtime/lib/compiled/expressions', '@glimmer/runtime/lib/vm/update', '@glimmer/reference', '@glimmer/util', '@glimmer/runtime/lib/bounds', '@glimmer/runtime/lib/builder', '@glimmer/runtime/lib/compiled/opcodes/builder', '@glimmer/runtime/lib/references'], function (exports, _glimmerRuntimeLibUpsert, _glimmerRuntimeLibComponentInterfaces, _glimmerRuntimeLibOpcodes, _glimmerRuntimeLibCompiledExpressions, _glimmerRuntimeLibVmUpdate, _glimmerReference, _glimmerUtil, _glimmerRuntimeLibBounds, _glimmerRuntimeLibBuilder, _glimmerRuntimeLibCompiledOpcodesBuilder, _glimmerRuntimeLibReferences) {
    'use strict';

    exports.normalizeTextValue = normalizeTextValue;

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.DynamicContent, function (vm, _ref) {
        var append = _ref.op1;

        var opcode = vm.constants.getOther(append);
        opcode.evaluate(vm);
    });
    function isEmpty(value) {
        return value === null || value === undefined || typeof value['toString'] !== 'function';
    }

    function normalizeTextValue(value) {
        if (isEmpty(value)) {
            return '';
        }
        return String(value);
    }

    function normalizeTrustedValue(value) {
        if (isEmpty(value)) {
            return '';
        }
        if (_glimmerRuntimeLibUpsert.isString(value)) {
            return value;
        }
        if (_glimmerRuntimeLibUpsert.isSafeString(value)) {
            return value.toHTML();
        }
        if (_glimmerRuntimeLibUpsert.isNode(value)) {
            return value;
        }
        return String(value);
    }
    function normalizeValue(value) {
        if (isEmpty(value)) {
            return '';
        }
        if (_glimmerRuntimeLibUpsert.isString(value)) {
            return value;
        }
        if (_glimmerRuntimeLibUpsert.isSafeString(value) || _glimmerRuntimeLibUpsert.isNode(value)) {
            return value;
        }
        return String(value);
    }

    var AppendDynamicOpcode = (function () {
        function AppendDynamicOpcode() {
            _classCallCheck(this, AppendDynamicOpcode);
        }

        AppendDynamicOpcode.prototype.evaluate = function evaluate(vm) {
            var reference = vm.frame.getOperand();
            var normalized = this.normalize(reference);
            var value = undefined,
                cache = undefined;
            if (_glimmerReference.isConst(reference)) {
                value = normalized.value();
            } else {
                cache = new _glimmerReference.ReferenceCache(normalized);
                value = cache.peek();
            }
            var stack = vm.stack();
            var upsert = this.insert(vm.env.getAppendOperations(), stack, value);
            var bounds = new _glimmerRuntimeLibBuilder.Fragment(upsert.bounds);
            stack.newBounds(bounds);
            if (cache /* i.e. !isConst(reference) */) {
                    vm.updateWith(this.updateWith(vm, reference, cache, bounds, upsert));
                }
        };

        return AppendDynamicOpcode;
    })();

    exports.AppendDynamicOpcode = AppendDynamicOpcode;

    var GuardedAppendOpcode = (function (_AppendDynamicOpcode) {
        _inherits(GuardedAppendOpcode, _AppendDynamicOpcode);

        function GuardedAppendOpcode(expression, symbolTable) {
            _classCallCheck(this, GuardedAppendOpcode);

            _AppendDynamicOpcode.call(this);
            this.expression = expression;
            this.symbolTable = symbolTable;
            this.deopted = null;
        }

        GuardedAppendOpcode.prototype.evaluate = function evaluate(vm) {
            if (this.deopted) {
                vm.pushEvalFrame(this.deopted);
            } else {
                vm.evaluateOperand(this.expression);
                var value = vm.frame.getOperand().value();
                if (_glimmerRuntimeLibComponentInterfaces.isComponentDefinition(value)) {
                    vm.pushEvalFrame(this.deopt(vm.env));
                } else {
                    _AppendDynamicOpcode.prototype.evaluate.call(this, vm);
                }
            }
        };

        GuardedAppendOpcode.prototype.deopt = function deopt(env) {
            var _this = this;

            // At compile time, we determined that this append callsite might refer
            // to a local variable/property lookup that resolves to a component
            // definition at runtime.
            //
            // We could have eagerly compiled this callsite into something like this:
            //
            //   {{#if (is-component-definition foo)}}
            //     {{component foo}}
            //   {{else}}
            //     {{foo}}
            //   {{/if}}
            //
            // However, in practice, there might be a large amout of these callsites
            // and most of them would resolve to a simple value lookup. Therefore, we
            // tried to be optimistic and assumed that the callsite will resolve to
            // appending a simple value.
            //
            // However, we have reached here because at runtime, the guard conditional
            // have detected that this callsite is indeed referring to a component
            // definition object. Since this is likely going to be true for other
            // instances of the same callsite, it is now appropiate to deopt into the
            // expanded version that handles both cases. The compilation would look
            // like this:
            //
            //               PutValue(expression)
            //               Test(is-component-definition)
            //               Enter(BEGIN, END)
            //   BEGIN:      Noop
            //               JumpUnless(VALUE)
            //               PutDynamicComponentDefinitionOpcode
            //               OpenComponent
            //               CloseComponent
            //               Jump(END)
            //   VALUE:      Noop
            //               OptimizedAppend
            //   END:        Noop
            //               Exit
            //
            // Keep in mind that even if we *don't* reach here at initial render time,
            // it is still possible (although quite rare) that the simple value we
            // encounter during initial render could later change into a component
            // definition object at update time. That is handled by the "lazy deopt"
            // code on the update side (scroll down for the next big block of comment).
            var dsl = new _glimmerRuntimeLibCompiledOpcodesBuilder.default(this.symbolTable, env);
            dsl.putValue(this.expression);
            dsl.test(IsComponentDefinitionReference.create);
            dsl.labelled(null, function (dsl, _BEGIN, END) {
                dsl.jumpUnless('VALUE');
                dsl.putDynamicComponentDefinition();
                dsl.openComponent(_glimmerRuntimeLibCompiledExpressions.CompiledArgs.empty());
                dsl.closeComponent();
                dsl.jump(END);
                dsl.label('VALUE');
                dsl.dynamicContent(new _this.AppendOpcode());
            });
            var deopted = this.deopted = dsl.toSlice();
            // From this point on, we have essentially replaced ourselves with a new set
            // of opcodes. Since we will always be executing the new/deopted code, it's
            // a good idea (as a pattern) to null out any unneeded fields here to avoid
            // holding on to unneeded/stale objects:
            // QUESTION: Shouldn't this whole object be GCed? If not, why not?
            this.expression = null;
            return deopted;
        };

        return GuardedAppendOpcode;
    })(AppendDynamicOpcode);

    exports.GuardedAppendOpcode = GuardedAppendOpcode;

    var IsComponentDefinitionReference = (function (_ConditionalReference) {
        _inherits(IsComponentDefinitionReference, _ConditionalReference);

        function IsComponentDefinitionReference() {
            _classCallCheck(this, IsComponentDefinitionReference);

            _ConditionalReference.apply(this, arguments);
        }

        IsComponentDefinitionReference.create = function create(inner) {
            return new IsComponentDefinitionReference(inner);
        };

        IsComponentDefinitionReference.prototype.toBool = function toBool(value) {
            return _glimmerRuntimeLibComponentInterfaces.isComponentDefinition(value);
        };

        return IsComponentDefinitionReference;
    })(_glimmerRuntimeLibReferences.ConditionalReference);

    var UpdateOpcode = (function (_UpdatingOpcode) {
        _inherits(UpdateOpcode, _UpdatingOpcode);

        function UpdateOpcode(cache, bounds, upsert) {
            _classCallCheck(this, UpdateOpcode);

            _UpdatingOpcode.call(this);
            this.cache = cache;
            this.bounds = bounds;
            this.upsert = upsert;
            this.tag = cache.tag;
        }

        UpdateOpcode.prototype.evaluate = function evaluate(vm) {
            var value = this.cache.revalidate();
            if (_glimmerReference.isModified(value)) {
                var bounds = this.bounds;
                var upsert = this.upsert;
                var dom = vm.dom;

                if (!this.upsert.update(dom, value)) {
                    var cursor = new _glimmerRuntimeLibBounds.Cursor(bounds.parentElement(), _glimmerRuntimeLibBounds.clear(bounds));
                    upsert = this.upsert = this.insert(vm.env.getAppendOperations(), cursor, value);
                }
                bounds.update(upsert.bounds);
            }
        };

        UpdateOpcode.prototype.toJSON = function toJSON() {
            var guid = this._guid;
            var type = this.type;
            var cache = this.cache;

            return {
                guid: guid,
                type: type,
                details: { lastValue: JSON.stringify(cache.peek()) }
            };
        };

        return UpdateOpcode;
    })(_glimmerRuntimeLibOpcodes.UpdatingOpcode);

    var GuardedUpdateOpcode = (function (_UpdateOpcode) {
        _inherits(GuardedUpdateOpcode, _UpdateOpcode);

        function GuardedUpdateOpcode(reference, cache, bounds, upsert, appendOpcode, state) {
            _classCallCheck(this, GuardedUpdateOpcode);

            _UpdateOpcode.call(this, cache, bounds, upsert);
            this.reference = reference;
            this.appendOpcode = appendOpcode;
            this.state = state;
            this.deopted = null;
            this.tag = this._tag = new _glimmerReference.UpdatableTag(this.tag);
        }

        GuardedUpdateOpcode.prototype.evaluate = function evaluate(vm) {
            if (this.deopted) {
                vm.evaluateOpcode(this.deopted);
            } else {
                if (_glimmerRuntimeLibComponentInterfaces.isComponentDefinition(this.reference.value())) {
                    this.lazyDeopt(vm);
                } else {
                    _UpdateOpcode.prototype.evaluate.call(this, vm);
                }
            }
        };

        GuardedUpdateOpcode.prototype.lazyDeopt = function lazyDeopt(vm) {
            // Durign initial render, we know that the reference does not contain a
            // component definition, so we optimistically assumed that this append
            // is just a normal append. However, at update time, we discovered that
            // the reference has switched into containing a component definition, so
            // we need to do a "lazy deopt", simulating what would have happened if
            // we had decided to perform the deopt in the first place during initial
            // render.
            //
            // More concretely, we would have expanded the curly into a if/else, and
            // based on whether the value is a component definition or not, we would
            // have entered either the dynamic component branch or the simple value
            // branch.
            //
            // Since we rendered a simple value during initial render (and all the
            // updates up until this point), we need to pretend that the result is
            // produced by the "VALUE" branch of the deopted append opcode:
            //
            //   Try(BEGIN, END)
            //     Assert(IsComponentDefinition, expected=false)
            //     OptimizedUpdate
            //
            // In this case, because the reference has switched from being a simple
            // value into a component definition, what would have happened is that
            // the assert would throw, causing the Try opcode to teardown the bounds
            // and rerun the original append opcode.
            //
            // Since the Try opcode would have nuked the updating opcodes anyway, we
            // wouldn't have to worry about simulating those. All we have to do is to
            // execute the Try opcode and immediately throw.
            var bounds = this.bounds;
            var appendOpcode = this.appendOpcode;
            var state = this.state;

            var env = vm.env;
            var slice = appendOpcode.deopt(env);
            var enter = _glimmerUtil.expect(env.program.opcode(slice[0] + 8), 'hardcoded deopt location');
            var ops = vm.constants.getSlice(enter.op1);
            var tracker = new _glimmerRuntimeLibBuilder.UpdatableBlockTracker(bounds.parentElement());
            tracker.newBounds(this.bounds);
            var children = new _glimmerUtil.LinkedList();
            state.frame['condition'] = IsComponentDefinitionReference.create(_glimmerUtil.expect(state.frame['operand'], 'operand should be populated'));
            var deopted = this.deopted = new _glimmerRuntimeLibVmUpdate.TryOpcode(ops, state, tracker, children);
            this._tag.update(deopted.tag);
            vm.evaluateOpcode(deopted);
            vm.throw();
            // From this point on, we have essentially replaced ourselve with a new
            // opcode. Since we will always be executing the new/deopted code, it's a
            // good idea (as a pattern) to null out any unneeded fields here to avoid
            // holding on to unneeded/stale objects:
            // QUESTION: Shouldn't this whole object be GCed? If not, why not?
            this._tag = null;
            this.reference = null;
            this.cache = null;
            this.bounds = null;
            this.upsert = null;
            this.appendOpcode = null;
            this.state = null;
        };

        GuardedUpdateOpcode.prototype.toJSON = function toJSON() {
            var guid = this._guid;
            var type = this.type;
            var deopted = this.deopted;

            if (deopted) {
                return {
                    guid: guid,
                    type: type,
                    deopted: true,
                    children: [deopted.toJSON()]
                };
            } else {
                return _UpdateOpcode.prototype.toJSON.call(this);
            }
        };

        return GuardedUpdateOpcode;
    })(UpdateOpcode);

    var OptimizedCautiousAppendOpcode = (function (_AppendDynamicOpcode2) {
        _inherits(OptimizedCautiousAppendOpcode, _AppendDynamicOpcode2);

        function OptimizedCautiousAppendOpcode() {
            _classCallCheck(this, OptimizedCautiousAppendOpcode);

            _AppendDynamicOpcode2.apply(this, arguments);
            this.type = 'optimized-cautious-append';
        }

        OptimizedCautiousAppendOpcode.prototype.normalize = function normalize(reference) {
            return _glimmerReference.map(reference, normalizeValue);
        };

        OptimizedCautiousAppendOpcode.prototype.insert = function insert(dom, cursor, value) {
            return _glimmerRuntimeLibUpsert.cautiousInsert(dom, cursor, value);
        };

        OptimizedCautiousAppendOpcode.prototype.updateWith = function updateWith(_vm, _reference, cache, bounds, upsert) {
            return new OptimizedCautiousUpdateOpcode(cache, bounds, upsert);
        };

        return OptimizedCautiousAppendOpcode;
    })(AppendDynamicOpcode);

    exports.OptimizedCautiousAppendOpcode = OptimizedCautiousAppendOpcode;

    var OptimizedCautiousUpdateOpcode = (function (_UpdateOpcode2) {
        _inherits(OptimizedCautiousUpdateOpcode, _UpdateOpcode2);

        function OptimizedCautiousUpdateOpcode() {
            _classCallCheck(this, OptimizedCautiousUpdateOpcode);

            _UpdateOpcode2.apply(this, arguments);
            this.type = 'optimized-cautious-update';
        }

        OptimizedCautiousUpdateOpcode.prototype.insert = function insert(dom, cursor, value) {
            return _glimmerRuntimeLibUpsert.cautiousInsert(dom, cursor, value);
        };

        return OptimizedCautiousUpdateOpcode;
    })(UpdateOpcode);

    var GuardedCautiousAppendOpcode = (function (_GuardedAppendOpcode) {
        _inherits(GuardedCautiousAppendOpcode, _GuardedAppendOpcode);

        function GuardedCautiousAppendOpcode() {
            _classCallCheck(this, GuardedCautiousAppendOpcode);

            _GuardedAppendOpcode.apply(this, arguments);
            this.type = 'guarded-cautious-append';
            this.AppendOpcode = OptimizedCautiousAppendOpcode;
        }

        GuardedCautiousAppendOpcode.prototype.normalize = function normalize(reference) {
            return _glimmerReference.map(reference, normalizeValue);
        };

        GuardedCautiousAppendOpcode.prototype.insert = function insert(dom, cursor, value) {
            return _glimmerRuntimeLibUpsert.cautiousInsert(dom, cursor, value);
        };

        GuardedCautiousAppendOpcode.prototype.updateWith = function updateWith(vm, reference, cache, bounds, upsert) {
            return new GuardedCautiousUpdateOpcode(reference, cache, bounds, upsert, this, vm.capture());
        };

        return GuardedCautiousAppendOpcode;
    })(GuardedAppendOpcode);

    exports.GuardedCautiousAppendOpcode = GuardedCautiousAppendOpcode;

    var GuardedCautiousUpdateOpcode = (function (_GuardedUpdateOpcode) {
        _inherits(GuardedCautiousUpdateOpcode, _GuardedUpdateOpcode);

        function GuardedCautiousUpdateOpcode() {
            _classCallCheck(this, GuardedCautiousUpdateOpcode);

            _GuardedUpdateOpcode.apply(this, arguments);
            this.type = 'guarded-cautious-update';
        }

        GuardedCautiousUpdateOpcode.prototype.insert = function insert(dom, cursor, value) {
            return _glimmerRuntimeLibUpsert.cautiousInsert(dom, cursor, value);
        };

        return GuardedCautiousUpdateOpcode;
    })(GuardedUpdateOpcode);

    var OptimizedTrustingAppendOpcode = (function (_AppendDynamicOpcode3) {
        _inherits(OptimizedTrustingAppendOpcode, _AppendDynamicOpcode3);

        function OptimizedTrustingAppendOpcode() {
            _classCallCheck(this, OptimizedTrustingAppendOpcode);

            _AppendDynamicOpcode3.apply(this, arguments);
            this.type = 'optimized-trusting-append';
        }

        OptimizedTrustingAppendOpcode.prototype.normalize = function normalize(reference) {
            return _glimmerReference.map(reference, normalizeTrustedValue);
        };

        OptimizedTrustingAppendOpcode.prototype.insert = function insert(dom, cursor, value) {
            return _glimmerRuntimeLibUpsert.trustingInsert(dom, cursor, value);
        };

        OptimizedTrustingAppendOpcode.prototype.updateWith = function updateWith(_vm, _reference, cache, bounds, upsert) {
            return new OptimizedTrustingUpdateOpcode(cache, bounds, upsert);
        };

        return OptimizedTrustingAppendOpcode;
    })(AppendDynamicOpcode);

    exports.OptimizedTrustingAppendOpcode = OptimizedTrustingAppendOpcode;

    var OptimizedTrustingUpdateOpcode = (function (_UpdateOpcode3) {
        _inherits(OptimizedTrustingUpdateOpcode, _UpdateOpcode3);

        function OptimizedTrustingUpdateOpcode() {
            _classCallCheck(this, OptimizedTrustingUpdateOpcode);

            _UpdateOpcode3.apply(this, arguments);
            this.type = 'optimized-trusting-update';
        }

        OptimizedTrustingUpdateOpcode.prototype.insert = function insert(dom, cursor, value) {
            return _glimmerRuntimeLibUpsert.trustingInsert(dom, cursor, value);
        };

        return OptimizedTrustingUpdateOpcode;
    })(UpdateOpcode);

    var GuardedTrustingAppendOpcode = (function (_GuardedAppendOpcode2) {
        _inherits(GuardedTrustingAppendOpcode, _GuardedAppendOpcode2);

        function GuardedTrustingAppendOpcode() {
            _classCallCheck(this, GuardedTrustingAppendOpcode);

            _GuardedAppendOpcode2.apply(this, arguments);
            this.type = 'guarded-trusting-append';
            this.AppendOpcode = OptimizedTrustingAppendOpcode;
        }

        GuardedTrustingAppendOpcode.prototype.normalize = function normalize(reference) {
            return _glimmerReference.map(reference, normalizeTrustedValue);
        };

        GuardedTrustingAppendOpcode.prototype.insert = function insert(dom, cursor, value) {
            return _glimmerRuntimeLibUpsert.trustingInsert(dom, cursor, value);
        };

        GuardedTrustingAppendOpcode.prototype.updateWith = function updateWith(vm, reference, cache, bounds, upsert) {
            return new GuardedTrustingUpdateOpcode(reference, cache, bounds, upsert, this, vm.capture());
        };

        return GuardedTrustingAppendOpcode;
    })(GuardedAppendOpcode);

    exports.GuardedTrustingAppendOpcode = GuardedTrustingAppendOpcode;

    var GuardedTrustingUpdateOpcode = (function (_GuardedUpdateOpcode2) {
        _inherits(GuardedTrustingUpdateOpcode, _GuardedUpdateOpcode2);

        function GuardedTrustingUpdateOpcode() {
            _classCallCheck(this, GuardedTrustingUpdateOpcode);

            _GuardedUpdateOpcode2.apply(this, arguments);
            this.type = 'trusting-update';
        }

        GuardedTrustingUpdateOpcode.prototype.insert = function insert(dom, cursor, value) {
            return _glimmerRuntimeLibUpsert.trustingInsert(dom, cursor, value);
        };

        return GuardedTrustingUpdateOpcode;
    })(GuardedUpdateOpcode);
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkBnbGltbWVyL3J1bnRpbWUvbGliL2NvbXBpbGVkL29wY29kZXMvY29udGVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQTZCQSw4QkFGUyxjQUFjLENBRVIsR0FBRyxDQUFDLDBCQUZNLFVBQVUsQ0FFYixjQUFjLEVBQUUsVUFBQyxFQUFFLEVBQUUsSUFBZSxFQUFBO1lBQVIsTUFBTSxHQUFiLElBQWUsQ0FBYixHQUFHOztBQUM5QyxZQUFJLE1BQU0sR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQW1DLENBQUM7QUFDN0UsY0FBTSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUNyQixDQUFDLENBQUM7QUFFSCxhQUFBLE9BQUEsQ0FBaUIsS0FBYSxFQUFBO0FBQzVCLGVBQU8sS0FBSyxLQUFLLElBQUksSUFBSSxLQUFLLEtBQUssU0FBUyxJQUFJLE9BQU8sS0FBSyxDQUFDLFVBQVUsQ0FBQyxLQUFLLFVBQVUsQ0FBQztLQUN6Rjs7QUFFSyxhQUFBLGtCQUFBLENBQTZCLEtBQWEsRUFBQTtBQUM5QyxZQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtBQUNsQixtQkFBTyxFQUFFLENBQUM7U0FDWDtBQUNELGVBQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ3RCOztBQUVELGFBQUEscUJBQUEsQ0FBK0IsS0FBYSxFQUFBO0FBQzFDLFlBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQ2xCLG1CQUFPLEVBQUUsQ0FBQztTQUNYO0FBQ0QsWUFBSSx5QkExQ0osUUFBUSxDQTBDSyxLQUFLLENBQUMsRUFBRTtBQUNuQixtQkFBTyxLQUFLLENBQUM7U0FDZDtBQUNELFlBQUkseUJBL0NKLFlBQVksQ0ErQ0ssS0FBSyxDQUFDLEVBQUU7QUFDdkIsbUJBQU8sS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDO1NBQ3ZCO0FBQ0QsWUFBSSx5QkFqREosTUFBTSxDQWlESyxLQUFLLENBQUMsRUFBRTtBQUNqQixtQkFBTyxLQUFLLENBQUM7U0FDZDtBQUNELGVBQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ3RCO0FBRUQsYUFBQSxjQUFBLENBQXdCLEtBQWEsRUFBQTtBQUNuQyxZQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtBQUNsQixtQkFBTyxFQUFFLENBQUM7U0FDWDtBQUNELFlBQUkseUJBMURKLFFBQVEsQ0EwREssS0FBSyxDQUFDLEVBQUU7QUFDbkIsbUJBQU8sS0FBSyxDQUFDO1NBQ2Q7QUFDRCxZQUFJLHlCQS9ESixZQUFZLENBK0RLLEtBQUssQ0FBQyxJQUFJLHlCQTlEM0IsTUFBTSxDQThENEIsS0FBSyxDQUFDLEVBQUU7QUFDeEMsbUJBQU8sS0FBSyxDQUFDO1NBQ2Q7QUFDRCxlQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUN0Qjs7UUFJSyxtQkFBQTtpQkFBQSxtQkFBQTtrQ0FBQSxtQkFBQTs7O0FBQUEsMkJBQUEsV0FLSixRQUFRLEdBQUEsa0JBQUMsRUFBTSxFQUFBO0FBQ2IsZ0JBQUksU0FBUyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLENBQUM7QUFDdEMsZ0JBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUM7QUFFM0MsZ0JBQUksS0FBSyxZQUFBO2dCQUFFLEtBQUssWUFBQSxDQUFDO0FBRWpCLGdCQUFJLGtCQXJFc0QsT0FBTyxDQXFFckQsU0FBUyxDQUFDLEVBQUU7QUFDdEIscUJBQUssR0FBRyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7YUFDNUIsTUFBTTtBQUNMLHFCQUFLLEdBQUcsc0JBeEVNLGNBQWMsQ0F3RUQsVUFBVSxDQUFDLENBQUM7QUFDdkMscUJBQUssR0FBRyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7YUFDdEI7QUFFRCxnQkFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDO0FBQ3ZCLGdCQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsbUJBQW1CLEVBQUUsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDckUsZ0JBQUksTUFBTSxHQUFHLDhCQTNFUixRQUFRLENBMkVhLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUV6QyxpQkFBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUV4QixnQkFBSSxLQUFLLGlDQUFpQztBQUN4QyxzQkFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUUsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO2lCQUN0RTtTQUNGOztlQTNCRyxtQkFBQTs7Ozs7UUE4QkEsbUJBQXlEO2tCQUF6RCxtQkFBeUQ7O0FBSTdELGlCQUpJLG1CQUF5RCxDQUl6QyxVQUFtQyxFQUFVLFdBQXdCLEVBQUE7a0NBSnJGLG1CQUF5RDs7QUFLM0QsMkNBQU8sQ0FBQztBQURVLGdCQUFBLENBQUEsVUFBVSxHQUFWLFVBQVUsQ0FBeUI7QUFBVSxnQkFBQSxDQUFBLFdBQVcsR0FBWCxXQUFXLENBQWE7QUFGakYsZ0JBQUEsQ0FBQSxPQUFPLEdBQWtCLElBQUksQ0FBQztTQUlyQzs7QUFORywyQkFBeUQsV0FRN0QsUUFBUSxHQUFBLGtCQUFDLEVBQU0sRUFBQTtBQUNiLGdCQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7QUFDaEIsa0JBQUUsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2FBQ2hDLE1BQU07QUFDTCxrQkFBRSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7QUFFcEMsb0JBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7QUFFMUMsb0JBQUcsc0NBOUdBLHFCQUFxQixDQThHQyxLQUFLLENBQUMsRUFBRTtBQUMvQixzQkFBRSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO2lCQUN0QyxNQUFNO0FBQ0wsbURBQU0sUUFBUSxLQUFBLE9BQUMsRUFBRSxDQUFDLENBQUM7aUJBQ3BCO2FBQ0Y7U0FDRjs7QUF0QkcsMkJBQXlELFdBd0J0RCxLQUFLLEdBQUEsZUFBQyxHQUFnQixFQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkMzQixnQkFBSSxHQUFHLEdBQUcscURBQXFCLElBQUksQ0FBQyxXQUFXLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFFdEQsZUFBRyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDOUIsZUFBRyxDQUFDLElBQUksQ0FBQyw4QkFBOEIsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUVoRCxlQUFHLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxVQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFBO0FBQ2xDLG1CQUFHLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ3hCLG1CQUFHLENBQUMsNkJBQTZCLEVBQUUsQ0FBQztBQUNwQyxtQkFBRyxDQUFDLGFBQWEsQ0FBQyxzQ0F4S0ssWUFBWSxDQXdLSixLQUFLLEVBQUUsQ0FBQyxDQUFDO0FBQ3hDLG1CQUFHLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDckIsbUJBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDZCxtQkFBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNuQixtQkFBRyxDQUFDLGNBQWMsQ0FBQyxJQUFJLE1BQUssWUFBWSxFQUFFLENBQUMsQ0FBQzthQUM3QyxDQUFDLENBQUM7QUFFSCxnQkFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUM7Ozs7OztBQVMzQyxnQkFBSSxDQUFDLFVBQVUsR0FBRyxJQUE4QixDQUFDO0FBRWpELG1CQUFPLE9BQU8sQ0FBQztTQUNoQjs7ZUFoR0csbUJBQXlEO09BQVEsbUJBQXNCOzs7O1FBbUc3Riw4QkFBcUM7a0JBQXJDLDhCQUFxQzs7aUJBQXJDLDhCQUFxQztrQ0FBckMsOEJBQXFDOzs7OztBQUFyQyxzQ0FBcUMsQ0FDNUIsTUFBTSxHQUFBLGdCQUFDLEtBQXdCLEVBQUE7QUFDcEMsbUJBQU8sSUFBSSw4QkFBOEIsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNsRDs7QUFISCxzQ0FBcUMsV0FLbkMsTUFBTSxHQUFBLGdCQUFDLEtBQWEsRUFBQTtBQUNsQixtQkFBTyxzQ0F2TUYscUJBQXFCLENBdU1HLEtBQUssQ0FBQyxDQUFDO1NBQ3JDOztlQVBILDhCQUFxQztvQ0F0TDVCLG9CQUFvQjs7UUFnTTdCLFlBQWlEO2tCQUFqRCxZQUFpRDs7QUFDL0MsaUJBREYsWUFBaUQsQ0FFbkMsS0FBd0IsRUFDeEIsTUFBZ0IsRUFDaEIsTUFBYyxFQUFBO2tDQUo1QixZQUFpRDs7QUFNN0Msc0NBQU8sQ0FBQztBQUpFLGdCQUFBLENBQUEsS0FBSyxHQUFMLEtBQUssQ0FBbUI7QUFDeEIsZ0JBQUEsQ0FBQSxNQUFNLEdBQU4sTUFBTSxDQUFVO0FBQ2hCLGdCQUFBLENBQUEsTUFBTSxHQUFOLE1BQU0sQ0FBUTtBQUd4QixnQkFBSSxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDO1NBQ3RCOztBQVJILG9CQUFpRCxXQVkvQyxRQUFRLEdBQUEsa0JBQUMsRUFBYyxFQUFBO0FBQ3JCLGdCQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxDQUFDO0FBRXBDLGdCQUFJLGtCQXBOMEMsVUFBVSxDQW9OekMsS0FBSyxDQUFDLEVBQUU7b0JBQ2YsTUFBTSxHQUFhLElBQUksQ0FBdkIsTUFBTTtvQkFBRSxNQUFNLEdBQUssSUFBSSxDQUFmLE1BQU07b0JBQ2QsR0FBRyxHQUFLLEVBQUUsQ0FBVixHQUFHOztBQUVULG9CQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxFQUFFO0FBQ2xDLHdCQUFJLE1BQU0sR0FBRyw2QkF2TlosTUFBTSxDQXVOaUIsTUFBTSxDQUFDLGFBQWEsRUFBRSxFQUFFLHlCQXZOdkMsS0FBSyxDQXVOd0MsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUMvRCwwQkFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLG1CQUFtQixFQUFFLEVBQUUsTUFBTSxFQUFFLEtBQVUsQ0FBQyxDQUFDO2lCQUN0RjtBQUVELHNCQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUM5QjtTQUNGOztBQTFCSCxvQkFBaUQsV0E0Qi9DLE1BQU0sR0FBQSxrQkFBQTtnQkFDUyxJQUFJLEdBQWtCLElBQUksQ0FBakMsS0FBSztnQkFBUSxJQUFJLEdBQVksSUFBSSxDQUFwQixJQUFJO2dCQUFFLEtBQUssR0FBSyxJQUFJLENBQWQsS0FBSzs7QUFFOUIsbUJBQU87QUFDTCxvQkFBSSxFQUFKLElBQUk7QUFDSixvQkFBSSxFQUFKLElBQUk7QUFDSix1QkFBTyxFQUFFLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUU7YUFDckQsQ0FBQztTQUNIOztlQXBDSCxZQUFpRDtpQ0F6TTVCLGNBQWM7O1FBZ1BuQyxtQkFBd0Q7a0JBQXhELG1CQUF3RDs7QUFJdEQsaUJBSkYsbUJBQXdELENBSzVDLFNBQTRCLEVBQ3BDLEtBQXdCLEVBQ3hCLE1BQWdCLEVBQ2hCLE1BQWMsRUFDTixZQUFvQyxFQUNwQyxLQUFjLEVBQUE7a0NBVjFCLG1CQUF3RDs7QUFZcEQscUNBQU0sS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztBQVByQixnQkFBQSxDQUFBLFNBQVMsR0FBVCxTQUFTLENBQW1CO0FBSTVCLGdCQUFBLENBQUEsWUFBWSxHQUFaLFlBQVksQ0FBd0I7QUFDcEMsZ0JBQUEsQ0FBQSxLQUFLLEdBQUwsS0FBSyxDQUFTO0FBUmhCLGdCQUFBLENBQUEsT0FBTyxHQUFzQixJQUFJLENBQUM7QUFXeEMsZ0JBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxzQkF6UFMsWUFBWSxDQXlQSixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDbkQ7O0FBZEgsMkJBQXdELFdBZ0J0RCxRQUFRLEdBQUEsa0JBQUMsRUFBYyxFQUFBO0FBQ3JCLGdCQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7QUFDaEIsa0JBQUUsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2FBQ2pDLE1BQU07QUFDTCxvQkFBSSxzQ0F0UUQscUJBQXFCLENBc1FFLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRTtBQUNqRCx3QkFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQztpQkFDcEIsTUFBTTtBQUNMLDRDQUFNLFFBQVEsS0FBQSxPQUFDLEVBQUUsQ0FBQyxDQUFDO2lCQUNwQjthQUNGO1NBQ0Y7O0FBMUJILDJCQUF3RCxXQTRCOUMsU0FBUyxHQUFBLG1CQUFDLEVBQWMsRUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQStCeEIsTUFBTSxHQUEwQixJQUFJLENBQXBDLE1BQU07Z0JBQUUsWUFBWSxHQUFZLElBQUksQ0FBNUIsWUFBWTtnQkFBRSxLQUFLLEdBQUssSUFBSSxDQUFkLEtBQUs7O0FBQ2pDLGdCQUFJLEdBQUcsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO0FBRWpCLGdCQUFJLEtBQUssR0FBTyxZQUFZLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3hDLGdCQUFJLEtBQUssR0FBTyxhQTFTd0IsTUFBTSxDQTBTdkIsR0FBRyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLDBCQUEwQixDQUFDLENBQUM7QUFDckYsZ0JBQUksR0FBRyxHQUFTLEVBQUUsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUVqRCxnQkFBSSxPQUFPLEdBQUcsOEJBdlNULHFCQUFxQixDQXVTYyxNQUFNLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQztBQUNoRSxtQkFBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7QUFFL0IsZ0JBQUksUUFBUSxHQUFHLGlCQWhUYSxVQUFVLEVBZ1RTLENBQUM7QUFFaEQsaUJBQUssQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLEdBQUcsOEJBQThCLENBQUMsTUFBTSxDQUFDLGFBbFR6QixNQUFNLENBa1QwQixLQUFLLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxFQUFFLDZCQUE2QixDQUFDLENBQUMsQ0FBQztBQUVoSSxnQkFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sR0FBRywrQkF0VHhCLFNBQVMsQ0FzVDZCLEdBQUcsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBRTFFLGdCQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7QUFFOUIsY0FBRSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUMzQixjQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7Ozs7OztBQVNYLGdCQUFJLENBQUMsSUFBSSxHQUFXLElBQThCLENBQUM7QUFDbkQsZ0JBQUksQ0FBQyxTQUFTLEdBQU0sSUFBOEIsQ0FBQztBQUNuRCxnQkFBSSxDQUFDLEtBQUssR0FBVSxJQUE4QixDQUFDO0FBQ25ELGdCQUFJLENBQUMsTUFBTSxHQUFTLElBQThCLENBQUM7QUFDbkQsZ0JBQUksQ0FBQyxNQUFNLEdBQVMsSUFBOEIsQ0FBQztBQUNuRCxnQkFBSSxDQUFDLFlBQVksR0FBRyxJQUE4QixDQUFDO0FBQ25ELGdCQUFJLENBQUMsS0FBSyxHQUFVLElBQThCLENBQUM7U0FDcEQ7O0FBOUZILDJCQUF3RCxXQWdHdEQsTUFBTSxHQUFBLGtCQUFBO2dCQUNTLElBQUksR0FBb0IsSUFBSSxDQUFuQyxLQUFLO2dCQUFRLElBQUksR0FBYyxJQUFJLENBQXRCLElBQUk7Z0JBQUUsT0FBTyxHQUFLLElBQUksQ0FBaEIsT0FBTzs7QUFFaEMsZ0JBQUksT0FBTyxFQUFFO0FBQ1gsdUJBQU87QUFDTCx3QkFBSSxFQUFKLElBQUk7QUFDSix3QkFBSSxFQUFKLElBQUk7QUFDSiwyQkFBTyxFQUFFLElBQUk7QUFDYiw0QkFBUSxFQUFFLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO2lCQUM3QixDQUFDO2FBQ0gsTUFBTTtBQUNMLHVCQUFPLHdCQUFNLE1BQU0sS0FBQSxNQUFFLENBQUM7YUFDdkI7U0FDRjs7ZUE3R0gsbUJBQXdEO09BQVEsWUFBZTs7UUFnSHpFLDZCQUFxQztrQkFBckMsNkJBQXFDOztBQUEzQyxpQkFBTSw2QkFBcUMsR0FBM0M7a0NBQU0sNkJBQXFDOztBQ3hFbkMsOENBQVMsU0FBUyxDQUFDLENBQUM7QUR5RTFCLGdCQUFBLENBQUEsSUFBSSxHQUFHLDJCQUEyQixDQUFDO1NBYXBDOztBQWRLLHFDQUFxQyxXQUcvQixTQUFTLEdBQUEsbUJBQUMsU0FBNEIsRUFBQTtBQUM5QyxtQkFBTyxrQkFoVzRELEdBQUcsQ0FnVzNELFNBQVMsRUFBRSxjQUFjLENBQUMsQ0FBQztTQUN2Qzs7QUFMRyxxQ0FBcUMsV0FPL0IsTUFBTSxHQUFBLGdCQUFDLEdBQXdCLEVBQUUsTUFBYyxFQUFFLEtBQXdCLEVBQUE7QUFDakYsbUJBQU8seUJBN1dULGNBQWMsQ0E2V1UsR0FBRyxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztTQUMzQzs7QUFURyxxQ0FBcUMsV0FXL0IsVUFBVSxHQUFBLG9CQUFDLEdBQU8sRUFBRSxVQUE2QixFQUFFLEtBQXdDLEVBQUUsTUFBZ0IsRUFBRSxNQUFjLEVBQUE7QUFDckksbUJBQU8sSUFBSSw2QkFBNkIsQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ2pFOztlQWJHLDZCQUFxQztPQUFRLG1CQUFzQzs7OztRQWdCekYsNkJBQW9DO2tCQUFwQyw2QkFBb0M7O0FBQXBDLGlCQUFBLDZCQUFvQyxHQUFwQztrQ0FBQSw2QkFBb0M7O0FDekU1Qix1Q0FBUyxTQUFTLENBQUMsQ0FBQztBRDBFMUIsZ0JBQUEsQ0FBQSxJQUFJLEdBQUcsMkJBQTJCLENBQUM7U0FLcEM7O0FBTkQscUNBQW9DLFdBR3hCLE1BQU0sR0FBQSxnQkFBQyxHQUF3QixFQUFFLE1BQWMsRUFBRSxLQUF3QixFQUFBO0FBQ2pGLG1CQUFPLHlCQXpYVCxjQUFjLENBeVhVLEdBQUcsRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDM0M7O2VBTEgsNkJBQW9DO09BQVEsWUFBK0I7O1FBUXJFLDJCQUFtQztrQkFBbkMsMkJBQW1DOztBQUF6QyxpQkFBTSwyQkFBbUMsR0FBekM7a0NBQU0sMkJBQW1DOztBQ3hFakMsNkNBQVMsU0FBUyxDQUFDLENBQUM7QUR5RTFCLGdCQUFBLENBQUEsSUFBSSxHQUFHLHlCQUF5QixDQUFDO0FBRXZCLGdCQUFBLENBQUEsWUFBWSxHQUFHLDZCQUE2QixDQUFDO1NBYXhEOztBQWhCSyxtQ0FBbUMsV0FLN0IsU0FBUyxHQUFBLG1CQUFDLFNBQTRCLEVBQUE7QUFDOUMsbUJBQU8sa0JBMVg0RCxHQUFHLENBMFgzRCxTQUFTLEVBQUUsY0FBYyxDQUFDLENBQUM7U0FDdkM7O0FBUEcsbUNBQW1DLFdBUzdCLE1BQU0sR0FBQSxnQkFBQyxHQUF3QixFQUFFLE1BQWMsRUFBRSxLQUF3QixFQUFBO0FBQ2pGLG1CQUFPLHlCQXZZVCxjQUFjLENBdVlVLEdBQUcsRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDM0M7O0FBWEcsbUNBQW1DLFdBYTdCLFVBQVUsR0FBQSxvQkFBQyxFQUFNLEVBQUUsU0FBNEIsRUFBRSxLQUF3QyxFQUFFLE1BQWdCLEVBQUUsTUFBYyxFQUFBO0FBQ25JLG1CQUFPLElBQUksMkJBQTJCLENBQUMsU0FBUyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztTQUM5Rjs7ZUFmRywyQkFBbUM7T0FBUSxtQkFBc0M7Ozs7UUFrQnZGLDJCQUFrQztrQkFBbEMsMkJBQWtDOztBQUFsQyxpQkFBQSwyQkFBa0MsR0FBbEM7a0NBQUEsMkJBQWtDOztBQzFFMUIsNkNBQVMsU0FBUyxDQUFDLENBQUM7QUQyRTFCLGdCQUFBLENBQUEsSUFBSSxHQUFHLHlCQUF5QixDQUFDO1NBS2xDOztBQU5ELG1DQUFrQyxXQUd0QixNQUFNLEdBQUEsZ0JBQUMsR0FBd0IsRUFBRSxNQUFjLEVBQUUsS0FBd0IsRUFBQTtBQUNqRixtQkFBTyx5QkFuWlQsY0FBYyxDQW1aVSxHQUFHLEVBQUUsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQzNDOztlQUxILDJCQUFrQztPQUFRLG1CQUFzQzs7UUFRMUUsNkJBQXFDO2tCQUFyQyw2QkFBcUM7O0FBQTNDLGlCQUFNLDZCQUFxQyxHQUEzQztrQ0FBTSw2QkFBcUM7O0FDekVuQyw4Q0FBUyxTQUFTLENBQUMsQ0FBQztBRDBFMUIsZ0JBQUEsQ0FBQSxJQUFJLEdBQUcsMkJBQTJCLENBQUM7U0FhcEM7O0FBZEsscUNBQXFDLFdBRy9CLFNBQVMsR0FBQSxtQkFBQyxTQUE0QixFQUFBO0FBQzlDLG1CQUFPLGtCQWxaNEQsR0FBRyxDQWtaM0QsU0FBUyxFQUFFLHFCQUFxQixDQUFDLENBQUM7U0FDOUM7O0FBTEcscUNBQXFDLFdBTy9CLE1BQU0sR0FBQSxnQkFBQyxHQUF3QixFQUFFLE1BQWMsRUFBRSxLQUF3QixFQUFBO0FBQ2pGLG1CQUFPLHlCQTlaVCxjQUFjLENBOFpVLEdBQUcsRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDM0M7O0FBVEcscUNBQXFDLFdBVy9CLFVBQVUsR0FBQSxvQkFBQyxHQUFPLEVBQUUsVUFBNkIsRUFBRSxLQUF3QyxFQUFFLE1BQWdCLEVBQUUsTUFBYyxFQUFBO0FBQ3JJLG1CQUFPLElBQUksNkJBQTZCLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztTQUNqRTs7ZUFiRyw2QkFBcUM7T0FBUSxtQkFBc0M7Ozs7UUFnQnpGLDZCQUFvQztrQkFBcEMsNkJBQW9DOztBQUFwQyxpQkFBQSw2QkFBb0MsR0FBcEM7a0NBQUEsNkJBQW9DOztBQzFFNUIsdUNBQVMsU0FBUyxDQUFDLENBQUM7QUQyRTFCLGdCQUFBLENBQUEsSUFBSSxHQUFHLDJCQUEyQixDQUFDO1NBS3BDOztBQU5ELHFDQUFvQyxXQUd4QixNQUFNLEdBQUEsZ0JBQUMsR0FBd0IsRUFBRSxNQUFjLEVBQUUsS0FBd0IsRUFBQTtBQUNqRixtQkFBTyx5QkExYVQsY0FBYyxDQTBhVSxHQUFHLEVBQUUsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQzNDOztlQUxILDZCQUFvQztPQUFRLFlBQStCOztRQVFyRSwyQkFBbUM7a0JBQW5DLDJCQUFtQzs7QUFBekMsaUJBQU0sMkJBQW1DLEdBQXpDO2tDQUFNLDJCQUFtQzs7QUN6RWpDLDhDQUFTLFNBQVMsQ0FBQyxDQUFDO0FEMEUxQixnQkFBQSxDQUFBLElBQUksR0FBRyx5QkFBeUIsQ0FBQztBQUV2QixnQkFBQSxDQUFBLFlBQVksR0FBRyw2QkFBNkIsQ0FBQztTQWF4RDs7QUFoQkssbUNBQW1DLFdBSzdCLFNBQVMsR0FBQSxtQkFBQyxTQUE0QixFQUFBO0FBQzlDLG1CQUFPLGtCQTVhNEQsR0FBRyxDQTRhM0QsU0FBUyxFQUFFLHFCQUFxQixDQUFDLENBQUM7U0FDOUM7O0FBUEcsbUNBQW1DLFdBUzdCLE1BQU0sR0FBQSxnQkFBQyxHQUF3QixFQUFFLE1BQWMsRUFBRSxLQUF3QixFQUFBO0FBQ2pGLG1CQUFPLHlCQXhiVCxjQUFjLENBd2JVLEdBQUcsRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDM0M7O0FBWEcsbUNBQW1DLFdBYTdCLFVBQVUsR0FBQSxvQkFBQyxFQUFNLEVBQUUsU0FBNEIsRUFBRSxLQUF3QyxFQUFFLE1BQWdCLEVBQUUsTUFBYyxFQUFBO0FBQ25JLG1CQUFPLElBQUksMkJBQTJCLENBQUMsU0FBUyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztTQUM5Rjs7ZUFmRywyQkFBbUM7T0FBUSxtQkFBc0M7Ozs7UUFrQnZGLDJCQUFrQztrQkFBbEMsMkJBQWtDOztBQUFsQyxpQkFBQSwyQkFBa0MsR0FBbEM7a0NBQUEsMkJBQWtDOztBQzNFMUIsOENBQVMsU0FBUyxDQUFDLENBQUM7QUQ0RTFCLGdCQUFBLENBQUEsSUFBSSxHQUFHLGlCQUFpQixDQUFDO1NBSzFCOztBQU5ELG1DQUFrQyxXQUd0QixNQUFNLEdBQUEsZ0JBQUMsR0FBd0IsRUFBRSxNQUFjLEVBQUUsS0FBd0IsRUFBQTtBQUNqRixtQkFBTyx5QkFwY1QsY0FBYyxDQW9jVSxHQUFHLEVBQUUsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQzNDOztlQUxILDJCQUFrQztPQUFRLG1CQUFzQyIsImZpbGUiOiJjb250ZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFVwc2VydCwge1xuICBJbnNlcnRpb24sXG4gIENhdXRpb3VzSW5zZXJ0aW9uLFxuICBUcnVzdGluZ0luc2VydGlvbixcblxuICBpc1NhZmVTdHJpbmcsXG4gIGlzTm9kZSxcbiAgaXNTdHJpbmcsXG5cbiAgY2F1dGlvdXNJbnNlcnQsXG4gIHRydXN0aW5nSW5zZXJ0XG59IGZyb20gJy4uLy4uL3Vwc2VydCc7XG5pbXBvcnQgeyBpc0NvbXBvbmVudERlZmluaXRpb24gfSBmcm9tICcuLi8uLi9jb21wb25lbnQvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBET01UcmVlQ29uc3RydWN0aW9uIH0gZnJvbSAnLi4vLi4vZG9tL2hlbHBlcic7XG5pbXBvcnQgeyBPcGNvZGVKU09OLCBVcGRhdGluZ09wY29kZSB9IGZyb20gJy4uLy4uL29wY29kZXMnO1xuaW1wb3J0IHsgQ29tcGlsZWRFeHByZXNzaW9uLCBDb21waWxlZEFyZ3MgfSBmcm9tICcuLi9leHByZXNzaW9ucyc7XG5pbXBvcnQgeyBWTSwgVXBkYXRpbmdWTSB9IGZyb20gJy4uLy4uL3ZtJztcbmltcG9ydCB7IFRyeU9wY29kZSwgVk1TdGF0ZSB9IGZyb20gJy4uLy4uL3ZtL3VwZGF0ZSc7XG5pbXBvcnQgeyBSZWZlcmVuY2UsIFJlZmVyZW5jZUNhY2hlLCBVcGRhdGFibGVUYWcsIGlzTW9kaWZpZWQsIGlzQ29uc3QsIG1hcCB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBGSVhNRSwgT3B0aW9uLCBPcGFxdWUsIExpbmtlZExpc3QsIGV4cGVjdCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgQ3Vyc29yLCBjbGVhciB9IGZyb20gJy4uLy4uL2JvdW5kcyc7XG5pbXBvcnQgeyBGcmFnbWVudCB9IGZyb20gJy4uLy4uL2J1aWxkZXInO1xuaW1wb3J0IE9wY29kZUJ1aWxkZXJEU0wgZnJvbSAnLi9idWlsZGVyJztcbmltcG9ydCB7IENvbmRpdGlvbmFsUmVmZXJlbmNlIH0gZnJvbSAnLi4vLi4vcmVmZXJlbmNlcyc7XG5pbXBvcnQgeyBFbnZpcm9ubWVudCB9IGZyb20gJy4uLy4uL2Vudmlyb25tZW50JztcbmltcG9ydCB7IFVwZGF0YWJsZUJsb2NrVHJhY2tlciB9IGZyb20gJy4uLy4uL2J1aWxkZXInO1xuaW1wb3J0IHsgU3ltYm9sVGFibGUgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IEFQUEVORF9PUENPREVTLCBPcGNvZGVOYW1lIGFzIE9wLCBTbGljZSB9IGZyb20gJy4uLy4uL29wY29kZXMnO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuRHluYW1pY0NvbnRlbnQsICh2bSwgeyBvcDE6IGFwcGVuZCB9KSA9PiB7XG4gIGxldCBvcGNvZGUgPSB2bS5jb25zdGFudHMuZ2V0T3RoZXIoYXBwZW5kKSBhcyBBcHBlbmREeW5hbWljT3Bjb2RlPEluc2VydGlvbj47XG4gIG9wY29kZS5ldmFsdWF0ZSh2bSk7XG59KTtcblxuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZTogT3BhcXVlKTogYm9vbGVhbiB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2YWx1ZVsndG9TdHJpbmcnXSAhPT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVRleHRWYWx1ZSh2YWx1ZTogT3BhcXVlKTogc3RyaW5nIHtcbiAgaWYgKGlzRW1wdHkodmFsdWUpKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVUcnVzdGVkVmFsdWUodmFsdWU6IE9wYXF1ZSk6IFRydXN0aW5nSW5zZXJ0aW9uIHtcbiAgaWYgKGlzRW1wdHkodmFsdWUpKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU2FmZVN0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9IVE1MKCk7XG4gIH1cbiAgaWYgKGlzTm9kZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlOiBPcGFxdWUpOiBDYXV0aW91c0luc2VydGlvbiB7XG4gIGlmIChpc0VtcHR5KHZhbHVlKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1NhZmVTdHJpbmcodmFsdWUpIHx8IGlzTm9kZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCB0eXBlIEFwcGVuZER5bmFtaWNPcGNvZGVDb25zdHJ1Y3RvciA9ICB0eXBlb2YgT3B0aW1pemVkQ2F1dGlvdXNBcHBlbmRPcGNvZGUgfCB0eXBlb2YgT3B0aW1pemVkVHJ1c3RpbmdBcHBlbmRPcGNvZGU7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBcHBlbmREeW5hbWljT3Bjb2RlPFQgZXh0ZW5kcyBJbnNlcnRpb24+IHtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IG5vcm1hbGl6ZShyZWZlcmVuY2U6IFJlZmVyZW5jZTxPcGFxdWU+KTogUmVmZXJlbmNlPFQ+O1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgaW5zZXJ0KGRvbTogRE9NVHJlZUNvbnN0cnVjdGlvbiwgY3Vyc29yOiBDdXJzb3IsIHZhbHVlOiBUKTogVXBzZXJ0O1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgdXBkYXRlV2l0aCh2bTogVk0sIHJlZmVyZW5jZTogUmVmZXJlbmNlPE9wYXF1ZT4sIGNhY2hlOiBSZWZlcmVuY2VDYWNoZTxUPiwgYm91bmRzOiBGcmFnbWVudCwgdXBzZXJ0OiBVcHNlcnQpOiBVcGRhdGluZ09wY29kZTtcblxuICBldmFsdWF0ZSh2bTogVk0pIHtcbiAgICBsZXQgcmVmZXJlbmNlID0gdm0uZnJhbWUuZ2V0T3BlcmFuZCgpO1xuICAgIGxldCBub3JtYWxpemVkID0gdGhpcy5ub3JtYWxpemUocmVmZXJlbmNlKTtcblxuICAgIGxldCB2YWx1ZSwgY2FjaGU7XG5cbiAgICBpZiAoaXNDb25zdChyZWZlcmVuY2UpKSB7XG4gICAgICB2YWx1ZSA9IG5vcm1hbGl6ZWQudmFsdWUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGUgPSBuZXcgUmVmZXJlbmNlQ2FjaGUobm9ybWFsaXplZCk7XG4gICAgICB2YWx1ZSA9IGNhY2hlLnBlZWsoKTtcbiAgICB9XG5cbiAgICBsZXQgc3RhY2sgPSB2bS5zdGFjaygpO1xuICAgIGxldCB1cHNlcnQgPSB0aGlzLmluc2VydCh2bS5lbnYuZ2V0QXBwZW5kT3BlcmF0aW9ucygpLCBzdGFjaywgdmFsdWUpO1xuICAgIGxldCBib3VuZHMgPSBuZXcgRnJhZ21lbnQodXBzZXJ0LmJvdW5kcyk7XG5cbiAgICBzdGFjay5uZXdCb3VuZHMoYm91bmRzKTtcblxuICAgIGlmIChjYWNoZSAvKiBpLmUuICFpc0NvbnN0KHJlZmVyZW5jZSkgKi8pIHtcbiAgICAgIHZtLnVwZGF0ZVdpdGgodGhpcy51cGRhdGVXaXRoKHZtLCByZWZlcmVuY2UsIGNhY2hlLCBib3VuZHMsIHVwc2VydCkpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgR3VhcmRlZEFwcGVuZE9wY29kZTxUIGV4dGVuZHMgSW5zZXJ0aW9uPiBleHRlbmRzIEFwcGVuZER5bmFtaWNPcGNvZGU8VD4ge1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgQXBwZW5kT3Bjb2RlOiB0eXBlb2YgT3B0aW1pemVkQ2F1dGlvdXNBcHBlbmRPcGNvZGUgfCB0eXBlb2YgT3B0aW1pemVkVHJ1c3RpbmdBcHBlbmRPcGNvZGU7XG4gIHByaXZhdGUgZGVvcHRlZDogT3B0aW9uPFNsaWNlPiA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBleHByZXNzaW9uOiBDb21waWxlZEV4cHJlc3Npb248YW55PiwgcHJpdmF0ZSBzeW1ib2xUYWJsZTogU3ltYm9sVGFibGUpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgZXZhbHVhdGUodm06IFZNKSB7XG4gICAgaWYgKHRoaXMuZGVvcHRlZCkge1xuICAgICAgdm0ucHVzaEV2YWxGcmFtZSh0aGlzLmRlb3B0ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5ldmFsdWF0ZU9wZXJhbmQodGhpcy5leHByZXNzaW9uKTtcblxuICAgICAgbGV0IHZhbHVlID0gdm0uZnJhbWUuZ2V0T3BlcmFuZCgpLnZhbHVlKCk7XG5cbiAgICAgIGlmKGlzQ29tcG9uZW50RGVmaW5pdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgdm0ucHVzaEV2YWxGcmFtZSh0aGlzLmRlb3B0KHZtLmVudikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VwZXIuZXZhbHVhdGUodm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkZW9wdChlbnY6IEVudmlyb25tZW50KTogU2xpY2UgeyAvLyBQdWJsaWMgYmVjYXVzZSBpdCdzIHVzZWQgaW4gdGhlIGxhenkgZGVvcHRcbiAgICAvLyBBdCBjb21waWxlIHRpbWUsIHdlIGRldGVybWluZWQgdGhhdCB0aGlzIGFwcGVuZCBjYWxsc2l0ZSBtaWdodCByZWZlclxuICAgIC8vIHRvIGEgbG9jYWwgdmFyaWFibGUvcHJvcGVydHkgbG9va3VwIHRoYXQgcmVzb2x2ZXMgdG8gYSBjb21wb25lbnRcbiAgICAvLyBkZWZpbml0aW9uIGF0IHJ1bnRpbWUuXG4gICAgLy9cbiAgICAvLyBXZSBjb3VsZCBoYXZlIGVhZ2VybHkgY29tcGlsZWQgdGhpcyBjYWxsc2l0ZSBpbnRvIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4gICAgLy9cbiAgICAvLyAgIHt7I2lmIChpcy1jb21wb25lbnQtZGVmaW5pdGlvbiBmb28pfX1cbiAgICAvLyAgICAge3tjb21wb25lbnQgZm9vfX1cbiAgICAvLyAgIHt7ZWxzZX19XG4gICAgLy8gICAgIHt7Zm9vfX1cbiAgICAvLyAgIHt7L2lmfX1cbiAgICAvL1xuICAgIC8vIEhvd2V2ZXIsIGluIHByYWN0aWNlLCB0aGVyZSBtaWdodCBiZSBhIGxhcmdlIGFtb3V0IG9mIHRoZXNlIGNhbGxzaXRlc1xuICAgIC8vIGFuZCBtb3N0IG9mIHRoZW0gd291bGQgcmVzb2x2ZSB0byBhIHNpbXBsZSB2YWx1ZSBsb29rdXAuIFRoZXJlZm9yZSwgd2VcbiAgICAvLyB0cmllZCB0byBiZSBvcHRpbWlzdGljIGFuZCBhc3N1bWVkIHRoYXQgdGhlIGNhbGxzaXRlIHdpbGwgcmVzb2x2ZSB0b1xuICAgIC8vIGFwcGVuZGluZyBhIHNpbXBsZSB2YWx1ZS5cbiAgICAvL1xuICAgIC8vIEhvd2V2ZXIsIHdlIGhhdmUgcmVhY2hlZCBoZXJlIGJlY2F1c2UgYXQgcnVudGltZSwgdGhlIGd1YXJkIGNvbmRpdGlvbmFsXG4gICAgLy8gaGF2ZSBkZXRlY3RlZCB0aGF0IHRoaXMgY2FsbHNpdGUgaXMgaW5kZWVkIHJlZmVycmluZyB0byBhIGNvbXBvbmVudFxuICAgIC8vIGRlZmluaXRpb24gb2JqZWN0LiBTaW5jZSB0aGlzIGlzIGxpa2VseSBnb2luZyB0byBiZSB0cnVlIGZvciBvdGhlclxuICAgIC8vIGluc3RhbmNlcyBvZiB0aGUgc2FtZSBjYWxsc2l0ZSwgaXQgaXMgbm93IGFwcHJvcGlhdGUgdG8gZGVvcHQgaW50byB0aGVcbiAgICAvLyBleHBhbmRlZCB2ZXJzaW9uIHRoYXQgaGFuZGxlcyBib3RoIGNhc2VzLiBUaGUgY29tcGlsYXRpb24gd291bGQgbG9va1xuICAgIC8vIGxpa2UgdGhpczpcbiAgICAvL1xuICAgIC8vICAgICAgICAgICAgICAgUHV0VmFsdWUoZXhwcmVzc2lvbilcbiAgICAvLyAgICAgICAgICAgICAgIFRlc3QoaXMtY29tcG9uZW50LWRlZmluaXRpb24pXG4gICAgLy8gICAgICAgICAgICAgICBFbnRlcihCRUdJTiwgRU5EKVxuICAgIC8vICAgQkVHSU46ICAgICAgTm9vcFxuICAgIC8vICAgICAgICAgICAgICAgSnVtcFVubGVzcyhWQUxVRSlcbiAgICAvLyAgICAgICAgICAgICAgIFB1dER5bmFtaWNDb21wb25lbnREZWZpbml0aW9uT3Bjb2RlXG4gICAgLy8gICAgICAgICAgICAgICBPcGVuQ29tcG9uZW50XG4gICAgLy8gICAgICAgICAgICAgICBDbG9zZUNvbXBvbmVudFxuICAgIC8vICAgICAgICAgICAgICAgSnVtcChFTkQpXG4gICAgLy8gICBWQUxVRTogICAgICBOb29wXG4gICAgLy8gICAgICAgICAgICAgICBPcHRpbWl6ZWRBcHBlbmRcbiAgICAvLyAgIEVORDogICAgICAgIE5vb3BcbiAgICAvLyAgICAgICAgICAgICAgIEV4aXRcbiAgICAvL1xuICAgIC8vIEtlZXAgaW4gbWluZCB0aGF0IGV2ZW4gaWYgd2UgKmRvbid0KiByZWFjaCBoZXJlIGF0IGluaXRpYWwgcmVuZGVyIHRpbWUsXG4gICAgLy8gaXQgaXMgc3RpbGwgcG9zc2libGUgKGFsdGhvdWdoIHF1aXRlIHJhcmUpIHRoYXQgdGhlIHNpbXBsZSB2YWx1ZSB3ZVxuICAgIC8vIGVuY291bnRlciBkdXJpbmcgaW5pdGlhbCByZW5kZXIgY291bGQgbGF0ZXIgY2hhbmdlIGludG8gYSBjb21wb25lbnRcbiAgICAvLyBkZWZpbml0aW9uIG9iamVjdCBhdCB1cGRhdGUgdGltZS4gVGhhdCBpcyBoYW5kbGVkIGJ5IHRoZSBcImxhenkgZGVvcHRcIlxuICAgIC8vIGNvZGUgb24gdGhlIHVwZGF0ZSBzaWRlIChzY3JvbGwgZG93biBmb3IgdGhlIG5leHQgYmlnIGJsb2NrIG9mIGNvbW1lbnQpLlxuXG4gICAgbGV0IGRzbCA9IG5ldyBPcGNvZGVCdWlsZGVyRFNMKHRoaXMuc3ltYm9sVGFibGUsIGVudik7XG5cbiAgICBkc2wucHV0VmFsdWUodGhpcy5leHByZXNzaW9uKTtcbiAgICBkc2wudGVzdChJc0NvbXBvbmVudERlZmluaXRpb25SZWZlcmVuY2UuY3JlYXRlKTtcblxuICAgIGRzbC5sYWJlbGxlZChudWxsLCAoZHNsLCBfQkVHSU4sIEVORCkgPT4ge1xuICAgICAgZHNsLmp1bXBVbmxlc3MoJ1ZBTFVFJyk7XG4gICAgICBkc2wucHV0RHluYW1pY0NvbXBvbmVudERlZmluaXRpb24oKTtcbiAgICAgIGRzbC5vcGVuQ29tcG9uZW50KENvbXBpbGVkQXJncy5lbXB0eSgpKTtcbiAgICAgIGRzbC5jbG9zZUNvbXBvbmVudCgpO1xuICAgICAgZHNsLmp1bXAoRU5EKTtcbiAgICAgIGRzbC5sYWJlbCgnVkFMVUUnKTtcbiAgICAgIGRzbC5keW5hbWljQ29udGVudChuZXcgdGhpcy5BcHBlbmRPcGNvZGUoKSk7XG4gICAgfSk7XG5cbiAgICBsZXQgZGVvcHRlZCA9IHRoaXMuZGVvcHRlZCA9IGRzbC50b1NsaWNlKCk7XG5cbiAgICAvLyBGcm9tIHRoaXMgcG9pbnQgb24sIHdlIGhhdmUgZXNzZW50aWFsbHkgcmVwbGFjZWQgb3Vyc2VsdmVzIHdpdGggYSBuZXcgc2V0XG4gICAgLy8gb2Ygb3Bjb2Rlcy4gU2luY2Ugd2Ugd2lsbCBhbHdheXMgYmUgZXhlY3V0aW5nIHRoZSBuZXcvZGVvcHRlZCBjb2RlLCBpdCdzXG4gICAgLy8gYSBnb29kIGlkZWEgKGFzIGEgcGF0dGVybikgdG8gbnVsbCBvdXQgYW55IHVubmVlZGVkIGZpZWxkcyBoZXJlIHRvIGF2b2lkXG4gICAgLy8gaG9sZGluZyBvbiB0byB1bm5lZWRlZC9zdGFsZSBvYmplY3RzOlxuXG4gICAgLy8gUVVFU1RJT046IFNob3VsZG4ndCB0aGlzIHdob2xlIG9iamVjdCBiZSBHQ2VkPyBJZiBub3QsIHdoeSBub3Q/XG5cbiAgICB0aGlzLmV4cHJlc3Npb24gPSBudWxsIGFzIEZJWE1FPGFueSwgJ1FVRVNUSU9OJz47XG5cbiAgICByZXR1cm4gZGVvcHRlZDtcbiAgfVxufVxuXG5jbGFzcyBJc0NvbXBvbmVudERlZmluaXRpb25SZWZlcmVuY2UgZXh0ZW5kcyBDb25kaXRpb25hbFJlZmVyZW5jZSB7XG4gIHN0YXRpYyBjcmVhdGUoaW5uZXI6IFJlZmVyZW5jZTxPcGFxdWU+KTogSXNDb21wb25lbnREZWZpbml0aW9uUmVmZXJlbmNlIHtcbiAgICByZXR1cm4gbmV3IElzQ29tcG9uZW50RGVmaW5pdGlvblJlZmVyZW5jZShpbm5lcik7XG4gIH1cblxuICB0b0Jvb2wodmFsdWU6IE9wYXF1ZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc0NvbXBvbmVudERlZmluaXRpb24odmFsdWUpO1xuICB9XG59XG5cbmFic3RyYWN0IGNsYXNzIFVwZGF0ZU9wY29kZTxUIGV4dGVuZHMgSW5zZXJ0aW9uPiBleHRlbmRzIFVwZGF0aW5nT3Bjb2RlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIGNhY2hlOiBSZWZlcmVuY2VDYWNoZTxUPixcbiAgICBwcm90ZWN0ZWQgYm91bmRzOiBGcmFnbWVudCxcbiAgICBwcm90ZWN0ZWQgdXBzZXJ0OiBVcHNlcnRcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnRhZyA9IGNhY2hlLnRhZztcbiAgfVxuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBpbnNlcnQoZG9tOiBET01UcmVlQ29uc3RydWN0aW9uLCBjdXJzb3I6IEN1cnNvciwgdmFsdWU6IFQpOiBVcHNlcnQ7XG5cbiAgZXZhbHVhdGUodm06IFVwZGF0aW5nVk0pIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLmNhY2hlLnJldmFsaWRhdGUoKTtcblxuICAgIGlmIChpc01vZGlmaWVkKHZhbHVlKSkge1xuICAgICAgbGV0IHsgYm91bmRzLCB1cHNlcnQgfSA9IHRoaXM7XG4gICAgICBsZXQgeyBkb20gfSA9IHZtO1xuXG4gICAgICBpZighdGhpcy51cHNlcnQudXBkYXRlKGRvbSwgdmFsdWUpKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgQ3Vyc29yKGJvdW5kcy5wYXJlbnRFbGVtZW50KCksIGNsZWFyKGJvdW5kcykpO1xuICAgICAgICB1cHNlcnQgPSB0aGlzLnVwc2VydCA9IHRoaXMuaW5zZXJ0KHZtLmVudi5nZXRBcHBlbmRPcGVyYXRpb25zKCksIGN1cnNvciwgdmFsdWUgYXMgVCk7XG4gICAgICB9XG5cbiAgICAgIGJvdW5kcy51cGRhdGUodXBzZXJ0LmJvdW5kcyk7XG4gICAgfVxuICB9XG5cbiAgdG9KU09OKCk6IE9wY29kZUpTT04ge1xuICAgIGxldCB7IF9ndWlkOiBndWlkLCB0eXBlLCBjYWNoZSB9ID0gdGhpcztcblxuICAgIHJldHVybiB7XG4gICAgICBndWlkLFxuICAgICAgdHlwZSxcbiAgICAgIGRldGFpbHM6IHsgbGFzdFZhbHVlOiBKU09OLnN0cmluZ2lmeShjYWNoZS5wZWVrKCkpIH1cbiAgICB9O1xuICB9XG59XG5cbmFic3RyYWN0IGNsYXNzIEd1YXJkZWRVcGRhdGVPcGNvZGU8VCBleHRlbmRzIEluc2VydGlvbj4gZXh0ZW5kcyBVcGRhdGVPcGNvZGU8VD4ge1xuICBwcml2YXRlIF90YWc6IFVwZGF0YWJsZVRhZztcbiAgcHJpdmF0ZSBkZW9wdGVkOiBPcHRpb248VHJ5T3Bjb2RlPiA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWZlcmVuY2U6IFJlZmVyZW5jZTxPcGFxdWU+LFxuICAgIGNhY2hlOiBSZWZlcmVuY2VDYWNoZTxUPixcbiAgICBib3VuZHM6IEZyYWdtZW50LFxuICAgIHVwc2VydDogVXBzZXJ0LFxuICAgIHByaXZhdGUgYXBwZW5kT3Bjb2RlOiBHdWFyZGVkQXBwZW5kT3Bjb2RlPFQ+LFxuICAgIHByaXZhdGUgc3RhdGU6IFZNU3RhdGVcbiAgKSB7XG4gICAgc3VwZXIoY2FjaGUsIGJvdW5kcywgdXBzZXJ0KTtcbiAgICB0aGlzLnRhZyA9IHRoaXMuX3RhZyA9IG5ldyBVcGRhdGFibGVUYWcodGhpcy50YWcpO1xuICB9XG5cbiAgZXZhbHVhdGUodm06IFVwZGF0aW5nVk0pIHtcbiAgICBpZiAodGhpcy5kZW9wdGVkKSB7XG4gICAgICB2bS5ldmFsdWF0ZU9wY29kZSh0aGlzLmRlb3B0ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNDb21wb25lbnREZWZpbml0aW9uKHRoaXMucmVmZXJlbmNlLnZhbHVlKCkpKSB7XG4gICAgICAgIHRoaXMubGF6eURlb3B0KHZtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1cGVyLmV2YWx1YXRlKHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGxhenlEZW9wdCh2bTogVXBkYXRpbmdWTSkge1xuICAgIC8vIER1cmlnbiBpbml0aWFsIHJlbmRlciwgd2Uga25vdyB0aGF0IHRoZSByZWZlcmVuY2UgZG9lcyBub3QgY29udGFpbiBhXG4gICAgLy8gY29tcG9uZW50IGRlZmluaXRpb24sIHNvIHdlIG9wdGltaXN0aWNhbGx5IGFzc3VtZWQgdGhhdCB0aGlzIGFwcGVuZFxuICAgIC8vIGlzIGp1c3QgYSBub3JtYWwgYXBwZW5kLiBIb3dldmVyLCBhdCB1cGRhdGUgdGltZSwgd2UgZGlzY292ZXJlZCB0aGF0XG4gICAgLy8gdGhlIHJlZmVyZW5jZSBoYXMgc3dpdGNoZWQgaW50byBjb250YWluaW5nIGEgY29tcG9uZW50IGRlZmluaXRpb24sIHNvXG4gICAgLy8gd2UgbmVlZCB0byBkbyBhIFwibGF6eSBkZW9wdFwiLCBzaW11bGF0aW5nIHdoYXQgd291bGQgaGF2ZSBoYXBwZW5lZCBpZlxuICAgIC8vIHdlIGhhZCBkZWNpZGVkIHRvIHBlcmZvcm0gdGhlIGRlb3B0IGluIHRoZSBmaXJzdCBwbGFjZSBkdXJpbmcgaW5pdGlhbFxuICAgIC8vIHJlbmRlci5cbiAgICAvL1xuICAgIC8vIE1vcmUgY29uY3JldGVseSwgd2Ugd291bGQgaGF2ZSBleHBhbmRlZCB0aGUgY3VybHkgaW50byBhIGlmL2Vsc2UsIGFuZFxuICAgIC8vIGJhc2VkIG9uIHdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgY29tcG9uZW50IGRlZmluaXRpb24gb3Igbm90LCB3ZSB3b3VsZFxuICAgIC8vIGhhdmUgZW50ZXJlZCBlaXRoZXIgdGhlIGR5bmFtaWMgY29tcG9uZW50IGJyYW5jaCBvciB0aGUgc2ltcGxlIHZhbHVlXG4gICAgLy8gYnJhbmNoLlxuICAgIC8vXG4gICAgLy8gU2luY2Ugd2UgcmVuZGVyZWQgYSBzaW1wbGUgdmFsdWUgZHVyaW5nIGluaXRpYWwgcmVuZGVyIChhbmQgYWxsIHRoZVxuICAgIC8vIHVwZGF0ZXMgdXAgdW50aWwgdGhpcyBwb2ludCksIHdlIG5lZWQgdG8gcHJldGVuZCB0aGF0IHRoZSByZXN1bHQgaXNcbiAgICAvLyBwcm9kdWNlZCBieSB0aGUgXCJWQUxVRVwiIGJyYW5jaCBvZiB0aGUgZGVvcHRlZCBhcHBlbmQgb3Bjb2RlOlxuICAgIC8vXG4gICAgLy8gICBUcnkoQkVHSU4sIEVORClcbiAgICAvLyAgICAgQXNzZXJ0KElzQ29tcG9uZW50RGVmaW5pdGlvbiwgZXhwZWN0ZWQ9ZmFsc2UpXG4gICAgLy8gICAgIE9wdGltaXplZFVwZGF0ZVxuICAgIC8vXG4gICAgLy8gSW4gdGhpcyBjYXNlLCBiZWNhdXNlIHRoZSByZWZlcmVuY2UgaGFzIHN3aXRjaGVkIGZyb20gYmVpbmcgYSBzaW1wbGVcbiAgICAvLyB2YWx1ZSBpbnRvIGEgY29tcG9uZW50IGRlZmluaXRpb24sIHdoYXQgd291bGQgaGF2ZSBoYXBwZW5lZCBpcyB0aGF0XG4gICAgLy8gdGhlIGFzc2VydCB3b3VsZCB0aHJvdywgY2F1c2luZyB0aGUgVHJ5IG9wY29kZSB0byB0ZWFyZG93biB0aGUgYm91bmRzXG4gICAgLy8gYW5kIHJlcnVuIHRoZSBvcmlnaW5hbCBhcHBlbmQgb3Bjb2RlLlxuICAgIC8vXG4gICAgLy8gU2luY2UgdGhlIFRyeSBvcGNvZGUgd291bGQgaGF2ZSBudWtlZCB0aGUgdXBkYXRpbmcgb3Bjb2RlcyBhbnl3YXksIHdlXG4gICAgLy8gd291bGRuJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCBzaW11bGF0aW5nIHRob3NlLiBBbGwgd2UgaGF2ZSB0byBkbyBpcyB0b1xuICAgIC8vIGV4ZWN1dGUgdGhlIFRyeSBvcGNvZGUgYW5kIGltbWVkaWF0ZWx5IHRocm93LlxuXG4gICAgbGV0IHsgYm91bmRzLCBhcHBlbmRPcGNvZGUsIHN0YXRlIH0gPSB0aGlzO1xuICAgIGxldCBlbnYgPSB2bS5lbnY7XG5cbiAgICBsZXQgc2xpY2UgICAgID0gYXBwZW5kT3Bjb2RlLmRlb3B0KGVudik7XG4gICAgbGV0IGVudGVyICAgICA9IGV4cGVjdChlbnYucHJvZ3JhbS5vcGNvZGUoc2xpY2VbMF0gKyA4KSwgJ2hhcmRjb2RlZCBkZW9wdCBsb2NhdGlvbicpO1xuICAgIGxldCBvcHMgICAgICAgPSB2bS5jb25zdGFudHMuZ2V0U2xpY2UoZW50ZXIub3AxKTtcblxuICAgIGxldCB0cmFja2VyID0gbmV3IFVwZGF0YWJsZUJsb2NrVHJhY2tlcihib3VuZHMucGFyZW50RWxlbWVudCgpKTtcbiAgICB0cmFja2VyLm5ld0JvdW5kcyh0aGlzLmJvdW5kcyk7XG5cbiAgICBsZXQgY2hpbGRyZW4gPSBuZXcgTGlua2VkTGlzdDxVcGRhdGluZ09wY29kZT4oKTtcblxuICAgIHN0YXRlLmZyYW1lWydjb25kaXRpb24nXSA9IElzQ29tcG9uZW50RGVmaW5pdGlvblJlZmVyZW5jZS5jcmVhdGUoZXhwZWN0KHN0YXRlLmZyYW1lWydvcGVyYW5kJ10sICdvcGVyYW5kIHNob3VsZCBiZSBwb3B1bGF0ZWQnKSk7XG5cbiAgICBsZXQgZGVvcHRlZCA9IHRoaXMuZGVvcHRlZCA9IG5ldyBUcnlPcGNvZGUob3BzLCBzdGF0ZSwgdHJhY2tlciwgY2hpbGRyZW4pO1xuXG4gICAgdGhpcy5fdGFnLnVwZGF0ZShkZW9wdGVkLnRhZyk7XG5cbiAgICB2bS5ldmFsdWF0ZU9wY29kZShkZW9wdGVkKTtcbiAgICB2bS50aHJvdygpO1xuXG4gICAgLy8gRnJvbSB0aGlzIHBvaW50IG9uLCB3ZSBoYXZlIGVzc2VudGlhbGx5IHJlcGxhY2VkIG91cnNlbHZlIHdpdGggYSBuZXdcbiAgICAvLyBvcGNvZGUuIFNpbmNlIHdlIHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGluZyB0aGUgbmV3L2Rlb3B0ZWQgY29kZSwgaXQncyBhXG4gICAgLy8gZ29vZCBpZGVhIChhcyBhIHBhdHRlcm4pIHRvIG51bGwgb3V0IGFueSB1bm5lZWRlZCBmaWVsZHMgaGVyZSB0byBhdm9pZFxuICAgIC8vIGhvbGRpbmcgb24gdG8gdW5uZWVkZWQvc3RhbGUgb2JqZWN0czpcblxuICAgIC8vIFFVRVNUSU9OOiBTaG91bGRuJ3QgdGhpcyB3aG9sZSBvYmplY3QgYmUgR0NlZD8gSWYgbm90LCB3aHkgbm90P1xuXG4gICAgdGhpcy5fdGFnICAgICAgICAgPSBudWxsIGFzIEZJWE1FPGFueSwgJ1FVRVNUSU9OJz47XG4gICAgdGhpcy5yZWZlcmVuY2UgICAgPSBudWxsIGFzIEZJWE1FPGFueSwgJ1FVRVNUSU9OJz47XG4gICAgdGhpcy5jYWNoZSAgICAgICAgPSBudWxsIGFzIEZJWE1FPGFueSwgJ1FVRVNUSU9OJz47XG4gICAgdGhpcy5ib3VuZHMgICAgICAgPSBudWxsIGFzIEZJWE1FPGFueSwgJ1FVRVNUSU9OJz47XG4gICAgdGhpcy51cHNlcnQgICAgICAgPSBudWxsIGFzIEZJWE1FPGFueSwgJ1FVRVNUSU9OJz47XG4gICAgdGhpcy5hcHBlbmRPcGNvZGUgPSBudWxsIGFzIEZJWE1FPGFueSwgJ1FVRVNUSU9OJz47XG4gICAgdGhpcy5zdGF0ZSAgICAgICAgPSBudWxsIGFzIEZJWE1FPGFueSwgJ1FVRVNUSU9OJz47XG4gIH1cblxuICB0b0pTT04oKTogT3Bjb2RlSlNPTiB7XG4gICAgbGV0IHsgX2d1aWQ6IGd1aWQsIHR5cGUsIGRlb3B0ZWQgfSA9IHRoaXM7XG5cbiAgICBpZiAoZGVvcHRlZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ3VpZCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgZGVvcHRlZDogdHJ1ZSxcbiAgICAgICAgY2hpbGRyZW46IFtkZW9wdGVkLnRvSlNPTigpXVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN1cGVyLnRvSlNPTigpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgT3B0aW1pemVkQ2F1dGlvdXNBcHBlbmRPcGNvZGUgZXh0ZW5kcyBBcHBlbmREeW5hbWljT3Bjb2RlPENhdXRpb3VzSW5zZXJ0aW9uPiB7XG4gIHR5cGUgPSAnb3B0aW1pemVkLWNhdXRpb3VzLWFwcGVuZCc7XG5cbiAgcHJvdGVjdGVkIG5vcm1hbGl6ZShyZWZlcmVuY2U6IFJlZmVyZW5jZTxPcGFxdWU+KTogUmVmZXJlbmNlPENhdXRpb3VzSW5zZXJ0aW9uPiB7XG4gICAgcmV0dXJuIG1hcChyZWZlcmVuY2UsIG5vcm1hbGl6ZVZhbHVlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBpbnNlcnQoZG9tOiBET01UcmVlQ29uc3RydWN0aW9uLCBjdXJzb3I6IEN1cnNvciwgdmFsdWU6IENhdXRpb3VzSW5zZXJ0aW9uKTogVXBzZXJ0IHtcbiAgICByZXR1cm4gY2F1dGlvdXNJbnNlcnQoZG9tLCBjdXJzb3IsIHZhbHVlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCB1cGRhdGVXaXRoKF92bTogVk0sIF9yZWZlcmVuY2U6IFJlZmVyZW5jZTxPcGFxdWU+LCBjYWNoZTogUmVmZXJlbmNlQ2FjaGU8Q2F1dGlvdXNJbnNlcnRpb24+LCBib3VuZHM6IEZyYWdtZW50LCB1cHNlcnQ6IFVwc2VydCk6IFVwZGF0aW5nT3Bjb2RlIHtcbiAgICByZXR1cm4gbmV3IE9wdGltaXplZENhdXRpb3VzVXBkYXRlT3Bjb2RlKGNhY2hlLCBib3VuZHMsIHVwc2VydCk7XG4gIH1cbn1cblxuY2xhc3MgT3B0aW1pemVkQ2F1dGlvdXNVcGRhdGVPcGNvZGUgZXh0ZW5kcyBVcGRhdGVPcGNvZGU8Q2F1dGlvdXNJbnNlcnRpb24+IHtcbiAgdHlwZSA9ICdvcHRpbWl6ZWQtY2F1dGlvdXMtdXBkYXRlJztcblxuICBwcm90ZWN0ZWQgaW5zZXJ0KGRvbTogRE9NVHJlZUNvbnN0cnVjdGlvbiwgY3Vyc29yOiBDdXJzb3IsIHZhbHVlOiBDYXV0aW91c0luc2VydGlvbik6IFVwc2VydCB7XG4gICAgcmV0dXJuIGNhdXRpb3VzSW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEd1YXJkZWRDYXV0aW91c0FwcGVuZE9wY29kZSBleHRlbmRzIEd1YXJkZWRBcHBlbmRPcGNvZGU8Q2F1dGlvdXNJbnNlcnRpb24+IHtcbiAgdHlwZSA9ICdndWFyZGVkLWNhdXRpb3VzLWFwcGVuZCc7XG5cbiAgcHJvdGVjdGVkIEFwcGVuZE9wY29kZSA9IE9wdGltaXplZENhdXRpb3VzQXBwZW5kT3Bjb2RlO1xuXG4gIHByb3RlY3RlZCBub3JtYWxpemUocmVmZXJlbmNlOiBSZWZlcmVuY2U8T3BhcXVlPik6IFJlZmVyZW5jZTxDYXV0aW91c0luc2VydGlvbj4ge1xuICAgIHJldHVybiBtYXAocmVmZXJlbmNlLCBub3JtYWxpemVWYWx1ZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgaW5zZXJ0KGRvbTogRE9NVHJlZUNvbnN0cnVjdGlvbiwgY3Vyc29yOiBDdXJzb3IsIHZhbHVlOiBDYXV0aW91c0luc2VydGlvbik6IFVwc2VydCB7XG4gICAgcmV0dXJuIGNhdXRpb3VzSW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgdXBkYXRlV2l0aCh2bTogVk0sIHJlZmVyZW5jZTogUmVmZXJlbmNlPE9wYXF1ZT4sIGNhY2hlOiBSZWZlcmVuY2VDYWNoZTxDYXV0aW91c0luc2VydGlvbj4sIGJvdW5kczogRnJhZ21lbnQsIHVwc2VydDogVXBzZXJ0KTogVXBkYXRpbmdPcGNvZGUge1xuICAgIHJldHVybiBuZXcgR3VhcmRlZENhdXRpb3VzVXBkYXRlT3Bjb2RlKHJlZmVyZW5jZSwgY2FjaGUsIGJvdW5kcywgdXBzZXJ0LCB0aGlzLCB2bS5jYXB0dXJlKCkpO1xuICB9XG59XG5cbmNsYXNzIEd1YXJkZWRDYXV0aW91c1VwZGF0ZU9wY29kZSBleHRlbmRzIEd1YXJkZWRVcGRhdGVPcGNvZGU8Q2F1dGlvdXNJbnNlcnRpb24+IHtcbiAgdHlwZSA9ICdndWFyZGVkLWNhdXRpb3VzLXVwZGF0ZSc7XG5cbiAgcHJvdGVjdGVkIGluc2VydChkb206IERPTVRyZWVDb25zdHJ1Y3Rpb24sIGN1cnNvcjogQ3Vyc29yLCB2YWx1ZTogQ2F1dGlvdXNJbnNlcnRpb24pOiBVcHNlcnQge1xuICAgIHJldHVybiBjYXV0aW91c0luc2VydChkb20sIGN1cnNvciwgdmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBPcHRpbWl6ZWRUcnVzdGluZ0FwcGVuZE9wY29kZSBleHRlbmRzIEFwcGVuZER5bmFtaWNPcGNvZGU8VHJ1c3RpbmdJbnNlcnRpb24+IHtcbiAgdHlwZSA9ICdvcHRpbWl6ZWQtdHJ1c3RpbmctYXBwZW5kJztcblxuICBwcm90ZWN0ZWQgbm9ybWFsaXplKHJlZmVyZW5jZTogUmVmZXJlbmNlPE9wYXF1ZT4pOiBSZWZlcmVuY2U8VHJ1c3RpbmdJbnNlcnRpb24+IHtcbiAgICByZXR1cm4gbWFwKHJlZmVyZW5jZSwgbm9ybWFsaXplVHJ1c3RlZFZhbHVlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBpbnNlcnQoZG9tOiBET01UcmVlQ29uc3RydWN0aW9uLCBjdXJzb3I6IEN1cnNvciwgdmFsdWU6IFRydXN0aW5nSW5zZXJ0aW9uKTogVXBzZXJ0IHtcbiAgICByZXR1cm4gdHJ1c3RpbmdJbnNlcnQoZG9tLCBjdXJzb3IsIHZhbHVlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCB1cGRhdGVXaXRoKF92bTogVk0sIF9yZWZlcmVuY2U6IFJlZmVyZW5jZTxPcGFxdWU+LCBjYWNoZTogUmVmZXJlbmNlQ2FjaGU8VHJ1c3RpbmdJbnNlcnRpb24+LCBib3VuZHM6IEZyYWdtZW50LCB1cHNlcnQ6IFVwc2VydCk6IFVwZGF0aW5nT3Bjb2RlIHtcbiAgICByZXR1cm4gbmV3IE9wdGltaXplZFRydXN0aW5nVXBkYXRlT3Bjb2RlKGNhY2hlLCBib3VuZHMsIHVwc2VydCk7XG4gIH1cbn1cblxuY2xhc3MgT3B0aW1pemVkVHJ1c3RpbmdVcGRhdGVPcGNvZGUgZXh0ZW5kcyBVcGRhdGVPcGNvZGU8VHJ1c3RpbmdJbnNlcnRpb24+IHtcbiAgdHlwZSA9ICdvcHRpbWl6ZWQtdHJ1c3RpbmctdXBkYXRlJztcblxuICBwcm90ZWN0ZWQgaW5zZXJ0KGRvbTogRE9NVHJlZUNvbnN0cnVjdGlvbiwgY3Vyc29yOiBDdXJzb3IsIHZhbHVlOiBUcnVzdGluZ0luc2VydGlvbik6IFVwc2VydCB7XG4gICAgcmV0dXJuIHRydXN0aW5nSW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEd1YXJkZWRUcnVzdGluZ0FwcGVuZE9wY29kZSBleHRlbmRzIEd1YXJkZWRBcHBlbmRPcGNvZGU8VHJ1c3RpbmdJbnNlcnRpb24+IHtcbiAgdHlwZSA9ICdndWFyZGVkLXRydXN0aW5nLWFwcGVuZCc7XG5cbiAgcHJvdGVjdGVkIEFwcGVuZE9wY29kZSA9IE9wdGltaXplZFRydXN0aW5nQXBwZW5kT3Bjb2RlO1xuXG4gIHByb3RlY3RlZCBub3JtYWxpemUocmVmZXJlbmNlOiBSZWZlcmVuY2U8T3BhcXVlPik6IFJlZmVyZW5jZTxUcnVzdGluZ0luc2VydGlvbj4ge1xuICAgIHJldHVybiBtYXAocmVmZXJlbmNlLCBub3JtYWxpemVUcnVzdGVkVmFsdWUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGluc2VydChkb206IERPTVRyZWVDb25zdHJ1Y3Rpb24sIGN1cnNvcjogQ3Vyc29yLCB2YWx1ZTogVHJ1c3RpbmdJbnNlcnRpb24pOiBVcHNlcnQge1xuICAgIHJldHVybiB0cnVzdGluZ0luc2VydChkb20sIGN1cnNvciwgdmFsdWUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHVwZGF0ZVdpdGgodm06IFZNLCByZWZlcmVuY2U6IFJlZmVyZW5jZTxPcGFxdWU+LCBjYWNoZTogUmVmZXJlbmNlQ2FjaGU8VHJ1c3RpbmdJbnNlcnRpb24+LCBib3VuZHM6IEZyYWdtZW50LCB1cHNlcnQ6IFVwc2VydCk6IFVwZGF0aW5nT3Bjb2RlIHtcbiAgICByZXR1cm4gbmV3IEd1YXJkZWRUcnVzdGluZ1VwZGF0ZU9wY29kZShyZWZlcmVuY2UsIGNhY2hlLCBib3VuZHMsIHVwc2VydCwgdGhpcywgdm0uY2FwdHVyZSgpKTtcbiAgfVxufVxuXG5jbGFzcyBHdWFyZGVkVHJ1c3RpbmdVcGRhdGVPcGNvZGUgZXh0ZW5kcyBHdWFyZGVkVXBkYXRlT3Bjb2RlPFRydXN0aW5nSW5zZXJ0aW9uPiB7XG4gIHR5cGUgPSAndHJ1c3RpbmctdXBkYXRlJztcblxuICBwcm90ZWN0ZWQgaW5zZXJ0KGRvbTogRE9NVHJlZUNvbnN0cnVjdGlvbiwgY3Vyc29yOiBDdXJzb3IsIHZhbHVlOiBUcnVzdGluZ0luc2VydGlvbik6IFVwc2VydCB7XG4gICAgcmV0dXJuIHRydXN0aW5nSW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IGlzU2FmZVN0cmluZywgaXNOb2RlLCBpc1N0cmluZywgY2F1dGlvdXNJbnNlcnQsIHRydXN0aW5nSW5zZXJ0IH0gZnJvbSAnLi4vLi4vdXBzZXJ0JztcbmltcG9ydCB7IGlzQ29tcG9uZW50RGVmaW5pdGlvbiB9IGZyb20gJy4uLy4uL2NvbXBvbmVudC9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFVwZGF0aW5nT3Bjb2RlIH0gZnJvbSAnLi4vLi4vb3Bjb2Rlcyc7XG5pbXBvcnQgeyBDb21waWxlZEFyZ3MgfSBmcm9tICcuLi9leHByZXNzaW9ucyc7XG5pbXBvcnQgeyBUcnlPcGNvZGUgfSBmcm9tICcuLi8uLi92bS91cGRhdGUnO1xuaW1wb3J0IHsgUmVmZXJlbmNlQ2FjaGUsIFVwZGF0YWJsZVRhZywgaXNNb2RpZmllZCwgaXNDb25zdCwgbWFwIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7IExpbmtlZExpc3QsIGV4cGVjdCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgQ3Vyc29yLCBjbGVhciB9IGZyb20gJy4uLy4uL2JvdW5kcyc7XG5pbXBvcnQgeyBGcmFnbWVudCB9IGZyb20gJy4uLy4uL2J1aWxkZXInO1xuaW1wb3J0IE9wY29kZUJ1aWxkZXJEU0wgZnJvbSAnLi9idWlsZGVyJztcbmltcG9ydCB7IENvbmRpdGlvbmFsUmVmZXJlbmNlIH0gZnJvbSAnLi4vLi4vcmVmZXJlbmNlcyc7XG5pbXBvcnQgeyBVcGRhdGFibGVCbG9ja1RyYWNrZXIgfSBmcm9tICcuLi8uLi9idWlsZGVyJztcbmltcG9ydCB7IEFQUEVORF9PUENPREVTLCBPcGNvZGVOYW1lIGFzIE9wIH0gZnJvbSAnLi4vLi4vb3Bjb2Rlcyc7XG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuRHluYW1pY0NvbnRlbnQsICh2bSwgeyBvcDE6IGFwcGVuZCB9KSA9PiB7XG4gICAgbGV0IG9wY29kZSA9IHZtLmNvbnN0YW50cy5nZXRPdGhlcihhcHBlbmQpO1xuICAgIG9wY29kZS5ldmFsdWF0ZSh2bSk7XG59KTtcbmZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdmFsdWVbJ3RvU3RyaW5nJ10gIT09ICdmdW5jdGlvbic7XG59XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplVGV4dFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKGlzRW1wdHkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVUcnVzdGVkVmFsdWUodmFsdWUpIHtcbiAgICBpZiAoaXNFbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzU2FmZVN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvSFRNTCgpO1xuICAgIH1cbiAgICBpZiAoaXNOb2RlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAoaXNFbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzU2FmZVN0cmluZyh2YWx1ZSkgfHwgaXNOb2RlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xufVxuZXhwb3J0IGNsYXNzIEFwcGVuZER5bmFtaWNPcGNvZGUge1xuICAgIGV2YWx1YXRlKHZtKSB7XG4gICAgICAgIGxldCByZWZlcmVuY2UgPSB2bS5mcmFtZS5nZXRPcGVyYW5kKCk7XG4gICAgICAgIGxldCBub3JtYWxpemVkID0gdGhpcy5ub3JtYWxpemUocmVmZXJlbmNlKTtcbiAgICAgICAgbGV0IHZhbHVlLCBjYWNoZTtcbiAgICAgICAgaWYgKGlzQ29uc3QocmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBub3JtYWxpemVkLnZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWNoZSA9IG5ldyBSZWZlcmVuY2VDYWNoZShub3JtYWxpemVkKTtcbiAgICAgICAgICAgIHZhbHVlID0gY2FjaGUucGVlaygpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFjayA9IHZtLnN0YWNrKCk7XG4gICAgICAgIGxldCB1cHNlcnQgPSB0aGlzLmluc2VydCh2bS5lbnYuZ2V0QXBwZW5kT3BlcmF0aW9ucygpLCBzdGFjaywgdmFsdWUpO1xuICAgICAgICBsZXQgYm91bmRzID0gbmV3IEZyYWdtZW50KHVwc2VydC5ib3VuZHMpO1xuICAgICAgICBzdGFjay5uZXdCb3VuZHMoYm91bmRzKTtcbiAgICAgICAgaWYgKGNhY2hlIC8qIGkuZS4gIWlzQ29uc3QocmVmZXJlbmNlKSAqLykge1xuICAgICAgICAgICAgdm0udXBkYXRlV2l0aCh0aGlzLnVwZGF0ZVdpdGgodm0sIHJlZmVyZW5jZSwgY2FjaGUsIGJvdW5kcywgdXBzZXJ0KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgR3VhcmRlZEFwcGVuZE9wY29kZSBleHRlbmRzIEFwcGVuZER5bmFtaWNPcGNvZGUge1xuICAgIGNvbnN0cnVjdG9yKGV4cHJlc3Npb24sIHN5bWJvbFRhYmxlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgIHRoaXMuc3ltYm9sVGFibGUgPSBzeW1ib2xUYWJsZTtcbiAgICAgICAgdGhpcy5kZW9wdGVkID0gbnVsbDtcbiAgICB9XG4gICAgZXZhbHVhdGUodm0pIHtcbiAgICAgICAgaWYgKHRoaXMuZGVvcHRlZCkge1xuICAgICAgICAgICAgdm0ucHVzaEV2YWxGcmFtZSh0aGlzLmRlb3B0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdm0uZXZhbHVhdGVPcGVyYW5kKHRoaXMuZXhwcmVzc2lvbik7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB2bS5mcmFtZS5nZXRPcGVyYW5kKCkudmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChpc0NvbXBvbmVudERlZmluaXRpb24odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdm0ucHVzaEV2YWxGcmFtZSh0aGlzLmRlb3B0KHZtLmVudikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3VwZXIuZXZhbHVhdGUodm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlb3B0KGVudikge1xuICAgICAgICAvLyBBdCBjb21waWxlIHRpbWUsIHdlIGRldGVybWluZWQgdGhhdCB0aGlzIGFwcGVuZCBjYWxsc2l0ZSBtaWdodCByZWZlclxuICAgICAgICAvLyB0byBhIGxvY2FsIHZhcmlhYmxlL3Byb3BlcnR5IGxvb2t1cCB0aGF0IHJlc29sdmVzIHRvIGEgY29tcG9uZW50XG4gICAgICAgIC8vIGRlZmluaXRpb24gYXQgcnVudGltZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgY291bGQgaGF2ZSBlYWdlcmx5IGNvbXBpbGVkIHRoaXMgY2FsbHNpdGUgaW50byBzb21ldGhpbmcgbGlrZSB0aGlzOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgIHt7I2lmIChpcy1jb21wb25lbnQtZGVmaW5pdGlvbiBmb28pfX1cbiAgICAgICAgLy8gICAgIHt7Y29tcG9uZW50IGZvb319XG4gICAgICAgIC8vICAge3tlbHNlfX1cbiAgICAgICAgLy8gICAgIHt7Zm9vfX1cbiAgICAgICAgLy8gICB7ey9pZn19XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEhvd2V2ZXIsIGluIHByYWN0aWNlLCB0aGVyZSBtaWdodCBiZSBhIGxhcmdlIGFtb3V0IG9mIHRoZXNlIGNhbGxzaXRlc1xuICAgICAgICAvLyBhbmQgbW9zdCBvZiB0aGVtIHdvdWxkIHJlc29sdmUgdG8gYSBzaW1wbGUgdmFsdWUgbG9va3VwLiBUaGVyZWZvcmUsIHdlXG4gICAgICAgIC8vIHRyaWVkIHRvIGJlIG9wdGltaXN0aWMgYW5kIGFzc3VtZWQgdGhhdCB0aGUgY2FsbHNpdGUgd2lsbCByZXNvbHZlIHRvXG4gICAgICAgIC8vIGFwcGVuZGluZyBhIHNpbXBsZSB2YWx1ZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSG93ZXZlciwgd2UgaGF2ZSByZWFjaGVkIGhlcmUgYmVjYXVzZSBhdCBydW50aW1lLCB0aGUgZ3VhcmQgY29uZGl0aW9uYWxcbiAgICAgICAgLy8gaGF2ZSBkZXRlY3RlZCB0aGF0IHRoaXMgY2FsbHNpdGUgaXMgaW5kZWVkIHJlZmVycmluZyB0byBhIGNvbXBvbmVudFxuICAgICAgICAvLyBkZWZpbml0aW9uIG9iamVjdC4gU2luY2UgdGhpcyBpcyBsaWtlbHkgZ29pbmcgdG8gYmUgdHJ1ZSBmb3Igb3RoZXJcbiAgICAgICAgLy8gaW5zdGFuY2VzIG9mIHRoZSBzYW1lIGNhbGxzaXRlLCBpdCBpcyBub3cgYXBwcm9waWF0ZSB0byBkZW9wdCBpbnRvIHRoZVxuICAgICAgICAvLyBleHBhbmRlZCB2ZXJzaW9uIHRoYXQgaGFuZGxlcyBib3RoIGNhc2VzLiBUaGUgY29tcGlsYXRpb24gd291bGQgbG9va1xuICAgICAgICAvLyBsaWtlIHRoaXM6XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgICAgICAgICAgUHV0VmFsdWUoZXhwcmVzc2lvbilcbiAgICAgICAgLy8gICAgICAgICAgICAgICBUZXN0KGlzLWNvbXBvbmVudC1kZWZpbml0aW9uKVxuICAgICAgICAvLyAgICAgICAgICAgICAgIEVudGVyKEJFR0lOLCBFTkQpXG4gICAgICAgIC8vICAgQkVHSU46ICAgICAgTm9vcFxuICAgICAgICAvLyAgICAgICAgICAgICAgIEp1bXBVbmxlc3MoVkFMVUUpXG4gICAgICAgIC8vICAgICAgICAgICAgICAgUHV0RHluYW1pY0NvbXBvbmVudERlZmluaXRpb25PcGNvZGVcbiAgICAgICAgLy8gICAgICAgICAgICAgICBPcGVuQ29tcG9uZW50XG4gICAgICAgIC8vICAgICAgICAgICAgICAgQ2xvc2VDb21wb25lbnRcbiAgICAgICAgLy8gICAgICAgICAgICAgICBKdW1wKEVORClcbiAgICAgICAgLy8gICBWQUxVRTogICAgICBOb29wXG4gICAgICAgIC8vICAgICAgICAgICAgICAgT3B0aW1pemVkQXBwZW5kXG4gICAgICAgIC8vICAgRU5EOiAgICAgICAgTm9vcFxuICAgICAgICAvLyAgICAgICAgICAgICAgIEV4aXRcbiAgICAgICAgLy9cbiAgICAgICAgLy8gS2VlcCBpbiBtaW5kIHRoYXQgZXZlbiBpZiB3ZSAqZG9uJ3QqIHJlYWNoIGhlcmUgYXQgaW5pdGlhbCByZW5kZXIgdGltZSxcbiAgICAgICAgLy8gaXQgaXMgc3RpbGwgcG9zc2libGUgKGFsdGhvdWdoIHF1aXRlIHJhcmUpIHRoYXQgdGhlIHNpbXBsZSB2YWx1ZSB3ZVxuICAgICAgICAvLyBlbmNvdW50ZXIgZHVyaW5nIGluaXRpYWwgcmVuZGVyIGNvdWxkIGxhdGVyIGNoYW5nZSBpbnRvIGEgY29tcG9uZW50XG4gICAgICAgIC8vIGRlZmluaXRpb24gb2JqZWN0IGF0IHVwZGF0ZSB0aW1lLiBUaGF0IGlzIGhhbmRsZWQgYnkgdGhlIFwibGF6eSBkZW9wdFwiXG4gICAgICAgIC8vIGNvZGUgb24gdGhlIHVwZGF0ZSBzaWRlIChzY3JvbGwgZG93biBmb3IgdGhlIG5leHQgYmlnIGJsb2NrIG9mIGNvbW1lbnQpLlxuICAgICAgICBsZXQgZHNsID0gbmV3IE9wY29kZUJ1aWxkZXJEU0wodGhpcy5zeW1ib2xUYWJsZSwgZW52KTtcbiAgICAgICAgZHNsLnB1dFZhbHVlKHRoaXMuZXhwcmVzc2lvbik7XG4gICAgICAgIGRzbC50ZXN0KElzQ29tcG9uZW50RGVmaW5pdGlvblJlZmVyZW5jZS5jcmVhdGUpO1xuICAgICAgICBkc2wubGFiZWxsZWQobnVsbCwgKGRzbCwgX0JFR0lOLCBFTkQpID0+IHtcbiAgICAgICAgICAgIGRzbC5qdW1wVW5sZXNzKCdWQUxVRScpO1xuICAgICAgICAgICAgZHNsLnB1dER5bmFtaWNDb21wb25lbnREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICBkc2wub3BlbkNvbXBvbmVudChDb21waWxlZEFyZ3MuZW1wdHkoKSk7XG4gICAgICAgICAgICBkc2wuY2xvc2VDb21wb25lbnQoKTtcbiAgICAgICAgICAgIGRzbC5qdW1wKEVORCk7XG4gICAgICAgICAgICBkc2wubGFiZWwoJ1ZBTFVFJyk7XG4gICAgICAgICAgICBkc2wuZHluYW1pY0NvbnRlbnQobmV3IHRoaXMuQXBwZW5kT3Bjb2RlKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGRlb3B0ZWQgPSB0aGlzLmRlb3B0ZWQgPSBkc2wudG9TbGljZSgpO1xuICAgICAgICAvLyBGcm9tIHRoaXMgcG9pbnQgb24sIHdlIGhhdmUgZXNzZW50aWFsbHkgcmVwbGFjZWQgb3Vyc2VsdmVzIHdpdGggYSBuZXcgc2V0XG4gICAgICAgIC8vIG9mIG9wY29kZXMuIFNpbmNlIHdlIHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGluZyB0aGUgbmV3L2Rlb3B0ZWQgY29kZSwgaXQnc1xuICAgICAgICAvLyBhIGdvb2QgaWRlYSAoYXMgYSBwYXR0ZXJuKSB0byBudWxsIG91dCBhbnkgdW5uZWVkZWQgZmllbGRzIGhlcmUgdG8gYXZvaWRcbiAgICAgICAgLy8gaG9sZGluZyBvbiB0byB1bm5lZWRlZC9zdGFsZSBvYmplY3RzOlxuICAgICAgICAvLyBRVUVTVElPTjogU2hvdWxkbid0IHRoaXMgd2hvbGUgb2JqZWN0IGJlIEdDZWQ/IElmIG5vdCwgd2h5IG5vdD9cbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGRlb3B0ZWQ7XG4gICAgfVxufVxuY2xhc3MgSXNDb21wb25lbnREZWZpbml0aW9uUmVmZXJlbmNlIGV4dGVuZHMgQ29uZGl0aW9uYWxSZWZlcmVuY2Uge1xuICAgIHN0YXRpYyBjcmVhdGUoaW5uZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJc0NvbXBvbmVudERlZmluaXRpb25SZWZlcmVuY2UoaW5uZXIpO1xuICAgIH1cbiAgICB0b0Jvb2wodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzQ29tcG9uZW50RGVmaW5pdGlvbih2YWx1ZSk7XG4gICAgfVxufVxuY2xhc3MgVXBkYXRlT3Bjb2RlIGV4dGVuZHMgVXBkYXRpbmdPcGNvZGUge1xuICAgIGNvbnN0cnVjdG9yKGNhY2hlLCBib3VuZHMsIHVwc2VydCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNhY2hlID0gY2FjaGU7XG4gICAgICAgIHRoaXMuYm91bmRzID0gYm91bmRzO1xuICAgICAgICB0aGlzLnVwc2VydCA9IHVwc2VydDtcbiAgICAgICAgdGhpcy50YWcgPSBjYWNoZS50YWc7XG4gICAgfVxuICAgIGV2YWx1YXRlKHZtKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuY2FjaGUucmV2YWxpZGF0ZSgpO1xuICAgICAgICBpZiAoaXNNb2RpZmllZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCB7IGJvdW5kcywgdXBzZXJ0IH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHsgZG9tIH0gPSB2bTtcbiAgICAgICAgICAgIGlmICghdGhpcy51cHNlcnQudXBkYXRlKGRvbSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBDdXJzb3IoYm91bmRzLnBhcmVudEVsZW1lbnQoKSwgY2xlYXIoYm91bmRzKSk7XG4gICAgICAgICAgICAgICAgdXBzZXJ0ID0gdGhpcy51cHNlcnQgPSB0aGlzLmluc2VydCh2bS5lbnYuZ2V0QXBwZW5kT3BlcmF0aW9ucygpLCBjdXJzb3IsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvdW5kcy51cGRhdGUodXBzZXJ0LmJvdW5kcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgeyBfZ3VpZDogZ3VpZCwgdHlwZSwgY2FjaGUgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBndWlkLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGRldGFpbHM6IHsgbGFzdFZhbHVlOiBKU09OLnN0cmluZ2lmeShjYWNoZS5wZWVrKCkpIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5jbGFzcyBHdWFyZGVkVXBkYXRlT3Bjb2RlIGV4dGVuZHMgVXBkYXRlT3Bjb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihyZWZlcmVuY2UsIGNhY2hlLCBib3VuZHMsIHVwc2VydCwgYXBwZW5kT3Bjb2RlLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjYWNoZSwgYm91bmRzLCB1cHNlcnQpO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZTtcbiAgICAgICAgdGhpcy5hcHBlbmRPcGNvZGUgPSBhcHBlbmRPcGNvZGU7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5kZW9wdGVkID0gbnVsbDtcbiAgICAgICAgdGhpcy50YWcgPSB0aGlzLl90YWcgPSBuZXcgVXBkYXRhYmxlVGFnKHRoaXMudGFnKTtcbiAgICB9XG4gICAgZXZhbHVhdGUodm0pIHtcbiAgICAgICAgaWYgKHRoaXMuZGVvcHRlZCkge1xuICAgICAgICAgICAgdm0uZXZhbHVhdGVPcGNvZGUodGhpcy5kZW9wdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc0NvbXBvbmVudERlZmluaXRpb24odGhpcy5yZWZlcmVuY2UudmFsdWUoKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhenlEZW9wdCh2bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdXBlci5ldmFsdWF0ZSh2bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGF6eURlb3B0KHZtKSB7XG4gICAgICAgIC8vIER1cmlnbiBpbml0aWFsIHJlbmRlciwgd2Uga25vdyB0aGF0IHRoZSByZWZlcmVuY2UgZG9lcyBub3QgY29udGFpbiBhXG4gICAgICAgIC8vIGNvbXBvbmVudCBkZWZpbml0aW9uLCBzbyB3ZSBvcHRpbWlzdGljYWxseSBhc3N1bWVkIHRoYXQgdGhpcyBhcHBlbmRcbiAgICAgICAgLy8gaXMganVzdCBhIG5vcm1hbCBhcHBlbmQuIEhvd2V2ZXIsIGF0IHVwZGF0ZSB0aW1lLCB3ZSBkaXNjb3ZlcmVkIHRoYXRcbiAgICAgICAgLy8gdGhlIHJlZmVyZW5jZSBoYXMgc3dpdGNoZWQgaW50byBjb250YWluaW5nIGEgY29tcG9uZW50IGRlZmluaXRpb24sIHNvXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZG8gYSBcImxhenkgZGVvcHRcIiwgc2ltdWxhdGluZyB3aGF0IHdvdWxkIGhhdmUgaGFwcGVuZWQgaWZcbiAgICAgICAgLy8gd2UgaGFkIGRlY2lkZWQgdG8gcGVyZm9ybSB0aGUgZGVvcHQgaW4gdGhlIGZpcnN0IHBsYWNlIGR1cmluZyBpbml0aWFsXG4gICAgICAgIC8vIHJlbmRlci5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTW9yZSBjb25jcmV0ZWx5LCB3ZSB3b3VsZCBoYXZlIGV4cGFuZGVkIHRoZSBjdXJseSBpbnRvIGEgaWYvZWxzZSwgYW5kXG4gICAgICAgIC8vIGJhc2VkIG9uIHdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgY29tcG9uZW50IGRlZmluaXRpb24gb3Igbm90LCB3ZSB3b3VsZFxuICAgICAgICAvLyBoYXZlIGVudGVyZWQgZWl0aGVyIHRoZSBkeW5hbWljIGNvbXBvbmVudCBicmFuY2ggb3IgdGhlIHNpbXBsZSB2YWx1ZVxuICAgICAgICAvLyBicmFuY2guXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNpbmNlIHdlIHJlbmRlcmVkIGEgc2ltcGxlIHZhbHVlIGR1cmluZyBpbml0aWFsIHJlbmRlciAoYW5kIGFsbCB0aGVcbiAgICAgICAgLy8gdXBkYXRlcyB1cCB1bnRpbCB0aGlzIHBvaW50KSwgd2UgbmVlZCB0byBwcmV0ZW5kIHRoYXQgdGhlIHJlc3VsdCBpc1xuICAgICAgICAvLyBwcm9kdWNlZCBieSB0aGUgXCJWQUxVRVwiIGJyYW5jaCBvZiB0aGUgZGVvcHRlZCBhcHBlbmQgb3Bjb2RlOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgIFRyeShCRUdJTiwgRU5EKVxuICAgICAgICAvLyAgICAgQXNzZXJ0KElzQ29tcG9uZW50RGVmaW5pdGlvbiwgZXhwZWN0ZWQ9ZmFsc2UpXG4gICAgICAgIC8vICAgICBPcHRpbWl6ZWRVcGRhdGVcbiAgICAgICAgLy9cbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCBiZWNhdXNlIHRoZSByZWZlcmVuY2UgaGFzIHN3aXRjaGVkIGZyb20gYmVpbmcgYSBzaW1wbGVcbiAgICAgICAgLy8gdmFsdWUgaW50byBhIGNvbXBvbmVudCBkZWZpbml0aW9uLCB3aGF0IHdvdWxkIGhhdmUgaGFwcGVuZWQgaXMgdGhhdFxuICAgICAgICAvLyB0aGUgYXNzZXJ0IHdvdWxkIHRocm93LCBjYXVzaW5nIHRoZSBUcnkgb3Bjb2RlIHRvIHRlYXJkb3duIHRoZSBib3VuZHNcbiAgICAgICAgLy8gYW5kIHJlcnVuIHRoZSBvcmlnaW5hbCBhcHBlbmQgb3Bjb2RlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBTaW5jZSB0aGUgVHJ5IG9wY29kZSB3b3VsZCBoYXZlIG51a2VkIHRoZSB1cGRhdGluZyBvcGNvZGVzIGFueXdheSwgd2VcbiAgICAgICAgLy8gd291bGRuJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCBzaW11bGF0aW5nIHRob3NlLiBBbGwgd2UgaGF2ZSB0byBkbyBpcyB0b1xuICAgICAgICAvLyBleGVjdXRlIHRoZSBUcnkgb3Bjb2RlIGFuZCBpbW1lZGlhdGVseSB0aHJvdy5cbiAgICAgICAgbGV0IHsgYm91bmRzLCBhcHBlbmRPcGNvZGUsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZW52ID0gdm0uZW52O1xuICAgICAgICBsZXQgc2xpY2UgPSBhcHBlbmRPcGNvZGUuZGVvcHQoZW52KTtcbiAgICAgICAgbGV0IGVudGVyID0gZXhwZWN0KGVudi5wcm9ncmFtLm9wY29kZShzbGljZVswXSArIDgpLCAnaGFyZGNvZGVkIGRlb3B0IGxvY2F0aW9uJyk7XG4gICAgICAgIGxldCBvcHMgPSB2bS5jb25zdGFudHMuZ2V0U2xpY2UoZW50ZXIub3AxKTtcbiAgICAgICAgbGV0IHRyYWNrZXIgPSBuZXcgVXBkYXRhYmxlQmxvY2tUcmFja2VyKGJvdW5kcy5wYXJlbnRFbGVtZW50KCkpO1xuICAgICAgICB0cmFja2VyLm5ld0JvdW5kcyh0aGlzLmJvdW5kcyk7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gICAgICAgIHN0YXRlLmZyYW1lWydjb25kaXRpb24nXSA9IElzQ29tcG9uZW50RGVmaW5pdGlvblJlZmVyZW5jZS5jcmVhdGUoZXhwZWN0KHN0YXRlLmZyYW1lWydvcGVyYW5kJ10sICdvcGVyYW5kIHNob3VsZCBiZSBwb3B1bGF0ZWQnKSk7XG4gICAgICAgIGxldCBkZW9wdGVkID0gdGhpcy5kZW9wdGVkID0gbmV3IFRyeU9wY29kZShvcHMsIHN0YXRlLCB0cmFja2VyLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMuX3RhZy51cGRhdGUoZGVvcHRlZC50YWcpO1xuICAgICAgICB2bS5ldmFsdWF0ZU9wY29kZShkZW9wdGVkKTtcbiAgICAgICAgdm0udGhyb3coKTtcbiAgICAgICAgLy8gRnJvbSB0aGlzIHBvaW50IG9uLCB3ZSBoYXZlIGVzc2VudGlhbGx5IHJlcGxhY2VkIG91cnNlbHZlIHdpdGggYSBuZXdcbiAgICAgICAgLy8gb3Bjb2RlLiBTaW5jZSB3ZSB3aWxsIGFsd2F5cyBiZSBleGVjdXRpbmcgdGhlIG5ldy9kZW9wdGVkIGNvZGUsIGl0J3MgYVxuICAgICAgICAvLyBnb29kIGlkZWEgKGFzIGEgcGF0dGVybikgdG8gbnVsbCBvdXQgYW55IHVubmVlZGVkIGZpZWxkcyBoZXJlIHRvIGF2b2lkXG4gICAgICAgIC8vIGhvbGRpbmcgb24gdG8gdW5uZWVkZWQvc3RhbGUgb2JqZWN0czpcbiAgICAgICAgLy8gUVVFU1RJT046IFNob3VsZG4ndCB0aGlzIHdob2xlIG9iamVjdCBiZSBHQ2VkPyBJZiBub3QsIHdoeSBub3Q/XG4gICAgICAgIHRoaXMuX3RhZyA9IG51bGw7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYm91bmRzID0gbnVsbDtcbiAgICAgICAgdGhpcy51cHNlcnQgPSBudWxsO1xuICAgICAgICB0aGlzLmFwcGVuZE9wY29kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCB7IF9ndWlkOiBndWlkLCB0eXBlLCBkZW9wdGVkIH0gPSB0aGlzO1xuICAgICAgICBpZiAoZGVvcHRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBndWlkLFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgZGVvcHRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW2Rlb3B0ZWQudG9KU09OKCldXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnRvSlNPTigpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE9wdGltaXplZENhdXRpb3VzQXBwZW5kT3Bjb2RlIGV4dGVuZHMgQXBwZW5kRHluYW1pY09wY29kZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdvcHRpbWl6ZWQtY2F1dGlvdXMtYXBwZW5kJztcbiAgICB9XG4gICAgbm9ybWFsaXplKHJlZmVyZW5jZSkge1xuICAgICAgICByZXR1cm4gbWFwKHJlZmVyZW5jZSwgbm9ybWFsaXplVmFsdWUpO1xuICAgIH1cbiAgICBpbnNlcnQoZG9tLCBjdXJzb3IsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYXV0aW91c0luc2VydChkb20sIGN1cnNvciwgdmFsdWUpO1xuICAgIH1cbiAgICB1cGRhdGVXaXRoKF92bSwgX3JlZmVyZW5jZSwgY2FjaGUsIGJvdW5kcywgdXBzZXJ0KSB7XG4gICAgICAgIHJldHVybiBuZXcgT3B0aW1pemVkQ2F1dGlvdXNVcGRhdGVPcGNvZGUoY2FjaGUsIGJvdW5kcywgdXBzZXJ0KTtcbiAgICB9XG59XG5jbGFzcyBPcHRpbWl6ZWRDYXV0aW91c1VwZGF0ZU9wY29kZSBleHRlbmRzIFVwZGF0ZU9wY29kZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdvcHRpbWl6ZWQtY2F1dGlvdXMtdXBkYXRlJztcbiAgICB9XG4gICAgaW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2F1dGlvdXNJbnNlcnQoZG9tLCBjdXJzb3IsIHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgR3VhcmRlZENhdXRpb3VzQXBwZW5kT3Bjb2RlIGV4dGVuZHMgR3VhcmRlZEFwcGVuZE9wY29kZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdndWFyZGVkLWNhdXRpb3VzLWFwcGVuZCc7XG4gICAgICAgIHRoaXMuQXBwZW5kT3Bjb2RlID0gT3B0aW1pemVkQ2F1dGlvdXNBcHBlbmRPcGNvZGU7XG4gICAgfVxuICAgIG5vcm1hbGl6ZShyZWZlcmVuY2UpIHtcbiAgICAgICAgcmV0dXJuIG1hcChyZWZlcmVuY2UsIG5vcm1hbGl6ZVZhbHVlKTtcbiAgICB9XG4gICAgaW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2F1dGlvdXNJbnNlcnQoZG9tLCBjdXJzb3IsIHZhbHVlKTtcbiAgICB9XG4gICAgdXBkYXRlV2l0aCh2bSwgcmVmZXJlbmNlLCBjYWNoZSwgYm91bmRzLCB1cHNlcnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHdWFyZGVkQ2F1dGlvdXNVcGRhdGVPcGNvZGUocmVmZXJlbmNlLCBjYWNoZSwgYm91bmRzLCB1cHNlcnQsIHRoaXMsIHZtLmNhcHR1cmUoKSk7XG4gICAgfVxufVxuY2xhc3MgR3VhcmRlZENhdXRpb3VzVXBkYXRlT3Bjb2RlIGV4dGVuZHMgR3VhcmRlZFVwZGF0ZU9wY29kZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdndWFyZGVkLWNhdXRpb3VzLXVwZGF0ZSc7XG4gICAgfVxuICAgIGluc2VydChkb20sIGN1cnNvciwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNhdXRpb3VzSW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE9wdGltaXplZFRydXN0aW5nQXBwZW5kT3Bjb2RlIGV4dGVuZHMgQXBwZW5kRHluYW1pY09wY29kZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdvcHRpbWl6ZWQtdHJ1c3RpbmctYXBwZW5kJztcbiAgICB9XG4gICAgbm9ybWFsaXplKHJlZmVyZW5jZSkge1xuICAgICAgICByZXR1cm4gbWFwKHJlZmVyZW5jZSwgbm9ybWFsaXplVHJ1c3RlZFZhbHVlKTtcbiAgICB9XG4gICAgaW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHJ1c3RpbmdJbnNlcnQoZG9tLCBjdXJzb3IsIHZhbHVlKTtcbiAgICB9XG4gICAgdXBkYXRlV2l0aChfdm0sIF9yZWZlcmVuY2UsIGNhY2hlLCBib3VuZHMsIHVwc2VydCkge1xuICAgICAgICByZXR1cm4gbmV3IE9wdGltaXplZFRydXN0aW5nVXBkYXRlT3Bjb2RlKGNhY2hlLCBib3VuZHMsIHVwc2VydCk7XG4gICAgfVxufVxuY2xhc3MgT3B0aW1pemVkVHJ1c3RpbmdVcGRhdGVPcGNvZGUgZXh0ZW5kcyBVcGRhdGVPcGNvZGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnb3B0aW1pemVkLXRydXN0aW5nLXVwZGF0ZSc7XG4gICAgfVxuICAgIGluc2VydChkb20sIGN1cnNvciwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRydXN0aW5nSW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEd1YXJkZWRUcnVzdGluZ0FwcGVuZE9wY29kZSBleHRlbmRzIEd1YXJkZWRBcHBlbmRPcGNvZGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZ3VhcmRlZC10cnVzdGluZy1hcHBlbmQnO1xuICAgICAgICB0aGlzLkFwcGVuZE9wY29kZSA9IE9wdGltaXplZFRydXN0aW5nQXBwZW5kT3Bjb2RlO1xuICAgIH1cbiAgICBub3JtYWxpemUocmVmZXJlbmNlKSB7XG4gICAgICAgIHJldHVybiBtYXAocmVmZXJlbmNlLCBub3JtYWxpemVUcnVzdGVkVmFsdWUpO1xuICAgIH1cbiAgICBpbnNlcnQoZG9tLCBjdXJzb3IsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0cnVzdGluZ0luc2VydChkb20sIGN1cnNvciwgdmFsdWUpO1xuICAgIH1cbiAgICB1cGRhdGVXaXRoKHZtLCByZWZlcmVuY2UsIGNhY2hlLCBib3VuZHMsIHVwc2VydCkge1xuICAgICAgICByZXR1cm4gbmV3IEd1YXJkZWRUcnVzdGluZ1VwZGF0ZU9wY29kZShyZWZlcmVuY2UsIGNhY2hlLCBib3VuZHMsIHVwc2VydCwgdGhpcywgdm0uY2FwdHVyZSgpKTtcbiAgICB9XG59XG5jbGFzcyBHdWFyZGVkVHJ1c3RpbmdVcGRhdGVPcGNvZGUgZXh0ZW5kcyBHdWFyZGVkVXBkYXRlT3Bjb2RlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3RydXN0aW5nLXVwZGF0ZSc7XG4gICAgfVxuICAgIGluc2VydChkb20sIGN1cnNvciwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRydXN0aW5nSW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSk7XG4gICAgfVxufVxuIl19