enifed('@glimmer/runtime/lib/vm/update', ['exports', '@glimmer/runtime/lib/bounds', '@glimmer/runtime/lib/builder', '@glimmer/util', '@glimmer/reference', '@glimmer/runtime/lib/compiled/expressions/args', '@glimmer/runtime/lib/opcodes', '@glimmer/runtime/lib/vm/append'], function (exports, _glimmerRuntimeLibBounds, _glimmerRuntimeLibBuilder, _glimmerUtil, _glimmerReference, _glimmerRuntimeLibCompiledExpressionsArgs, _glimmerRuntimeLibOpcodes, _glimmerRuntimeLibVmAppend) {
    'use strict';

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var UpdatingVM = (function () {
        function UpdatingVM(env, _ref) {
            var _ref$alwaysRevalidate = _ref.alwaysRevalidate;
            var alwaysRevalidate = _ref$alwaysRevalidate === undefined ? false : _ref$alwaysRevalidate;

            _classCallCheck(this, UpdatingVM);

            this.frameStack = new _glimmerUtil.Stack();
            this.env = env;
            this.constants = env.constants;
            this.dom = env.getDOM();
            this.alwaysRevalidate = alwaysRevalidate;
        }

        UpdatingVM.prototype.execute = function execute(opcodes, handler) {
            var frameStack = this.frameStack;

            this.try(opcodes, handler);
            while (true) {
                if (frameStack.isEmpty()) break;
                var opcode = this.frame.nextStatement();
                if (opcode === null) {
                    this.frameStack.pop();
                    continue;
                }
                _glimmerUtil.LOGGER.debug('[VM] OP ' + opcode.type);
                _glimmerUtil.LOGGER.trace(opcode);
                opcode.evaluate(this);
            }
        };

        UpdatingVM.prototype.goto = function goto(op) {
            this.frame.goto(op);
        };

        UpdatingVM.prototype.try = function _try(ops, handler) {
            this.frameStack.push(new UpdatingVMFrame(this, ops, handler));
        };

        UpdatingVM.prototype.throw = function _throw() {
            this.frame.handleException();
            this.frameStack.pop();
        };

        UpdatingVM.prototype.evaluateOpcode = function evaluateOpcode(opcode) {
            opcode.evaluate(this);
        };

        _createClass(UpdatingVM, [{
            key: 'frame',
            get: function () {
                return _glimmerUtil.expect(this.frameStack.current, 'bug: expected a frame');
            }
        }]);

        return UpdatingVM;
    })();

    exports.default = UpdatingVM;

    var BlockOpcode = (function (_UpdatingOpcode) {
        _inherits(BlockOpcode, _UpdatingOpcode);

        function BlockOpcode(ops, state, bounds, children) {
            _classCallCheck(this, BlockOpcode);

            _UpdatingOpcode.call(this);
            this.ops = ops;
            this.type = "block";
            this.next = null;
            this.prev = null;
            var env = state.env;
            var scope = state.scope;
            var dynamicScope = state.dynamicScope;
            var frame = state.frame;

            this.children = children;
            this.env = env;
            this.scope = scope;
            this.dynamicScope = dynamicScope;
            this.frame = frame;
            this.bounds = bounds;
        }

        BlockOpcode.prototype.parentElement = function parentElement() {
            return this.bounds.parentElement();
        };

        BlockOpcode.prototype.firstNode = function firstNode() {
            return this.bounds.firstNode();
        };

        BlockOpcode.prototype.lastNode = function lastNode() {
            return this.bounds.lastNode();
        };

        BlockOpcode.prototype.evaluate = function evaluate(vm) {
            vm.try(this.children, null);
        };

        BlockOpcode.prototype.destroy = function destroy() {
            this.bounds.destroy();
        };

        BlockOpcode.prototype.didDestroy = function didDestroy() {
            this.env.didDestroy(this.bounds);
        };

        BlockOpcode.prototype.toJSON = function toJSON() {
            var details = _glimmerUtil.dict();
            details["guid"] = '' + this._guid;
            return {
                guid: this._guid,
                type: this.type,
                details: details,
                children: this.children.toArray().map(function (op) {
                    return op.toJSON();
                })
            };
        };

        return BlockOpcode;
    })(_glimmerRuntimeLibOpcodes.UpdatingOpcode);

    exports.BlockOpcode = BlockOpcode;

    var TryOpcode = (function (_BlockOpcode) {
        _inherits(TryOpcode, _BlockOpcode);

        function TryOpcode(ops, state, bounds, children) {
            _classCallCheck(this, TryOpcode);

            _BlockOpcode.call(this, ops, state, bounds, children);
            this.type = "try";
            this.tag = this._tag = new _glimmerReference.UpdatableTag(_glimmerReference.CONSTANT_TAG);
        }

        TryOpcode.prototype.didInitializeChildren = function didInitializeChildren() {
            this._tag.update(_glimmerReference.combineSlice(this.children));
        };

        TryOpcode.prototype.evaluate = function evaluate(vm) {
            vm.try(this.children, this);
        };

        TryOpcode.prototype.handleException = function handleException() {
            var env = this.env;
            var scope = this.scope;
            var ops = this.ops;
            var dynamicScope = this.dynamicScope;
            var frame = this.frame;

            var elementStack = _glimmerRuntimeLibBuilder.ElementStack.resume(this.env, this.bounds, this.bounds.reset(env));
            var vm = new _glimmerRuntimeLibVmAppend.default(env, scope, dynamicScope, elementStack);
            var result = vm.resume(ops, frame);
            this.children = result.opcodes();
            this.didInitializeChildren();
        };

        TryOpcode.prototype.toJSON = function toJSON() {
            var json = _BlockOpcode.prototype.toJSON.call(this);
            var details = json["details"];
            if (!details) {
                details = json["details"] = {};
            }
            return _BlockOpcode.prototype.toJSON.call(this);
        };

        return TryOpcode;
    })(BlockOpcode);

    exports.TryOpcode = TryOpcode;

    var ListRevalidationDelegate = (function () {
        function ListRevalidationDelegate(opcode, marker) {
            _classCallCheck(this, ListRevalidationDelegate);

            this.opcode = opcode;
            this.marker = marker;
            this.didInsert = false;
            this.didDelete = false;
            this.map = opcode.map;
            this.updating = opcode['children'];
        }

        ListRevalidationDelegate.prototype.insert = function insert(key, item, memo, before) {
            var map = this.map;
            var opcode = this.opcode;
            var updating = this.updating;

            var nextSibling = null;
            var reference = null;
            if (before) {
                reference = map[before];
                nextSibling = reference['bounds'].firstNode();
            } else {
                nextSibling = this.marker;
            }
            var vm = opcode.vmForInsertion(nextSibling);
            var tryOpcode = null;
            vm.execute(opcode.ops, function (vm) {
                vm.frame.setArgs(_glimmerRuntimeLibCompiledExpressionsArgs.EvaluatedArgs.positional([item, memo]));
                vm.frame.setOperand(item);
                vm.frame.setCondition(new _glimmerReference.ConstReference(true));
                vm.frame.setKey(key);
                var state = vm.capture();
                var tracker = vm.stack().pushUpdatableBlock();
                tryOpcode = new TryOpcode(opcode.ops, state, tracker, vm.updating());
            });
            tryOpcode.didInitializeChildren();
            updating.insertBefore(tryOpcode, reference);
            map[key] = tryOpcode;
            this.didInsert = true;
        };

        ListRevalidationDelegate.prototype.retain = function retain(_key, _item, _memo) {};

        ListRevalidationDelegate.prototype.move = function move(key, _item, _memo, before) {
            var map = this.map;
            var updating = this.updating;

            var entry = map[key];
            var reference = map[before] || null;
            if (before) {
                _glimmerRuntimeLibBounds.move(entry, reference.firstNode());
            } else {
                _glimmerRuntimeLibBounds.move(entry, this.marker);
            }
            updating.remove(entry);
            updating.insertBefore(entry, reference);
        };

        ListRevalidationDelegate.prototype.delete = function _delete(key) {
            var map = this.map;

            var opcode = map[key];
            opcode.didDestroy();
            _glimmerRuntimeLibBounds.clear(opcode);
            this.updating.remove(opcode);
            delete map[key];
            this.didDelete = true;
        };

        ListRevalidationDelegate.prototype.done = function done() {
            this.opcode.didInitializeChildren(this.didInsert || this.didDelete);
        };

        return ListRevalidationDelegate;
    })();

    var ListBlockOpcode = (function (_BlockOpcode2) {
        _inherits(ListBlockOpcode, _BlockOpcode2);

        function ListBlockOpcode(ops, state, bounds, children, artifacts) {
            _classCallCheck(this, ListBlockOpcode);

            _BlockOpcode2.call(this, ops, state, bounds, children);
            this.type = "list-block";
            this.map = _glimmerUtil.dict();
            this.lastIterated = _glimmerReference.INITIAL;
            this.artifacts = artifacts;
            var _tag = this._tag = new _glimmerReference.UpdatableTag(_glimmerReference.CONSTANT_TAG);
            this.tag = _glimmerReference.combine([artifacts.tag, _tag]);
        }

        ListBlockOpcode.prototype.didInitializeChildren = function didInitializeChildren() {
            var listDidChange = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

            this.lastIterated = this.artifacts.tag.value();
            if (listDidChange) {
                this._tag.update(_glimmerReference.combineSlice(this.children));
            }
        };

        ListBlockOpcode.prototype.evaluate = function evaluate(vm) {
            var artifacts = this.artifacts;
            var lastIterated = this.lastIterated;

            if (!artifacts.tag.validate(lastIterated)) {
                var bounds = this.bounds;
                var dom = vm.dom;

                var marker = dom.createComment('');
                dom.insertAfter(bounds.parentElement(), marker, _glimmerUtil.expect(bounds.lastNode(), "can't insert after an empty bounds"));
                var target = new ListRevalidationDelegate(this, marker);
                var synchronizer = new _glimmerReference.IteratorSynchronizer({ target: target, artifacts: artifacts });
                synchronizer.sync();
                this.parentElement().removeChild(marker);
            }
            // Run now-updated updating opcodes
            _BlockOpcode2.prototype.evaluate.call(this, vm);
        };

        ListBlockOpcode.prototype.vmForInsertion = function vmForInsertion(nextSibling) {
            var env = this.env;
            var scope = this.scope;
            var dynamicScope = this.dynamicScope;

            var elementStack = _glimmerRuntimeLibBuilder.ElementStack.forInitialRender(this.env, this.bounds.parentElement(), nextSibling);
            return new _glimmerRuntimeLibVmAppend.default(env, scope, dynamicScope, elementStack);
        };

        ListBlockOpcode.prototype.toJSON = function toJSON() {
            var json = _BlockOpcode2.prototype.toJSON.call(this);
            var map = this.map;
            var inner = Object.keys(map).map(function (key) {
                return JSON.stringify(key) + ': ' + map[key]._guid;
            }).join(", ");
            var details = json["details"];
            if (!details) {
                details = json["details"] = {};
            }
            details["map"] = '{' + inner + '}';
            return json;
        };

        return ListBlockOpcode;
    })(BlockOpcode);

    exports.ListBlockOpcode = ListBlockOpcode;

    var UpdatingVMFrame = (function () {
        function UpdatingVMFrame(vm, ops, exceptionHandler) {
            _classCallCheck(this, UpdatingVMFrame);

            this.vm = vm;
            this.ops = ops;
            this.exceptionHandler = exceptionHandler;
            this.vm = vm;
            this.ops = ops;
            this.current = ops.head();
        }

        UpdatingVMFrame.prototype.goto = function goto(op) {
            this.current = op;
        };

        UpdatingVMFrame.prototype.nextStatement = function nextStatement() {
            var current = this.current;
            var ops = this.ops;

            if (current) this.current = ops.nextNode(current);
            return current;
        };

        UpdatingVMFrame.prototype.handleException = function handleException() {
            if (this.exceptionHandler) {
                this.exceptionHandler.handleException();
            }
        };

        return UpdatingVMFrame;
    })();
});

// Tags
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkBnbGltbWVyL3J1bnRpbWUvbGliL3ZtL3VwZGF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztRQTJCYyxVQUFBO0FBUVosaUJBUlksVUFBQSxDQVFBLEdBQWdCLEVBQUUsSUFBNEIsRUFBQTt3Q0FBNUIsSUFBNEIsQ0FBMUIsZ0JBQWdCO2dCQUFoQixnQkFBZ0IseUNBQUcsS0FBSzs7a0NBUjVDLFVBQUE7O0FBTUosZ0JBQUEsQ0FBQSxVQUFVLEdBQTJCLGlCQTlCZCxLQUFLLEVBOEJxQyxDQUFDO0FBR3hFLGdCQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUNmLGdCQUFJLENBQUMsU0FBUyxHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUM7QUFDL0IsZ0JBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQ3hCLGdCQUFJLENBQUMsZ0JBQWdCLEdBQUcsZ0JBQWdCLENBQUM7U0FDMUM7O0FBYlcsa0JBQUEsV0FlWixPQUFPLEdBQUEsaUJBQUMsT0FBc0IsRUFBRSxPQUF5QixFQUFBO2dCQUNqRCxVQUFVLEdBQUssSUFBSSxDQUFuQixVQUFVOztBQUVoQixnQkFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFFM0IsbUJBQU8sSUFBSSxFQUFFO0FBQ1gsb0JBQUksVUFBVSxDQUFDLE9BQU8sRUFBRSxFQUFFLE1BQU07QUFFaEMsb0JBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxFQUFFLENBQUM7QUFFeEMsb0JBQUksTUFBTSxLQUFLLElBQUksRUFBRTtBQUNuQix3QkFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUN0Qiw2QkFBUztpQkFDVjtBQUVELDZCQXRERyxNQUFNLENBc0RGLEtBQUssY0FBWSxNQUFNLENBQUMsSUFBSSxDQUFHLENBQUM7QUFDdkMsNkJBdkRHLE1BQU0sQ0F1REYsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBRXJCLHNCQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3ZCO1NBQ0Y7O0FBbkNXLGtCQUFBLFdBeUNaLElBQUksR0FBQSxjQUFDLEVBQWtCLEVBQUE7QUFDckIsZ0JBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ3JCOztBQTNDVyxrQkFBQSxXQTZDWixHQUFHLEdBQUEsY0FBQyxHQUFrQixFQUFFLE9BQWlDLEVBQUE7QUFDdkQsZ0JBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksZUFBZSxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztTQUMvRDs7QUEvQ1csa0JBQUEsV0FpRFosS0FBSyxHQUFBLGtCQUFBO0FBQ0gsZ0JBQUksQ0FBQyxLQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7QUFDN0IsZ0JBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDdkI7O0FBcERXLGtCQUFBLFdBc0RaLGNBQWMsR0FBQSx3QkFBQyxNQUFzQixFQUFBO0FBQ25DLGtCQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3ZCOztxQkF4RFcsVUFBQTs7aUJBcUNLLFlBQUE7QUFDZix1QkFBTyxhQTlEcUQsTUFBTSxDQThEcEQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsdUJBQXVCLENBQUMsQ0FBQzthQUNqRTs7O2VBdkNXLFVBQUE7OztzQkFBQSxVQUFBOztRQXNFUixXQUE0QjtrQkFBNUIsV0FBNEI7O0FBWWhDLGlCQVpJLFdBQTRCLENBWWIsR0FBVSxFQUFFLEtBQWMsRUFBRSxNQUF5QixFQUFFLFFBQW9DLEVBQUE7a0NBWjFHLFdBQTRCOztBQWE5QixzQ0FBTyxDQUFDO0FBRFMsZ0JBQUEsQ0FBQSxHQUFHLEdBQUgsR0FBRyxDQUFPO0FBWHRCLGdCQUFBLENBQUEsSUFBSSxHQUFHLE9BQU8sQ0FBQztBQUNmLGdCQUFBLENBQUEsSUFBSSxHQUFHLElBQUksQ0FBQztBQUNaLGdCQUFBLENBQUEsSUFBSSxHQUFHLElBQUksQ0FBQztnQkFXWCxHQUFHLEdBQWlDLEtBQUssQ0FBekMsR0FBRztnQkFBRSxLQUFLLEdBQTBCLEtBQUssQ0FBcEMsS0FBSztnQkFBRSxZQUFZLEdBQVksS0FBSyxDQUE3QixZQUFZO2dCQUFFLEtBQUssR0FBSyxLQUFLLENBQWYsS0FBSzs7QUFDckMsZ0JBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0FBQ3pCLGdCQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUNmLGdCQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUNuQixnQkFBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7QUFDakMsZ0JBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ25CLGdCQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztTQUN0Qjs7QUFyQkcsbUJBQTRCLFdBeUJoQyxhQUFhLEdBQUEseUJBQUE7QUFDWCxtQkFBTyxJQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRSxDQUFDO1NBQ3BDOztBQTNCRyxtQkFBNEIsV0E2QmhDLFNBQVMsR0FBQSxxQkFBQTtBQUNQLG1CQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLENBQUM7U0FDaEM7O0FBL0JHLG1CQUE0QixXQWlDaEMsUUFBUSxHQUFBLG9CQUFBO0FBQ04sbUJBQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztTQUMvQjs7QUFuQ0csbUJBQTRCLFdBcUNoQyxRQUFRLEdBQUEsa0JBQUMsRUFBYyxFQUFBO0FBQ3JCLGNBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUM3Qjs7QUF2Q0csbUJBQTRCLFdBeUNoQyxPQUFPLEdBQUEsbUJBQUE7QUFDTCxnQkFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUN2Qjs7QUEzQ0csbUJBQTRCLFdBNkNoQyxVQUFVLEdBQUEsc0JBQUE7QUFDUixnQkFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ2xDOztBQS9DRyxtQkFBNEIsV0FpRGhDLE1BQU0sR0FBQSxrQkFBQTtBQUNKLGdCQUFJLE9BQU8sR0FBRyxhQWhKd0MsSUFBSSxFQWdKOUIsQ0FBQztBQUU3QixtQkFBTyxDQUFDLE1BQU0sQ0FBQyxRQUFNLElBQUksQ0FBQyxLQUFLLEFBQUUsQ0FBQztBQUVsQyxtQkFBTztBQUNMLG9CQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUs7QUFDaEIsb0JBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtBQUNmLHVCQUFPLEVBQVAsT0FBTztBQUNQLHdCQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLENBQUMsVUFBQSxFQUFFOzJCQUFJLEVBQUUsQ0FBQyxNQUFNLEVBQUU7aUJBQUEsQ0FBQzthQUN6RCxDQUFDO1NBQ0g7O2VBNURHLFdBQTRCO2lDQTdFRixjQUFjOzs7O1FBNEl4QyxTQUFpQjtrQkFBakIsU0FBaUI7O0FBT3JCLGlCQVBJLFNBQWlCLENBT1QsR0FBVSxFQUFFLEtBQWMsRUFBRSxNQUF3QixFQUFFLFFBQW9DLEVBQUE7a0NBUGxHLFNBQWlCOztBQVFuQixvQ0FBTSxHQUFHLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztBQVAvQixnQkFBQSxDQUFBLElBQUksR0FBRyxLQUFLLENBQUM7QUFRbEIsZ0JBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxzQkEzSnpCLFlBQVksbUJBRVosWUFBWSxDQXlKMkMsQ0FBQztTQUN2RDs7QUFWRyxpQkFBaUIsV0FZckIscUJBQXFCLEdBQUEsaUNBQUE7QUFDbkIsZ0JBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGtCQTlKbkIsWUFBWSxDQThKb0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7U0FDL0M7O0FBZEcsaUJBQWlCLFdBZ0JyQixRQUFRLEdBQUEsa0JBQUMsRUFBYyxFQUFBO0FBQ3JCLGNBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUM3Qjs7QUFsQkcsaUJBQWlCLFdBb0JyQixlQUFlLEdBQUEsMkJBQUE7Z0JBQ1AsR0FBRyxHQUFzQyxJQUFJLENBQTdDLEdBQUc7Z0JBQUUsS0FBSyxHQUErQixJQUFJLENBQXhDLEtBQUs7Z0JBQUUsR0FBRyxHQUEwQixJQUFJLENBQWpDLEdBQUc7Z0JBQUUsWUFBWSxHQUFZLElBQUksQ0FBNUIsWUFBWTtnQkFBRSxLQUFLLEdBQUssSUFBSSxDQUFkLEtBQUs7O0FBRTFDLGdCQUFJLFlBQVksR0FBRywwQkFyTGQsWUFBWSxDQXFMZSxNQUFNLENBQ3BDLElBQUksQ0FBQyxHQUFHLEVBQ1IsSUFBSSxDQUFDLE1BQU0sRUFDWCxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FDdkIsQ0FBQztBQUVGLGdCQUFJLEVBQUUsR0FBRyx1Q0FBTyxHQUFHLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxZQUFZLENBQUMsQ0FBQztBQUN4RCxnQkFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFFbkMsZ0JBQUksQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ2pDLGdCQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQztTQUM5Qjs7QUFsQ0csaUJBQWlCLFdBb0NyQixNQUFNLEdBQUEsa0JBQUE7QUFDSixnQkFBSSxJQUFJLEdBQUcsdUJBQU0sTUFBTSxLQUFBLE1BQUUsQ0FBQztBQUUxQixnQkFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQzlCLGdCQUFJLENBQUMsT0FBTyxFQUFFO0FBQ1osdUJBQU8sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDO2FBQ2hDO0FBRUQsbUJBQU8sdUJBQU0sTUFBTSxLQUFBLE1BQUUsQ0FBQztTQUN2Qjs7ZUE3Q0csU0FBaUI7T0FBUSxXQUFXOzs7O1FBZ0QxQyx3QkFBQTtBQU9FLGlCQVBGLHdCQUFBLENBT3NCLE1BQXVCLEVBQVUsTUFBc0IsRUFBQTtrQ0FQN0Usd0JBQUE7O0FBT3NCLGdCQUFBLENBQUEsTUFBTSxHQUFOLE1BQU0sQ0FBaUI7QUFBVSxnQkFBQSxDQUFBLE1BQU0sR0FBTixNQUFNLENBQWdCO0FBSG5FLGdCQUFBLENBQUEsU0FBUyxHQUFHLEtBQUssQ0FBQztBQUNsQixnQkFBQSxDQUFBLFNBQVMsR0FBRyxLQUFLLENBQUM7QUFHeEIsZ0JBQUksQ0FBQyxHQUFHLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQztBQUN0QixnQkFBSSxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDcEM7O0FBVkgsZ0NBQUEsV0FZRSxNQUFNLEdBQUEsZ0JBQUMsR0FBVyxFQUFFLElBQTJCLEVBQUUsSUFBMkIsRUFBRSxNQUFjLEVBQUE7Z0JBQ3BGLEdBQUcsR0FBdUIsSUFBSSxDQUE5QixHQUFHO2dCQUFFLE1BQU0sR0FBZSxJQUFJLENBQXpCLE1BQU07Z0JBQUUsUUFBUSxHQUFLLElBQUksQ0FBakIsUUFBUTs7QUFDM0IsZ0JBQUksV0FBVyxHQUF3QixJQUFJLENBQUM7QUFDNUMsZ0JBQUksU0FBUyxHQUF3QixJQUFJLENBQUM7QUFFMUMsZ0JBQUksTUFBTSxFQUFFO0FBQ1YseUJBQVMsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDeEIsMkJBQVcsR0FBRyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUMsU0FBUyxFQUFFLENBQUM7YUFDL0MsTUFBTTtBQUNMLDJCQUFXLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQzthQUMzQjtBQUVELGdCQUFJLEVBQUUsR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQzVDLGdCQUFJLFNBQVMsR0FBc0IsSUFBSSxDQUFDO0FBRXhDLGNBQUUsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxVQUFBLEVBQUUsRUFBQTtBQUN2QixrQkFBRSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsMENBek5kLGFBQWEsQ0F5TmUsVUFBVSxDQUFDLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN6RCxrQkFBRSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDMUIsa0JBQUUsQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLHNCQXpPMUIsY0FBYyxDQXlPK0IsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUNoRCxrQkFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7QUFFckIsb0JBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUN6QixvQkFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLGtCQUFrQixFQUFFLENBQUM7QUFFOUMseUJBQVMsR0FBRyxJQUFJLFNBQVMsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7YUFDdEUsQ0FBQyxDQUFDO0FBRUgscUJBQVUsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO0FBRW5DLG9CQUFRLENBQUMsWUFBWSxDQUFDLFNBQVUsRUFBRSxTQUFTLENBQUMsQ0FBQztBQUU3QyxlQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsU0FBVSxDQUFDO0FBRXRCLGdCQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztTQUN2Qjs7QUE5Q0gsZ0NBQUEsV0FnREUsTUFBTSxHQUFBLGdCQUFDLElBQVksRUFBRSxLQUE0QixFQUFFLEtBQTRCLEVBQUEsRUFDOUU7O0FBakRILGdDQUFBLFdBbURFLElBQUksR0FBQSxjQUFDLEdBQVcsRUFBRSxLQUE0QixFQUFFLEtBQTRCLEVBQUUsTUFBYyxFQUFBO2dCQUNwRixHQUFHLEdBQWUsSUFBSSxDQUF0QixHQUFHO2dCQUFFLFFBQVEsR0FBSyxJQUFJLENBQWpCLFFBQVE7O0FBRW5CLGdCQUFJLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDckIsZ0JBQUksU0FBUyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUM7QUFFcEMsZ0JBQUksTUFBTSxFQUFFO0FBQ1YseUNBelE2QixJQUFJLENBeVF0QixLQUFLLEVBQUUsU0FBUyxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7YUFDMUMsTUFBTTtBQUNMLHlDQTNRNkIsSUFBSSxDQTJRdEIsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUNoQztBQUVELG9CQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3ZCLG9CQUFRLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsQ0FBQztTQUN6Qzs7QUFqRUgsZ0NBQUEsV0FtRUUsTUFBTSxHQUFBLGlCQUFDLEdBQVcsRUFBQTtnQkFDVixHQUFHLEdBQUssSUFBSSxDQUFaLEdBQUc7O0FBQ1QsZ0JBQUksTUFBTSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN0QixrQkFBTSxDQUFDLFVBQVUsRUFBRSxDQUFDO0FBQ3BCLHFDQXRSd0IsS0FBSyxDQXNSdkIsTUFBTSxDQUFDLENBQUM7QUFDZCxnQkFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDN0IsbUJBQU8sR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBRWhCLGdCQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztTQUN2Qjs7QUE1RUgsZ0NBQUEsV0E4RUUsSUFBSSxHQUFBLGdCQUFBO0FBQ0YsZ0JBQUksQ0FBQyxNQUFNLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDckU7O2VBaEZILHdCQUFBOzs7UUFtRk0sZUFBdUI7a0JBQXZCLGVBQXVCOztBQVEzQixpQkFSSSxlQUF1QixDQVFmLEdBQVUsRUFBRSxLQUFjLEVBQUUsTUFBZSxFQUFFLFFBQW9DLEVBQUUsU0FBNkIsRUFBQTtrQ0FSeEgsZUFBdUI7O0FBU3pCLHFDQUFNLEdBQUcsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBUi9CLGdCQUFBLENBQUEsSUFBSSxHQUFHLFlBQVksQ0FBQztBQUNwQixnQkFBQSxDQUFBLEdBQUcsR0FBRyxhQWxTMkMsSUFBSSxFQWtTNUIsQ0FBQztBQUd6QixnQkFBQSxDQUFBLFlBQVkscUJBdlJwQixPQUFPLEFBdVJpQyxDQUFDO0FBS3ZDLGdCQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztBQUMzQixnQkFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxzQkFoU3pCLFlBQVksbUJBRVosWUFBWSxDQThSMkMsQ0FBQztBQUN0RCxnQkFBSSxDQUFDLEdBQUcsR0FBRyxrQkFuU2IsT0FBTyxDQW1TYyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztTQUMzQzs7QUFiRyx1QkFBdUIsV0FlM0IscUJBQXFCLEdBQUEsaUNBQXFCO2dCQUFwQixhQUFhLHlEQUFHLElBQUk7O0FBQ3hDLGdCQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDO0FBRS9DLGdCQUFJLGFBQWEsRUFBRTtBQUNqQixvQkFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsa0JBdlNyQixZQUFZLENBdVNzQixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQzthQUMvQztTQUNGOztBQXJCRyx1QkFBdUIsV0F1QjNCLFFBQVEsR0FBQSxrQkFBQyxFQUFjLEVBQUE7Z0JBQ2YsU0FBUyxHQUFtQixJQUFJLENBQWhDLFNBQVM7Z0JBQUUsWUFBWSxHQUFLLElBQUksQ0FBckIsWUFBWTs7QUFFN0IsZ0JBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsRUFBRTtvQkFDbkMsTUFBTSxHQUFLLElBQUksQ0FBZixNQUFNO29CQUNOLEdBQUcsR0FBSyxFQUFFLENBQVYsR0FBRzs7QUFFVCxvQkFBSSxNQUFNLEdBQUcsR0FBRyxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNuQyxtQkFBRyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsYUFBYSxFQUFFLEVBQUUsTUFBTSxFQUFFLGFBL1RVLE1BQU0sQ0ErVFQsTUFBTSxDQUFDLFFBQVEsRUFBRSxFQUFFLG9DQUFvQyxDQUFDLENBQUMsQ0FBQztBQUVqSCxvQkFBSSxNQUFNLEdBQUcsSUFBSSx3QkFBd0IsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDeEQsb0JBQUksWUFBWSxHQUFHLHNCQTdUdkIsb0JBQW9CLENBNlQ0QixFQUFFLE1BQU0sRUFBTixNQUFNLEVBQUUsU0FBUyxFQUFULFNBQVMsRUFBRSxDQUFDLENBQUM7QUFFbkUsNEJBQVksQ0FBQyxJQUFJLEVBQUUsQ0FBQztBQUVwQixvQkFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUMxQzs7QUFHRCxvQ0FBTSxRQUFRLEtBQUEsT0FBQyxFQUFFLENBQUMsQ0FBQztTQUNwQjs7QUEzQ0csdUJBQXVCLFdBNkMzQixjQUFjLEdBQUEsd0JBQUMsV0FBZ0MsRUFBQTtnQkFDdkMsR0FBRyxHQUEwQixJQUFJLENBQWpDLEdBQUc7Z0JBQUUsS0FBSyxHQUFtQixJQUFJLENBQTVCLEtBQUs7Z0JBQUUsWUFBWSxHQUFLLElBQUksQ0FBckIsWUFBWTs7QUFFOUIsZ0JBQUksWUFBWSxHQUFHLDBCQWpWZCxZQUFZLENBaVZlLGdCQUFnQixDQUM5QyxJQUFJLENBQUMsR0FBRyxFQUNSLElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxFQUFFLEVBQzNCLFdBQVcsQ0FDWixDQUFDO0FBRUYsbUJBQU8sdUNBQU8sR0FBRyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsWUFBWSxDQUFDLENBQUM7U0FDdkQ7O0FBdkRHLHVCQUF1QixXQXlEM0IsTUFBTSxHQUFBLGtCQUFBO0FBQ0osZ0JBQUksSUFBSSxHQUFHLHdCQUFNLE1BQU0sS0FBQSxNQUFFLENBQUM7QUFDMUIsZ0JBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7QUFFbkIsZ0JBQUksS0FBSyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQUEsR0FBRyxFQUFBO0FBQ2xDLHVCQUFVLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFVBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBRzthQUNwRCxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBRWQsZ0JBQUksT0FBTyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUM5QixnQkFBSSxDQUFDLE9BQU8sRUFBRTtBQUNaLHVCQUFPLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQzthQUNoQztBQUVELG1CQUFPLENBQUMsS0FBSyxDQUFDLFNBQU8sS0FBSyxNQUFHLENBQUM7QUFFOUIsbUJBQU8sSUFBSSxDQUFDO1NBQ2I7O2VBekVHLGVBQXVCO09BQVEsV0FBVzs7OztRQTRFaEQsZUFBQTtBQUdFLGlCQUhGLGVBQUEsQ0FHc0IsRUFBYyxFQUFVLEdBQWtCLEVBQVUsZ0JBQTBDLEVBQUE7a0NBSHBILGVBQUE7O0FBR3NCLGdCQUFBLENBQUEsRUFBRSxHQUFGLEVBQUUsQ0FBWTtBQUFVLGdCQUFBLENBQUEsR0FBRyxHQUFILEdBQUcsQ0FBZTtBQUFVLGdCQUFBLENBQUEsZ0JBQWdCLEdBQWhCLGdCQUFnQixDQUEwQjtBQUNoSCxnQkFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7QUFDYixnQkFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFDZixnQkFBSSxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUM7U0FDM0I7O0FBUEgsdUJBQUEsV0FTRSxJQUFJLEdBQUEsY0FBQyxFQUFrQixFQUFBO0FBQ3JCLGdCQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztTQUNuQjs7QUFYSCx1QkFBQSxXQWFFLGFBQWEsR0FBQSx5QkFBQTtnQkFDTCxPQUFPLEdBQVUsSUFBSSxDQUFyQixPQUFPO2dCQUFFLEdBQUcsR0FBSyxJQUFJLENBQVosR0FBRzs7QUFDbEIsZ0JBQUksT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPLEdBQUcsR0FBRyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNsRCxtQkFBTyxPQUFPLENBQUM7U0FDaEI7O0FBakJILHVCQUFBLFdBbUJFLGVBQWUsR0FBQSwyQkFBQTtBQUNiLGdCQUFJLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtBQUN6QixvQkFBSSxDQUFDLGdCQUFnQixDQUFDLGVBQWUsRUFBRSxDQUFDO2FBQ3pDO1NBQ0Y7O2VBdkJILGVBQUEiLCJmaWxlIjoidXBkYXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2NvcGUsIER5bmFtaWNTY29wZSwgRW52aXJvbm1lbnQgfSBmcm9tICcuLi9lbnZpcm9ubWVudCc7XG5pbXBvcnQgeyBEZXN0cm95YWJsZUJvdW5kcywgY2xlYXIsIG1vdmUgYXMgbW92ZUJvdW5kcyB9IGZyb20gJy4uL2JvdW5kcyc7XG5pbXBvcnQgeyBFbGVtZW50U3RhY2ssIFRyYWNrZXIsIFVwZGF0YWJsZVRyYWNrZXIgfSBmcm9tICcuLi9idWlsZGVyJztcbmltcG9ydCB7IExPR0dFUiwgT3B0aW9uLCBPcGFxdWUsIFN0YWNrLCBMaW5rZWRMaXN0LCBEaWN0LCBkaWN0LCBleHBlY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7XG4gIENvbnN0UmVmZXJlbmNlLFxuICBQYXRoUmVmZXJlbmNlLFxuICBJdGVyYXRpb25BcnRpZmFjdHMsXG4gIEl0ZXJhdG9yU3luY2hyb25pemVyLFxuICBJdGVyYXRvclN5bmNocm9uaXplckRlbGVnYXRlLFxuXG4gIC8vIFRhZ3NcbiAgY29tYmluZSxcbiAgUmV2aXNpb24sXG4gIFVwZGF0YWJsZVRhZyxcbiAgY29tYmluZVNsaWNlLFxuICBDT05TVEFOVF9UQUcsXG4gIElOSVRJQUxcbn0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7IEV2YWx1YXRlZEFyZ3MgfSBmcm9tICcuLi9jb21waWxlZC9leHByZXNzaW9ucy9hcmdzJztcbmltcG9ydCB7IENvbnN0YW50cywgT3Bjb2RlSlNPTiwgVXBkYXRpbmdPcGNvZGUsIFVwZGF0aW5nT3BTZXEsIFNsaWNlIH0gZnJvbSAnLi4vb3Bjb2Rlcyc7XG5pbXBvcnQgeyBET01DaGFuZ2VzIH0gZnJvbSAnLi4vZG9tL2hlbHBlcic7XG5pbXBvcnQgKiBhcyBTaW1wbGUgZnJvbSAnLi4vZG9tL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgQ2FwdHVyZWRGcmFtZSB9IGZyb20gJy4vZnJhbWUnO1xuXG5pbXBvcnQgVk0gZnJvbSAnLi9hcHBlbmQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVcGRhdGluZ1ZNIHtcbiAgcHVibGljIGVudjogRW52aXJvbm1lbnQ7XG4gIHB1YmxpYyBkb206IERPTUNoYW5nZXM7XG4gIHB1YmxpYyBhbHdheXNSZXZhbGlkYXRlOiBib29sZWFuO1xuICBwdWJsaWMgY29uc3RhbnRzOiBDb25zdGFudHM7XG5cbiAgcHJpdmF0ZSBmcmFtZVN0YWNrOiBTdGFjazxVcGRhdGluZ1ZNRnJhbWU+ID0gbmV3IFN0YWNrPFVwZGF0aW5nVk1GcmFtZT4oKTtcblxuICBjb25zdHJ1Y3RvcihlbnY6IEVudmlyb25tZW50LCB7IGFsd2F5c1JldmFsaWRhdGUgPSBmYWxzZSB9KSB7XG4gICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgdGhpcy5jb25zdGFudHMgPSBlbnYuY29uc3RhbnRzO1xuICAgIHRoaXMuZG9tID0gZW52LmdldERPTSgpO1xuICAgIHRoaXMuYWx3YXlzUmV2YWxpZGF0ZSA9IGFsd2F5c1JldmFsaWRhdGU7XG4gIH1cblxuICBleGVjdXRlKG9wY29kZXM6IFVwZGF0aW5nT3BTZXEsIGhhbmRsZXI6IEV4Y2VwdGlvbkhhbmRsZXIpIHtcbiAgICBsZXQgeyBmcmFtZVN0YWNrIH0gPSB0aGlzO1xuXG4gICAgdGhpcy50cnkob3Bjb2RlcywgaGFuZGxlcik7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGZyYW1lU3RhY2suaXNFbXB0eSgpKSBicmVhaztcblxuICAgICAgbGV0IG9wY29kZSA9IHRoaXMuZnJhbWUubmV4dFN0YXRlbWVudCgpO1xuXG4gICAgICBpZiAob3Bjb2RlID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZnJhbWVTdGFjay5wb3AoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIExPR0dFUi5kZWJ1ZyhgW1ZNXSBPUCAke29wY29kZS50eXBlfWApO1xuICAgICAgTE9HR0VSLnRyYWNlKG9wY29kZSk7XG5cbiAgICAgIG9wY29kZS5ldmFsdWF0ZSh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldCBmcmFtZSgpIHtcbiAgICByZXR1cm4gZXhwZWN0KHRoaXMuZnJhbWVTdGFjay5jdXJyZW50LCAnYnVnOiBleHBlY3RlZCBhIGZyYW1lJyk7XG4gIH1cblxuICBnb3RvKG9wOiBVcGRhdGluZ09wY29kZSkge1xuICAgIHRoaXMuZnJhbWUuZ290byhvcCk7XG4gIH1cblxuICB0cnkob3BzOiBVcGRhdGluZ09wU2VxLCBoYW5kbGVyOiBPcHRpb248RXhjZXB0aW9uSGFuZGxlcj4pIHtcbiAgICB0aGlzLmZyYW1lU3RhY2sucHVzaChuZXcgVXBkYXRpbmdWTUZyYW1lKHRoaXMsIG9wcywgaGFuZGxlcikpO1xuICB9XG5cbiAgdGhyb3coKSB7XG4gICAgdGhpcy5mcmFtZS5oYW5kbGVFeGNlcHRpb24oKTtcbiAgICB0aGlzLmZyYW1lU3RhY2sucG9wKCk7XG4gIH1cblxuICBldmFsdWF0ZU9wY29kZShvcGNvZGU6IFVwZGF0aW5nT3Bjb2RlKSB7XG4gICAgb3Bjb2RlLmV2YWx1YXRlKHRoaXMpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhjZXB0aW9uSGFuZGxlciB7XG4gIGhhbmRsZUV4Y2VwdGlvbigpOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZNU3RhdGUge1xuICBlbnY6IEVudmlyb25tZW50O1xuICBzY29wZTogU2NvcGU7XG4gIGR5bmFtaWNTY29wZTogRHluYW1pY1Njb3BlO1xuICBmcmFtZTogQ2FwdHVyZWRGcmFtZTtcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJsb2NrT3Bjb2RlIGV4dGVuZHMgVXBkYXRpbmdPcGNvZGUgaW1wbGVtZW50cyBEZXN0cm95YWJsZUJvdW5kcyB7XG4gIHB1YmxpYyB0eXBlID0gXCJibG9ja1wiO1xuICBwdWJsaWMgbmV4dCA9IG51bGw7XG4gIHB1YmxpYyBwcmV2ID0gbnVsbDtcblxuICBwcm90ZWN0ZWQgZW52OiBFbnZpcm9ubWVudDtcbiAgcHJvdGVjdGVkIHNjb3BlOiBTY29wZTtcbiAgcHJvdGVjdGVkIGR5bmFtaWNTY29wZTogRHluYW1pY1Njb3BlO1xuICBwcm90ZWN0ZWQgZnJhbWU6IENhcHR1cmVkRnJhbWU7XG4gIHByb3RlY3RlZCBjaGlsZHJlbjogTGlua2VkTGlzdDxVcGRhdGluZ09wY29kZT47XG4gIHByb3RlY3RlZCBib3VuZHM6IERlc3Ryb3lhYmxlQm91bmRzO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBvcHM6IFNsaWNlLCBzdGF0ZTogVk1TdGF0ZSwgYm91bmRzOiBEZXN0cm95YWJsZUJvdW5kcywgY2hpbGRyZW46IExpbmtlZExpc3Q8VXBkYXRpbmdPcGNvZGU+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBsZXQgeyBlbnYsIHNjb3BlLCBkeW5hbWljU2NvcGUsIGZyYW1lIH0gPSBzdGF0ZTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMuZHluYW1pY1Njb3BlID0gZHluYW1pY1Njb3BlO1xuICAgIHRoaXMuZnJhbWUgPSBmcmFtZTtcbiAgICB0aGlzLmJvdW5kcyA9IGJvdW5kcztcbiAgfVxuXG4gIGFic3RyYWN0IGRpZEluaXRpYWxpemVDaGlsZHJlbigpOiB2b2lkO1xuXG4gIHBhcmVudEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm91bmRzLnBhcmVudEVsZW1lbnQoKTtcbiAgfVxuXG4gIGZpcnN0Tm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3VuZHMuZmlyc3ROb2RlKCk7XG4gIH1cblxuICBsYXN0Tm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3VuZHMubGFzdE5vZGUoKTtcbiAgfVxuXG4gIGV2YWx1YXRlKHZtOiBVcGRhdGluZ1ZNKSB7XG4gICAgdm0udHJ5KHRoaXMuY2hpbGRyZW4sIG51bGwpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmJvdW5kcy5kZXN0cm95KCk7XG4gIH1cblxuICBkaWREZXN0cm95KCkge1xuICAgIHRoaXMuZW52LmRpZERlc3Ryb3kodGhpcy5ib3VuZHMpO1xuICB9XG5cbiAgdG9KU09OKCkgOiBPcGNvZGVKU09OIHtcbiAgICBsZXQgZGV0YWlscyA9IGRpY3Q8c3RyaW5nPigpO1xuXG4gICAgZGV0YWlsc1tcImd1aWRcIl0gPSBgJHt0aGlzLl9ndWlkfWA7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ3VpZDogdGhpcy5fZ3VpZCxcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIGRldGFpbHMsXG4gICAgICBjaGlsZHJlbjogdGhpcy5jaGlsZHJlbi50b0FycmF5KCkubWFwKG9wID0+IG9wLnRvSlNPTigpKVxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRyeU9wY29kZSBleHRlbmRzIEJsb2NrT3Bjb2RlIGltcGxlbWVudHMgRXhjZXB0aW9uSGFuZGxlciB7XG4gIHB1YmxpYyB0eXBlID0gXCJ0cnlcIjtcblxuICBwcml2YXRlIF90YWc6IFVwZGF0YWJsZVRhZztcblxuICBwcm90ZWN0ZWQgYm91bmRzOiBVcGRhdGFibGVUcmFja2VyO1xuXG4gIGNvbnN0cnVjdG9yKG9wczogU2xpY2UsIHN0YXRlOiBWTVN0YXRlLCBib3VuZHM6IFVwZGF0YWJsZVRyYWNrZXIsIGNoaWxkcmVuOiBMaW5rZWRMaXN0PFVwZGF0aW5nT3Bjb2RlPikge1xuICAgIHN1cGVyKG9wcywgc3RhdGUsIGJvdW5kcywgY2hpbGRyZW4pO1xuICAgIHRoaXMudGFnID0gdGhpcy5fdGFnID0gbmV3IFVwZGF0YWJsZVRhZyhDT05TVEFOVF9UQUcpO1xuICB9XG5cbiAgZGlkSW5pdGlhbGl6ZUNoaWxkcmVuKCkge1xuICAgIHRoaXMuX3RhZy51cGRhdGUoY29tYmluZVNsaWNlKHRoaXMuY2hpbGRyZW4pKTtcbiAgfVxuXG4gIGV2YWx1YXRlKHZtOiBVcGRhdGluZ1ZNKSB7XG4gICAgdm0udHJ5KHRoaXMuY2hpbGRyZW4sIHRoaXMpO1xuICB9XG5cbiAgaGFuZGxlRXhjZXB0aW9uKCkge1xuICAgIGxldCB7IGVudiwgc2NvcGUsIG9wcywgZHluYW1pY1Njb3BlLCBmcmFtZSB9ID0gdGhpcztcblxuICAgIGxldCBlbGVtZW50U3RhY2sgPSBFbGVtZW50U3RhY2sucmVzdW1lKFxuICAgICAgdGhpcy5lbnYsXG4gICAgICB0aGlzLmJvdW5kcyxcbiAgICAgIHRoaXMuYm91bmRzLnJlc2V0KGVudilcbiAgICApO1xuXG4gICAgbGV0IHZtID0gbmV3IFZNKGVudiwgc2NvcGUsIGR5bmFtaWNTY29wZSwgZWxlbWVudFN0YWNrKTtcbiAgICBsZXQgcmVzdWx0ID0gdm0ucmVzdW1lKG9wcywgZnJhbWUpO1xuXG4gICAgdGhpcy5jaGlsZHJlbiA9IHJlc3VsdC5vcGNvZGVzKCk7XG4gICAgdGhpcy5kaWRJbml0aWFsaXplQ2hpbGRyZW4oKTtcbiAgfVxuXG4gIHRvSlNPTigpIDogT3Bjb2RlSlNPTiB7XG4gICAgbGV0IGpzb24gPSBzdXBlci50b0pTT04oKTtcblxuICAgIGxldCBkZXRhaWxzID0ganNvbltcImRldGFpbHNcIl07XG4gICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICBkZXRhaWxzID0ganNvbltcImRldGFpbHNcIl0gPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIudG9KU09OKCk7XG4gIH1cbn1cblxuY2xhc3MgTGlzdFJldmFsaWRhdGlvbkRlbGVnYXRlIGltcGxlbWVudHMgSXRlcmF0b3JTeW5jaHJvbml6ZXJEZWxlZ2F0ZSB7XG4gIHByaXZhdGUgbWFwOiBEaWN0PEJsb2NrT3Bjb2RlPjtcbiAgcHJpdmF0ZSB1cGRhdGluZzogTGlua2VkTGlzdDxVcGRhdGluZ09wY29kZT47XG5cbiAgcHJpdmF0ZSBkaWRJbnNlcnQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBkaWREZWxldGUgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG9wY29kZTogTGlzdEJsb2NrT3Bjb2RlLCBwcml2YXRlIG1hcmtlcjogU2ltcGxlLkNvbW1lbnQpIHtcbiAgICB0aGlzLm1hcCA9IG9wY29kZS5tYXA7XG4gICAgdGhpcy51cGRhdGluZyA9IG9wY29kZVsnY2hpbGRyZW4nXTtcbiAgfVxuXG4gIGluc2VydChrZXk6IHN0cmluZywgaXRlbTogUGF0aFJlZmVyZW5jZTxPcGFxdWU+LCBtZW1vOiBQYXRoUmVmZXJlbmNlPE9wYXF1ZT4sIGJlZm9yZTogc3RyaW5nKSB7XG4gICAgbGV0IHsgbWFwLCBvcGNvZGUsIHVwZGF0aW5nIH0gPSB0aGlzO1xuICAgIGxldCBuZXh0U2libGluZzogT3B0aW9uPFNpbXBsZS5Ob2RlPiA9IG51bGw7XG4gICAgbGV0IHJlZmVyZW5jZTogT3B0aW9uPEJsb2NrT3Bjb2RlPiA9IG51bGw7XG5cbiAgICBpZiAoYmVmb3JlKSB7XG4gICAgICByZWZlcmVuY2UgPSBtYXBbYmVmb3JlXTtcbiAgICAgIG5leHRTaWJsaW5nID0gcmVmZXJlbmNlWydib3VuZHMnXS5maXJzdE5vZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFNpYmxpbmcgPSB0aGlzLm1hcmtlcjtcbiAgICB9XG5cbiAgICBsZXQgdm0gPSBvcGNvZGUudm1Gb3JJbnNlcnRpb24obmV4dFNpYmxpbmcpO1xuICAgIGxldCB0cnlPcGNvZGU6IE9wdGlvbjxUcnlPcGNvZGU+ID0gbnVsbDtcblxuICAgIHZtLmV4ZWN1dGUob3Bjb2RlLm9wcywgdm0gPT4ge1xuICAgICAgdm0uZnJhbWUuc2V0QXJncyhFdmFsdWF0ZWRBcmdzLnBvc2l0aW9uYWwoW2l0ZW0sIG1lbW9dKSk7XG4gICAgICB2bS5mcmFtZS5zZXRPcGVyYW5kKGl0ZW0pO1xuICAgICAgdm0uZnJhbWUuc2V0Q29uZGl0aW9uKG5ldyBDb25zdFJlZmVyZW5jZSh0cnVlKSk7XG4gICAgICB2bS5mcmFtZS5zZXRLZXkoa2V5KTtcblxuICAgICAgbGV0IHN0YXRlID0gdm0uY2FwdHVyZSgpO1xuICAgICAgbGV0IHRyYWNrZXIgPSB2bS5zdGFjaygpLnB1c2hVcGRhdGFibGVCbG9jaygpO1xuXG4gICAgICB0cnlPcGNvZGUgPSBuZXcgVHJ5T3Bjb2RlKG9wY29kZS5vcHMsIHN0YXRlLCB0cmFja2VyLCB2bS51cGRhdGluZygpKTtcbiAgICB9KTtcblxuICAgIHRyeU9wY29kZSEuZGlkSW5pdGlhbGl6ZUNoaWxkcmVuKCk7XG5cbiAgICB1cGRhdGluZy5pbnNlcnRCZWZvcmUodHJ5T3Bjb2RlISwgcmVmZXJlbmNlKTtcblxuICAgIG1hcFtrZXldID0gdHJ5T3Bjb2RlITtcblxuICAgIHRoaXMuZGlkSW5zZXJ0ID0gdHJ1ZTtcbiAgfVxuXG4gIHJldGFpbihfa2V5OiBzdHJpbmcsIF9pdGVtOiBQYXRoUmVmZXJlbmNlPE9wYXF1ZT4sIF9tZW1vOiBQYXRoUmVmZXJlbmNlPE9wYXF1ZT4pIHtcbiAgfVxuXG4gIG1vdmUoa2V5OiBzdHJpbmcsIF9pdGVtOiBQYXRoUmVmZXJlbmNlPE9wYXF1ZT4sIF9tZW1vOiBQYXRoUmVmZXJlbmNlPE9wYXF1ZT4sIGJlZm9yZTogc3RyaW5nKSB7XG4gICAgbGV0IHsgbWFwLCB1cGRhdGluZyB9ID0gdGhpcztcblxuICAgIGxldCBlbnRyeSA9IG1hcFtrZXldO1xuICAgIGxldCByZWZlcmVuY2UgPSBtYXBbYmVmb3JlXSB8fCBudWxsO1xuXG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgbW92ZUJvdW5kcyhlbnRyeSwgcmVmZXJlbmNlLmZpcnN0Tm9kZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW92ZUJvdW5kcyhlbnRyeSwgdGhpcy5tYXJrZXIpO1xuICAgIH1cblxuICAgIHVwZGF0aW5nLnJlbW92ZShlbnRyeSk7XG4gICAgdXBkYXRpbmcuaW5zZXJ0QmVmb3JlKGVudHJ5LCByZWZlcmVuY2UpO1xuICB9XG5cbiAgZGVsZXRlKGtleTogc3RyaW5nKSB7XG4gICAgbGV0IHsgbWFwIH0gPSB0aGlzO1xuICAgIGxldCBvcGNvZGUgPSBtYXBba2V5XTtcbiAgICBvcGNvZGUuZGlkRGVzdHJveSgpO1xuICAgIGNsZWFyKG9wY29kZSk7XG4gICAgdGhpcy51cGRhdGluZy5yZW1vdmUob3Bjb2RlKTtcbiAgICBkZWxldGUgbWFwW2tleV07XG5cbiAgICB0aGlzLmRpZERlbGV0ZSA9IHRydWU7XG4gIH1cblxuICBkb25lKCkge1xuICAgIHRoaXMub3Bjb2RlLmRpZEluaXRpYWxpemVDaGlsZHJlbih0aGlzLmRpZEluc2VydCB8fCB0aGlzLmRpZERlbGV0ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIExpc3RCbG9ja09wY29kZSBleHRlbmRzIEJsb2NrT3Bjb2RlIHtcbiAgcHVibGljIHR5cGUgPSBcImxpc3QtYmxvY2tcIjtcbiAgcHVibGljIG1hcCA9IGRpY3Q8QmxvY2tPcGNvZGU+KCk7XG4gIHB1YmxpYyBhcnRpZmFjdHM6IEl0ZXJhdGlvbkFydGlmYWN0cztcblxuICBwcml2YXRlIGxhc3RJdGVyYXRlZDogUmV2aXNpb24gPSBJTklUSUFMO1xuICBwcml2YXRlIF90YWc6IFVwZGF0YWJsZVRhZztcblxuICBjb25zdHJ1Y3RvcihvcHM6IFNsaWNlLCBzdGF0ZTogVk1TdGF0ZSwgYm91bmRzOiBUcmFja2VyLCBjaGlsZHJlbjogTGlua2VkTGlzdDxVcGRhdGluZ09wY29kZT4sIGFydGlmYWN0czogSXRlcmF0aW9uQXJ0aWZhY3RzKSB7XG4gICAgc3VwZXIob3BzLCBzdGF0ZSwgYm91bmRzLCBjaGlsZHJlbik7XG4gICAgdGhpcy5hcnRpZmFjdHMgPSBhcnRpZmFjdHM7XG4gICAgbGV0IF90YWcgPSB0aGlzLl90YWcgPSBuZXcgVXBkYXRhYmxlVGFnKENPTlNUQU5UX1RBRyk7XG4gICAgdGhpcy50YWcgPSBjb21iaW5lKFthcnRpZmFjdHMudGFnLCBfdGFnXSk7XG4gIH1cblxuICBkaWRJbml0aWFsaXplQ2hpbGRyZW4obGlzdERpZENoYW5nZSA9IHRydWUpIHtcbiAgICB0aGlzLmxhc3RJdGVyYXRlZCA9IHRoaXMuYXJ0aWZhY3RzLnRhZy52YWx1ZSgpO1xuXG4gICAgaWYgKGxpc3REaWRDaGFuZ2UpIHtcbiAgICAgIHRoaXMuX3RhZy51cGRhdGUoY29tYmluZVNsaWNlKHRoaXMuY2hpbGRyZW4pKTtcbiAgICB9XG4gIH1cblxuICBldmFsdWF0ZSh2bTogVXBkYXRpbmdWTSkge1xuICAgIGxldCB7IGFydGlmYWN0cywgbGFzdEl0ZXJhdGVkIH0gPSB0aGlzO1xuXG4gICAgaWYgKCFhcnRpZmFjdHMudGFnLnZhbGlkYXRlKGxhc3RJdGVyYXRlZCkpIHtcbiAgICAgIGxldCB7IGJvdW5kcyB9ID0gdGhpcztcbiAgICAgIGxldCB7IGRvbSB9ID0gdm07XG5cbiAgICAgIGxldCBtYXJrZXIgPSBkb20uY3JlYXRlQ29tbWVudCgnJyk7XG4gICAgICBkb20uaW5zZXJ0QWZ0ZXIoYm91bmRzLnBhcmVudEVsZW1lbnQoKSwgbWFya2VyLCBleHBlY3QoYm91bmRzLmxhc3ROb2RlKCksIFwiY2FuJ3QgaW5zZXJ0IGFmdGVyIGFuIGVtcHR5IGJvdW5kc1wiKSk7XG5cbiAgICAgIGxldCB0YXJnZXQgPSBuZXcgTGlzdFJldmFsaWRhdGlvbkRlbGVnYXRlKHRoaXMsIG1hcmtlcik7XG4gICAgICBsZXQgc3luY2hyb25pemVyID0gbmV3IEl0ZXJhdG9yU3luY2hyb25pemVyKHsgdGFyZ2V0LCBhcnRpZmFjdHMgfSk7XG5cbiAgICAgIHN5bmNocm9uaXplci5zeW5jKCk7XG5cbiAgICAgIHRoaXMucGFyZW50RWxlbWVudCgpLnJlbW92ZUNoaWxkKG1hcmtlcik7XG4gICAgfVxuXG4gICAgLy8gUnVuIG5vdy11cGRhdGVkIHVwZGF0aW5nIG9wY29kZXNcbiAgICBzdXBlci5ldmFsdWF0ZSh2bSk7XG4gIH1cblxuICB2bUZvckluc2VydGlvbihuZXh0U2libGluZzogT3B0aW9uPFNpbXBsZS5Ob2RlPik6IFZNIHtcbiAgICBsZXQgeyBlbnYsIHNjb3BlLCBkeW5hbWljU2NvcGUgfSA9IHRoaXM7XG5cbiAgICBsZXQgZWxlbWVudFN0YWNrID0gRWxlbWVudFN0YWNrLmZvckluaXRpYWxSZW5kZXIoXG4gICAgICB0aGlzLmVudixcbiAgICAgIHRoaXMuYm91bmRzLnBhcmVudEVsZW1lbnQoKSxcbiAgICAgIG5leHRTaWJsaW5nXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgVk0oZW52LCBzY29wZSwgZHluYW1pY1Njb3BlLCBlbGVtZW50U3RhY2spO1xuICB9XG5cbiAgdG9KU09OKCkgOiBPcGNvZGVKU09OIHtcbiAgICBsZXQganNvbiA9IHN1cGVyLnRvSlNPTigpO1xuICAgIGxldCBtYXAgPSB0aGlzLm1hcDtcblxuICAgIGxldCBpbm5lciA9IE9iamVjdC5rZXlzKG1hcCkubWFwKGtleSA9PiB7XG4gICAgICByZXR1cm4gYCR7SlNPTi5zdHJpbmdpZnkoa2V5KX06ICR7bWFwW2tleV0uX2d1aWR9YDtcbiAgICB9KS5qb2luKFwiLCBcIik7XG5cbiAgICBsZXQgZGV0YWlscyA9IGpzb25bXCJkZXRhaWxzXCJdO1xuICAgIGlmICghZGV0YWlscykge1xuICAgICAgZGV0YWlscyA9IGpzb25bXCJkZXRhaWxzXCJdID0ge307XG4gICAgfVxuXG4gICAgZGV0YWlsc1tcIm1hcFwiXSA9IGB7JHtpbm5lcn19YDtcblxuICAgIHJldHVybiBqc29uO1xuICB9XG59XG5cbmNsYXNzIFVwZGF0aW5nVk1GcmFtZSB7XG4gIHByaXZhdGUgY3VycmVudDogT3B0aW9uPFVwZGF0aW5nT3Bjb2RlPjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHZtOiBVcGRhdGluZ1ZNLCBwcml2YXRlIG9wczogVXBkYXRpbmdPcFNlcSwgcHJpdmF0ZSBleGNlcHRpb25IYW5kbGVyOiBPcHRpb248RXhjZXB0aW9uSGFuZGxlcj4pIHtcbiAgICB0aGlzLnZtID0gdm07XG4gICAgdGhpcy5vcHMgPSBvcHM7XG4gICAgdGhpcy5jdXJyZW50ID0gb3BzLmhlYWQoKTtcbiAgfVxuXG4gIGdvdG8ob3A6IFVwZGF0aW5nT3Bjb2RlKSB7XG4gICAgdGhpcy5jdXJyZW50ID0gb3A7XG4gIH1cblxuICBuZXh0U3RhdGVtZW50KCk6IE9wdGlvbjxVcGRhdGluZ09wY29kZT4ge1xuICAgIGxldCB7IGN1cnJlbnQsIG9wcyB9ID0gdGhpcztcbiAgICBpZiAoY3VycmVudCkgdGhpcy5jdXJyZW50ID0gb3BzLm5leHROb2RlKGN1cnJlbnQpO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgaGFuZGxlRXhjZXB0aW9uKCkge1xuICAgIGlmICh0aGlzLmV4Y2VwdGlvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuZXhjZXB0aW9uSGFuZGxlci5oYW5kbGVFeGNlcHRpb24oKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==