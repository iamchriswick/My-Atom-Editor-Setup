enifed('@glimmer/object-model/lib/object', ['exports', '@glimmer/object-model/lib/blueprint'], function (exports, _glimmerObjectModelLibBlueprint) {
    'use strict';

    exports.classof = classof;

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var GlimmerObjectBase = function GlimmerObjectBase() {
        _classCallCheck(this, GlimmerObjectBase);
    };

    exports.GlimmerObjectBase = GlimmerObjectBase;

    var GlimmerObject = (function () {
        GlimmerObject.create = function create(properties) {
            return new this(properties);
        };

        GlimmerObject.extend = function extend(extensions) {
            // This method intentionally uses internal typecasts to convince TypeScript
            // that what we're doing is legitimate. The real action of this method is in
            // its signature (and the signature of GlimmerClass).
            var sub = (function (_ref) {
                _inherits(sub, _ref);

                function sub() {
                    _classCallCheck(this, sub);

                    _ref.apply(this, arguments);
                }

                return sub;
            })(this);
            if (extensions !== undefined) {
                var blueprints = Object.keys(extensions).map(function (k) {
                    var extension = extensions[k];
                    if (extension instanceof _glimmerObjectModelLibBlueprint.GlimmerDescriptor) {
                        return extension.blueprint(k);
                    } else {
                        return new _glimmerObjectModelLibBlueprint.ValueBlueprint(k, extensions[k]);
                    }
                });
                blueprints.forEach(function (b) {
                    return b.define(sub.prototype);
                });
            }
            return sub;
        };

        function GlimmerObject(properties) {
            _classCallCheck(this, GlimmerObject);

            if (properties !== undefined) {
                Object.assign(this, properties);
            }
        }

        /**
         * Adapter for TypeScript.
         *
         * A shim library could just declare the variable as the type
         * GlimmerClass<FirstInstance>. The key point is that shimming
         * between the two worlds requires writing a static interface
         * definition, as TypeScript isn't willing to treat the dynamic
         * intersection as a valid constructor return type.
         *
         * This function is a noop and is used like this:
         *
         * ```ts
         * // in one file
         * let Person = GlimmerObject.extend({
         *   named: 'Dan'
         * });
         *
         *
         * // in a TypeScript wrapper file
         * import { Person as OriginalPerson } from 'original-definition';
         *
         * interface PersonInstance {
         *   named: string
         * }
         *
         * export let Person = classof<PersonInstance>(OriginalPerson);
         *
         * // in a subclassing file
         * import { Person } from 'wrapped-definition';
         *
         * class FancyPerson extends Person {
         *   salutation: string;
         *
         *   fullName() {
         *     return `${this.salutation} ${this.named}`;
         *   }
         * }
         *
         * FancyPerson.create({ name: 'Tom Dale', salutation: 'Mr.' }).fullName();
         * // typechecks and returns 'Mr. Tom Dale'
         * ```
        */
        return GlimmerObject;
    })();

    exports.default = GlimmerObject;

    function classof(klass) {
        return klass;
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkBnbGltbWVyL29iamVjdC1tb2RlbC9saWIvb2JqZWN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O1FBY00saUJBQUEsWUFBQSxpQkFBQTs4QkFBQSxpQkFBQTs7Ozs7UUFJUSxhQUFBO0FBQUEscUJBQUEsQ0FDTCxNQUFNLEdBQUEsZ0JBQXdJLFVBQTBCLEVBQUE7QUFDN0ssbUJBQU8sSUFBSSxJQUFJLENBQUMsVUFBVSxDQUErQyxDQUFDO1NBQzNFOztBQUhXLHFCQUFBLENBS0wsTUFBTSxHQUFBLGdCQUFpRyxVQUF1QixFQUFBOzs7O0FBS25JLGdCQUFJLEdBQUc7MEJBQUgsR0FBRzs7eUJBQUgsR0FBRzswQ0FBSCxHQUFHOzs7Ozt1QkFBSCxHQUFHO2VBQWtCLElBQWlDLENBQUcsQ0FBQztBQUU5RCxnQkFBSSxVQUFVLEtBQUssU0FBUyxFQUFFO0FBQzVCLG9CQUFJLFVBQVUsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFBLENBQUMsRUFBQTtBQUM1Qyx3QkFBSSxTQUFTLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzlCLHdCQUFJLFNBQVMsNENBakNaLGlCQUFpQixBQWlDd0IsRUFBRTtBQUMxQywrQkFBTyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUMvQixNQUFNO0FBQ0wsK0JBQU8sb0NBcENXLGNBQWMsQ0FvQ04sQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUM3QztpQkFDRixDQUFDLENBQUM7QUFFSCwwQkFBVSxDQUFDLE9BQU8sQ0FBQyxVQUFBLENBQUM7MkJBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDO2lCQUFBLENBQUMsQ0FBQzthQUNsRDtBQUVELG1CQUFPLEdBQVUsQ0FBQztTQUNuQjs7QUFFRCxpQkE1QlksYUFBQSxDQTRCQSxVQUFtQixFQUFBO2tDQTVCbkIsYUFBQTs7QUE2QlYsZ0JBQUksVUFBVSxLQUFLLFNBQVMsRUFBRTtBQUM1QixzQkFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7YUFDakM7U0FDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFoQ1csYUFBQTs7O3NCQUFBLGFBQUE7O0FBNkVSLGFBQUEsT0FBQSxDQUFxQixLQUFVLEVBQUE7QUFDbkMsZUFBTyxLQUFZLENBQUM7S0FDckIiLCJmaWxlIjoib2JqZWN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR2xpbW1lckRlc2NyaXB0b3IsIFZhbHVlQmx1ZXByaW50IH0gZnJvbSAnLi9ibHVlcHJpbnQnO1xyXG5leHBvcnQgdHlwZSBHbGltbWVyT2JqZWN0Q2xhc3MgPSB0eXBlb2YgR2xpbW1lck9iamVjdDtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29uc3RydWN0b3I8VCBleHRlbmRzIEdsaW1tZXJPYmplY3Q+IHtcclxuICBuZXcoLi4uYXJncyk6IFQ7XHJcbiAgcHJvdG90eXBlOiBUO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEdsaW1tZXJDbGFzczxFeHRlbnNpb25zIGV4dGVuZHMgR2xpbW1lck9iamVjdD4gZXh0ZW5kcyBDb25zdHJ1Y3RvcjxFeHRlbnNpb25zPiB7XHJcbiAgbmV3KC4uLmFyZ3MpOiBFeHRlbnNpb25zO1xyXG4gIGNyZWF0ZTxFeHRlbnNpb25zLCBDcmVhdGVPcHRpb25zLCBUIGV4dGVuZHMgdHlwZW9mIEdsaW1tZXJPYmplY3Q+KHRoaXM6IFQgJiBHbGltbWVyQ2xhc3M8RXh0ZW5zaW9ucz4sIHByb3BlcnRpZXM/OiBDcmVhdGVPcHRpb25zKTogRXh0ZW5zaW9ucyAmIENyZWF0ZU9wdGlvbnMgJiBHbGltbWVyT2JqZWN0O1xyXG4gIGV4dGVuZDxPcmlnaW5hbCBleHRlbmRzIEdsaW1tZXJPYmplY3QsIEV4dGVuc2lvbnMgZXh0ZW5kcyBHbGltbWVyT2JqZWN0Pih0aGlzOiBHbGltbWVyQ2xhc3M8T3JpZ2luYWw+LCBleHRlbnNpb25zPzogRXh0ZW5zaW9ucyk6IEdsaW1tZXJDbGFzczxPcmlnaW5hbCAmIEV4dGVuc2lvbnM+O1xyXG59XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgR2xpbW1lck9iamVjdEJhc2U8RXh0ZW5zaW9ucz4ge1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2xpbW1lck9iamVjdCB7XHJcbiAgc3RhdGljIGNyZWF0ZTxFeHRlbnNpb25zIGV4dGVuZHMgR2xpbW1lck9iamVjdCwgQ3JlYXRlT3B0aW9ucyBleHRlbmRzIEdsaW1tZXJPYmplY3QsIFQgZXh0ZW5kcyB0eXBlb2YgR2xpbW1lck9iamVjdD4odGhpczogR2xpbW1lckNsYXNzPEV4dGVuc2lvbnM+LCBwcm9wZXJ0aWVzPzogQ3JlYXRlT3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHByb3BlcnRpZXMpIGFzIEV4dGVuc2lvbnMgJiBDcmVhdGVPcHRpb25zICYgR2xpbW1lck9iamVjdDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBleHRlbmQ8T3JpZ2luYWwgZXh0ZW5kcyBHbGltbWVyT2JqZWN0LCBFeHRlbnNpb25zIGV4dGVuZHMgR2xpbW1lck9iamVjdD4odGhpczogR2xpbW1lckNsYXNzPE9yaWdpbmFsPiwgZXh0ZW5zaW9ucz86IEV4dGVuc2lvbnMpOiBHbGltbWVyQ2xhc3M8T3JpZ2luYWwgJiBFeHRlbnNpb25zICYgR2xpbW1lck9iamVjdD4ge1xyXG4gICAgLy8gVGhpcyBtZXRob2QgaW50ZW50aW9uYWxseSB1c2VzIGludGVybmFsIHR5cGVjYXN0cyB0byBjb252aW5jZSBUeXBlU2NyaXB0XHJcbiAgICAvLyB0aGF0IHdoYXQgd2UncmUgZG9pbmcgaXMgbGVnaXRpbWF0ZS4gVGhlIHJlYWwgYWN0aW9uIG9mIHRoaXMgbWV0aG9kIGlzIGluXHJcbiAgICAvLyBpdHMgc2lnbmF0dXJlIChhbmQgdGhlIHNpZ25hdHVyZSBvZiBHbGltbWVyQ2xhc3MpLlxyXG5cclxuICAgIGxldCBzdWIgPSBjbGFzcyBleHRlbmRzICh0aGlzIGFzIGFueSBhcyBPYmplY3RDb25zdHJ1Y3Rvcikge307XHJcblxyXG4gICAgaWYgKGV4dGVuc2lvbnMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBsZXQgYmx1ZXByaW50cyA9IE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpLm1hcChrID0+IHtcclxuICAgICAgICBsZXQgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uc1trXTtcclxuICAgICAgICBpZiAoZXh0ZW5zaW9uIGluc3RhbmNlb2YgR2xpbW1lckRlc2NyaXB0b3IpIHtcclxuICAgICAgICAgIHJldHVybiBleHRlbnNpb24uYmx1ZXByaW50KGspO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gbmV3IFZhbHVlQmx1ZXByaW50KGssIGV4dGVuc2lvbnNba10pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBibHVlcHJpbnRzLmZvckVhY2goYiA9PiBiLmRlZmluZShzdWIucHJvdG90eXBlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN1YiBhcyBhbnk7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0aWVzPzogT2JqZWN0KSB7XHJcbiAgICBpZiAocHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcHJvcGVydGllcyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQWRhcHRlciBmb3IgVHlwZVNjcmlwdC5cclxuICpcclxuICogQSBzaGltIGxpYnJhcnkgY291bGQganVzdCBkZWNsYXJlIHRoZSB2YXJpYWJsZSBhcyB0aGUgdHlwZVxyXG4gKiBHbGltbWVyQ2xhc3M8Rmlyc3RJbnN0YW5jZT4uIFRoZSBrZXkgcG9pbnQgaXMgdGhhdCBzaGltbWluZ1xyXG4gKiBiZXR3ZWVuIHRoZSB0d28gd29ybGRzIHJlcXVpcmVzIHdyaXRpbmcgYSBzdGF0aWMgaW50ZXJmYWNlXHJcbiAqIGRlZmluaXRpb24sIGFzIFR5cGVTY3JpcHQgaXNuJ3Qgd2lsbGluZyB0byB0cmVhdCB0aGUgZHluYW1pY1xyXG4gKiBpbnRlcnNlY3Rpb24gYXMgYSB2YWxpZCBjb25zdHJ1Y3RvciByZXR1cm4gdHlwZS5cclxuICpcclxuICogVGhpcyBmdW5jdGlvbiBpcyBhIG5vb3AgYW5kIGlzIHVzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGB0c1xyXG4gKiAvLyBpbiBvbmUgZmlsZVxyXG4gKiBsZXQgUGVyc29uID0gR2xpbW1lck9iamVjdC5leHRlbmQoe1xyXG4gKiAgIG5hbWVkOiAnRGFuJ1xyXG4gKiB9KTtcclxuICpcclxuICpcclxuICogLy8gaW4gYSBUeXBlU2NyaXB0IHdyYXBwZXIgZmlsZVxyXG4gKiBpbXBvcnQgeyBQZXJzb24gYXMgT3JpZ2luYWxQZXJzb24gfSBmcm9tICdvcmlnaW5hbC1kZWZpbml0aW9uJztcclxuICpcclxuICogaW50ZXJmYWNlIFBlcnNvbkluc3RhbmNlIHtcclxuICogICBuYW1lZDogc3RyaW5nXHJcbiAqIH1cclxuICpcclxuICogZXhwb3J0IGxldCBQZXJzb24gPSBjbGFzc29mPFBlcnNvbkluc3RhbmNlPihPcmlnaW5hbFBlcnNvbik7XHJcbiAqXHJcbiAqIC8vIGluIGEgc3ViY2xhc3NpbmcgZmlsZVxyXG4gKiBpbXBvcnQgeyBQZXJzb24gfSBmcm9tICd3cmFwcGVkLWRlZmluaXRpb24nO1xyXG4gKlxyXG4gKiBjbGFzcyBGYW5jeVBlcnNvbiBleHRlbmRzIFBlcnNvbiB7XHJcbiAqICAgc2FsdXRhdGlvbjogc3RyaW5nO1xyXG4gKlxyXG4gKiAgIGZ1bGxOYW1lKCkge1xyXG4gKiAgICAgcmV0dXJuIGAke3RoaXMuc2FsdXRhdGlvbn0gJHt0aGlzLm5hbWVkfWA7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqXHJcbiAqIEZhbmN5UGVyc29uLmNyZWF0ZSh7IG5hbWU6ICdUb20gRGFsZScsIHNhbHV0YXRpb246ICdNci4nIH0pLmZ1bGxOYW1lKCk7XHJcbiAqIC8vIHR5cGVjaGVja3MgYW5kIHJldHVybnMgJ01yLiBUb20gRGFsZSdcclxuICogYGBgXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGFzc29mPFQ+KGtsYXNzOiBhbnkpOiBHbGltbWVyQ2xhc3M8VD4ge1xyXG4gIHJldHVybiBrbGFzcyBhcyBhbnk7XHJcbn1cclxuIl19