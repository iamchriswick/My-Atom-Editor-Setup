enifed('@glimmer/compiler/index.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/compiler');
    QUnit.test('@glimmer/compiler/index.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/compiler/index.ts should pass tslint.');
    });
});

enifed('@glimmer/compiler/lib/compiler.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/compiler/lib');
    QUnit.test('@glimmer/compiler/lib/compiler.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/compiler/lib/compiler.ts should pass tslint.');
    });
});

enifed('@glimmer/compiler/lib/javascript-compiler.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/compiler/lib');
    QUnit.test('@glimmer/compiler/lib/javascript-compiler.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/compiler/lib/javascript-compiler.ts should pass tslint.');
    });
});

enifed('@glimmer/compiler/lib/template-compiler.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/compiler/lib');
    QUnit.test('@glimmer/compiler/lib/template-compiler.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/compiler/lib/template-compiler.ts should pass tslint.');
    });
});

enifed('@glimmer/compiler/lib/template-visitor.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/compiler/lib');
    QUnit.test('@glimmer/compiler/lib/template-visitor.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/compiler/lib/template-visitor.ts should pass tslint.');
    });
});

enifed('@glimmer/compiler/lib/utils.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/compiler/lib');
    QUnit.test('@glimmer/compiler/lib/utils.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/compiler/lib/utils.ts should pass tslint.');
    });
});

enifed("@glimmer/compiler/tests/compile-options-test", ["exports", "@glimmer/test-helpers", "@glimmer/compiler"], function (exports, _glimmerTestHelpers, _glimmerCompiler) {
    "use strict";

    var env = undefined;
    QUnit.module('Compile options', {
        setup: function () {
            env = new _glimmerTestHelpers.TestEnvironment();
        }
    });
    QUnit.test('moduleName option is passed into meta', function () {
        var moduleName = 'It ain\'t hard to tell';
        var template = _glimmerTestHelpers.compile('Hi, {{name}}!', {
            env: env,
            meta: {
                moduleName: moduleName
            }
        });
        equal(template.meta.moduleName, moduleName, 'Template has the moduleName');
    });
    QUnit.module('precompile', {
        setup: function () {
            env = new _glimmerTestHelpers.TestEnvironment();
        }
    });
    QUnit.test('returned meta is correct', function () {
        var wire = JSON.parse(_glimmerCompiler.precompile('Hi, {{name}}!', {
            meta: {
                moduleName: 'my/module-name',
                metaIsOpaque: 'yes'
            }
        }));
        equal(wire.meta.moduleName, 'my/module-name', 'Template has correct meta');
        equal(wire.meta.metaIsOpaque, 'yes', 'Template has correct meta');
    });
});

enifed('@glimmer/compiler/tests/compile-options-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/compiler/tests');
    QUnit.test('@glimmer/compiler/tests/compile-options-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/compiler/tests/compile-options-test.ts should pass tslint.');
    });
});

enifed("@glimmer/compiler/tests/template-visitor-node-test", ["exports", "@glimmer/syntax", "@glimmer/compiler"], function (exports, _glimmerSyntax, _glimmerCompiler) {
    "use strict";

    function actionsEqual(input, expectedActions) {
        var ast = _glimmerSyntax.preprocess(input);
        var templateVisitor = new _glimmerCompiler.TemplateVisitor();
        templateVisitor.visit(ast);
        var actualActions = templateVisitor.actions;
        // Remove the AST node reference from the actions to keep tests leaner
        for (var i = 0; i < actualActions.length; i++) {
            actualActions[i][1].shift();
        }
        deepEqual(actualActions, expectedActions);
    }
    QUnit.module("TemplateVisitor");
    test("empty", function () {
        var input = "";
        actionsEqual(input, [['startProgram', [0, []]], ['endProgram', [0]]]);
    });
    test("basic", function () {
        var input = "foo{{bar}}<div></div>";
        actionsEqual(input, [['startProgram', [0, []]], ['text', [0, 3]], ['mustache', [1, 3]], ['openElement', [2, 3, 0, []]], ['closeElement', [2, 3]], ['endProgram', [0]]]);
    });
    test("nested HTML", function () {
        var input = "<a></a><a><a><a></a></a></a>";
        actionsEqual(input, [['startProgram', [0, []]], ['openElement', [0, 2, 0, []]], ['closeElement', [0, 2]], ['openElement', [1, 2, 0, []]], ['openElement', [0, 1, 0, []]], ['openElement', [0, 1, 0, []]], ['closeElement', [0, 1]], ['closeElement', [0, 1]], ['closeElement', [1, 2]], ['endProgram', [0]]]);
    });
    test("mustaches are counted correctly", function () {
        var input = "<a><a>{{foo}}</a><a {{foo}}><a>{{foo}}</a><a>{{foo}}</a></a></a>";
        actionsEqual(input, [['startProgram', [0, []]], ['openElement', [0, 1, 2, []]], ['openElement', [0, 2, 1, []]], ['mustache', [0, 1]], ['closeElement', [0, 2]], ['openElement', [1, 2, 3, []]], ['openElement', [0, 2, 1, []]], ['mustache', [0, 1]], ['closeElement', [0, 2]], ['openElement', [1, 2, 1, []]], ['mustache', [0, 1]], ['closeElement', [1, 2]], ['closeElement', [1, 2]], ['closeElement', [0, 1]], ['endProgram', [0]]]);
    });
    test("empty block", function () {
        var input = "{{#a}}{{/a}}";
        actionsEqual(input, [['startBlock', [0, []]], ['endBlock', [1]], ['startProgram', [1, []]], ['block', [0, 1]], ['endProgram', [0]]]);
    });
    test("block with inverse", function () {
        var input = "{{#a}}b{{^}}{{/a}}";
        actionsEqual(input, [['startBlock', [0, []]], ['endBlock', [1]], ['startBlock', [0, []]], ['text', [0, 1]], ['endBlock', [1]], ['startProgram', [2, []]], ['block', [0, 1]], ['endProgram', [0]]]);
    });
    test("nested blocks", function () {
        var input = "{{#a}}{{#a}}<b></b>{{/a}}{{#a}}{{b}}{{/a}}{{/a}}{{#a}}b{{/a}}";
        actionsEqual(input, [['startBlock', [0, []]], ['text', [0, 1]], ['endBlock', [1]], ['startBlock', [0, []]], ['mustache', [0, 1]], ['endBlock', [2]], ['startBlock', [0, []]], ['openElement', [0, 1, 0, []]], ['closeElement', [0, 1]], ['endBlock', [2]], ['startBlock', [2, []]], ['block', [0, 2]], ['block', [1, 2]], ['endBlock', [1]], ['startProgram', [2, []]], ['block', [0, 2]], ['block', [1, 2]], ['endProgram', [0]]]);
    });
    test("comment", function () {
        var input = "<!-- some comment -->";
        actionsEqual(input, [['startProgram', [0, []]], ['comment', [0, 1]], ['endProgram', [0]]]);
    });
    test("handlebars comment", function () {
        var input = "{{! some comment }}";
        actionsEqual(input, [['startProgram', [0, []]], ['endProgram', [0]]]);
    });
    test("handlebars comment in element space", function () {
        var input = "<div {{! some comment }}></div>";
        actionsEqual(input, [['startProgram', [0, []]], ['openElement', [0, 1, 0, []]], ['closeElement', [0, 1]], ['endProgram', [0]]]);
    });
});

enifed('@glimmer/compiler/tests/template-visitor-node-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/compiler/tests');
    QUnit.test('@glimmer/compiler/tests/template-visitor-node-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/compiler/tests/template-visitor-node-test.ts should pass tslint.');
    });
});

enifed('@glimmer/node/index.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/node');
    QUnit.test('@glimmer/node/index.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/node/index.ts should pass tslint.');
    });
});

enifed('@glimmer/node/lib/node-dom-helper.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/node/lib');
    QUnit.test('@glimmer/node/lib/node-dom-helper.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/node/lib/node-dom-helper.ts should pass tslint.');
    });
});

enifed('@glimmer/node/tests/node-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/node/tests');
    QUnit.test('@glimmer/node/tests/node-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/node/tests/node-test.ts should pass tslint.');
    });
});

enifed('@glimmer/object-model/index.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object-model');
    QUnit.test('@glimmer/object-model/index.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object-model/index.ts should pass tslint.');
    });
});

enifed('@glimmer/object-model/lib/blueprint.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object-model/lib');
    QUnit.test('@glimmer/object-model/lib/blueprint.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object-model/lib/blueprint.ts should pass tslint.');
    });
});

enifed('@glimmer/object-model/lib/meta.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object-model/lib');
    QUnit.test('@glimmer/object-model/lib/meta.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object-model/lib/meta.ts should pass tslint.');
    });
});

enifed('@glimmer/object-model/lib/object.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object-model/lib');
    QUnit.test('@glimmer/object-model/lib/object.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object-model/lib/object.ts should pass tslint.');
    });
});

enifed('@glimmer/object-model/lib/reference.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object-model/lib');
    QUnit.test('@glimmer/object-model/lib/reference.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object-model/lib/reference.ts should pass tslint.');
    });
});

enifed('@glimmer/object-model/tests/classof-test', ['exports', '@glimmer/object-model/index'], function (exports, _glimmerObjectModelIndex) {
    'use strict';

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    QUnit.module('[glimmer-object-model] classof');
    QUnit.test('basic usage', function (assert) {
        var Person = _glimmerObjectModelIndex.default.extend({
            named: 'Dan'
        });
        var PersonClass = _glimmerObjectModelIndex.classof(Person);

        var FancyPerson = (function (_PersonClass) {
            _inherits(FancyPerson, _PersonClass);

            function FancyPerson() {
                _classCallCheck(this, FancyPerson);

                _PersonClass.apply(this, arguments);
            }

            FancyPerson.prototype.fullName = function fullName() {
                return this.salutation + ' ' + this.named;
            };

            return FancyPerson;
        })(PersonClass);

        var person = FancyPerson.create({ named: 'Dan', salutation: 'Mr.' });
        assert.equal(person.fullName(), 'Mr. Dan');
    });
});

enifed('@glimmer/object-model/tests/classof-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object-model/tests');
    QUnit.test('@glimmer/object-model/tests/classof-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object-model/tests/classof-test.ts should pass tslint.');
    });
});

enifed('@glimmer/object-model/tests/computed-test', ['exports', '@glimmer/object-model/index'], function (exports, _glimmerObjectModelIndex) {
    'use strict';

    QUnit.module('[glimmer-object-model] - computed properties');
    QUnit.test('basic computed properties', function (assert) {
        var Person = _glimmerObjectModelIndex.default.extend({
            first: 'Dan',
            last: 'Gebhardt',
            full: _glimmerObjectModelIndex.computed('first', 'last', {
                get: function () {
                    return this.first + ' ' + this.last;
                },
                set: function (value) {
                    var _value$split = value.split(' ');

                    var first = _value$split[0];
                    var last = _value$split[1];

                    this.first = first;
                    this.last = last;
                }
            })
        });
        var FancyPerson = Person.extend({
            sal: 'Mr.'
        });
        var obj = FancyPerson.create();
        assert.equal(obj.full, 'Dan Gebhardt');
        assert.equal(obj.sal, 'Mr.');
    });
    QUnit.test('references for computed properties', function (assert) {
        var Person = _glimmerObjectModelIndex.default.extend({
            first: 'Dan',
            last: 'Gebhardt',
            full: _glimmerObjectModelIndex.computed('first', 'last', {
                get: function () {
                    return this.first + ' ' + this.last;
                },
                set: function (value) {
                    var _value$split2 = value.split(' ');

                    var first = _value$split2[0];
                    var last = _value$split2[1];

                    this.first = first;
                    this.last = last;
                }
            })
        });
        var obj = Person.create();
        var ref = _glimmerObjectModelIndex.root(obj).get('full');
        var name = ref.value();
        var snapshot = ref.tag.value();
        assert.strictEqual(obj.full, 'Dan Gebhardt');
        _glimmerObjectModelIndex.set(obj, 'first', 'Daniel');
        assert.strictEqual(obj.full, 'Daniel Gebhardt');
        assert.strictEqual(ref.tag.validate(snapshot), false);
        assert.strictEqual(ref.value(), 'Daniel Gebhardt');
    });
    QUnit.test('references for multiple subclasses of computed properties', function (assert) {
        var Person = _glimmerObjectModelIndex.default.extend({
            first: 'Dan',
            last: 'Gebhardt',
            full: _glimmerObjectModelIndex.computed('first', 'last', {
                get: function () {
                    return this.first + ' ' + this.last;
                },
                set: function (value) {
                    var _value$split3 = value.split(' ');

                    var first = _value$split3[0];
                    var last = _value$split3[1];

                    this.first = first;
                    this.last = last;
                }
            })
        });
        var FancyPerson = Person.extend({
            sal: 'Mr.',
            name: _glimmerObjectModelIndex.computed('sal', 'full', {
                get: function () {
                    return this.sal + ' ' + this.full;
                },
                set: function (value) {
                    var _value$match = value.match(/([^ ]+) (.*)/);

                    var sal = _value$match[1];
                    var full = _value$match[2];

                    this.sal = sal;
                    this.full = full;
                }
            })
        });
        var obj = FancyPerson.create();
        var ref = _glimmerObjectModelIndex.root(obj).get('name');
        var name = ref.value();
        var snapshot = ref.tag.value();
        assert.strictEqual(obj.full, 'Dan Gebhardt');
        assert.strictEqual(obj.name, 'Mr. Dan Gebhardt');
        _glimmerObjectModelIndex.set(obj, 'first', 'Daniel');
        assert.strictEqual(obj.full, 'Daniel Gebhardt');
        assert.strictEqual(obj.name, 'Mr. Daniel Gebhardt');
        assert.strictEqual(ref.tag.validate(snapshot), false);
        assert.strictEqual(ref.value(), 'Mr. Daniel Gebhardt');
    });
});

enifed('@glimmer/object-model/tests/computed-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object-model/tests');
    QUnit.test('@glimmer/object-model/tests/computed-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object-model/tests/computed-test.ts should pass tslint.');
    });
});

enifed('@glimmer/object-model/tests/extend-test', ['exports', '@glimmer/object-model/index'], function (exports, _glimmerObjectModelIndex) {
    'use strict';

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    QUnit.module("[glimmer-object-model] extend");
    // NOTE: The fact that the following code passes the type checker
    // is a part of the tested functionality of this test suite.
    QUnit.test('basic create works', function (assert) {
        var obj = _glimmerObjectModelIndex.default.create({ name: 'hello' });
        assert.equal(obj.name, 'hello');
    });
    QUnit.test('basic extend works', function (assert) {
        var Sub = _glimmerObjectModelIndex.default.extend();
        var obj = Sub.create({ name: 'hello' });
        assert.equal(obj.name, 'hello');
    });
    QUnit.test('repeating extend works', function (assert) {
        var Sub = _glimmerObjectModelIndex.default.extend().extend();
        var obj = Sub.create({ name: 'hello' });
        assert.equal(obj.name, 'hello');
    });
    QUnit.test('extending with new properties works', function (assert) {
        var Sub = _glimmerObjectModelIndex.default.extend({
            parentName: 'hi'
        });
        var obj = Sub.create({ name: 'hello' });
        assert.equal(obj.name, 'hello');
        assert.equal(obj.parentName, 'hi');
    });
    QUnit.test('extending with methods works', function (assert) {
        var Sub = _glimmerObjectModelIndex.default.extend({
            hi: function () {
                return this.name;
            }
        });
        var obj = Sub.create({ name: 'Dan' });
        assert.equal(obj.hi(), 'Dan');
    });
    QUnit.test('extending multiple times with new functionality each time works', function (assert) {
        var First = _glimmerObjectModelIndex.default.extend({
            name: 'Dan'
        });
        var Second = First.extend({
            hi: function () {
                return 'Hi ' + this.salutation + ' ' + this.name;
            }
        });
        var Sub = Second.extend({
            greet: function () {
                return this.hi().toUpperCase();
            }
        });
        var obj = Sub.create({ salutation: 'Mr.' });
        assert.equal(obj.greet(), 'HI MR. DAN');
    });
    QUnit.test('mixing ES6 subclassing with ES5 subclassing', function (assert) {
        var First = _glimmerObjectModelIndex.default.extend({
            named: 'Dan'
        });
        /// TS GUNK: START
        var FirstClass = _glimmerObjectModelIndex.classof(First);
        /// TS GUNK: END

        var Second = (function (_FirstClass) {
            _inherits(Second, _FirstClass);

            function Second() {
                _classCallCheck(this, Second);

                _FirstClass.apply(this, arguments);
            }

            Second.prototype.hi = function hi() {
                return 'Hi ' + this.salutation + ' ' + this.named;
            };

            return Second;
        })(FirstClass);

        var Sub = (function (_Second) {
            _inherits(Sub, _Second);

            function Sub() {
                _classCallCheck(this, Sub);

                _Second.apply(this, arguments);
            }

            Sub.prototype.greet = function greet() {
                return this.hi().toUpperCase();
            };

            return Sub;
        })(Second);

        var obj = Sub.create({ salutation: 'Mr.' });
        assert.equal(obj.greet(), 'HI MR. DAN');
    });
});

enifed('@glimmer/object-model/tests/extend-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object-model/tests');
    QUnit.test('@glimmer/object-model/tests/extend-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object-model/tests/extend-test.ts should pass tslint.');
    });
});

enifed('@glimmer/object-model/tests/reference-test', ['exports', '@glimmer/object-model/index'], function (exports, _glimmerObjectModelIndex) {
    'use strict';

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    QUnit.module('[glimmer-object-model] reference');
    function MakeSub() {
        var Sub = _glimmerObjectModelIndex.classof(_glimmerObjectModelIndex.default.extend({
            name: 'Dan'
        }));
        var SubSub = _glimmerObjectModelIndex.classof(Sub.extend({
            sal: 'Mr.'
        }));
        var obj = Sub.create();
        var root = _glimmerObjectModelIndex.root(obj);
        var name = root.get('name');
        return { Sub: Sub, SubSub: SubSub, root: root, obj: obj, name: name };
    }
    QUnit.test('getting a reference', function (assert) {
        var _MakeSub = MakeSub();

        var root = _MakeSub.root;
        var obj = _MakeSub.obj;
        var name = _MakeSub.name;

        assert.strictEqual(root.value(), obj);
        assert.strictEqual(name.value(), 'Dan');
    });
    QUnit.test('unchanged references are valid', function (assert) {
        var _MakeSub2 = MakeSub();

        var root = _MakeSub2.root;
        var obj = _MakeSub2.obj;
        var name = _MakeSub2.name;

        var dan = name.value();
        var nameTag = name.tag;
        var initialSnapshot = nameTag.value();
        assert.strictEqual(name.value(), dan);
        assert.strictEqual(nameTag.validate(initialSnapshot), true);
    });
    QUnit.test('changed references are invalid', function (assert) {
        var _MakeSub3 = MakeSub();

        var root = _MakeSub3.root;
        var obj = _MakeSub3.obj;
        var name = _MakeSub3.name;

        var nameTag = name.tag;
        var initialSnapshot = nameTag.value();
        _glimmerObjectModelIndex.set(obj, 'name', 'Daniel');
        assert.strictEqual(nameTag.validate(initialSnapshot), false);
        assert.strictEqual(name.value(), 'Daniel');
    });

    var Bucket = function Bucket(name, sal, loud) {
        _classCallCheck(this, Bucket);

        this.name = name;
        this.sal = sal;
        this.loud = loud;
    };

    var State = (function () {
        function State(root) {
            _classCallCheck(this, State);

            this.references = {
                name: root.get('name'),
                sal: root.get('sal'),
                loud: root.get('loud')
            };
            this.update();
        }

        State.prototype.updateValues = function updateValues() {
            this.values = {
                name: this.references.name.value(),
                sal: this.references.sal.value(),
                loud: this.references.loud.value()
            };
        };

        State.prototype.updateTags = function updateTags() {
            this.tags = {
                name: this.references.name.tag,
                sal: this.references.sal.tag,
                loud: this.references.loud.tag
            };
        };

        State.prototype.updateSnapshot = function updateSnapshot() {
            this.snapshot = {
                name: this.tags.name.value(),
                sal: this.tags.sal.value(),
                loud: this.tags.loud.value()
            };
        };

        State.prototype.update = function update() {
            this.updateValues();
            this.updateTags();
            this.updateSnapshot();
        };

        State.prototype.validateTags = function validateTags(_ref) {
            var _ref$name = _ref.name;
            var name = _ref$name === undefined ? true : _ref$name;
            var _ref$sal = _ref.sal;
            var sal = _ref$sal === undefined ? true : _ref$sal;
            var _ref$loud = _ref.loud;
            var loud = _ref$loud === undefined ? true : _ref$loud;

            QUnit.assert.strictEqual(this.tags.name.validate(this.snapshot.name), name, 'valid(name) != ' + name);
            QUnit.assert.strictEqual(this.tags.sal.validate(this.snapshot.sal), sal, 'valid(sal) != ' + sal);
            QUnit.assert.strictEqual(this.tags.loud.validate(this.snapshot.loud), loud, 'valid(loud) != ' + loud);
            this.updateTags();
        };

        State.prototype.validateValues = function validateValues(_ref2) {
            var _ref2$name = _ref2.name;
            var name = _ref2$name === undefined ? this.values.name : _ref2$name;
            var _ref2$sal = _ref2.sal;
            var sal = _ref2$sal === undefined ? this.values.sal : _ref2$sal;
            var _ref2$loud = _ref2.loud;
            var loud = _ref2$loud === undefined ? this.values.loud : _ref2$loud;

            QUnit.assert.strictEqual(this.references.name.value(), name, 'name != ' + name);
            QUnit.assert.strictEqual(this.references.sal.value(), sal, 'sal != ' + sal);
            QUnit.assert.strictEqual(this.references.loud.value(), loud, 'loud != ' + loud);
            this.updateValues();
        };

        return State;
    })();

    QUnit.test('references are granular', function (assert) {
        var _MakeSub4 = MakeSub();

        var SubSub = _MakeSub4.SubSub;

        var obj = SubSub.create({ loud: true });
        var root = _glimmerObjectModelIndex.root(obj);
        var state = new State(root);
        _glimmerObjectModelIndex.set(obj, 'name', 'Daniel');
        step('Update name');
        state.validateTags({ name: false });
        state.validateValues({ name: 'Daniel' });
        state.update();
        _glimmerObjectModelIndex.set(obj, 'loud', false);
        step('Update loud');
        state.validateTags({ loud: false });
        state.validateValues({ loud: false });
        state.update();
    });
    QUnit.test('works with ES6 subclassing', function (assert) {
        var _MakeSub5 = MakeSub();

        var Sub = _MakeSub5.Sub;

        var SubSub = (function (_Sub) {
            _inherits(SubSub, _Sub);

            function SubSub() {
                _classCallCheck(this, SubSub);

                _Sub.apply(this, arguments);
            }

            return SubSub;
        })(Sub);

        var obj = SubSub.create({ loud: true, sal: 'Mr.' });
        var root = _glimmerObjectModelIndex.root(obj);
        var state = new State(root);
        _glimmerObjectModelIndex.set(obj, 'name', 'Daniel');
        step('Update name');
        state.validateTags({ name: false });
        state.validateValues({ name: 'Daniel' });
        state.update();
        _glimmerObjectModelIndex.set(obj, 'loud', false);
        step('Update loud');
        state.validateTags({ loud: false });
        state.validateValues({ loud: false });
        state.update();
    });
    function step(desc) {
        QUnit.assert.ok(true, desc);
    }
});

enifed('@glimmer/object-model/tests/reference-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object-model/tests');
    QUnit.test('@glimmer/object-model/tests/reference-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object-model/tests/reference-test.ts should pass tslint.');
    });
});

enifed('@glimmer/object-reference/index.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object-reference');
    QUnit.test('@glimmer/object-reference/index.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object-reference/index.ts should pass tslint.');
    });
});

enifed('@glimmer/object-reference/lib/meta.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object-reference/lib');
    QUnit.test('@glimmer/object-reference/lib/meta.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object-reference/lib/meta.ts should pass tslint.');
    });
});

enifed('@glimmer/object-reference/lib/object.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object-reference/lib');
    QUnit.test('@glimmer/object-reference/lib/object.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object-reference/lib/object.ts should pass tslint.');
    });
});

enifed('@glimmer/object-reference/lib/references/descriptors.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object-reference/lib/references');
    QUnit.test('@glimmer/object-reference/lib/references/descriptors.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object-reference/lib/references/descriptors.ts should pass tslint.');
    });
});

enifed('@glimmer/object-reference/lib/references/path.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object-reference/lib/references');
    QUnit.test('@glimmer/object-reference/lib/references/path.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object-reference/lib/references/path.ts should pass tslint.');
    });
});

enifed('@glimmer/object-reference/lib/references/root.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object-reference/lib/references');
    QUnit.test('@glimmer/object-reference/lib/references/root.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object-reference/lib/references/root.ts should pass tslint.');
    });
});

enifed('@glimmer/object-reference/lib/types.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object-reference/lib');
    QUnit.test('@glimmer/object-reference/lib/types.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object-reference/lib/types.ts should pass tslint.');
    });
});

enifed('@glimmer/object-reference/lib/utils.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object-reference/lib');
    QUnit.test('@glimmer/object-reference/lib/utils.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object-reference/lib/utils.ts should pass tslint.');
    });
});

enifed("@glimmer/object-reference/tests/iterable-test", ["exports"], function (exports) {
  "use strict";
});

enifed('@glimmer/object-reference/tests/iterable-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object-reference/tests');
    QUnit.test('@glimmer/object-reference/tests/iterable-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object-reference/tests/iterable-test.ts should pass tslint.');
    });
});

enifed("@glimmer/object-reference/tests/reference-test", ["exports", "@glimmer/object-reference"], function (exports, _glimmerObjectReference) {
    "use strict";

    //function computed(obj, name, getter, depStrings) {
    //Object.defineProperty(obj, name, {
    //enumerable: true,
    //configurable: true,
    //get: getter
    //});
    //let deps = depStrings.map(d => d.split('.'));
    //[>jshint -W064<]
    //Meta.for(obj).addReferenceTypeFor(name, ComputedBlueprint(name, deps)); [>jshint +W064<]
    //}
    function addObserver(obj, name, path) {
        return _glimmerObjectReference.metaFor(obj).root().referenceFromParts(path.split('.'));
    }
    QUnit.module("references");
    QUnit.test("basic reference data flow", function () {
        var obj1 = { label: "obj1", model: { person: { name: { first: "Yehuda", last: "Katz" } } } };
        var obj2 = { label: "obj2", model: { person: { name: obj1.model.person.name } } };
        var obj3 = { label: "obj3", model: { person: obj1.model.person } };
        var obj4 = { label: "obj4", model: obj1.model };
        var originalPerson = obj1.model.person;
        var o1 = [addObserver(obj1, 'obj1', 'model.person.name.first'), addObserver(obj1.model, 'obj1.model', 'person.name.first'), addObserver(obj1.model.person, 'obj1.model.person', 'name.first'), addObserver(obj1.model.person.name, 'obj1.model.person.name', 'first')];
        var o2 = [addObserver(obj2, 'obj2', 'model.person.name.first'), addObserver(obj2.model, 'obj2.model', 'person.name.first'), addObserver(obj2.model.person, 'obj2.model.person', 'name.first'), addObserver(obj2.model.person.name, 'obj2.model.person.name', 'first')];
        var o3 = [addObserver(obj3, 'obj3', 'model.person.name.first'), addObserver(obj3.model, 'obj3.model', 'person.name.first'), addObserver(obj3.model.person, 'obj3.model.person', 'name.first'), addObserver(obj3.model.person.name, 'obj3.model.person.name', 'first')];
        var o4 = [addObserver(obj4, 'obj4', 'model.person.name.first'), addObserver(obj4.model, 'obj4.model', 'person.name.first'), addObserver(obj4.model.person, 'obj4.model.person', 'name.first'), addObserver(obj4.model.person.name, 'obj4.model.person.name', 'first')];
        allDirty(o1, "Yehuda");
        allDirty(o2, "Yehuda");
        allDirty(o3, "Yehuda");
        allDirty(o4, "Yehuda");
        allClean(o1);
        allClean(o2);
        allClean(o3);
        allClean(o4);
        _glimmerObjectReference.setProperty(obj1.model, 'person', { name: { first: 'Godfrey', last: 'Chan' } });
        isDirty(o1[0], "Godfrey");
        isDirty(o1[1], "Godfrey");
        isClean(o1[2]);
        isClean(o1[3]);
        allClean(o2);
        allClean(o3);
        isDirty(o4[0], "Godfrey");
        isDirty(o4[1], "Godfrey");
        isClean(o4[2]);
        isClean(o4[3]);
        _glimmerObjectReference.setProperty(originalPerson.name, 'first', "Godhuda");
        isClean(o1[0]);
        isClean(o1[1]);
        isDirty(o1[2], "Godhuda");
        isDirty(o1[3], "Godhuda");
        allDirty(o2, "Godhuda");
        allDirty(o3, "Godhuda");
        isClean(o4[0]);
        isClean(o4[1]);
        isDirty(o4[2], "Godhuda");
        isDirty(o4[3], "Godhuda");
        _glimmerObjectReference.setProperty(obj1.model, 'person', undefined);
        isDirty(o1[0], undefined);
        isDirty(o1[1], undefined);
        isClean(o1[2]);
        isClean(o1[3]);
        allClean(o2);
        allClean(o3);
        isDirty(o4[0], undefined);
        isDirty(o4[1], undefined);
        isClean(o4[2]);
        isClean(o4[3]);
        _glimmerObjectReference.setProperty(obj1.model, 'person', originalPerson);
        isDirty(o1[0], "Godhuda");
        isDirty(o1[1], "Godhuda");
        isClean(o1[2]);
        isClean(o1[3]);
        allClean(o2);
        allClean(o3);
        isDirty(o4[0], "Godhuda");
        isDirty(o4[1], "Godhuda");
        isClean(o4[2]);
        isClean(o4[3]);
    });
    QUnit.test("test data flow that goes through primitive wrappers", function () {
        var obj1 = { label: "obj1", model: { person: { name: { first: "Yehuda", last: "Katz" } } } };
        var obj2 = { label: "obj2", model: { person: { name: obj1.model.person.name } } };
        var obj3 = { label: "obj3", model: { person: obj1.model.person } };
        var obj4 = { label: "obj4", model: obj1.model };
        var originalPerson = obj1.model.person;
        var o1 = [addObserver(obj1, 'obj1', 'model.person.name.first.length'), addObserver(obj1.model, 'obj1.model', 'person.name.first.length'), addObserver(obj1.model.person, 'obj1.model.person', 'name.first.length'), addObserver(obj1.model.person.name, 'obj1.model.person.name', 'first.length')];
        var o2 = [addObserver(obj2, 'obj2', 'model.person.name.first.length'), addObserver(obj2.model, 'obj2.model', 'person.name.first.length'), addObserver(obj2.model.person, 'obj2.model.person', 'name.first.length'), addObserver(obj2.model.person.name, 'obj2.model.person.name', 'first.length')];
        var o3 = [addObserver(obj3, 'obj3', 'model.person.name.first.length'), addObserver(obj3.model, 'obj3.model', 'person.name.first.length'), addObserver(obj3.model.person, 'obj3.model.person', 'name.first.length'), addObserver(obj3.model.person.name, 'obj3.model.person.name', 'first.length')];
        var o4 = [addObserver(obj4, 'obj4', 'model.person.name.first.length'), addObserver(obj4.model, 'obj4.model', 'person.name.first.length'), addObserver(obj4.model.person, 'obj4.model.person', 'name.first.length'), addObserver(obj4.model.person.name, 'obj4.model.person.name', 'first.length')];
        allDirty(o1, 6);
        allDirty(o2, 6);
        allDirty(o3, 6);
        allDirty(o4, 6);
        allClean(o1);
        allClean(o2);
        allClean(o3);
        allClean(o4);
        _glimmerObjectReference.setProperty(obj1.model, 'person', { name: { first: 'Godfrey', last: 'Chan' } });
        isDirty(o1[0], 7);
        isDirty(o1[1], 7);
        isClean(o1[2]);
        isClean(o1[3]);
        allClean(o2);
        allClean(o3);
        isDirty(o4[0], 7);
        isDirty(o4[1], 7);
        isClean(o4[2]);
        isClean(o4[3]);
        _glimmerObjectReference.setProperty(originalPerson.name, 'first', "God-huda");
        isClean(o1[0]);
        isClean(o1[1]);
        isDirty(o1[2], 8);
        isDirty(o1[3], 8);
        allDirty(o2, 8);
        allDirty(o3, 8);
        isClean(o4[0]);
        isClean(o4[1]);
        isDirty(o4[2], 8);
        isDirty(o4[3], 8);
        _glimmerObjectReference.setProperty(obj1.model, 'person', undefined);
        isDirty(o1[0], undefined);
        isDirty(o1[1], undefined);
        isClean(o1[2]);
        isClean(o1[3]);
        allClean(o2);
        allClean(o3);
        isDirty(o4[0], undefined);
        isDirty(o4[1], undefined);
        isClean(o4[2]);
        isClean(o4[3]);
        _glimmerObjectReference.setProperty(obj1.model, 'person', originalPerson);
        isDirty(o1[0], 8);
        isDirty(o1[1], 8);
        isClean(o1[2]);
        isClean(o1[3]);
        allClean(o2);
        allClean(o3);
        isDirty(o4[0], 8);
        isDirty(o4[1], 8);
        isClean(o4[2]);
        isClean(o4[3]);
    });
    function isDirty(ref, newValue) {
        // ok(ref.isDirty(), ref.label() + " is dirty");
        ok(ref.value() === newValue, ref.label() + " has new value " + newValue);
    }
    function isClean(ref) {
        // clean references are allowed to report dirty
    }
    function allDirty(refs, newValue) {
        refs.forEach(function (ref) {
            isDirty(ref, newValue);
        });
    }
    function allClean(refs) {
        refs.forEach(function (ref) {
            isClean(ref);
        });
    }
});

enifed('@glimmer/object-reference/tests/reference-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object-reference/tests');
    QUnit.test('@glimmer/object-reference/tests/reference-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object-reference/tests/reference-test.ts should pass tslint.');
    });
});

enifed('@glimmer/object/index.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object');
    QUnit.test('@glimmer/object/index.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/index.ts should pass tslint.');
    });
});

enifed('@glimmer/object/lib/computed.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object/lib');
    QUnit.test('@glimmer/object/lib/computed.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/lib/computed.ts should pass tslint.');
    });
});

enifed('@glimmer/object/lib/descriptors.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object/lib');
    QUnit.test('@glimmer/object/lib/descriptors.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/lib/descriptors.ts should pass tslint.');
    });
});

enifed('@glimmer/object/lib/mixin.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object/lib');
    QUnit.test('@glimmer/object/lib/mixin.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/lib/mixin.ts should pass tslint.');
    });
});

enifed('@glimmer/object/lib/object.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object/lib');
    QUnit.test('@glimmer/object/lib/object.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/lib/object.ts should pass tslint.');
    });
});

enifed('@glimmer/object/lib/utils.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object/lib');
    QUnit.test('@glimmer/object/lib/utils.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/lib/utils.ts should pass tslint.');
    });
});

enifed('@glimmer/object/tests/ember-computed-test', ['exports', '@glimmer/object'], function (exports, _glimmerObject) {
    'use strict';

    var emberGet = function aget(x, y) {
        return x[y];
    };
    var emberSet = function aset(x, y, z) {
        return x[y] = z;
    };
    function testWithDefault(name, callback) {
        QUnit.test(name, function (assert) {
            callback(emberGet, emberSet);
        });
    }
    var EmberObject = _glimmerObject.default;
    function K() {
        return this;
    }
    QUnit.module('GlimmerObject.extend - Computed Properties');
    testWithDefault('computed property on instance', function (get, set) {
        var MyClass = EmberObject.extend({
            foo: _glimmerObject.computed(function () {
                return 'FOO';
            })
        });
        equal(get(new MyClass(), 'foo'), 'FOO');
    });
    testWithDefault('computed property on subclass', function (get, set) {
        var MyClass = EmberObject.extend({
            foo: _glimmerObject.computed(function () {
                return 'FOO';
            })
        });
        var Subclass = MyClass.extend({
            foo: _glimmerObject.computed(function () {
                return 'BAR';
            })
        });
        equal(get(new Subclass(), 'foo'), 'BAR');
    });
    testWithDefault('replacing computed property with regular val', function (get, set) {
        var MyClass = EmberObject.extend({
            foo: _glimmerObject.computed(function () {
                return 'FOO';
            })
        });
        var Subclass = MyClass.extend({
            foo: 'BAR'
        });
        equal(get(new Subclass(), 'foo'), 'BAR');
    });
    testWithDefault('complex dependent keys', function (get, set) {
        var MyClass = EmberObject.extend({
            init: function () {
                this._super.apply(this, arguments);
                set(this, 'bar', { baz: 'BIFF' });
            },
            foo: _glimmerObject.computed(function () {
                return get(get(this, 'bar'), 'baz');
            }).property('bar.baz')
        });
        var Subclass = MyClass.extend({});
        var obj1 = new MyClass();
        var obj2 = new Subclass();
        equal(get(obj1, 'foo'), 'BIFF');
        equal(get(obj2, 'foo'), 'BIFF');
        set(get(obj1, 'bar'), 'baz', 'BLARG');
        equal(get(obj1, 'foo'), 'BLARG');
        equal(get(obj2, 'foo'), 'BIFF');
        set(get(obj2, 'bar'), 'baz', 'BOOM');
        equal(get(obj1, 'foo'), 'BLARG');
        equal(get(obj2, 'foo'), 'BOOM');
    });
    testWithDefault('complex dependent keys changing complex dependent keys', function (get, set) {
        var MyClass = EmberObject.extend({
            init: function () {
                this._super.apply(this, arguments);
                set(this, 'bar', { baz: 'BIFF' });
            },
            foo: _glimmerObject.computed(function () {
                return get(get(this, 'bar'), 'baz');
            }).property('bar.baz')
        });
        var Subclass = MyClass.extend({
            init: function () {
                this._super.apply(this, arguments);
                set(this, 'bar2', { baz: 'BIFF2' });
            },
            foo: _glimmerObject.computed(function () {
                return get(get(this, 'bar2'), 'baz');
            }).property('bar2.baz')
        });
        var obj2 = new Subclass();
        equal(get(obj2, 'foo'), 'BIFF2');
        set(get(obj2, 'bar'), 'baz', 'BLARG');
        equal(get(obj2, 'foo'), 'BIFF2', 'should not invalidate property');
        set(get(obj2, 'bar2'), 'baz', 'BLARG');
        equal(get(obj2, 'foo'), 'BLARG', 'should invalidate property');
    });
    QUnit.test('can retrieve metadata for a computed property', function (assert) {
        var MyClass = EmberObject.extend({
            computedProperty: _glimmerObject.computed(function () {}).meta({ key: 'keyValue' })
        });
        equal(emberGet(MyClass.metaForProperty('computedProperty'), 'key'), 'keyValue', 'metadata saved on the computed property can be retrieved');
        var ClassWithNoMetadata = EmberObject.extend({
            computedProperty: _glimmerObject.computed(function () {}).volatile(),
            staticProperty: 12
        });
        equal(typeof ClassWithNoMetadata.metaForProperty('computedProperty'), 'object', 'returns empty hash if no metadata has been saved');
        assert.throws(function () {
            ClassWithNoMetadata.metaForProperty('nonexistentProperty');
        }, 'metaForProperty() could not find a computed property with key \'nonexistentProperty\'.');
        assert.throws(function () {
            ClassWithNoMetadata.metaForProperty('staticProperty');
        }, 'metaForProperty() could not find a computed property with key \'staticProperty\'.');
    });
    QUnit.test('can iterate over a list of computed properties for a class', function () {
        var MyClass = EmberObject.extend({
            foo: _glimmerObject.computed(function () {}),
            fooDidChange: _glimmerObject.observer('foo', function () {}),
            bar: _glimmerObject.computed(function () {}),
            qux: _glimmerObject.alias('foo')
        });
        var SubClass = MyClass.extend({
            baz: _glimmerObject.computed(function () {})
        });
        SubClass.reopen({
            bat: _glimmerObject.computed(function () {}).meta({ iAmBat: true })
        });
        var list = [];
        MyClass.eachComputedProperty(function (name) {
            list.push(name);
        });
        deepEqual(list.sort(), ['bar', 'foo', 'qux'], 'watched and unwatched computed properties are iterated');
        list = [];
        SubClass.eachComputedProperty(function (name, meta) {
            list.push(name);
            if (name === 'bat') {
                deepEqual(meta, { iAmBat: true });
            } else {
                deepEqual(meta, {});
            }
        });
        deepEqual(list.sort(), ['bar', 'bat', 'baz', 'foo', 'qux'], 'all inherited properties are included');
    });
    QUnit.test('list of properties updates when an additional property is added (such cache busting)', function () {
        var MyClass = EmberObject.extend({
            foo: _glimmerObject.computed(K),
            fooDidChange: _glimmerObject.observer('foo', function () {}),
            bar: _glimmerObject.computed(K)
        });
        var list = [];
        MyClass.eachComputedProperty(function (name) {
            list.push(name);
        });
        deepEqual(list.sort(), ['bar', 'foo'].sort(), 'expected two computed properties');
        MyClass.reopen({
            baz: _glimmerObject.computed(K)
        });
        MyClass.create(); // force apply mixins
        list = [];
        MyClass.eachComputedProperty(function (name) {
            list.push(name);
        });
        deepEqual(list.sort(), ['bar', 'foo', 'baz'].sort(), 'expected three computed properties');
    });
    QUnit.test('Calling _super in call outside the immediate function of a CP getter works', function () {
        function macro(callback) {
            return _glimmerObject.computed(function () {
                return callback.call(this);
            });
        }
        var MyClass = EmberObject.extend({
            foo: _glimmerObject.computed(function () {
                return 'FOO';
            })
        });
        var SubClass = MyClass.extend({
            foo: macro(function () {
                return this._super();
            })
        });
        equal(emberGet(SubClass.create(), 'foo'), 'FOO', 'super value is fetched');
    });
    QUnit.test('Calling _super in apply outside the immediate function of a CP getter works', function () {
        function macro(callback) {
            return _glimmerObject.computed(function () {
                return callback.apply(this);
            });
        }
        var MyClass = EmberObject.extend({
            foo: _glimmerObject.computed(function () {
                return 'FOO';
            })
        });
        var SubClass = MyClass.extend({
            foo: macro(function () {
                return this._super();
            })
        });
        equal(emberGet(SubClass.create(), 'foo'), 'FOO', 'super value is fetched');
    });
});

enifed('@glimmer/object/tests/ember-computed-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object/tests');
    QUnit.test('@glimmer/object/tests/ember-computed-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/tests/ember-computed-test.ts should pass tslint.');
    });
});

enifed('@glimmer/object/tests/ember-create-test', ['exports', '@glimmer/object', '@glimmer/test-helpers'], function (exports, _glimmerObject, _glimmerTestHelpers) {
    'use strict';

    var _templateObject = _taggedTemplateLiteralLoose(['Ember.Object.create no longer supports defining computed properties.\n           Define computed properties using extend() or reopen() before calling create().'], ['Ember.Object.create no longer supports defining computed properties.\n           Define computed properties using extend() or reopen() before calling create().']);

    function _taggedTemplateLiteralLoose(strings, raw) { strings.raw = raw; return strings; }

    var moduleOptions = undefined;
    QUnit.module('GlimmerObject.create', moduleOptions);
    QUnit.test('simple properties are set', function () {
        var o = _glimmerObject.default.create({ ohai: 'there' });
        equal(o.get('ohai'), 'there');
    });
    QUnit.test('reopening a parent flushes the child', function (assert) {
        var MyClass = _glimmerObject.default.extend();
        var SubClass = MyClass.extend();
        MyClass.reopen({
            hello: function () {
                return "hello";
            }
        });
        var sub = SubClass.create();
        assert.equal(sub.hello(), "hello");
    });
    QUnit.test('reopening a parent flushes the child', function (assert) {
        var MyClass = _glimmerObject.default.extend({
            hello: function () {
                return "original hello";
            }
        });
        var SubClass = MyClass.extend({
            hello: function () {
                return this._super();
            }
        });
        var GrandChild = SubClass.extend({
            hello: function () {
                return this._super();
            }
        });
        MyClass.reopen({
            hello: function () {
                return this._super() + " new hello";
            }
        });
        var sub = GrandChild.create();
        assert.equal(sub.hello(), "original hello new hello");
    });
    QUnit.test('reopening a parent with a computed property flushes the child', function (assert) {
        var MyClass = _glimmerObject.default.extend({
            hello: _glimmerObject.computed(function () {
                return "original hello";
            })
        });
        var SubClass = MyClass.extend({
            hello: _glimmerObject.computed(function () {
                return this._super();
            })
        });
        var GrandChild = SubClass.extend({
            hello: _glimmerObject.computed(function () {
                return this._super();
            })
        });
        MyClass.reopen({
            hello: _glimmerObject.computed(function () {
                return this._super() + " new hello";
            })
        });
        var sub = GrandChild.create();
        assert.equal(sub.hello, "original hello new hello");
    });
    QUnit.test('calls computed property setters', function (assert) {
        var MyClass = _glimmerObject.default.extend({
            foo: _glimmerObject.computed({
                get: function () {
                    return 'this is not the value you\'re looking for';
                },
                set: function (key, value) {
                    return value;
                }
            })
        });
        var o = MyClass.create({ foo: 'bar' });
        assert.equal(o.get('foo'), 'bar');
    });
    QUnit.skip('allows bindings to be defined', function () {
        var obj = _glimmerObject.default.create({
            foo: 'foo',
            barBinding: 'foo'
        });
        equal(obj.get('bar'), 'foo', 'The binding value is correct');
    });
    QUnit.skip('calls setUnknownProperty if defined', function () {
        var setUnknownPropertyCalled = false;
        var MyClass = _glimmerObject.default.extend({
            setUnknownProperty: function (key, value) {
                setUnknownPropertyCalled = true;
            }
        });
        MyClass.create({ foo: 'bar' });
        ok(setUnknownPropertyCalled, 'setUnknownProperty was called');
    });
    QUnit.skip('throws if you try to define a computed property', function (assert) {
        assert.throws(function () {
            _glimmerObject.default.create({
                foo: _glimmerObject.computed(function () {})
            });
        }, _glimmerTestHelpers.strip(_templateObject));
    });
    QUnit.skip('throws if you try to call _super in a method', function (assert) {
        assert.throws(function () {
            _glimmerObject.default.create({
                foo: function () {
                    this._super.apply(this, arguments);
                }
            });
        }, 'Ember.Object.create no longer supports defining methods that call _super.');
    });
    QUnit.skip('throws if you try to \'mixin\' a definition', function (assert) {
        var myMixin = _glimmerObject.Mixin.create({
            adder: function (arg1, arg2) {
                return arg1 + arg2;
            }
        });
        assert.throws(function () {
            _glimmerObject.default.create(myMixin);
        }, 'Ember.Object.create no longer supports mixing in other definitions, use .extend & .create seperately instead.');
    });
    // This test is for IE8.
    QUnit.test('property name is the same as own prototype property', function () {
        var MyClass = _glimmerObject.default.extend({
            toString: function () {
                return 'MyClass';
            }
        });
        equal(MyClass.create().toString(), 'MyClass', 'should inherit property from the arguments of `EmberObject.create`');
    });
    QUnit.test('inherits properties from passed in EmberObject', function () {
        var baseObj = _glimmerObject.default.create({ foo: 'bar' });
        var secondaryObj = _glimmerObject.default.create(baseObj);
        equal(secondaryObj['foo'], baseObj['foo'], 'Em.O.create inherits properties from EmberObject parameter');
    });
    QUnit.skip('throws if you try to pass anything a string as a parameter', function () {
        var expected = 'EmberObject.create only accepts an objects.';
        throws(function () {
            _glimmerObject.default.create('some-string');
        }, expected);
    });
    QUnit.skip('EmberObject.create can take undefined as a parameter', function () {
        var o = _glimmerObject.default.create(undefined);
        deepEqual(_glimmerObject.default.create(), o);
    });
    QUnit.skip('EmberObject.create can take null as a parameter', function () {
        var o = _glimmerObject.default.create(null);
        deepEqual(_glimmerObject.default.create(), o);
    });
});

enifed('@glimmer/object/tests/ember-create-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object/tests');
    QUnit.test('@glimmer/object/tests/ember-create-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/tests/ember-create-test.ts should pass tslint.');
    });
});

enifed('@glimmer/object/tests/ember-extend-test', ['exports', '@glimmer/object'], function (exports, _glimmerObject) {
    'use strict';

    QUnit.module('GlimmerObject.extend');
    QUnit.test('Basic extend', function () {
        var SomeClass = _glimmerObject.default.extend({ foo: 'BAR' });
        ok(SomeClass.isClass, 'A class has isClass of true');
        var obj = new SomeClass();
        equal(obj.foo, 'BAR');
    });
    QUnit.test('Sub-subclass', function () {
        var SomeClass = _glimmerObject.default.extend({ foo: 'BAR' });
        var AnotherClass = SomeClass.extend({ bar: 'FOO' });
        var obj = new AnotherClass();
        equal(obj.foo, 'BAR');
        equal(obj.bar, 'FOO');
    });
    QUnit.test('Overriding a method several layers deep', function () {
        var SomeClass = _glimmerObject.default.extend({
            fooCnt: 0,
            foo: function () {
                this.fooCnt++;
            },
            barCnt: 0,
            bar: function () {
                this.barCnt++;
            }
        });
        var AnotherClass = SomeClass.extend({
            barCnt: 0,
            bar: function () {
                this.barCnt++;
                this._super.apply(this, arguments);
            }
        });
        var FinalClass = AnotherClass.extend({
            fooCnt: 0,
            foo: function () {
                this.fooCnt++;
                this._super.apply(this, arguments);
            }
        });
        var obj = new FinalClass();
        obj.foo();
        obj.bar();
        equal(obj.fooCnt, 2, 'should invoke both');
        equal(obj.barCnt, 2, 'should invoke both');
        // Try overriding on create also
        obj = FinalClass.extend({
            foo: function () {
                this.fooCnt++;
                this._super.apply(this, arguments);
            }
        }).create();
        obj.foo();
        obj.bar();
        equal(obj.fooCnt, 3, 'should invoke final as well');
        equal(obj.barCnt, 2, 'should invoke both');
    });
    QUnit.test('With concatenatedProperties', function () {
        var SomeClass = _glimmerObject.default.extend({ things: 'foo', concatenatedProperties: ['things'] });
        var AnotherClass = SomeClass.extend({ things: 'bar' });
        var YetAnotherClass = SomeClass.extend({ things: 'baz' });
        var some = new SomeClass();
        var another = new AnotherClass();
        var yetAnother = new YetAnotherClass();
        deepEqual(some.get('things'), ['foo'], 'base class should have just its value');
        deepEqual(another.get('things'), ['foo', 'bar'], 'subclass should have base class\' and its own');
        deepEqual(yetAnother.get('things'), ['foo', 'baz'], 'subclass should have base class\' and its own');
    });
    function get(obj, key) {
        return obj[key];
    }
    QUnit.test('With concatenatedProperties class properties', function () {
        var SomeClass = _glimmerObject.default.extend();
        SomeClass.reopenClass({
            concatenatedProperties: ['things'],
            things: 'foo'
        });
        var AnotherClass = SomeClass.extend();
        AnotherClass.reopenClass({ things: 'bar' });
        var YetAnotherClass = SomeClass.extend();
        YetAnotherClass.reopenClass({ things: 'baz' });
        var some = new SomeClass();
        var another = new AnotherClass();
        var yetAnother = new YetAnotherClass();
        deepEqual(get(some.constructor, 'things'), ['foo'], 'base class should have just its value');
        deepEqual(get(another.constructor, 'things'), ['foo', 'bar'], 'subclass should have base class\' and its own');
        deepEqual(get(yetAnother.constructor, 'things'), ['foo', 'baz'], 'subclass should have base class\' and its own');
    });
});

enifed('@glimmer/object/tests/ember-extend-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object/tests');
    QUnit.test('@glimmer/object/tests/ember-extend-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/tests/ember-extend-test.ts should pass tslint.');
    });
});

enifed('@glimmer/object/tests/ember-metal-alias-method-test', ['exports', '@glimmer/object/tests/support', '@glimmer/object'], function (exports, _glimmerObjectTestsSupport, _glimmerObject) {
    'use strict';

    QUnit.module('Mixin.aliasMethod');
    function validateAliasMethod(obj) {
        equal(obj.fooMethod(), 'FOO', 'obj.fooMethod()');
        equal(obj.barMethod(), 'FOO', 'obj.barMethod should be a copy of foo');
    }
    QUnit.test('methods of another name are aliased when the mixin is applied', function () {
        var MyMixin = _glimmerObjectTestsSupport.Mixin.create({
            fooMethod: function () {
                return 'FOO';
            },
            barMethod: _glimmerObject.aliasMethod('fooMethod')
        });
        var obj = MyMixin.apply({});
        validateAliasMethod(obj);
    });
    QUnit.test('should follow aliasMethods all the way down', function () {
        var MyMixin = _glimmerObjectTestsSupport.Mixin.create({
            bar: _glimmerObject.aliasMethod('foo'),
            baz: function () {
                return 'baz';
            },
            foo: _glimmerObject.aliasMethod('baz')
        });
        var obj = MyMixin.apply({});
        equal(_glimmerObjectTestsSupport.get(obj, 'bar')(), 'baz', 'should have followed aliasMethods');
    });
    QUnit.skip('should alias methods from other dependent mixins', function () {
        var BaseMixin = _glimmerObjectTestsSupport.Mixin.create({
            fooMethod: function () {
                return 'FOO';
            }
        });
        var MyMixin = _glimmerObjectTestsSupport.Mixin.create(BaseMixin, {
            barMethod: _glimmerObject.aliasMethod('fooMethod')
        });
        var obj = MyMixin.apply({});
        validateAliasMethod(obj);
    });
    QUnit.test('should alias methods from other mixins applied at same time', function () {
        var BaseMixin = _glimmerObjectTestsSupport.Mixin.create({
            fooMethod: function () {
                return 'FOO';
            }
        });
        var MyMixin = _glimmerObjectTestsSupport.Mixin.create({
            barMethod: _glimmerObject.aliasMethod('fooMethod')
        });
        var obj = _glimmerObjectTestsSupport.mixin({}, BaseMixin, MyMixin);
        validateAliasMethod(obj);
    });
    QUnit.test('should alias methods from mixins already applied on object', function () {
        var BaseMixin = _glimmerObjectTestsSupport.Mixin.create({
            quxMethod: function () {
                return 'qux';
            }
        });
        var MyMixin = _glimmerObjectTestsSupport.Mixin.create({
            bar: _glimmerObject.aliasMethod('foo'),
            barMethod: _glimmerObject.aliasMethod('fooMethod')
        });
        var obj = {
            fooMethod: function () {
                return 'FOO';
            }
        };
        BaseMixin.apply(obj);
        MyMixin.apply(obj);
        validateAliasMethod(obj);
    });
});

enifed('@glimmer/object/tests/ember-metal-alias-method-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object/tests');
    QUnit.test('@glimmer/object/tests/ember-metal-alias-method-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/tests/ember-metal-alias-method-test.ts should pass tslint.');
    });
});

enifed('@glimmer/object/tests/ember-metal-alias-test', ['exports', '@glimmer/object', '@glimmer/object-reference', '@glimmer/object/tests/support'], function (exports, _glimmerObject, _glimmerObjectReference, _glimmerObjectTestsSupport) {
    'use strict';

    var obj = undefined,
        count = undefined;
    QUnit.module('defineProperty - alias', {
        setup: function () {
            obj = { foo: { faz: 'FOO' } };
            count = 0;
        },
        teardown: function () {
            obj = null;
        }
    });
    function shouldBeClean(reference, msg) {
        // a "clean" reference is allowed to report dirty
    }
    function shouldBeDirty(reference, msg) {
        // equal(reference.isDirty(), true, msg || `${reference} should be dirty`);
    }
    QUnit.test('should proxy get to alt key', function () {
        _glimmerObjectTestsSupport.defineProperty(obj, 'bar', _glimmerObject.alias('foo.faz'));
        equal(_glimmerObjectTestsSupport.get(obj, 'bar'), 'FOO');
    });
    QUnit.test('should proxy set to alt key', function () {
        _glimmerObjectTestsSupport.defineProperty(obj, 'bar', _glimmerObject.alias('foo.faz'));
        _glimmerObjectTestsSupport.set(obj, 'bar', 'BAR');
        equal(_glimmerObjectTestsSupport.get(obj, 'foo.faz'), 'BAR');
    });
    QUnit.test('should observe the alias', function () {
        _glimmerObjectTestsSupport.defineProperty(obj, 'bar', _glimmerObject.alias('foo.faz'));
        var ref = _glimmerObjectReference.Meta.for(obj).root().get('bar');
        var val = ref.value();
        equal(val, 'FOO');
        shouldBeClean(ref);
        _glimmerObjectTestsSupport.set(obj.foo, 'faz', 'FAZ');
        shouldBeDirty(ref, "after setting the property the alias is for");
        equal(ref.value(), 'FAZ');
    });
    function observe(obj, key) {
        var ref = _glimmerObjectReference.Meta.for(obj).root().get(key);
        // ref.value();
        return ref;
    }
    QUnit.test('old dependent keys should not trigger property changes', function () {
        var obj1 = Object.create(null);
        _glimmerObjectTestsSupport.defineProperty(obj1, 'foo', null);
        _glimmerObjectTestsSupport.defineProperty(obj1, 'bar', _glimmerObject.alias('foo'));
        _glimmerObjectTestsSupport.defineProperty(obj1, 'baz', _glimmerObject.alias('foo'));
        _glimmerObjectTestsSupport.defineProperty(obj1, 'baz', _glimmerObject.alias('bar')); // redefine baz
        var ref = observe(obj1, 'baz');
        equal(ref.value(), null, "The value starts out null");
        _glimmerObjectTestsSupport.set(obj1, 'foo', 'FOO');
        equal(ref.value(), 'FOO', "And it sees the new value");
        _glimmerObjectTestsSupport.set(obj1, 'foo', 'OOF');
    });
    QUnit.test('overridden dependent keys should not trigger property changes', function () {
        var obj1 = Object.create(null);
        _glimmerObjectTestsSupport.defineProperty(obj1, 'foo', null);
        _glimmerObjectTestsSupport.defineProperty(obj1, 'bar', _glimmerObject.alias('foo'));
        _glimmerObjectTestsSupport.defineProperty(obj1, 'baz', _glimmerObject.alias('foo'));
        var ref = observe(obj1, 'baz');
        equal(ref.value(), null);
        var obj2 = Object.create(obj1);
        _glimmerObjectTestsSupport.defineProperty(obj2, 'baz', _glimmerObject.alias('bar')); // override baz
        _glimmerObjectTestsSupport.set(obj2, 'foo', 'FOO');
        _glimmerObjectTestsSupport.set(obj2, 'foo', 'OOF');
    });
    QUnit.test('begins watching alt key as soon as alias is watched', function () {
        _glimmerObjectTestsSupport.defineProperty(obj, 'bar', _glimmerObject.alias('foo.faz'));
        var ref = observe(obj, 'bar');
        equal(ref.value(), 'FOO');
        _glimmerObjectTestsSupport.set(obj, 'foo.faz', 'BAR');
        equal(ref.value(), 'BAR');
    });
    QUnit.test('immediately sets up dependencies if already being watched', function () {
        var ref = observe(obj, 'bar');
        _glimmerObjectTestsSupport.defineProperty(obj, 'bar', _glimmerObject.alias('foo.faz'));
        _glimmerObjectTestsSupport.set(obj, 'foo.faz', 'BAR');
        equal(ref.value(), 'BAR');
        // equal(count, 1);
    });
    QUnit.test('setting alias on self should fail assertion', function (assert) {
        assert.throws(function () {
            _glimmerObjectTestsSupport.defineProperty(obj, 'bar', _glimmerObject.alias('bar'));
        }, /Setting alias \'bar\' on self/);
    });
});

enifed('@glimmer/object/tests/ember-metal-alias-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object/tests');
    QUnit.test('@glimmer/object/tests/ember-metal-alias-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/tests/ember-metal-alias-test.ts should pass tslint.');
    });
});

enifed('@glimmer/object/tests/ember-metal-computed-test', ['exports', '@glimmer/object/tests/support', '@glimmer/object'], function (exports, _glimmerObjectTestsSupport, _glimmerObject) {
    'use strict';

    function K() {
        return this;
    }
    QUnit.module('Mixin.create - Computed Properties');
    QUnit.test('overriding computed properties', function () {
        var MixinA = undefined,
            MixinB = undefined,
            MixinC = undefined,
            MixinD = undefined;
        var obj = undefined;
        MixinA = _glimmerObjectTestsSupport.Mixin.create({
            aProp: _glimmerObject.computed(function () {
                return 'A';
            })
        });
        MixinB = _glimmerObjectTestsSupport.Mixin.create({
            aProp: _glimmerObject.computed(function () {
                return this._super.apply(this, arguments) + 'B';
            })
        });
        MixinC = _glimmerObjectTestsSupport.Mixin.create({
            aProp: _glimmerObject.computed(function () {
                return this._super.apply(this, arguments) + 'C';
            })
        });
        MixinD = _glimmerObjectTestsSupport.Mixin.create({
            aProp: _glimmerObject.computed(function () {
                return this._super.apply(this, arguments) + 'D';
            })
        });
        obj = {};
        MixinA.apply(obj);
        MixinB.apply(obj);
        equal(_glimmerObjectTestsSupport.get(obj, 'aProp'), 'AB', 'should expose super for B');
        obj = {};
        MixinA.apply(obj);
        MixinC.apply(obj);
        equal(_glimmerObjectTestsSupport.get(obj, 'aProp'), 'AC', 'should expose super for C');
        obj = {};
        MixinA.apply(obj);
        MixinD.apply(obj);
        equal(_glimmerObjectTestsSupport.get(obj, 'aProp'), 'AD', 'should define super for D');
        obj = {};
        _glimmerObjectTestsSupport.mixin(obj, {
            aProp: _glimmerObject.computed(function (key) {
                return 'obj';
            })
        });
        MixinD.apply(obj);
        equal(_glimmerObjectTestsSupport.get(obj, 'aProp'), 'objD', 'should preserve original computed property');
    });
    QUnit.test('calling set on overridden computed properties', function () {
        var SuperMixin = undefined,
            SubMixin = undefined;
        var obj = undefined;
        var superGetOccurred = false;
        var superSetOccurred = false;
        SuperMixin = _glimmerObjectTestsSupport.Mixin.create({
            aProp: _glimmerObject.computed({
                get: function (key) {
                    superGetOccurred = true;
                },
                set: function (key, value) {
                    superSetOccurred = true;
                }
            })
        });
        SubMixin = _glimmerObjectTestsSupport.Mixin.create(SuperMixin, {
            aProp: _glimmerObject.computed({
                get: function (key) {
                    return this._super.apply(this, arguments);
                },
                set: function (key, value) {
                    return this._super.apply(this, arguments);
                }
            })
        });
        obj = {};
        SubMixin.apply(obj);
        _glimmerObjectTestsSupport.set(obj, 'aProp', 'set thyself');
        ok(superSetOccurred, 'should pass set to _super');
        superSetOccurred = false; // reset the set assertion
        obj = {};
        SubMixin.apply(obj);
        _glimmerObjectTestsSupport.get(obj, 'aProp');
        ok(superGetOccurred, 'should pass get to _super');
        _glimmerObjectTestsSupport.set(obj, 'aProp', 'set thyself');
        ok(superSetOccurred, 'should pass set to _super after getting');
    });
    QUnit.test('setter behavior works properly when overriding computed properties', function () {
        var obj = {};
        var MixinA = _glimmerObjectTestsSupport.Mixin.create({
            cpWithSetter2: _glimmerObject.computed(K),
            cpWithSetter3: _glimmerObject.computed(K),
            cpWithoutSetter: _glimmerObject.computed(K)
        });
        var cpWasCalled = false;
        var MixinB = _glimmerObjectTestsSupport.Mixin.create({
            cpWithSetter2: _glimmerObject.computed({
                get: K,
                set: function (k, v) {
                    cpWasCalled = true;
                }
            }),
            cpWithSetter3: _glimmerObject.computed({
                get: K,
                set: function (k, v) {
                    cpWasCalled = true;
                }
            }),
            cpWithoutSetter: _glimmerObject.computed(function (k) {
                cpWasCalled = true;
            })
        });
        MixinA.apply(obj);
        MixinB.apply(obj);
        _glimmerObjectTestsSupport.set(obj, 'cpWithSetter2', 'test');
        ok(cpWasCalled, 'The computed property setter was called when defined with two args');
        cpWasCalled = false;
        _glimmerObjectTestsSupport.set(obj, 'cpWithSetter3', 'test');
        ok(cpWasCalled, 'The computed property setter was called when defined with three args');
        cpWasCalled = false;
        _glimmerObjectTestsSupport.set(obj, 'cpWithoutSetter', 'test');
        equal(_glimmerObjectTestsSupport.get(obj, 'cpWithoutSetter'), 'test', 'The default setter was called, the value is correct');
        ok(!cpWasCalled, 'The default setter was called, not the CP itself');
    });
});

enifed('@glimmer/object/tests/ember-metal-computed-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object/tests');
    QUnit.test('@glimmer/object/tests/ember-metal-computed-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/tests/ember-metal-computed-test.ts should pass tslint.');
    });
});

enifed('@glimmer/object/tests/ember-metal-concatenated-properties-test', ['exports', '@glimmer/object/tests/support', '@glimmer/object'], function (exports, _glimmerObjectTestsSupport, _glimmerObject) {
    'use strict';

    QUnit.module('Mixin.concatenatedProperties');
    QUnit.test('defining concatenated properties should concat future version', function () {
        var MixinA = _glimmerObject.Mixin.create({
            concatenatedProperties: ['foo'],
            foo: ['a', 'b', 'c']
        });
        var MixinB = _glimmerObject.Mixin.create({
            foo: ['d', 'e', 'f']
        });
        var obj = _glimmerObjectTestsSupport.mixin({}, MixinA, MixinB);
        deepEqual(_glimmerObjectTestsSupport.get(obj, 'foo'), ['a', 'b', 'c', 'd', 'e', 'f']);
    });
    QUnit.test('defining concatenated properties should concat future version', function () {
        var MixinA = _glimmerObject.Mixin.create({
            concatenatedProperties: null
        });
        var MixinB = _glimmerObject.Mixin.create({
            concatenatedProperties: null
        });
        var obj = _glimmerObjectTestsSupport.mixin({}, MixinA, MixinB);
        deepEqual(obj.concatenatedProperties, []);
    });
    QUnit.test('concatenatedProperties should be concatenated', function () {
        var MixinA = _glimmerObject.Mixin.create({
            concatenatedProperties: ['foo'],
            foo: ['a', 'b', 'c']
        });
        var MixinB = _glimmerObject.Mixin.create({
            concatenatedProperties: 'bar',
            foo: ['d', 'e', 'f'],
            bar: [1, 2, 3]
        });
        var MixinC = _glimmerObject.Mixin.create({
            bar: [4, 5, 6]
        });
        var obj = _glimmerObjectTestsSupport.mixin({}, MixinA, MixinB, MixinC);
        deepEqual(_glimmerObjectTestsSupport.get(obj, 'concatenatedProperties'), ['foo', 'bar'], 'get concatenatedProperties');
        deepEqual(_glimmerObjectTestsSupport.get(obj, 'foo'), ['a', 'b', 'c', 'd', 'e', 'f'], 'get foo');
        deepEqual(_glimmerObjectTestsSupport.get(obj, 'bar'), [1, 2, 3, 4, 5, 6], 'get bar');
    });
    QUnit.test('adding a prop that is not an array should make array', function () {
        var MixinA = _glimmerObject.Mixin.create({
            concatenatedProperties: ['foo'],
            foo: [1, 2, 3]
        });
        var MixinB = _glimmerObject.Mixin.create({
            foo: 4
        });
        var obj = _glimmerObjectTestsSupport.mixin({}, MixinA, MixinB);
        deepEqual(_glimmerObjectTestsSupport.get(obj, 'foo'), [1, 2, 3, 4]);
    });
    QUnit.test('adding a prop that is not an array should make array', function () {
        var MixinA = _glimmerObject.Mixin.create({
            concatenatedProperties: ['foo'],
            foo: 'bar'
        });
        var obj = _glimmerObjectTestsSupport.mixin({}, MixinA);
        deepEqual(_glimmerObjectTestsSupport.get(obj, 'foo'), ['bar']);
    });
    QUnit.skip('adding a non-concatenable property that already has a defined value should result in an array with both values', function () {
        var mixinA = _glimmerObject.Mixin.create({
            foo: 1
        });
        var mixinB = _glimmerObject.Mixin.create({
            concatenatedProperties: ['foo'],
            foo: 2
        });
        var obj = _glimmerObjectTestsSupport.mixin({}, mixinA, mixinB);
        deepEqual(_glimmerObjectTestsSupport.get(obj, 'foo'), [1, 2]);
    });
    QUnit.skip('adding a concatenable property that already has a defined value should result in a concatenated value', function () {
        var mixinA = _glimmerObject.Mixin.create({
            foobar: 'foo'
        });
        var mixinB = _glimmerObject.Mixin.create({
            concatenatedProperties: ['foobar'],
            foobar: 'bar'
        });
        var obj = _glimmerObjectTestsSupport.mixin({}, mixinA, mixinB);
        equal(_glimmerObjectTestsSupport.get(obj, 'foobar'), 'foobar');
    });
});

enifed('@glimmer/object/tests/ember-metal-concatenated-properties-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object/tests');
    QUnit.test('@glimmer/object/tests/ember-metal-concatenated-properties-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/tests/ember-metal-concatenated-properties-test.ts should pass tslint.');
    });
});

enifed('@glimmer/object/tests/ember-metal-merged-properties-test', ['exports', '@glimmer/object', '@glimmer/object/tests/support'], function (exports, _glimmerObject, _glimmerObjectTestsSupport) {
    'use strict';

    QUnit.module('Mixin.create - mergedProperties');
    QUnit.test('defining mergedProperties should merge future version', function () {
        var MixinA = _glimmerObject.Mixin.create({
            mergedProperties: ['foo'],
            foo: { a: true, b: true, c: true }
        });
        var MixinB = _glimmerObject.Mixin.create({
            foo: { d: true, e: true, f: true }
        });
        var obj = _glimmerObjectTestsSupport.mixin({}, MixinA, MixinB);
        deepEqual(_glimmerObjectTestsSupport.get(obj, 'foo'), { a: true, b: true, c: true, d: true, e: true, f: true });
    });
    QUnit.test('defining mergedProperties on future mixin should merged into past', function () {
        var MixinA = _glimmerObject.Mixin.create({
            foo: { a: true, b: true, c: true }
        });
        var MixinB = _glimmerObject.Mixin.create({
            mergedProperties: ['foo'],
            foo: { d: true, e: true, f: true }
        });
        var obj = _glimmerObjectTestsSupport.mixin({}, MixinA, MixinB);
        deepEqual(_glimmerObjectTestsSupport.get(obj, 'foo'), { a: true, b: true, c: true, d: true, e: true, f: true });
    });
    QUnit.test('defining mergedProperties with null properties should keep properties null', function () {
        var MixinA = _glimmerObject.Mixin.create({
            mergedProperties: ['foo'],
            foo: null
        });
        var MixinB = _glimmerObject.Mixin.create({
            foo: null
        });
        var obj = _glimmerObjectTestsSupport.mixin({}, MixinA, MixinB);
        equal(_glimmerObjectTestsSupport.get(obj, 'foo'), null);
    });
    QUnit.test('mergedProperties\' properties can get overwritten', function () {
        var MixinA = _glimmerObject.Mixin.create({
            mergedProperties: ['foo'],
            foo: { a: 1 }
        });
        var MixinB = _glimmerObject.Mixin.create({
            foo: { a: 2 }
        });
        var obj = _glimmerObjectTestsSupport.mixin({}, MixinA, MixinB);
        deepEqual(_glimmerObjectTestsSupport.get(obj, 'foo'), { a: 2 });
    });
    QUnit.test('mergedProperties should be concatenated', function () {
        var MixinA = _glimmerObject.Mixin.create({
            mergedProperties: ['foo'],
            foo: { a: true, b: true, c: true }
        });
        var MixinB = _glimmerObject.Mixin.create({
            mergedProperties: 'bar',
            foo: { d: true, e: true, f: true },
            bar: { a: true, l: true }
        });
        var MixinC = _glimmerObject.Mixin.create({
            bar: { e: true, x: true }
        });
        var obj = _glimmerObjectTestsSupport.mixin({}, MixinA, MixinB, MixinC);
        deepEqual(_glimmerObjectTestsSupport.get(obj, 'mergedProperties'), ['foo', 'bar'], 'get mergedProperties');
        deepEqual(_glimmerObjectTestsSupport.get(obj, 'foo'), { a: true, b: true, c: true, d: true, e: true, f: true }, 'get foo');
        deepEqual(_glimmerObjectTestsSupport.get(obj, 'bar'), { a: true, l: true, e: true, x: true }, 'get bar');
    });
    QUnit.test('mergedProperties should exist even if not explicitly set on create', function () {
        var AnObj = _glimmerObject.default.extend({
            mergedProperties: ['options'],
            options: {
                a: 'a',
                b: {
                    c: 'ccc'
                }
            }
        });
        var obj = AnObj.create({
            options: {
                a: 'A'
            }
        });
        equal(_glimmerObjectTestsSupport.get(obj, 'options').a, 'A');
        equal(_glimmerObjectTestsSupport.get(obj, 'options').b.c, 'ccc');
    });
    QUnit.test('mergedProperties\' overwriting methods can call _super', function () {
        expect(4);
        var MixinA = _glimmerObject.Mixin.create({
            mergedProperties: ['foo'],
            foo: {
                meth: function (a) {
                    equal(a, 'WOOT', '_super successfully called MixinA\'s `foo.meth` method');
                    return 'WAT';
                }
            }
        });
        var MixinB = _glimmerObject.Mixin.create({
            foo: {
                meth: function (a) {
                    ok(true, 'MixinB\'s `foo.meth` method called');
                    return this._super.apply(this, arguments);
                }
            }
        });
        var MixinC = _glimmerObject.Mixin.create({
            foo: {
                meth: function (a) {
                    ok(true, 'MixinC\'s `foo.meth` method called');
                    return this._super(a);
                }
            }
        });
        var obj = _glimmerObjectTestsSupport.mixin({}, MixinA, MixinB, MixinC);
        equal(obj.foo.meth('WOOT'), 'WAT');
    });
    QUnit.test('Merging an Array should raise an error', function (assert) {
        expect(1);
        var MixinA = _glimmerObject.Mixin.create({
            mergedProperties: ['foo'],
            foo: { a: true, b: true, c: true }
        });
        var MixinB = _glimmerObject.Mixin.create({
            foo: ['a']
        });
        assert.throws(function () {
            _glimmerObjectTestsSupport.mixin({}, MixinA, MixinB);
        }, /You passed in `\["a"\]` as the value for `foo` but `foo` cannot be an Array/);
    });
});

enifed('@glimmer/object/tests/ember-metal-merged-properties-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object/tests');
    QUnit.test('@glimmer/object/tests/ember-metal-merged-properties-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/tests/ember-metal-merged-properties-test.ts should pass tslint.');
    });
});

enifed('@glimmer/object/tests/ember-metal-mixin-introspection-test', ['exports', '@glimmer/object/tests/support', '@glimmer/object'], function (exports, _glimmerObjectTestsSupport, _glimmerObject) {
    // NOTE: A previous iteration differentiated between public and private props
    // as well as methods vs props.  We are just keeping these for testing; the
    // current impl doesn't care about the differences as much...
    'use strict';

    var PrivateProperty = _glimmerObject.Mixin.create({
        _foo: '_FOO'
    });
    var PublicProperty = _glimmerObject.Mixin.create({
        foo: 'FOO'
    });
    var PrivateMethod = _glimmerObject.Mixin.create({
        _fooMethod: function () {}
    });
    var PublicMethod = _glimmerObject.Mixin.create({
        fooMethod: function () {}
    });
    var BarProperties = _glimmerObject.Mixin.create({
        _bar: '_BAR',
        bar: 'bar'
    });
    var BarMethods = _glimmerObject.Mixin.create({
        _barMethod: function () {},
        barMethod: function () {}
    });
    var Combined = _glimmerObject.Mixin.create(BarProperties, BarMethods);
    var obj = undefined;
    QUnit.module('Mixin.mixins (introspection)', {
        setup: function () {
            obj = {};
            _glimmerObjectTestsSupport.mixin(obj, PrivateProperty, PublicProperty, PrivateMethod, PublicMethod, Combined);
        }
    });
    QUnit.test('Ember.mixins()', function () {
        deepEqual(_glimmerObject.Mixin.mixins(obj), [PrivateProperty, PublicProperty, PrivateMethod, PublicMethod, BarProperties, BarMethods, Combined], 'should return included mixins');
    });
});

enifed('@glimmer/object/tests/ember-metal-mixin-introspection-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object/tests');
    QUnit.test('@glimmer/object/tests/ember-metal-mixin-introspection-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/tests/ember-metal-mixin-introspection-test.ts should pass tslint.');
    });
});

enifed('@glimmer/object/tests/ember-metal-mixin-reopen-test', ['exports', '@glimmer/object', '@glimmer/object/tests/support'], function (exports, _glimmerObject, _glimmerObjectTestsSupport) {
    'use strict';

    QUnit.module('Mixin#reopen');
    QUnit.test('using reopen() to add more properties to a simple', function () {
        var MixinA = _glimmerObject.Mixin.create({ foo: 'FOO', baz: 'BAZ' });
        MixinA.reopen({ bar: 'BAR', foo: 'FOO2' });
        var obj = {};
        MixinA.apply(obj);
        equal(_glimmerObjectTestsSupport.get(obj, 'foo'), 'FOO2', 'mixin() should override');
        equal(_glimmerObjectTestsSupport.get(obj, 'baz'), 'BAZ', 'preserve MixinA props');
        equal(_glimmerObjectTestsSupport.get(obj, 'bar'), 'BAR', 'include MixinB props');
    });
    QUnit.test('using reopen() and calling _super where there is not a super function does not cause infinite recursion', function () {
        var Taco = _glimmerObject.default.extend({
            createBreakfast: function () {
                // There is no original createBreakfast function.
                // Calling the wrapped _super function here
                // used to end in an infinite call loop
                this._super.apply(this, arguments);
                return 'Breakfast!';
            }
        });
        Taco.reopen({
            createBreakfast: function () {
                return this._super.apply(this, arguments);
            }
        });
        var taco = Taco.create();
        var result = undefined;
        try {
            result = taco.createBreakfast();
        } catch (e) {
            result = 'Your breakfast was interrupted by an infinite stack error.';
            throw e;
        }
        equal(result, 'Breakfast!');
    });
});

enifed('@glimmer/object/tests/ember-metal-mixin-reopen-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object/tests');
    QUnit.test('@glimmer/object/tests/ember-metal-mixin-reopen-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/tests/ember-metal-mixin-reopen-test.ts should pass tslint.');
    });
});

enifed('@glimmer/object/tests/ember-mixin-detect-test', ['exports', '@glimmer/object'], function (exports, _glimmerObject) {
    'use strict';

    QUnit.module('Mixin.detect');
    QUnit.test('detect() finds a directly applied mixin', function () {
        var MixinA = _glimmerObject.Mixin.create();
        var obj = {};
        equal(MixinA.detect(obj), false, 'MixinA.detect(obj) before apply()');
        MixinA.apply(obj);
        equal(MixinA.detect(obj), true, 'MixinA.detect(obj) after apply()');
    });
    QUnit.test('detect() finds nested mixins', function () {
        var MixinA = _glimmerObject.Mixin.create({});
        var MixinB = _glimmerObject.Mixin.create(MixinA);
        var obj = {};
        equal(MixinA.detect(obj), false, 'MixinA.detect(obj) before apply()');
        MixinB.apply(obj);
        equal(MixinA.detect(obj), true, 'MixinA.detect(obj) after apply()');
    });
    QUnit.test('detect() finds mixins on other mixins', function () {
        var MixinA = _glimmerObject.Mixin.create({});
        var MixinB = _glimmerObject.Mixin.create(MixinA);
        equal(MixinA.detect(MixinB), true, 'MixinA is part of MixinB');
        equal(MixinB.detect(MixinA), false, 'MixinB is not part of MixinA');
    });
    QUnit.test('detect handles null values', function () {
        var MixinA = _glimmerObject.Mixin.create();
        equal(MixinA.detect(null), false);
    });
});

enifed('@glimmer/object/tests/ember-mixin-detect-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object/tests');
    QUnit.test('@glimmer/object/tests/ember-mixin-detect-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/tests/ember-mixin-detect-test.ts should pass tslint.');
    });
});

enifed('@glimmer/object/tests/ember-mixin-method-test', ['exports', '@glimmer/object/tests/support', '@glimmer/object'], function (exports, _glimmerObjectTestsSupport, _glimmerObject) {
    'use strict';

    QUnit.module('Mixin.create - Methods');
    QUnit.test('defining simple methods', function () {
        var MixinA = undefined,
            obj = undefined,
            props = undefined;
        props = {
            publicMethod: function () {
                return 'publicMethod';
            },
            _privateMethod: function () {
                return 'privateMethod';
            }
        };
        MixinA = _glimmerObject.Mixin.create(props);
        obj = {};
        MixinA.apply(obj);
        // but should be defined
        equal(props.publicMethod(), 'publicMethod', 'publicMethod is func');
        equal(props._privateMethod(), 'privateMethod', 'privateMethod is func');
    });
    QUnit.test('overriding public methods', function () {
        var MixinA = undefined,
            MixinB = undefined,
            MixinD = undefined,
            MixinF = undefined,
            obj = undefined;
        MixinA = _glimmerObject.Mixin.create({
            publicMethod: function () {
                return 'A';
            }
        });
        MixinB = _glimmerObject.Mixin.create(MixinA, {
            publicMethod: function () {
                return this._super.apply(this, arguments) + 'B';
            }
        });
        MixinD = _glimmerObject.Mixin.create(MixinA, {
            publicMethod: function () {
                return this._super.apply(this, arguments) + 'D';
            }
        });
        MixinF = _glimmerObject.Mixin.create({
            publicMethod: function () {
                return this._super.apply(this, arguments) + 'F';
            }
        });
        obj = {};
        MixinB.apply(obj);
        equal(obj.publicMethod(), 'AB', 'should define super for A and B');
        obj = {};
        MixinD.apply(obj);
        equal(obj.publicMethod(), 'AD', 'should define super for A and B');
        obj = {};
        MixinA.apply(obj);
        MixinF.apply(obj);
        equal(obj.publicMethod(), 'AF', 'should define super for A and F');
        obj = { publicMethod: function () {
                return 'obj';
            } };
        MixinF.apply(obj);
        equal(obj.publicMethod(), 'objF', 'should define super for F');
    });
    QUnit.test('overriding inherited objects', function () {
        var cnt = 0;
        var MixinA = _glimmerObject.Mixin.create({
            foo: function () {
                cnt++;
            }
        });
        var MixinB = _glimmerObject.Mixin.create({
            foo: function () {
                this._super.apply(this, arguments);
                cnt++;
            }
        });
        var objA = {};
        MixinA.apply(objA);
        var objB = Object.create(objA);
        MixinB.apply(objB);
        cnt = 0;
        objB['foo']();
        equal(cnt, 2, 'should invoke both methods');
        cnt = 0;
        objA['foo']();
        equal(cnt, 1, 'should not screw w/ parent obj');
    });
    QUnit.test('Including the same mixin more than once will only run once', function () {
        var cnt = 0;
        var MixinA = _glimmerObject.Mixin.create({
            foo: function () {
                cnt++;
            }
        });
        var MixinB = _glimmerObject.Mixin.create(MixinA, {
            foo: function () {
                this._super.apply(this, arguments);
            }
        });
        var MixinC = _glimmerObject.Mixin.create(MixinA, {
            foo: function () {
                this._super.apply(this, arguments);
            }
        });
        var MixinD = _glimmerObject.Mixin.create(MixinB, MixinC, MixinA, {
            foo: function () {
                this._super.apply(this, arguments);
            }
        });
        var obj = {};
        MixinD.apply(obj);
        MixinA.apply(obj); // try to apply again..
        cnt = 0;
        obj['foo']();
        equal(cnt, 1, 'should invoke MixinA.foo one time');
    });
    QUnit.test('_super from a single mixin with no superclass does not error', function () {
        var MixinA = _glimmerObject.Mixin.create({
            foo: function () {
                this._super.apply(this, arguments);
            }
        });
        var obj = {};
        MixinA.apply(obj);
        obj['foo']();
        ok(true);
    });
    QUnit.test('_super from a first-of-two mixins with no superclass function does not error', function () {
        // _super was previously calling itself in the second assertion.
        // Use remaining count of calls to ensure it doesn't loop indefinitely.
        var remaining = 3;
        var MixinA = _glimmerObject.Mixin.create({
            foo: function () {
                if (remaining-- > 0) {
                    this._super.apply(this, arguments);
                }
            }
        });
        var MixinB = _glimmerObject.Mixin.create({
            foo: function () {
                this._super.apply(this, arguments);
            }
        });
        var obj = {};
        MixinA.apply(obj);
        MixinB.apply(obj);
        obj['foo']();
        ok(true);
    });
    // ..........................................................
    // CONFLICTS
    //
    QUnit.module('Mixin.create - Method Conflicts');
    QUnit.test('overriding toString', function () {
        var MixinA = _glimmerObject.Mixin.create({
            toString: function () {
                return 'FOO';
            }
        });
        var obj = {};
        MixinA.apply(obj);
        equal(obj.toString(), 'FOO', 'should override toString w/o error');
        obj = {};
        _glimmerObjectTestsSupport.mixin(obj, { toString: function () {
                return 'FOO';
            } });
        equal(obj.toString(), 'FOO', 'should override toString w/o error');
    });
    // ..........................................................
    // BUGS
    //
    QUnit.module('Mixin.create - Method Regressions (BUGS)');
    QUnit.test('applying several mixins at once with sup already defined causes infinite loop', function () {
        var cnt = 0;
        var MixinA = _glimmerObject.Mixin.create({
            foo: function () {
                cnt++;
            }
        });
        var MixinB = _glimmerObject.Mixin.create({
            foo: function () {
                this._super.apply(this, arguments);
                cnt++;
            }
        });
        var MixinC = _glimmerObject.Mixin.create({
            foo: function () {
                this._super.apply(this, arguments);
                cnt++;
            }
        });
        var obj = {};
        _glimmerObjectTestsSupport.mixin(obj, MixinA); // sup already exists
        _glimmerObjectTestsSupport.mixin(obj, MixinB, MixinC); // must be more than one mixin
        cnt = 0;
        obj['foo']();
        equal(cnt, 3, 'should invoke all 3 methods');
    });
});

enifed('@glimmer/object/tests/ember-mixin-method-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object/tests');
    QUnit.test('@glimmer/object/tests/ember-mixin-method-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/tests/ember-mixin-method-test.ts should pass tslint.');
    });
});

enifed('@glimmer/object/tests/ember-reopen-class-test', ['exports', '@glimmer/object'], function (exports, _glimmerObject) {
    'use strict';

    function get(obj, key) {
        return obj[key];
    }
    QUnit.module('GlimmerObject.reopenClass');
    QUnit.test('adds new properties to subclass', function () {
        var Subclass = _glimmerObject.default.extend();
        Subclass.reopenClass({
            foo: function () {
                return 'FOO';
            },
            bar: 'BAR'
        });
        equal(Subclass.foo(), 'FOO', 'Adds method');
        equal(get(Subclass, 'bar'), 'BAR', 'Adds property');
    });
    QUnit.test('class properties inherited by subclasses', function () {
        var Subclass = _glimmerObject.default.extend();
        Subclass.reopenClass({
            foo: function () {
                return 'FOO';
            },
            bar: 'BAR'
        });
        var SubSub = Subclass.extend();
        equal(SubSub['foo'](), 'FOO', 'Adds method');
        equal(get(SubSub, 'bar'), 'BAR', 'Adds property');
    });
});

enifed('@glimmer/object/tests/ember-reopen-class-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object/tests');
    QUnit.test('@glimmer/object/tests/ember-reopen-class-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/tests/ember-reopen-class-test.ts should pass tslint.');
    });
});

enifed('@glimmer/object/tests/ember-reopen-test', ['exports', '@glimmer/object'], function (exports, _glimmerObject) {
    'use strict';

    function get(obj, key) {
        return obj[key];
    }
    QUnit.module('GlimmerObject.reopen');
    QUnit.test('adds new properties to subclass instance', function () {
        var Subclass = _glimmerObject.default.extend();
        Subclass.reopen({
            foo: function () {
                return 'FOO';
            },
            bar: 'BAR'
        });
        equal(new Subclass()['foo'](), 'FOO', 'Adds method');
        equal(get(new Subclass(), 'bar'), 'BAR', 'Adds property');
    });
    QUnit.test('reopened properties inherited by subclasses', function () {
        var Subclass = _glimmerObject.default.extend();
        var SubSub = Subclass.extend();
        Subclass.reopen({
            foo: function () {
                return 'FOO';
            },
            bar: 'BAR'
        });
        equal(new SubSub()['foo'](), 'FOO', 'Adds method');
        equal(get(new SubSub(), 'bar'), 'BAR', 'Adds property');
    });
    QUnit.test('allows reopening already instantiated classes', function () {
        var Subclass = _glimmerObject.default.extend();
        Subclass.create();
        Subclass.reopen({
            trololol: true
        });
        equal(Subclass.create().get('trololol'), true, 'reopen works');
    });
});

enifed('@glimmer/object/tests/ember-reopen-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object/tests');
    QUnit.test('@glimmer/object/tests/ember-reopen-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/tests/ember-reopen-test.ts should pass tslint.');
    });
});

enifed('@glimmer/object/tests/object-test', ['exports', '@glimmer/object', '@glimmer/object-reference'], function (exports, _glimmerObject, _glimmerObjectReference) {
    'use strict';

    var Wrapper = _glimmerObject.default.extend({
        fullName: _glimmerObject.computed(function () {
            return this.model && this.model.fullName;
        }).property('model.fullName')
    });
    var Model = _glimmerObject.default.extend({
        fullName: _glimmerObject.computed(function () {
            return this.person && this.person.fullName;
        }).property('person.fullName')
    });
    var Person = _glimmerObject.default.extend({
        fullName: _glimmerObject.computed(function () {
            return this.name && this.name.fullName;
        }).property('name.fullName')
    });
    var Name = _glimmerObject.default.extend({
        fullName: _glimmerObject.computed(function () {
            return this.first + ' ' + this.last;
        }).property('first', 'last')
    });
    QUnit.module('the object model');
    QUnit.test('the simple object model allows you to derive references', function () {
        var obj1 = new Wrapper({
            model: new Model({
                person: new Person({
                    name: new Name({ first: "Yehuda", last: "Katz" })
                })
            })
        });
        var originalPerson = obj1.model.person;
        var obj2 = new Wrapper({
            model: new Model({
                person: new Person({
                    name: obj1.model.person.name
                })
            })
        });
        var obj3 = new Wrapper({
            model: new Model({
                person: obj1.model.person
            })
        });
        var obj4 = new Wrapper({
            model: obj1.model
        });
        var o1 = referencesFor(obj1);
        var o2 = referencesFor(obj2);
        var o3 = referencesFor(obj3);
        var o4 = referencesFor(obj4);
        allDirty(o1, "Yehuda");
        allDirty(o2, "Yehuda");
        allDirty(o3, "Yehuda");
        allDirty(o4, "Yehuda");
        allClean(o1);
        allClean(o2);
        allClean(o3);
        allClean(o4);
        _glimmerObjectReference.setProperty(obj1.model, 'person', new Person({ name: new Name({ first: 'Godfrey', last: 'Chan' }) }));
        isDirty(o1[0], "Godfrey");
        isDirty(o1[1], "Godfrey");
        isClean(o1[2]);
        isClean(o1[3]);
        allClean(o2);
        allClean(o3);
        isDirty(o4[0], "Godfrey");
        isDirty(o4[1], "Godfrey");
        isClean(o4[2]);
        isClean(o4[3]);
        _glimmerObjectReference.setProperty(originalPerson.name, 'first', "Godhuda");
        isClean(o1[0]);
        isClean(o1[1]);
        isDirty(o1[2], "Godhuda");
        isDirty(o1[3], "Godhuda");
        allDirty(o2, "Godhuda");
        allDirty(o3, "Godhuda");
        isClean(o4[0]);
        isClean(o4[1]);
        isDirty(o4[2], "Godhuda");
        isDirty(o4[3], "Godhuda");
        _glimmerObjectReference.setProperty(obj1.model, 'person', undefined);
        isDirty(o1[0], undefined);
        isDirty(o1[1], undefined);
        isClean(o1[2]);
        isClean(o1[3]);
        allClean(o2);
        allClean(o3);
        isDirty(o4[0], undefined);
        isDirty(o4[1], undefined);
        isClean(o4[2]);
        isClean(o4[3]);
        _glimmerObjectReference.setProperty(obj1.model, 'person', originalPerson);
        isDirty(o1[0], "Godhuda");
        isDirty(o1[1], "Godhuda");
        isClean(o1[2]);
        isClean(o1[3]);
        allClean(o2);
        allClean(o3);
        isDirty(o4[0], "Godhuda");
        isDirty(o4[1], "Godhuda");
        isClean(o4[2]);
        isClean(o4[3]);
        function referencesFor(obj) {
            return [root(obj).path('model.person.name.first'), root(obj.model).path('person.name.first'), root(obj.model.person).path('name.first'), root(obj.model.person.name).path('first')];
        }
    });
    function root(obj) {
        return _glimmerObjectReference.metaFor(obj).root();
    }
    QUnit.test("Simple computed properties", function () {
        var name = new Name({ first: "Godfrey", last: "Chan" });
        var ref = _glimmerObjectReference.metaFor(name).root().get('fullName');
        equal(name.fullName, "Godfrey Chan");
        equal(ref.value(), "Godfrey Chan");
        isClean(ref);
        _glimmerObjectReference.setProperty(name, 'first', "Godhuda");
        isDirty(ref, 'Godhuda Chan');
        equal(name.fullName, "Godhuda Chan");
        equal(ref.value(), "Godhuda Chan");
        isClean(ref);
    });
    QUnit.test("Computed properties", function () {
        var obj1 = new Wrapper({
            model: new Model({
                person: new Person({
                    name: new Name({ first: "Yehuda", last: "Katz" })
                })
            })
        });
        var originalPerson = obj1.model.person;
        var ref = _glimmerObjectReference.metaFor(obj1).root().get('fullName');
        equal(obj1.fullName, "Yehuda Katz");
        equal(ref.value(), "Yehuda Katz");
        isClean(ref);
        _glimmerObjectReference.setProperty(obj1.model, 'person', new Person({ name: new Name({ first: 'Godfrey', last: 'Chan' }) }));
        isDirty(ref, "Godfrey Chan");
        equal(obj1.fullName, "Godfrey Chan");
        equal(ref.value(), "Godfrey Chan");
        isClean(ref);
        _glimmerObjectReference.setProperty(originalPerson.name, 'first', "Godhuda");
        isDirty(ref, "Godfrey Chan");
        equal(obj1.fullName, "Godfrey Chan");
        equal(ref.value(), "Godfrey Chan");
        isClean(ref);
        _glimmerObjectReference.setProperty(obj1.model, 'person', undefined);
        isDirty(ref, undefined);
        equal(obj1.fullName, undefined);
        equal(ref.value(), undefined);
        isClean(ref);
        _glimmerObjectReference.setProperty(obj1.model, 'person', originalPerson);
        isDirty(ref, "Godhuda Katz");
        equal(obj1.fullName, "Godhuda Katz");
        equal(ref.value(), "Godhuda Katz");
        isClean(ref);
    });
    function isDirty(ref, newValue) {
        ok(ref.value() === newValue, ref.label() + " has new value " + newValue);
    }
    function isClean(ref) {
        // clean references are allowed to report dirty
    }
    function allDirty(refs, newValue) {
        refs.forEach(function (ref) {
            isDirty(ref, newValue);
        });
    }
    function allClean(refs) {
        refs.forEach(function (ref) {
            isClean(ref);
        });
    }
});

enifed('@glimmer/object/tests/object-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object/tests');
    QUnit.test('@glimmer/object/tests/object-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/tests/object-test.ts should pass tslint.');
    });
});

enifed('@glimmer/object/tests/support', ['exports', '@glimmer/object', '@glimmer/object-reference'], function (exports, _glimmerObject, _glimmerObjectReference) {
    'use strict';

    exports.get = get;
    exports.set = set;
    exports.mixin = mixin;
    exports.defineProperty = defineProperty;
    exports.Mixin = _glimmerObject.Mixin;

    function get(obj, key) {
        if (key.indexOf('.') !== -1) {
            var path = key.split('.');
            return path.reduce(function (obj, key) {
                return obj[key];
            }, obj);
        }
        return obj[key];
    }

    function set(obj, key, value) {
        if (key.indexOf('.') !== -1) {
            var path = key.split('.');
            var _parent = path.slice(0, -1).reduce(function (obj, key) {
                return obj[key];
            }, obj);
            _glimmerObjectReference.setProperty(_parent, path[path.length - 1], value);
        } else {
            _glimmerObjectReference.setProperty(obj, key, value);
        }
    }

    function mixin(obj) {
        for (var _len = arguments.length, extensions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            extensions[_key - 1] = arguments[_key];
        }

        // if (obj._meta) throw new Error("Can't reopen a POJO after mixins were already applied to it");
        extensions.forEach(function (e) {
            return _glimmerObject.toMixin(e).apply(obj);
        });
        return obj;
    }

    function defineProperty(obj, key, desc) {
        var extensions = {};
        extensions[key] = desc;
        mixin(obj, extensions);
    }
});

enifed('@glimmer/object/tests/support.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/object/tests');
    QUnit.test('@glimmer/object/tests/support.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/object/tests/support.ts should pass tslint.');
    });
});

enifed('@glimmer/public-runtime/index.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/public-runtime');
    QUnit.test('@glimmer/public-runtime/index.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/public-runtime/index.ts should pass tslint.');
    });
});

enifed('@glimmer/reference/index.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/reference');
    QUnit.test('@glimmer/reference/index.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/reference/index.ts should pass tslint.');
    });
});

enifed('@glimmer/reference/lib/const.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/reference/lib');
    QUnit.test('@glimmer/reference/lib/const.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/reference/lib/const.ts should pass tslint.');
    });
});

enifed('@glimmer/reference/lib/iterable.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/reference/lib');
    QUnit.test('@glimmer/reference/lib/iterable.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/reference/lib/iterable.ts should pass tslint.');
    });
});

enifed('@glimmer/reference/lib/reference.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/reference/lib');
    QUnit.test('@glimmer/reference/lib/reference.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/reference/lib/reference.ts should pass tslint.');
    });
});

enifed('@glimmer/reference/lib/utils.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/reference/lib');
    QUnit.test('@glimmer/reference/lib/utils.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/reference/lib/utils.ts should pass tslint.');
    });
});

enifed('@glimmer/reference/lib/validators.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/reference/lib');
    QUnit.test('@glimmer/reference/lib/validators.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/reference/lib/validators.ts should pass tslint.');
    });
});

enifed('@glimmer/reference/tests/iterable-test', ['exports', '@glimmer/reference', '@glimmer/object-reference', '@glimmer/util'], function (exports, _glimmerReference, _glimmerObjectReference, _glimmerUtil) {
    'use strict';

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    QUnit.module("Reference iterables");

    var Target = (function () {
        function Target() {
            _classCallCheck(this, Target);

            this.map = _glimmerUtil.dict();
            this.list = new _glimmerUtil.LinkedList();
            this.tag = _glimmerReference.VOLATILE_TAG;
        }

        Target.prototype.retain = function retain(key, item, memo) {
            if (item !== this.map[key].value) {
                throw new Error("unstable reference");
            }
        };

        Target.prototype.done = function done() {};

        Target.prototype.append = function append(key, item, memo) {
            var node = this.map[key] = new _glimmerUtil.ListNode(item);
            this.list.append(node);
        };

        Target.prototype.insert = function insert(key, item, memo, before) {
            var referenceNode = before ? this.map[before] : null;
            var node = this.map[key] = new _glimmerUtil.ListNode(item);
            this.list.insertBefore(node, referenceNode);
        };

        Target.prototype.move = function move(key, item, memo, before) {
            var referenceNode = before ? this.map[before] : null;
            var node = this.map[key];
            if (item !== node.value) {
                throw new Error("unstable reference");
            }
            this.list.remove(node);
            this.list.insertBefore(node, referenceNode);
        };

        Target.prototype.delete = function _delete(key) {
            var node = this.map[key];
            delete this.map[key];
            this.list.remove(node);
        };

        Target.prototype.toArray = function toArray() {
            return this.list.toArray().map(function (node) {
                return node.value;
            });
        };

        Target.prototype.toValues = function toValues() {
            return this.toArray().map(function (ref) {
                return ref.value();
            });
        };

        return Target;
    })();

    var TestIterationItem = function TestIterationItem(key, value, memo) {
        _classCallCheck(this, TestIterationItem);

        this.key = key;
        this.value = value;
        this.memo = memo;
    };

    var TestIterator = (function () {
        function TestIterator(array) {
            _classCallCheck(this, TestIterator);

            this.position = 0;
            this.array = array;
        }

        TestIterator.prototype.isEmpty = function isEmpty() {
            return this.array.length === 0;
        };

        TestIterator.prototype.next = function next() {
            var position = this.position;
            var array = this.array;

            if (position >= array.length) return null;
            var value = array[position];
            this.position++;
            return new TestIterationItem(value.key, value, position);
        };

        return TestIterator;
    })();

    var TestIterable = (function () {
        function TestIterable(arrayRef) {
            _classCallCheck(this, TestIterable);

            this.tag = arrayRef.tag;
            this.arrayRef = arrayRef;
        }

        TestIterable.prototype.iterate = function iterate() {
            return new TestIterator(this.arrayRef.value());
        };

        TestIterable.prototype.valueReferenceFor = function valueReferenceFor(item) {
            return new _glimmerObjectReference.UpdatableReference(item.value);
        };

        TestIterable.prototype.updateValueReference = function updateValueReference(reference, item) {
            reference.update(item.value);
        };

        TestIterable.prototype.memoReferenceFor = function memoReferenceFor(item) {
            return new _glimmerObjectReference.UpdatableReference(item.memo);
        };

        TestIterable.prototype.updateMemoReference = function updateMemoReference(reference, item) {
            reference.update(item.memo);
        };

        return TestIterable;
    })();

    function initialize(arr) {
        var target = new Target();
        var reference = new _glimmerObjectReference.UpdatableReference(arr);
        var iterator = new _glimmerReference.ReferenceIterator(new TestIterable(reference));
        var item = undefined;
        while (item = iterator.next()) {
            target.append(item.key, item.value, item.memo);
        }
        return { reference: reference, target: target, artifacts: iterator.artifacts };
    }
    function sync(target, artifacts) {
        var synchronizer = new _glimmerReference.IteratorSynchronizer({ target: target, artifacts: artifacts });
        synchronizer.sync();
    }
    QUnit.test("They provide a sequence of references with keys", function (assert) {
        var arr = [{ key: "a", name: "Yehuda" }, { key: "b", name: "Godfrey" }];

        var _initialize = initialize(arr);

        var target = _initialize.target;

        assert.deepEqual(target.toValues(), arr);
    });
    QUnit.test("When re-iterated via mutation, the original references are updated", function (assert) {
        var arr = [{ key: "a", name: "Yehuda" }, { key: "b", name: "Godfrey" }];

        var _initialize2 = initialize(arr);

        var target = _initialize2.target;
        var artifacts = _initialize2.artifacts;

        assert.deepEqual(target.toValues(), arr);
        arr.reverse();
        sync(target, artifacts);
        assert.deepEqual(target.toValues(), arr);
        arr.push({ key: "c", name: "Godhuda" });
        sync(target, artifacts);
        assert.deepEqual(target.toValues(), arr);
        arr.shift();
        sync(target, artifacts);
        assert.deepEqual(target.toValues(), arr);
    });
    QUnit.test("When re-iterated via deep mutation, the original references are updated", function (assert) {
        var arr = [{ key: "a", name: "Yehuda" }, { key: "b", name: "Godfrey" }];

        var _initialize3 = initialize(arr);

        var target = _initialize3.target;
        var artifacts = _initialize3.artifacts;

        assert.deepEqual(target.toValues(), arr);
        arr[0].key = "b";
        arr[0].name = "Godfrey";
        arr[1].key = "a";
        arr[1].name = "Yehuda";
        sync(target, artifacts);
        assert.deepEqual(target.toValues(), arr);
        arr[0].name = "Yehuda";
        arr[1].name = "Godfrey";
        sync(target, artifacts);
        assert.deepEqual(target.toValues(), arr);
        arr.push({ key: "c", name: "Godhuda" });
        sync(target, artifacts);
        assert.deepEqual(target.toValues(), arr);
        arr.shift();
        sync(target, artifacts);
        assert.deepEqual(target.toValues(), arr);
    });
    QUnit.test("When re-iterated via replacement, the original references are updated", function (assert) {
        var arr = [{ key: "a", name: "Yehuda" }, { key: "b", name: "Godfrey" }];

        var _initialize4 = initialize(arr);

        var target = _initialize4.target;
        var reference = _initialize4.reference;
        var artifacts = _initialize4.artifacts;

        assert.deepEqual(target.toValues(), arr);
        arr = arr.slice();
        arr.reverse();
        reference.update(arr);
        sync(target, artifacts);
        assert.deepEqual(target.toValues(), arr);
        reference.update([{ key: 'a', name: "Tom" }, { key: "b", name: "Stef " }]);
        sync(target, artifacts);
        assert.deepEqual(target.toValues(), [{ key: 'a', name: "Tom" }, { key: "b", name: "Stef " }]);
        arr = arr.slice();
        arr.push({ key: "c", name: "Godhuda" });
        reference.update(arr);
        sync(target, artifacts);
        assert.deepEqual(target.toValues(), arr);
        arr = arr.slice();
        arr.shift();
        reference.update(arr);
        sync(target, artifacts);
        assert.deepEqual(target.toValues(), arr);
    });
});

enifed('@glimmer/reference/tests/iterable-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/reference/tests');
    QUnit.test('@glimmer/reference/tests/iterable-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/reference/tests/iterable-test.ts should pass tslint.');
    });
});

enifed('@glimmer/reference/tests/references-test', ['exports', '@glimmer/reference', '@glimmer/util'], function (exports, _glimmerReference, _glimmerUtil) {
    'use strict';

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var UpdatableReference = (function () {
        function UpdatableReference(content) {
            _classCallCheck(this, UpdatableReference);

            this.content = content;
            this.tag = this._tag = new _glimmerReference.DirtyableTag();
        }

        UpdatableReference.prototype.value = function value() {
            return this.content;
        };

        UpdatableReference.prototype.update = function update(content) {
            this._tag.dirty();
            return this.content = content;
        };

        return UpdatableReference;
    })();

    var TaggedDict = (function () {
        function TaggedDict() {
            _classCallCheck(this, TaggedDict);

            this.data = _glimmerUtil.dict();
            this.tag = this._tag = new _glimmerReference.DirtyableTag();
        }

        TaggedDict.prototype.get = function get(key) {
            return this.data[key];
        };

        TaggedDict.prototype.set = function set(key, value) {
            this._tag.dirty();
            return this.data[key] = value;
        };

        return TaggedDict;
    })();

    QUnit.module("References");
    QUnit.test("CachedReference caches computation correctly", function (assert) {
        var computed = 0;

        var DictValueReference = (function (_CachedReference) {
            _inherits(DictValueReference, _CachedReference);

            function DictValueReference(dict, key) {
                _classCallCheck(this, DictValueReference);

                _CachedReference.call(this);
                this.dict = dict;
                this.key = key;
                this.tag = dict.tag;
            }

            DictValueReference.prototype.compute = function compute() {
                computed++;
                return this.dict.get(this.key);
            };

            return DictValueReference;
        })(_glimmerReference.CachedReference);

        var dict = new TaggedDict();
        var reference = new DictValueReference(dict, 'foo');
        dict.set('foo', 'bar');
        assert.strictEqual(computed, 0, 'precond');
        assert.equal(reference.value(), 'bar');
        assert.equal(reference.value(), 'bar');
        assert.equal(reference.value(), 'bar');
        assert.strictEqual(computed, 1, 'computed');
        dict.set('foo', 'BAR');
        assert.equal(reference.value(), 'BAR');
        assert.equal(reference.value(), 'BAR');
        assert.equal(reference.value(), 'BAR');
        assert.strictEqual(computed, 2, 'computed');
        dict.set('baz', 'bat');
        assert.equal(reference.value(), 'BAR');
        assert.equal(reference.value(), 'BAR');
        assert.equal(reference.value(), 'BAR');
        assert.strictEqual(computed, 3, 'computed');
        dict.set('foo', 'bar');
        assert.equal(reference.value(), 'bar');
        assert.equal(reference.value(), 'bar');
        assert.equal(reference.value(), 'bar');
        assert.strictEqual(computed, 4, 'computed');
    });
    QUnit.test("CachedReference caches nested computation correctly", function (assert) {
        var computed = 0;

        var DictValueReference = (function (_CachedReference2) {
            _inherits(DictValueReference, _CachedReference2);

            function DictValueReference(parent, key) {
                _classCallCheck(this, DictValueReference);

                _CachedReference2.call(this);
                this.parent = parent;
                this.key = key;
                var _tag = this._tag = new _glimmerReference.UpdatableTag(_glimmerReference.CONSTANT_TAG);
                this.tag = _glimmerReference.combine([parent.tag, _tag]);
            }

            DictValueReference.prototype.compute = function compute() {
                computed++;
                var parent = this.parent;
                var _tag = this._tag;
                var key = this.key;

                var dict = parent.value();
                _tag.update(dict.tag);
                return dict.get(key);
            };

            return DictValueReference;
        })(_glimmerReference.CachedReference);

        var first = new TaggedDict();
        var second = new TaggedDict();
        var dictReference = new UpdatableReference(first);
        var valueReference = new DictValueReference(dictReference, 'foo');
        first.set('foo', 'bar');
        assert.strictEqual(computed, 0, 'precond');
        assert.equal(valueReference.value(), 'bar');
        assert.equal(valueReference.value(), 'bar');
        assert.equal(valueReference.value(), 'bar');
        assert.strictEqual(computed, 1, 'computed');
        second.set('foo', 'BAR');
        assert.equal(valueReference.value(), 'bar');
        assert.equal(valueReference.value(), 'bar');
        assert.equal(valueReference.value(), 'bar');
        assert.strictEqual(computed, 1, 'computed');
        dictReference.update(second);
        assert.equal(valueReference.value(), 'BAR');
        assert.equal(valueReference.value(), 'BAR');
        assert.equal(valueReference.value(), 'BAR');
        assert.strictEqual(computed, 2, 'computed');
        second.set('foo', 'foo-bar');
        assert.equal(valueReference.value(), 'foo-bar');
        assert.equal(valueReference.value(), 'foo-bar');
        assert.equal(valueReference.value(), 'foo-bar');
        assert.strictEqual(computed, 3, 'computed');
    });
});

enifed('@glimmer/reference/tests/references-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/reference/tests');
    QUnit.test('@glimmer/reference/tests/references-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/reference/tests/references-test.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/index.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime');
    QUnit.test('@glimmer/runtime/index.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/index.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/bootstrap.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib');
    QUnit.test('@glimmer/runtime/lib/bootstrap.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/bootstrap.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/bounds.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib');
    QUnit.test('@glimmer/runtime/lib/bounds.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/bounds.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/builder.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib');
    QUnit.test('@glimmer/runtime/lib/builder.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/builder.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compat/inner-html-fix.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compat');
    QUnit.test('@glimmer/runtime/lib/compat/inner-html-fix.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compat/inner-html-fix.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compat/svg-inner-html-fix.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compat');
    QUnit.test('@glimmer/runtime/lib/compat/svg-inner-html-fix.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compat/svg-inner-html-fix.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compat/text-node-merging-fix.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compat');
    QUnit.test('@glimmer/runtime/lib/compat/text-node-merging-fix.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compat/text-node-merging-fix.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compiled/blocks.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compiled');
    QUnit.test('@glimmer/runtime/lib/compiled/blocks.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compiled/blocks.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compiled/expressions.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compiled');
    QUnit.test('@glimmer/runtime/lib/compiled/expressions.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compiled/expressions.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compiled/expressions/args.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compiled/expressions');
    QUnit.test('@glimmer/runtime/lib/compiled/expressions/args.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compiled/expressions/args.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compiled/expressions/concat.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compiled/expressions');
    QUnit.test('@glimmer/runtime/lib/compiled/expressions/concat.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compiled/expressions/concat.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compiled/expressions/function.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compiled/expressions');
    QUnit.test('@glimmer/runtime/lib/compiled/expressions/function.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compiled/expressions/function.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compiled/expressions/has-block.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compiled/expressions');
    QUnit.test('@glimmer/runtime/lib/compiled/expressions/has-block.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compiled/expressions/has-block.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compiled/expressions/helper.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compiled/expressions');
    QUnit.test('@glimmer/runtime/lib/compiled/expressions/helper.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compiled/expressions/helper.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compiled/expressions/lookups.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compiled/expressions');
    QUnit.test('@glimmer/runtime/lib/compiled/expressions/lookups.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compiled/expressions/lookups.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compiled/expressions/named-args.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compiled/expressions');
    QUnit.test('@glimmer/runtime/lib/compiled/expressions/named-args.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compiled/expressions/named-args.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compiled/expressions/positional-args.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compiled/expressions');
    QUnit.test('@glimmer/runtime/lib/compiled/expressions/positional-args.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compiled/expressions/positional-args.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compiled/expressions/value.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compiled/expressions');
    QUnit.test('@glimmer/runtime/lib/compiled/expressions/value.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compiled/expressions/value.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compiled/opcodes/blocks.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compiled/opcodes');
    QUnit.test('@glimmer/runtime/lib/compiled/opcodes/blocks.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compiled/opcodes/blocks.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compiled/opcodes/builder.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compiled/opcodes');
    QUnit.test('@glimmer/runtime/lib/compiled/opcodes/builder.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compiled/opcodes/builder.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compiled/opcodes/component.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compiled/opcodes');
    QUnit.test('@glimmer/runtime/lib/compiled/opcodes/component.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compiled/opcodes/component.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compiled/opcodes/content.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compiled/opcodes');
    QUnit.test('@glimmer/runtime/lib/compiled/opcodes/content.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compiled/opcodes/content.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compiled/opcodes/dom.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compiled/opcodes');
    QUnit.test('@glimmer/runtime/lib/compiled/opcodes/dom.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compiled/opcodes/dom.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compiled/opcodes/lists.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compiled/opcodes');
    QUnit.test('@glimmer/runtime/lib/compiled/opcodes/lists.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compiled/opcodes/lists.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compiled/opcodes/partial.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compiled/opcodes');
    QUnit.test('@glimmer/runtime/lib/compiled/opcodes/partial.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compiled/opcodes/partial.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compiled/opcodes/vm.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/compiled/opcodes');
    QUnit.test('@glimmer/runtime/lib/compiled/opcodes/vm.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compiled/opcodes/vm.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/compiler.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib');
    QUnit.test('@glimmer/runtime/lib/compiler.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/compiler.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/component/interfaces.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/component');
    QUnit.test('@glimmer/runtime/lib/component/interfaces.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/component/interfaces.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/dom/attribute-managers.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/dom');
    QUnit.test('@glimmer/runtime/lib/dom/attribute-managers.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/dom/attribute-managers.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/dom/helper.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/dom');
    QUnit.test('@glimmer/runtime/lib/dom/helper.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/dom/helper.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/dom/interfaces.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/dom');
    QUnit.test('@glimmer/runtime/lib/dom/interfaces.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/dom/interfaces.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/dom/props.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/dom');
    QUnit.test('@glimmer/runtime/lib/dom/props.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/dom/props.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/dom/sanitized-values.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/dom');
    QUnit.test('@glimmer/runtime/lib/dom/sanitized-values.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/dom/sanitized-values.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/environment.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib');
    QUnit.test('@glimmer/runtime/lib/environment.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/environment.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/helpers/get-dynamic-var.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/helpers');
    QUnit.test('@glimmer/runtime/lib/helpers/get-dynamic-var.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/helpers/get-dynamic-var.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/modifier/interfaces.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/modifier');
    QUnit.test('@glimmer/runtime/lib/modifier/interfaces.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/modifier/interfaces.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/opcode-builder.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib');
    QUnit.test('@glimmer/runtime/lib/opcode-builder.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/opcode-builder.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/opcodes.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib');
    QUnit.test('@glimmer/runtime/lib/opcodes.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/opcodes.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/partial.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib');
    QUnit.test('@glimmer/runtime/lib/partial.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/partial.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/references.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib');
    QUnit.test('@glimmer/runtime/lib/references.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/references.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/scanner.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib');
    QUnit.test('@glimmer/runtime/lib/scanner.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/scanner.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/symbol-table.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib');
    QUnit.test('@glimmer/runtime/lib/symbol-table.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/symbol-table.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/syntax/functions.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/syntax');
    QUnit.test('@glimmer/runtime/lib/syntax/functions.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/syntax/functions.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/syntax/specialize.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/syntax');
    QUnit.test('@glimmer/runtime/lib/syntax/specialize.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/syntax/specialize.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/template.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib');
    QUnit.test('@glimmer/runtime/lib/template.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/template.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/upsert.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib');
    QUnit.test('@glimmer/runtime/lib/upsert.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/upsert.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/utils.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib');
    QUnit.test('@glimmer/runtime/lib/utils.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/utils.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/vm.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib');
    QUnit.test('@glimmer/runtime/lib/vm.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/vm.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/vm/append.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/vm');
    QUnit.test('@glimmer/runtime/lib/vm/append.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/vm/append.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/vm/frame.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/vm');
    QUnit.test('@glimmer/runtime/lib/vm/frame.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/vm/frame.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/vm/render-result.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/vm');
    QUnit.test('@glimmer/runtime/lib/vm/render-result.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/vm/render-result.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/lib/vm/update.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/lib/vm');
    QUnit.test('@glimmer/runtime/lib/vm/update.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/lib/vm/update.ts should pass tslint.');
    });
});

enifed("@glimmer/runtime/tests/attributes-test", ["exports", "@glimmer/runtime/index", "@glimmer/test-helpers", "@glimmer/object-reference"], function (exports, _glimmerRuntimeIndex, _glimmerTestHelpers, _glimmerObjectReference) {
    "use strict";

    var root = undefined;
    var env = undefined;
    var self = undefined;
    var result = undefined;
    function compile(template) {
        return env.compile(template);
    }
    function rootElement() {
        return env.getDOM().createElement('div');
    }
    function commonSetup() {
        env = new _glimmerTestHelpers.TestEnvironment(); // TODO: Support SimpleDOM
        root = rootElement();
        root.setAttribute('debug-root', 'true');
    }
    function render(template) {
        var context = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
        var view = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

        self = new _glimmerObjectReference.UpdatableReference(context);
        env.begin();
        result = template.render(self, root, new _glimmerTestHelpers.TestDynamicScope());
        env.commit();
        assertInvariants(result);
        return result;
    }
    function assertInvariants(result, msg) {
        strictEqual(result.firstNode(), root.firstChild, "The firstNode of the result is the same as the root's firstChild" + (msg ? ': ' + msg : ''));
        strictEqual(result.lastNode(), root.lastChild, "The lastNode of the result is the same as the root's lastChild" + (msg ? ': ' + msg : ''));
    }
    function rerender() {
        var context = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

        if (context !== null) self.update(context);
        env.begin();
        result.rerender();
        env.commit();
    }
    // used to obtain the resulting property value after assignment
    function nativeValueForElementProperty(tagName, property, value) {
        var element = document.createElement(tagName);
        element[property] = value;
        return element[property];
    }
    QUnit.module("Attributes", {
        setup: commonSetup
    });
    test("helpers shadow self", function () {
        env.registerHelper('foo', function () {
            return "hello";
        });
        var template = compile('<div data-test="{{foo}}"></div>');
        var context = { foo: 'bye' };
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, '<div data-test="hello"></div>');
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div data-test="hello"></div>');
        rerender({ foo: 'bar' });
        _glimmerTestHelpers.equalTokens(root, '<div data-test="hello"></div>');
        rerender({ foo: 'bye' });
        _glimmerTestHelpers.equalTokens(root, '<div data-test="hello"></div>');
    });
    test("disable updates properly", function () {
        var template = compile('<input disabled={{enabled}} />');
        var context = { enabled: true };
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, '<input disabled />');
        rerender({ enabled: false });
        _glimmerTestHelpers.equalTokens(root, '<input />');
        rerender({ enabled: 'wat' });
        _glimmerTestHelpers.equalTokens(root, '<input disabled />');
        rerender({ enabled: null });
        _glimmerTestHelpers.equalTokens(root, '<input />');
        rerender({ enabled: true });
        _glimmerTestHelpers.equalTokens(root, '<input disabled />');
        rerender({ enabled: undefined });
        _glimmerTestHelpers.equalTokens(root, '<input />');
        rerender({ enabled: true });
        _glimmerTestHelpers.equalTokens(root, '<input disabled />');
    });
    test("quoted disable is always disabled", function () {
        var template = compile('<input disabled="{{enabled}}" />');
        var context = { enabled: true };
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, '<input disabled />');
        rerender({ enabled: false });
        _glimmerTestHelpers.equalTokens(root, '<input disabled />');
        rerender({ enabled: 'wat' });
        _glimmerTestHelpers.equalTokens(root, '<input disabled />');
        rerender({ enabled: null });
        _glimmerTestHelpers.equalTokens(root, '<input />');
        rerender({ enabled: true });
        _glimmerTestHelpers.equalTokens(root, '<input disabled />');
        rerender({ enabled: undefined });
        _glimmerTestHelpers.equalTokens(root, '<input />');
        rerender({ enabled: true });
        _glimmerTestHelpers.equalTokens(root, '<input disabled />');
    });
    test("disable without an explicit value is truthy", function () {
        var template = compile('<input disabled />');
        render(template, {});
        _glimmerTestHelpers.equalTokens(root, '<input disabled />');
        ok(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'disabled'));
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<input disabled />');
        ok(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'disabled'));
    });
    test("a[href] marks javascript: protocol as unsafe", function () {
        var template = compile('<a href="{{foo}}"></a>');
        var context = { foo: 'javascript:foo()' };
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, '<a href="unsafe:javascript:foo()"></a>');
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<a href="unsafe:javascript:foo()"></a>');
    });
    test("a[href] marks javascript: protocol as unsafe, http as safe", function () {
        var template = compile('<a href="{{foo}}"></a>');
        var context = { foo: 'javascript:foo()' };
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, '<a href="unsafe:javascript:foo()"></a>');
        rerender({ foo: 'http://foo.bar' });
        _glimmerTestHelpers.equalTokens(root, '<a href="http://foo.bar"></a>');
        rerender({ foo: 'javascript:foo()' });
        _glimmerTestHelpers.equalTokens(root, '<a href="unsafe:javascript:foo()"></a>');
    });
    test("a[href] marks javascript: protocol as unsafe on updates", function () {
        var template = compile('<a href="{{foo}}"></a>');
        var context = { foo: 'http://foo.bar' };
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, '<a href="http://foo.bar"></a>');
        rerender({ foo: 'javascript:foo()' });
        _glimmerTestHelpers.equalTokens(root, '<a href="unsafe:javascript:foo()"></a>');
        rerender({ foo: 'http://foo.bar' });
        _glimmerTestHelpers.equalTokens(root, '<a href="http://foo.bar"></a>');
    });
    test("a[href] marks vbscript: protocol as unsafe", function () {
        var template = compile('<a href="{{foo}}"></a>');
        var context = { foo: 'vbscript:foo()' };
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, '<a href="unsafe:vbscript:foo()"></a>');
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<a href="unsafe:vbscript:foo()"></a>');
    });
    test("a[href] can be removed by setting to `null`", function () {
        var template = compile('<a href={{foo}}></a>');
        var context = { foo: 'http://foo.bar/derp.jpg' };
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, '<a href="http://foo.bar/derp.jpg"></a>');
        rerender({ foo: null });
        _glimmerTestHelpers.equalTokens(root, '<a></a>');
    });
    test("a[href] can be removed by setting to `undefined`", function () {
        var template = compile('<a href={{foo}}></a>');
        var context = { foo: 'http://foo.bar/derp.jpg' };
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, '<a href="http://foo.bar/derp.jpg"></a>');
        rerender({ foo: undefined });
        _glimmerTestHelpers.equalTokens(root, '<a></a>');
    });
    test("img[src] marks javascript: protocol as unsafe", function () {
        var template = compile('<img src="{{foo}}">');
        var context = { foo: 'javascript:foo()' };
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, '<img src="unsafe:javascript:foo()">');
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<img src="unsafe:javascript:foo()">');
    });
    test("img[src] marks javascript: protocol as unsafe on updates", function () {
        var template = compile('<img src="{{foo}}">');
        var context = { foo: 'http://foo.bar/derp.jpg' };
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, '<img src="http://foo.bar/derp.jpg">');
        rerender({ foo: 'javascript:foo()' });
        _glimmerTestHelpers.equalTokens(root, '<img src="unsafe:javascript:foo()">');
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<img src="unsafe:javascript:foo()">');
    });
    test("img[src] marks javascript: protocol as unsafe, http as safe", function () {
        var template = compile('<img src="{{foo}}">');
        var context = { foo: 'javascript:foo()' };
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, '<img src="unsafe:javascript:foo()">');
        rerender({ foo: 'http://foo.bar' });
        _glimmerTestHelpers.equalTokens(root, '<img src="http://foo.bar">');
        rerender({ foo: 'javascript:foo()' });
        _glimmerTestHelpers.equalTokens(root, '<img src="unsafe:javascript:foo()">');
    });
    test("img[src] marks vbscript: protocol as unsafe", function () {
        var template = compile('<img src="{{foo}}">');
        var context = { foo: 'vbscript:foo()' };
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, '<img src="unsafe:vbscript:foo()">');
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<img src="unsafe:vbscript:foo()">');
    });
    test("img[src] can be removed by setting to `null`", function () {
        var template = compile('<img src={{foo}}>');
        var context = { foo: 'http://foo.bar/derp.jpg' };
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, '<img src="http://foo.bar/derp.jpg">');
        rerender({ foo: null });
        _glimmerTestHelpers.equalTokens(root, '<img>');
    });
    test("img[src] can be removed by setting to `undefined`", function () {
        var template = compile('<img src={{foo}}>');
        var context = { foo: 'http://foo.bar/derp.jpg' };
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, '<img src="http://foo.bar/derp.jpg">');
        rerender({ foo: undefined });
        _glimmerTestHelpers.equalTokens(root, '<img>');
    });
    test("div[href] is not not marked as unsafe", function () {
        var template = compile('<div href="{{foo}}"></div>');
        var context = { foo: 'javascript:foo()' };
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, '<div href="javascript:foo()"></div>');
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div href="javascript:foo()"></div>');
    });
    test("triple curlies in attribute position", function (assert) {
        var template = compile('<div data-bar="bar" data-foo={{{rawString}}}>Hello</div>');
        render(template, { rawString: 'TRIPLE' });
        _glimmerTestHelpers.equalTokens(root, '<div data-foo="TRIPLE" data-bar="bar">Hello</div>', "initial render");
        rerender({ rawString: 'DOUBLE' });
        _glimmerTestHelpers.equalTokens(root, '<div data-foo="DOUBLE" data-bar="bar">Hello</div>', "initial render");
    });
    test('can read attributes', function (assert) {
        var template = compile('<div data-bar="bar"></div>');
        render(template);
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'data-bar'), 'bar');
    });
    test('can read attributes from namespace elements', function (assert) {
        var template = compile('<svg viewBox="0 0 0 0"></svg>');
        render(template);
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'viewBox'), '0 0 0 0');
    });
    test('can read properties', function (assert) {
        var template = compile('<input value="gnargnar" />');
        render(template);
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'value'), 'gnargnar');
    });
    test('handles null input values', function (assert) {
        var template = compile('<input value={{isNull}} />');
        render(template, { isNull: null });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'value'), '');
        rerender({ isNull: 'hey' });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'value'), 'hey');
        rerender({ isNull: null });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'value'), '');
    });
    test('handles undefined input values', function (assert) {
        var template = compile('<input value={{isUndefined}} />');
        render(template, { isUndefined: undefined });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'value'), '');
        rerender({ isUndefined: 'hey' });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'value'), 'hey');
        rerender({ isUndefined: undefined });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'value'), '');
    });
    test('handles undefined `toString` input values', function (assert) {
        var obj = Object.create(null);
        var template = compile('<input value={{obj}} />');
        render(template, { obj: obj });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'value'), '');
        rerender({ obj: 'hello' });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'value'), 'hello');
        rerender({ obj: obj });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'value'), '');
    });
    test('input[checked] prop updates when set to undefined', function (assert) {
        var template = compile('<input checked={{if foo true undefined}} />');
        env.registerHelper('if', function (params) {
            if (params[0]) {
                return params[1];
            } else {
                return params[2];
            }
        });
        render(template, { foo: true });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'checked'), true);
        rerender({ foo: false });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'checked'), false);
        rerender({ foo: true });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'checked'), true);
    });
    test('input[checked] prop updates when set to null', function (assert) {
        var template = compile('<input checked={{foo}} />');
        render(template, { foo: true });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'checked'), true);
        rerender({ foo: null });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'checked'), false);
        rerender({ foo: true });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'checked'), true);
    });
    test('select[value] prop updates when set to undefined', function (assert) {
        var template = compile('<select value={{foo}}><option></option><option value="us" selected>us</option></select>');
        // setting `select[value]` only works after initial render, just use `undefined` here but it doesn't really matter
        render(template, { foo: undefined });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'value'), 'us');
        // now setting the `value` property will have an effect
        rerender({ foo: null });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'value'), '');
        rerender({ foo: 'us' });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'value'), 'us');
    });
    test('handles empty string textarea values', function (assert) {
        var template = compile('<textarea value={{name}} />');
        render(template, { name: '' });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'value'), '');
        rerender({ name: 'Alex' });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'value'), 'Alex');
        rerender({ name: '' });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'value'), '');
    });
    test('handles empty string input placeholders', function (assert) {
        var template = compile('<input type="text" placeholder={{name}} />');
        render(template, { name: '' });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'placeholder'), '');
        rerender({ name: 'Alex' });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'placeholder'), 'Alex');
        rerender({ name: '' });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(root.firstChild, 'placeholder'), '');
    });
    test('does not set undefined attributes', function (assert) {
        var template = compile('<div data-foo={{isUndefined}} /><div data-foo={{isNotUndefined}} />');
        render(template, { isUndefined: undefined, isNotUndefined: 'hello' });
        var firstElement = root.firstChild;
        var secondElement = root.lastChild;
        assert.ok(!firstElement.hasAttribute('data-foo'));
        assert.ok(secondElement.hasAttribute('data-foo'));
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(secondElement, 'data-foo'), 'hello');
        rerender({ isUndefined: 'hey', isNotUndefined: 'hello' });
        assert.ok(firstElement.hasAttribute('data-foo'));
        assert.ok(secondElement.hasAttribute('data-foo'));
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(secondElement, 'data-foo'), 'hello');
        rerender({ isUndefined: 'hey', isNotUndefined: 'world' });
        assert.ok(firstElement.hasAttribute('data-foo'));
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(firstElement, 'data-foo'), 'hey');
        assert.ok(secondElement.hasAttribute('data-foo'));
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(secondElement, 'data-foo'), 'world');
        rerender({ isUndefined: undefined, isNotUndefined: 'hello' });
        assert.ok(!firstElement.hasAttribute('data-foo'));
        assert.ok(secondElement.hasAttribute('data-foo'));
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(secondElement, 'data-foo'), 'hello');
    });
    test('does not set null attributes', function (assert) {
        var template = compile('<div data-foo={{isNull}} /><div data-foo={{isNotNull}}></div>');
        render(template, { isNull: null, isNotNull: 'hello' });
        var firstElement = root.firstChild;
        var secondElement = root.lastChild;
        assert.ok(!firstElement.hasAttribute('data-foo'));
        assert.ok(secondElement.hasAttribute('data-foo'));
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(secondElement, 'data-foo'), 'hello');
        rerender({ isNull: 'hey', isNotNull: 'hello' });
        assert.ok(firstElement.hasAttribute('data-foo'));
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(firstElement, 'data-foo'), 'hey');
        assert.ok(secondElement.hasAttribute('data-foo'));
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(secondElement, 'data-foo'), 'hello');
        rerender({ isNull: 'hey', isNotNull: 'world' });
        assert.ok(firstElement.hasAttribute('data-foo'));
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(firstElement, 'data-foo'), 'hey');
        assert.ok(secondElement.hasAttribute('data-foo'));
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(secondElement, 'data-foo'), 'world');
        rerender({ isNull: null, isNotNull: 'hello' });
        assert.ok(!firstElement.hasAttribute('data-foo'));
        assert.ok(secondElement.hasAttribute('data-foo'));
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(secondElement, 'data-foo'), 'hello');
    });
    test('does not set undefined properties initially', function (assert) {
        var template = compile('<div title={{isUndefined}} /><div title={{isNotUndefined}}></div>');
        render(template, { isUndefined: undefined, isNotUndefined: 'hello' });
        var firstElement = root.firstChild;
        var secondElement = root.lastChild;
        assert.ok(!firstElement.hasAttribute('title'));
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(secondElement, 'title'), 'hello');
        _glimmerTestHelpers.equalTokens(root, '<div></div><div title="hello"></div>');
        rerender({ isUndefined: 'hey', isNotUndefined: 'hello' });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(firstElement, 'title'), 'hey');
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(secondElement, 'title'), 'hello');
        _glimmerTestHelpers.equalTokens(root, '<div title="hey"></div><div title="hello"></div>');
        rerender({ isUndefined: 'hey', isNotUndefined: 'world' });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(firstElement, 'title'), 'hey');
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(secondElement, 'title'), 'world');
        _glimmerTestHelpers.equalTokens(root, '<div title="hey"></div><div title="world"></div>');
        rerender({ isUndefined: undefined, isNotUndefined: 'hello' });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(secondElement, 'title'), 'hello');
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(firstElement, 'title'), '');
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(firstElement, 'title'), nativeValueForElementProperty('div', 'title', ''));
        _glimmerTestHelpers.equalTokens(root, '<div></div><div title="hello"></div>');
    });
    test('does not set null properties initially', function (assert) {
        var template = compile('<div title={{isNull}} /><div title={{isNotNull}}></div>');
        render(template, { isNull: null, isNotNull: 'hello' });
        var firstElement = root.firstChild;
        var secondElement = root.lastChild;
        assert.ok(!firstElement.hasAttribute('title'));
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(secondElement, 'title'), 'hello');
        _glimmerTestHelpers.equalTokens(root, '<div></div><div title="hello"></div>');
        rerender({ isNull: 'hey', isNotNull: 'hello' });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(firstElement, 'title'), 'hey');
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(secondElement, 'title'), 'hello');
        _glimmerTestHelpers.equalTokens(root, '<div title="hey"></div><div title="hello"></div>');
        rerender({ isNull: 'hey', isNotNull: 'world' });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(firstElement, 'title'), 'hey');
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(secondElement, 'title'), 'world');
        _glimmerTestHelpers.equalTokens(root, '<div title="hey"></div><div title="world"></div>');
        rerender({ isNull: null, isNotNull: 'hello' });
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(secondElement, 'title'), 'hello');
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(firstElement, 'title'), '');
        assert.equal(_glimmerRuntimeIndex.readDOMAttr(firstElement, 'title'), nativeValueForElementProperty('div', 'title', ''));
        _glimmerTestHelpers.equalTokens(root, '<div></div><div title="hello"></div>');
    });
    test("input list attribute updates properly", function () {
        var template = compile('<input list="{{foo}}" />');
        var context = { foo: "bar" };
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, '<input list="bar" />');
        rerender({ foo: "baz" });
        _glimmerTestHelpers.equalTokens(root, '<input list="baz" />');
        rerender({ foo: "bar" });
        _glimmerTestHelpers.equalTokens(root, '<input list="bar" />');
    });
});

enifed('@glimmer/runtime/tests/attributes-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/tests');
    QUnit.test('@glimmer/runtime/tests/attributes-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/tests/attributes-test.ts should pass tslint.');
    });
});

enifed("@glimmer/runtime/tests/compile-errors-test", ["exports", "@glimmer/test-helpers"], function (exports, _glimmerTestHelpers) {
    "use strict";

    var env = undefined;
    QUnit.module("Compile errors", {
        setup: function () {
            env = new _glimmerTestHelpers.TestEnvironment();
        }
    });
    QUnit.test('context switching using ../ is not allowed', function (assert) {
        assert.throws(function () {
            env.compile('<div><p>{{../value}}</p></div>');
        }, new Error("Changing context using \"../\" is not supported in Glimmer: \"../value\" on line 1."));
    });
    QUnit.test('mixing . and / is not allowed', function (assert) {
        assert.throws(function () {
            env.compile('<div><p>{{a/b.c}}</p></div>');
        }, new Error("Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths: \"a/b.c\" on line 1."));
    });
    QUnit.test('explicit self ref with ./ is not allowed', function (assert) {
        assert.throws(function () {
            env.compile('<div><p>{{./value}}</p></div>');
        }, new Error("Using \"./\" is not supported in Glimmer and unnecessary: \"./value\" on line 1."), "should throw error");
    });
});

enifed('@glimmer/runtime/tests/compile-errors-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/tests');
    QUnit.test('@glimmer/runtime/tests/compile-errors-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/tests/compile-errors-test.ts should pass tslint.');
    });
});

enifed("@glimmer/runtime/tests/component-test", ["exports", "@glimmer/test-helpers", "@glimmer/object-reference"], function (exports, _glimmerTestHelpers, _glimmerObjectReference) {
    "use strict";

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    var env = undefined,
        root = undefined,
        result = undefined,
        self = undefined;
    function rootElement() {
        return env.getDOM().createElement('div');
    }
    function compile(template) {
        return env.compile(template);
    }
    function commonSetup() {
        env = new _glimmerTestHelpers.TestEnvironment(); // TODO: Support SimpleDOM
        env.registerBasicComponent('my-component', MyComponent, "<div>{{yield}}</div>");
        root = rootElement();
    }
    function render(template) {
        var context = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        self = new _glimmerObjectReference.UpdatableReference(context);
        env.begin();
        result = template.render(self, root, new _glimmerTestHelpers.TestDynamicScope());
        env.commit();
        assertInvariants(result);
        return result;
    }
    function rerender() {
        var context = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

        if (context !== null) self.update(context);
        env.begin();
        result.rerender();
        env.commit();
    }
    function assertInvariants(result) {
        strictEqual(result.firstNode(), root.firstChild, "The firstNode of the result is the same as the root's firstChild");
        strictEqual(result.lastNode(), root.lastChild, "The lastNode of the result is the same as the root's lastChild");
    }
    QUnit.module("Components", {
        setup: commonSetup
    });

    var MyComponent = (function (_BasicComponent) {
        _inherits(MyComponent, _BasicComponent);

        function MyComponent(attrs) {
            _classCallCheck(this, MyComponent);

            _BasicComponent.call(this, attrs);
            this.attrs = attrs;
        }

        _createClass(MyComponent, [{
            key: "testing",
            get: function () {
                if (this.attrs.color === 'red') {
                    return '123';
                } else {
                    return '456';
                }
            }
        }]);

        return MyComponent;
    })(_glimmerTestHelpers.BasicComponent);

    var MyOtherComponent = (function (_BasicComponent2) {
        _inherits(MyOtherComponent, _BasicComponent2);

        function MyOtherComponent() {
            _classCallCheck(this, MyOtherComponent);

            _BasicComponent2.apply(this, arguments);
        }

        return MyOtherComponent;
    })(_glimmerTestHelpers.BasicComponent);

    QUnit.test('creating a new component', function (assert) {
        var template = compile("<my-component color='{{color}}'>hello!</my-component>");
        render(template, { color: 'red' });
        _glimmerTestHelpers.equalTokens(root, "<div color='red'>hello!</div>");
        rerender({ color: 'green' });
        _glimmerTestHelpers.equalTokens(root, "<div color='green'>hello!</div>");
    });
    QUnit.test('the component class is its context', function (assert) {
        env.registerBasicComponent('my-component', MyComponent, '<div><p>{{testing}}</p>{{yield}}</div>');
        var template = compile("<my-component @color={{color}} color='{{color}}'>hello!</my-component>");
        render(template, { color: 'red' });
        _glimmerTestHelpers.equalTokens(root, "<div color='red'><p>123</p>hello!</div>");
        rerender({ color: 'green' });
        _glimmerTestHelpers.equalTokens(root, "<div color='green'><p>456</p>hello!</div>");
    });
    QUnit.test('attrs are available in the layout', function (assert) {
        env.registerBasicComponent('my-component', MyComponent, '<div><p>{{attrs.color}}</p>{{yield}}</div>');
        var template = compile("<my-component color='{{color}}' @color={{color}}>hello!</my-component>");
        render(template, { color: 'red' });
        _glimmerTestHelpers.equalTokens(root, "<div color='red'><p>red</p>hello!</div>");
        rerender({ color: 'green' });
        _glimmerTestHelpers.equalTokens(root, "<div color='green'><p>green</p>hello!</div>");
    });
    QUnit.test('nested components', function (assert) {
        env.registerBasicComponent('my-other-component', MyOtherComponent, '<p>{{yield}}</p>');
        var template = compile('<my-component><my-other-component>{{color}}</my-other-component></my-component>');
        render(template, { color: 'red' });
        _glimmerTestHelpers.equalTokens(root, '<div><p>red</p></div>');
        rerender({ color: 'green' });
        _glimmerTestHelpers.equalTokens(root, '<div><p>green</p></div>');
    });
    function testError(layout, expected) {
        QUnit.skip("'" + layout + "' produces an error like " + expected, function (assert) {
            env.registerBasicComponent('my-component', MyComponent, layout);
            var template = compile("<my-component>hello!</my-component>");
            assert.throws(function () {
                return render(template);
            }, expected);
        });
    }
    testError("<div>{{yield}}</div>nope", /non-whitespace text/);
    testError("<div>{{yield}}</div><div></div>", /multiple root elements/);
    testError("<div>{{yield}}</div>{{color}}", /cannot have curlies/);
    testError("{{color}}", /cannot have curlies/);
    testError("nope", /non-whitespace text/);
    testError("", /single root element/);
});

enifed('@glimmer/runtime/tests/component-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/tests');
    QUnit.test('@glimmer/runtime/tests/component-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/tests/component-test.ts should pass tslint.');
    });
});

enifed("@glimmer/runtime/tests/debugger-test", ["exports", "@glimmer/runtime", "@glimmer/test-helpers", "@glimmer/object-reference"], function (exports, _glimmerRuntime, _glimmerTestHelpers, _glimmerObjectReference) {
    "use strict";

    var env = undefined,
        root = undefined,
        result = undefined,
        self = undefined;
    function rootElement() {
        return env.getDOM().createElement('div');
    }
    function compile(template) {
        return env.compile(template);
    }
    function commonSetup() {
        env = new _glimmerTestHelpers.TestEnvironment(); // TODO: Support SimpleDOM
        root = rootElement();
    }
    function render(template) {
        var context = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        self = new _glimmerObjectReference.UpdatableReference(context);
        env.begin();
        result = template.render(self, root, new _glimmerTestHelpers.TestDynamicScope());
        env.commit();
        return result;
    }
    QUnit.module("Debugger", {
        setup: commonSetup,
        afterEach: function () {
            _glimmerRuntime.resetDebuggerCallback();
        }
    });
    QUnit.test('basic debugger statement', function (assert) {
        var template = compile("{{debugger}}");
        _glimmerRuntime.setDebuggerCallback(function (context, get) {
            assert.equal(context.foo, 'bar');
            assert.ok(context.a.b.c);
            assert.equal(get('foo'), 'bar');
            assert.ok(get('a.b.c'));
        });
        render(template, {
            foo: 'bar',
            a: {
                b: {
                    c: true
                }
            }
        });
    });
    QUnit.test('can get locals', function (assert) {
        var template = compile("{{#with foo as |bar|}}{{debugger}}{{/with}}");
        _glimmerRuntime.setDebuggerCallback(function (context, get) {
            assert.equal(get('foo'), 'woot');
            assert.equal(get('bar'), 'woot');
            assert.deepEqual(get('this'), context);
        });
        render(template, {
            foo: 'woot'
        });
    });
});

enifed('@glimmer/runtime/tests/debugger-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/tests');
    QUnit.test('@glimmer/runtime/tests/debugger-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/tests/debugger-test.ts should pass tslint.');
    });
});

enifed("@glimmer/runtime/tests/ember-component-test",["exports","@glimmer/object","@glimmer/test-helpers","@glimmer/util","@glimmer/object-reference"],function(exports,_glimmerObject,_glimmerTestHelpers,_glimmerUtil,_glimmerObjectReference){"use strict";exports.appendViewFor = appendViewFor;exports.assertAppended = assertAppended;exports.assertElementIsEmberishElement = assertElementIsEmberishElement;var _templateObject=_taggedTemplateLiteralLoose(["\n      <div>\n        {{component something}}\n      </div>"],["\n      <div>\n        {{component something}}\n      </div>"]),_templateObject2=_taggedTemplateLiteralLoose(["{{#with @a as |item|}}{{@a}}: {{item}}, {{#with @b as |item|}}\n                     {{@b}}: {{item}}, {{#with @c as |item|}}{{@c}}: {{item}}{{/with}}{{/with}}{{/with}}"],["{{#with @a as |item|}}{{@a}}: {{item}}, {{#with @b as |item|}}\n                     {{@b}}: {{item}}, {{#with @c as |item|}}{{@c}}: {{item}}{{/with}}{{/with}}{{/with}}"]),_templateObject3=_taggedTemplateLiteralLoose(["\n      <div>\n        [Outside: {{zomg}}]\n        {{#with zomg as |lol|}}\n          [Inside: {{zomg}}]\n          [Inside: {{lol}}]\n          <foo-bar @foo={{zomg}}>\n            [Block: {{zomg}}]\n            [Block: {{lol}}]\n          </foo-bar>\n        {{/with}}\n      </div>"],["\n      <div>\n        [Outside: {{zomg}}]\n        {{#with zomg as |lol|}}\n          [Inside: {{zomg}}]\n          [Inside: {{lol}}]\n          <foo-bar @foo={{zomg}}>\n            [Block: {{zomg}}]\n            [Block: {{lol}}]\n          </foo-bar>\n        {{/with}}\n      </div>"]),_templateObject4=_taggedTemplateLiteralLoose(["\n        [Outside: zomg]\n        [Inside: zomg]\n        [Inside: zomg]\n        [Layout: ]\n        [Layout: ]\n        [Layout: zomg]\n        [Block: zomg]\n        [Block: zomg]"],["\n        [Outside: zomg]\n        [Inside: zomg]\n        [Inside: zomg]\n        [Layout: ]\n        [Layout: ]\n        [Layout: zomg]\n        [Block: zomg]\n        [Block: zomg]"]),_templateObject5=_taggedTemplateLiteralLoose(["\n      <div>\n        [Outside: {{zomg}}]\n        {{#with zomg as |lol|}}\n          [Inside: {{zomg}}]\n          [Inside: {{lol}}]\n          {{#foo-bar foo=zomg}}\n            [Block: {{zomg}}]\n            [Block: {{lol}}]\n          {{/foo-bar}}\n        {{/with}}\n      </div>"],["\n      <div>\n        [Outside: {{zomg}}]\n        {{#with zomg as |lol|}}\n          [Inside: {{zomg}}]\n          [Inside: {{lol}}]\n          {{#foo-bar foo=zomg}}\n            [Block: {{zomg}}]\n            [Block: {{lol}}]\n          {{/foo-bar}}\n        {{/with}}\n      </div>"]),_templateObject6=_taggedTemplateLiteralLoose(["\n    [Name: {{name}} | Target: {{targetObject.name}}]\n    {{#qux-derp}}\n      [Name: {{name}} | Target: {{targetObject.name}}]\n    {{/qux-derp}}\n    [Name: {{name}} | Target: {{targetObject.name}}]\n  "],["\n    [Name: {{name}} | Target: {{targetObject.name}}]\n    {{#qux-derp}}\n      [Name: {{name}} | Target: {{targetObject.name}}]\n    {{/qux-derp}}\n    [Name: {{name}} | Target: {{targetObject.name}}]\n  "]),_templateObject7=_taggedTemplateLiteralLoose(["\n        [Name: foo-bar | Target: outer-scope]\n        [Name: qux-derp | Target: foo-bar]\n        [Name: foo-bar | Target: outer-scope]\n        [Name: foo-bar | Target: outer-scope]\n        "],["\n        [Name: foo-bar | Target: outer-scope]\n        [Name: qux-derp | Target: foo-bar]\n        [Name: foo-bar | Target: outer-scope]\n        [Name: foo-bar | Target: outer-scope]\n        "]),_templateObject8=_taggedTemplateLiteralLoose(["\n      <div>\n        <foo-bar />\n        <foo-bar @baz={{zomg}} />\n      </div>"],["\n      <div>\n        <foo-bar />\n        <foo-bar @baz={{zomg}} />\n      </div>"]),_templateObject9=_taggedTemplateLiteralLoose(["\n        <p>foo bar baz</p>\n        <p>foo bar zomg</p>"],["\n        <p>foo bar baz</p>\n        <p>foo bar zomg</p>"]),_templateObject10=_taggedTemplateLiteralLoose(["\n      {{#each items key=\"id\" as |item|}}\n        <sub-item @name={{item.id}} />\n      {{/each}}"],["\n      {{#each items key=\"id\" as |item|}}\n        <sub-item @name={{item.id}} />\n      {{/each}}"]),_templateObject11=_taggedTemplateLiteralLoose(["\n      <aside>{{@item.id}}:\n        {{#if @item.visible}}\n          {{#each @item.subitems key=\"id\" as |subitem|}}\n             <sub-item @name={{subitem.id}} />\n          {{/each}}\n        {{/if}}\n      </aside>"],["\n      <aside>{{@item.id}}:\n        {{#if @item.visible}}\n          {{#each @item.subitems key=\"id\" as |subitem|}}\n             <sub-item @name={{subitem.id}} />\n          {{/each}}\n        {{/if}}\n      </aside>"]),_templateObject12=_taggedTemplateLiteralLoose(["\n        <article>{{#each items key=\"id\" as |item|}}\n          <my-item @item={{item}} />\n        {{/each}}</article>"],["\n        <article>{{#each items key=\"id\" as |item|}}\n          <my-item @item={{item}} />\n        {{/each}}</article>"]),_templateObject13=_taggedTemplateLiteralLoose(["\n        <aside>0:<p>0.0</p><p>0.1</p></aside>\n        <aside>1:<!----></aside>\n        <aside>2:<p>2.0</p><p>2.1</p></aside>"],["\n        <aside>0:<p>0.0</p><p>0.1</p></aside>\n        <aside>1:<!----></aside>\n        <aside>2:<p>2.0</p><p>2.1</p></aside>"]),_templateObject14=_taggedTemplateLiteralLoose(["\n      <ul>\n        {{#each items key=\"id\" as |item|}}\n          <li>{{item.id}}: {{yield item}}</li>\n        {{/each}}\n      </ul>"],["\n      <ul>\n        {{#each items key=\"id\" as |item|}}\n          <li>{{item.id}}: {{yield item}}</li>\n        {{/each}}\n      </ul>"]),_templateObject15=_taggedTemplateLiteralLoose(["\n      {{#item-list items=items as |item|}}\n        {{item.name}}{{#if showDescription}} - {{item.description}}{{/if}}\n      {{/item-list}}"],["\n      {{#item-list items=items as |item|}}\n        {{item.name}}{{#if showDescription}} - {{item.description}}{{/if}}\n      {{/item-list}}"]),_templateObject16=_taggedTemplateLiteralLoose(["\n      <ul>\n        <li>1: Foo<!----></li>\n        <li>2: Bar<!----></li>\n        <li>3: Baz<!----></li>\n      </ul>"],["\n      <ul>\n        <li>1: Foo<!----></li>\n        <li>2: Bar<!----></li>\n        <li>3: Baz<!----></li>\n      </ul>"]),_templateObject17=_taggedTemplateLiteralLoose(["\n      <ul>\n        <li>1: Foo - Foo!</li>\n        <li>2: Bar - Bar!</li>\n        <li>3: Baz - Baz!</li>\n      </ul>"],["\n      <ul>\n        <li>1: Foo - Foo!</li>\n        <li>2: Bar - Bar!</li>\n        <li>3: Baz - Baz!</li>\n      </ul>"]),_templateObject18=_taggedTemplateLiteralLoose(["<div>{{sample-component \"Foo\" 4 \"Bar\" id=\"args-3\"}}\n      {{sample-component \"Foo\" 4 \"Bar\" 5 \"Baz\" id=\"args-5\"}}\n      {{!sample-component \"Foo\" 4 \"Bar\" 5 \"Baz\" id=\"helper\"}}</div>"],["<div>{{sample-component \"Foo\" 4 \"Bar\" id=\"args-3\"}}\n      {{sample-component \"Foo\" 4 \"Bar\" 5 \"Baz\" id=\"args-5\"}}\n      {{!sample-component \"Foo\" 4 \"Bar\" 5 \"Baz\" id=\"helper\"}}</div>"]),_templateObject19=_taggedTemplateLiteralLoose(["\n      {{#with (hash comp=(component 'foo-bar')) as |my|}}\n        {{#my.comp arg1=\"World!\"}}Test1{{/my.comp}} Test2\n      {{/with}}\n    "],["\n      {{#with (hash comp=(component 'foo-bar')) as |my|}}\n        {{#my.comp arg1=\"World!\"}}Test1{{/my.comp}} Test2\n      {{/with}}\n    "]),_templateObject20=_taggedTemplateLiteralLoose(["\n      {{#with (hash comp=(component 'foo-bar')) as |my|}}\n        {{my.comp arg1=\"World!\"}} Test\n      {{/with}}\n    "],["\n      {{#with (hash comp=(component 'foo-bar')) as |my|}}\n        {{my.comp arg1=\"World!\"}} Test\n      {{/with}}\n    "]),_templateObject21=_taggedTemplateLiteralLoose(["\n      {{#foo-bar as |my|}}\n        {{my.comp arg1=\"World!\"}} Test\n      {{/foo-bar}}\n    "],["\n      {{#foo-bar as |my|}}\n        {{my.comp arg1=\"World!\"}} Test\n      {{/foo-bar}}\n    "]),_templateObject22=_taggedTemplateLiteralLoose(["\n      {{#foo-bar as |my|}}\n        {{#my.comp arg1=\"World!\"}}Test1{{/my.comp}} Test2\n      {{/foo-bar}}\n    "],["\n      {{#foo-bar as |my|}}\n        {{#my.comp arg1=\"World!\"}}Test1{{/my.comp}} Test2\n      {{/foo-bar}}\n    "]),_templateObject23=_taggedTemplateLiteralLoose(["\n      {{#with (hash comp=(component 'foo-bar')) as |my|}}\n        {{#my.comp}}World!{{/my.comp}} Test\n      {{/with}}\n    "],["\n      {{#with (hash comp=(component 'foo-bar')) as |my|}}\n        {{#my.comp}}World!{{/my.comp}} Test\n      {{/with}}\n    "]),_templateObject24=_taggedTemplateLiteralLoose(["\n      {{#with (hash comp=(component 'foo-bar')) as |my|}}\n        {{my.comp}} World!\n      {{/with}}\n    "],["\n      {{#with (hash comp=(component 'foo-bar')) as |my|}}\n        {{my.comp}} World!\n      {{/with}}\n    "]),_templateObject25=_taggedTemplateLiteralLoose(["\n      {{#foo-bar as |my|}}\n        {{#my.comp}}World!{{/my.comp}} Test\n      {{/foo-bar}}\n    "],["\n      {{#foo-bar as |my|}}\n        {{#my.comp}}World!{{/my.comp}} Test\n      {{/foo-bar}}\n    "]),_templateObject26=_taggedTemplateLiteralLoose(["\n      {{#foo-bar as |my|}}\n        {{my.comp}} World!\n      {{/foo-bar}}\n    "],["\n      {{#foo-bar as |my|}}\n        {{my.comp}} World!\n      {{/foo-bar}}\n    "]),_templateObject27=_taggedTemplateLiteralLoose(["\n      <div>\n        {{x-curly}}\n        {{x-curly}}\n        <x-glimmer />\n        <x-glimmer />\n        {{x-curly}}\n        <x-glimmer />\n      </div>"],["\n      <div>\n        {{x-curly}}\n        {{x-curly}}\n        <x-glimmer />\n        <x-glimmer />\n        {{x-curly}}\n        <x-glimmer />\n      </div>"]);function _defaults(obj,defaults){var keys=Object.getOwnPropertyNames(defaults);for(var i=0;i < keys.length;i++) {var key=keys[i];var value=Object.getOwnPropertyDescriptor(defaults,key);if(value && value.configurable && obj[key] === undefined){Object.defineProperty(obj,key,value);}}return obj;}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _inherits(subClass,superClass){if(typeof superClass !== "function" && superClass !== null){throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);}subClass.prototype = Object.create(superClass && superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):_defaults(subClass,superClass);}function _taggedTemplateLiteralLoose(strings,raw){strings.raw = raw;return strings;}var EmberishRootView=(function(_EmberObject){_inherits(EmberishRootView,_EmberObject);function EmberishRootView(){_classCallCheck(this,EmberishRootView);_EmberObject.apply(this,arguments);}EmberishRootView.prototype.appendTo = function appendTo(selector){var element=this.parent = document.querySelector(selector);var self=new _glimmerObjectReference.UpdatableReference(this);this._result = this.template.render(self,element,new _glimmerTestHelpers.TestDynamicScope());this.element = element.firstElementChild;};EmberishRootView.prototype.rerender = function rerender(){var context=arguments.length <= 0 || arguments[0] === undefined?null:arguments[0];if(context){this.setProperties(context);}this.env.begin();this._result.rerender();this.env.commit();this.element = this.parent.firstElementChild;};EmberishRootView.prototype.destroy = function destroy(){_EmberObject.prototype.destroy.call(this);if(this._result){this._result.destroy();}};return EmberishRootView;})(_glimmerObject.default);exports.EmberishRootView = EmberishRootView;var view=undefined,env=undefined;function _module(name){QUnit.module("[components] " + name,{setup:function(){env = new _glimmerTestHelpers.TestEnvironment();}});}_module("Components - generic - props");function appendViewFor(template){var context=arguments.length <= 1 || arguments[1] === undefined?{}:arguments[1];var MyRootView=(function(_EmberishRootView){_inherits(MyRootView,_EmberishRootView);function MyRootView(){_classCallCheck(this,MyRootView);_EmberishRootView.apply(this,arguments);this.env = env;this.template = env.compile(template);}return MyRootView;})(EmberishRootView);MyRootView[_glimmerObjectReference.CLASS_META].seal();view = new MyRootView(context);env.begin();view.appendTo('#qunit-fixture');env.commit();return view;}function assertAppended(content){_glimmerTestHelpers.equalTokens(document.querySelector('#qunit-fixture'),content);}function assertText(expected){var rawText=document.querySelector('#qunit-fixture').innerText;var text=rawText.split(/[\r\n]/g).map(function(part){var p=part.replace(/\s+/g,' ');return p.trim();}).filter(function(part){return part !== '';}).join(' ');QUnit.assert.strictEqual(text,expected,"#qunit-fixture content should be: `" + expected + "`");}function assertFired(component,name){var count=arguments.length <= 2 || arguments[2] === undefined?1:arguments[2];var hooks=component['hooks'];if(!hooks){throw new TypeError("Not hooked: " + component);}if(name in hooks){strictEqual(hooks[name],count,"The " + name + " hook fired " + count + " " + (count === 1?'time':'times'));}else {ok(false,"The " + name + " hook fired");}}function assertComponentElement(){var tagName=undefined,attrs=undefined,contents=undefined;for(var _len=arguments.length,args=Array(_len),_key=0;_key < _len;_key++) {args[_key] = arguments[_key];}if(args.length === 2){if(typeof args[1] === 'string'){;tagName = args[0];attrs = {};contents = args[1];}else {;tagName = args[0];attrs = args[1];contents = null;}}else if(args.length === 1){tagName = args[0];attrs = {};contents = null;}else {tagName = args[0];attrs = args[1];contents = args[2];}_glimmerTestHelpers.equalsElement(view.element,tagName,attrs,contents);}function assertEmberishElement(){var tagName=undefined,attrs=undefined,contents=undefined;for(var _len2=arguments.length,args=Array(_len2),_key2=0;_key2 < _len2;_key2++) {args[_key2] = arguments[_key2];}if(args.length === 2){if(typeof args[1] === 'string'){;tagName = args[0];attrs = {};contents = args[1];}else {;tagName = args[0];attrs = args[1];contents = null;}}else if(args.length === 1){tagName = args[0];attrs = {};contents = null;}else {tagName = args[0];attrs = args[1];contents = args[2];}var fullAttrs=_glimmerUtil.assign({class:_glimmerTestHelpers.classes('ember-view'),id:_glimmerTestHelpers.regex(/^ember\d*$/)},attrs);_glimmerTestHelpers.equalsElement(view.element,tagName,fullAttrs,contents);}function assertElementIsEmberishElement(element){var tagName=undefined,attrs=undefined,contents=undefined;for(var _len3=arguments.length,args=Array(_len3 > 1?_len3 - 1:0),_key3=1;_key3 < _len3;_key3++) {args[_key3 - 1] = arguments[_key3];}if(args.length === 2){if(typeof args[1] === 'string'){;tagName = args[0];attrs = {};contents = args[1];}else {;tagName = args[0];attrs = args[1];contents = null;}}else if(args.length === 1){tagName = args[0];attrs = {};contents = null;}else {tagName = args[0];attrs = args[1];contents = args[2];}var fullAttrs=_glimmerUtil.assign({class:_glimmerTestHelpers.classes('ember-view'),id:_glimmerTestHelpers.regex(/^ember\d*$/)},attrs);_glimmerTestHelpers.equalsElement(element,tagName,fullAttrs,contents);}function rerender(){view.rerender();};function isExpected(expected){return typeof expected === 'object';} // Glimmer                Curly
// foo="bar"              foo=(attr "bar")
// foo="{{bar}}"          foo=(attr bar)
// foo="bar{{baz}}bat"    foo=(attr "bar" baz "bat")
// foo="{{foo bar}}"      foo=(attr (foo bar))
// foo={{foo bar}}        foo=(foo bar)                        { glimmer: "foo bar", curly: "(foo bar)" }
// foo={{"bar"}}          foo="bar"                            '"bar"'
// foo={{bar}}            foo=bar                              "bar"
// foo={{null}}           foo=null                             "null"
// foo={{1}}              foo=1                                "1"
function testComponent(title,_ref){var kind=_ref.kind;var layout=_ref.layout;var _ref$invokeAs=_ref.invokeAs;var invokeAs=_ref$invokeAs === undefined?{}:_ref$invokeAs;var expected=_ref.expected;var skip=_ref.skip;var _ref$updates=_ref.updates;var updates=_ref$updates === undefined?[]:_ref$updates;if(skip === true)return;var _invokeAs$attributes=invokeAs.attributes;var attributes=_invokeAs$attributes === undefined?{}:_invokeAs$attributes;var _invokeAs$args=invokeAs.args;var args=_invokeAs$args === undefined?{}:_invokeAs$args;var context=invokeAs.context;var blockParams=invokeAs.blockParams;var template=invokeAs.template;var inverse=invokeAs.inverse;if(!kind || kind === 'curly'){var test=skip === 'curly'?QUnit.skip:QUnit.test;test("curly: " + title,function(assert){if(typeof layout !== 'string')throw new Error('Only string layouts are supported for curly tests');env.registerEmberishCurlyComponent('test-component',_glimmerTestHelpers.EmberishCurlyComponent,layout);var list=['test-component'];Object.keys(attributes).forEach(function(key){throw new Error("Cannot use attrs in a curly component test"); // list.push(`${key}="${attrs[key]}"`);
});Object.keys(args).forEach(function(key){list.push(key + "=" + toCurly(args[key]));});if(blockParams)list.push("as |" + blockParams.join(' ') + "|");var tag=list.join(' ');var syntax=undefined;if(typeof template === 'string'){var inv=typeof inverse === 'string'?"{{else}}" + inverse:'';syntax = "{{#" + tag + "}}" + template + inv + "{{/test-component}}";}else {syntax = "{{" + tag + "}}";}assert.ok(true,"generated invocation: " + syntax);var view=appendViewFor(syntax,context || {});assertExpected('div',expected);updates.forEach(function(update){view.rerender(update.context);assertExpected('div',update.expected);});});}if(!kind || kind === 'curly' || kind === 'dynamic'){var test=skip === 'dynamic'?QUnit.skip:QUnit.test;test("curly - component helper: " + title,function(assert){env.registerEmberishCurlyComponent('test-component',_glimmerTestHelpers.EmberishCurlyComponent,layout);env.registerEmberishCurlyComponent('test-component2',_glimmerTestHelpers.EmberishCurlyComponent,layout + " -- 2");var list=['component','componentName'];Object.keys(attributes).forEach(function(key){throw new Error("Cannot use attrs in a curly component test"); // list.push(`${key}="${attrs[key]}"`);
});Object.keys(args).forEach(function(key){list.push(key + "=" + toCurly(args[key]));});if(blockParams)list.push("as |" + blockParams.join(' ') + "|");var tag=list.join(' ');var syntax=undefined;if(typeof template === 'string'){var inv=typeof inverse === 'string'?"{{else}}" + inverse:'';syntax = "{{#" + tag + "}}" + template + inv + "{{/component}}";}else {syntax = "{{" + tag + "}}";}assert.ok(true,"generated invocation: " + syntax);var creation=_glimmerUtil.assign(context || {},{componentName:'test-component'});var view=appendViewFor(syntax,creation);assertExpected('div',expected);view.rerender({componentName:'test-component2'});if(isExpected(expected)){assertExpected('div',_glimmerUtil.assign({},expected,{content:expected.content + " -- 2"}));}else {assertExpected('div',expected + " -- 2");}updates.forEach(function(update){var context=update.context;var expected=update.expected;view.rerender(_glimmerUtil.assign({},context || {},{componentName:'test-component'}));assertExpected('div',expected);view.rerender({componentName:'test-component2'});if(isExpected(expected)){assertExpected('div',_glimmerUtil.assign({},expected,{content:expected.content + " -- 2"}));}else {assertExpected('div',expected + " -- 2");}});});}if(!kind || kind === 'glimmer'){var test=skip === 'glimmer'?QUnit.skip:QUnit.test;test("glimmer: " + title,function(assert){var layoutOptions=undefined;if(typeof layout === 'string'){layoutOptions = {attributes:{},args:{},template:layout};}else {layoutOptions = layout;}var layoutBody=glimmerTag('aside',layoutOptions);env.registerEmberishGlimmerComponent('test-component',_glimmerTestHelpers.EmberishGlimmerComponent," " + layoutBody + "<!-- hi -->");var invocation=glimmerTag('test-component',invokeAs);assert.ok(true,"generated layout: " + layoutBody);assert.ok(true,"generated invocation: " + invocation);appendViewFor(invocation,context || {});assertExpected('aside',expected,attributes);updates.forEach(function(update){ok(true,"Updating with " + JSON.stringify(update));view.rerender(update.context);assertExpected('aside',update.expected,attributes);});});}}function glimmerTag(tagName,_ref2){var _ref2$blockParams=_ref2.blockParams;var blockParams=_ref2$blockParams === undefined?null:_ref2$blockParams;var _ref2$attributes=_ref2.attributes;var attributes=_ref2$attributes === undefined?{}:_ref2$attributes;var _ref2$args=_ref2.args;var args=_ref2$args === undefined?{}:_ref2$args;var _ref2$template=_ref2.template;var template=_ref2$template === undefined?null:_ref2$template;var list=[tagName];Object.keys(attributes).forEach(function(key){list.push(key + "=\"" + attributes[key] + "\"");});Object.keys(args).forEach(function(key){list.push("@" + key + "={{" + toGlimmer(args[key]) + "}}");});if(blockParams)list.push("as |" + blockParams.join(' ') + "|");var tag=list.join(" ");if(typeof template === 'string'){return "<" + tag + ">" + template + "</" + tagName + ">";}else {return "<" + tag + " />";}}function assertExpected(tagName,expected){var defaultAttrs=arguments.length <= 2 || arguments[2] === undefined?{}:arguments[2];var attrs=undefined;var content=undefined;if(typeof expected === 'string'){attrs = defaultAttrs;content = expected;}else {attrs = expected.attrs;content = expected.content;}assertEmberishElement(tagName,attrs,content);}function toGlimmer(obj){if(obj && obj.glimmer)return obj.glimmer;else return String(obj);}function toCurly(obj){if(obj && obj.curly)return obj.curly;else return String(obj);}testComponent('non-block without properties',{layout:'In layout',expected:'In layout'});testComponent('block without properties',{layout:'In layout -- {{yield}}',invokeAs:{template:'In template'},expected:'In layout -- In template'});testComponent('yield inside a conditional on the component',{layout:'In layout -- {{#if @predicate}}{{yield}}{{/if}}',invokeAs:{template:'In template',args:{predicate:'predicate'},context:{predicate:true}},expected:{attrs:{},content:'In layout -- In template'},updates:[{expected:'In layout -- In template'},{context:{predicate:false},expected:'In layout -- <!---->'},{context:{predicate:true},expected:'In layout -- In template'}]});testComponent('non-block with properties on attrs',{layout:'In layout - someProp: {{@someProp}}',invokeAs:{args:{someProp:'"something here"'}},expected:'In layout - someProp: something here'});testComponent('block with properties on attrs',{layout:'In layout - someProp: {{@someProp}} - {{yield}}',invokeAs:{template:'In template',args:{someProp:'"something here"'}},expected:'In layout - someProp: something here - In template'});testComponent('with ariaRole specified',{skip:true,kind:'curly',layout:'Here!',invokeAs:{attributes:{id:'"aria-test"',ariaRole:'"main"'}},expected:{content:'Here!',attrs:{id:'"aria-test"',role:'"main"'}}});testComponent('with ariaRole and class specified',{skip:true,kind:'curly',layout:'Here!',invokeAs:{attributes:{id:'"aria-test"',class:'"foo"',ariaRole:'"main"'}},expected:{content:'Here!',attrs:{id:'"aria-test"',class:_glimmerTestHelpers.classes('ember-view foo'),role:'"main"'}}});testComponent('with ariaRole specified as an outer binding',{skip:true,kind:'curly',layout:'Here!',invokeAs:{attributes:{id:'"aria-test"',class:'"foo"',ariaRole:'ariaRole'},context:{ariaRole:'main'}},expected:{content:'Here!',attrs:{id:'"aria-test"',class:_glimmerTestHelpers.classes('ember-view foo'),role:'"main"'}}});testComponent('glimmer component with role specified as an outer binding and copied',{skip:true,kind:'glimmer',layout:'Here!',invokeAs:{attributes:{id:'"aria-test"',role:'"{{myRole}}"'},context:{myRole:'main'}},expected:{content:'Here!',attrs:{id:'"aria-test"',role:'"main"'}}});testComponent('yielding to an non-existent block',{layout:'Before-{{yield}}-After',expected:'Before--After'});testComponent('yield',{layout:'{{#if @predicate}}Yes:{{yield @someValue}}{{else}}No:{{yield to="inverse"}}{{/if}}',invokeAs:{args:{predicate:'activated',someValue:'42'},context:{activated:true,outer:"outer"},blockParams:['result'],template:'Hello{{result}}{{outer}}',inverse:'Goodbye{{outer}}'},expected:'Yes:Hello42outer'});[{value:'true',output:'true'},{value:'false',output:'false'},{value:'null',output:''},{value:'undefined',output:''},{value:'1',output:'1'},{value:'"foo"',output:'foo'}].forEach(function(_ref3){var value=_ref3.value;var output=_ref3.output;testComponent("yielding " + value,{layout:"{{yield " + value + "}}",invokeAs:{blockParams:['yielded'],template:'{{yielded}}-{{yielded.foo.bar}}'},expected:output + "-"});});testComponent("yielding a string and rendering its length",{layout:"{{yield \"foo\"}}-{{yield \"\"}}",invokeAs:{blockParams:['yielded'],template:'{{yielded}}-{{yielded.length}}'},expected:"foo-3--0"});testComponent('use a non-existent block param',{skip:'glimmer',layout:'{{yield someValue}}',invokeAs:{args:{someValue:'42'},blockParams:['val1','val2'],template:'{{val1}} - {{val2}}'},expected:'42 - '});testComponent('yield to inverse',{skip:'glimmer',layout:'{{#if @predicate}}Yes:{{yield @someValue}}{{else}}No:{{yield to="inverse"}}{{/if}}',invokeAs:{args:{predicate:'activated',someValue:'42'},context:{activated:false,outer:"outer"},blockParams:['result'],template:'Hello{{result}}{{outer}}',inverse:'Goodbye{{outer}}'},expected:'No:Goodbyeouter'});_module('Components - has-block helper');testComponent('parameterized has-block (subexpr, inverse) when inverse supplied',{kind:'curly',layout:'{{#if (has-block "inverse")}}Yes{{else}}No{{/if}}',invokeAs:{template:'block here',inverse:'inverse here'},expected:'Yes'});testComponent('parameterized has-block (subexpr, inverse) when inverse not supplied',{layout:'{{#if (has-block "inverse")}}Yes{{else}}No{{/if}}',invokeAs:{template:'block here'},expected:'No'});testComponent('parameterized has-block (subexpr, default) when block supplied',{layout:'{{#if (has-block)}}Yes{{else}}No{{/if}}',invokeAs:{template:'block here'},expected:'Yes'});testComponent('parameterized has-block (subexpr, default) when block not supplied',{kind:'curly',layout:'{{#if (has-block)}}Yes{{else}}No{{/if}}',expected:'No'});testComponent('parameterized has-block (content, inverse) when inverse supplied',{kind:'curly',layout:'{{has-block "inverse"}}',invokeAs:{template:'block here',inverse:'inverse here'},expected:'true'});testComponent('parameterized has-block (content, inverse) when inverse not supplied',{layout:'{{has-block "inverse"}}',invokeAs:{template:'block here'},expected:'false'});testComponent('parameterized has-block (content, default) when block supplied',{layout:'{{has-block}}',invokeAs:{template:'block here'},expected:'true'});testComponent('parameterized has-block (content, default) when block not supplied',{kind:'curly',layout:'{{has-block}}',expected:'false'});testComponent('parameterized has-block (prop, inverse) when inverse supplied',{kind:'curly',layout:'<button name={{has-block "inverse"}}></button>',invokeAs:{template:'block here',inverse:'inverse here'},expected:'<button name="true"></button>'});testComponent('parameterized has-block (prop, inverse) when inverse not supplied',{layout:'<button name={{has-block "inverse"}}></button>',invokeAs:{template:'block here'},expected:'<button name="false"></button>'});testComponent('parameterized has-block (prop, default) when block supplied',{layout:'<button name={{has-block}}></button>',invokeAs:{template:'block here'},expected:'<button name="true"></button>'});testComponent('parameterized has-block (prop, default) when block not supplied',{kind:'curly',layout:'<button name={{has-block}}></button>',expected:'<button name="false"></button>'});testComponent('parameterized has-block (attr, inverse) when inverse supplied',{kind:'curly',layout:'<button data-has-block="{{has-block "inverse"}}"></button>',invokeAs:{template:'block here',inverse:'inverse here'},expected:'<button data-has-block="true"></button>'});testComponent('parameterized has-block (attr, inverse) when inverse not supplied',{layout:'<button data-has-block="{{has-block "inverse"}}"></button>',invokeAs:{template:'block here'},expected:'<button data-has-block="false"></button>'});testComponent('parameterized has-block (attr, default) when block supplied',{layout:'<button data-has-block="{{has-block}}"></button>',invokeAs:{template:'block here'},expected:'<button data-has-block="true"></button>'});testComponent('parameterized has-block (attr, default) when block not supplied',{kind:'curly',layout:'<button data-has-block="{{has-block}}"></button>',expected:'<button data-has-block="false"></button>'});testComponent('parameterized has-block (concatted attr, inverse) when inverse supplied',{kind:'curly',layout:'<button data-has-block="is-{{has-block "inverse"}}"></button>',invokeAs:{template:'block here',inverse:'inverse here'},expected:'<button data-has-block="is-true"></button>'});testComponent('parameterized has-block (concatted attr, inverse) when inverse not supplied',{layout:'<button data-has-block="is-{{has-block "inverse"}}"></button>',invokeAs:{template:'block here'},expected:'<button data-has-block="is-false"></button>'});testComponent('parameterized has-block (concatted attr, default) when block supplied',{layout:'<button data-has-block="is-{{has-block}}"></button>',invokeAs:{template:'block here'},expected:'<button data-has-block="is-true"></button>'});testComponent('parameterized has-block (concatted attr, default) when block not supplied',{kind:'curly',layout:'<button data-has-block="is-{{has-block}}"></button>',expected:'<button data-has-block="is-false"></button>'});_module('Dynamically-scoped variable accessors');testComponent('Can get and set dynamic variable',{layout:'{{#-with-dynamic-vars myKeyword=@value}}{{yield}}{{/-with-dynamic-vars}}',invokeAs:{template:'{{-get-dynamic-var "myKeyword"}}',context:{value:"hello"},args:{value:'value'}},expected:'hello',updates:[{expected:'hello'},{context:{value:'goodbye'},expected:'goodbye'}]});testComponent('Can get and set dynamic variable with bound names',{layout:'{{#-with-dynamic-vars myKeyword=@value1 secondKeyword=@value2}}{{yield}}{{/-with-dynamic-vars}}',invokeAs:{template:'{{-get-dynamic-var keyword}}',context:{value1:"hello",value2:"goodbye",keyword:"myKeyword"},args:{value1:"value1",value2:"value2"}},expected:'hello',updates:[{expected:'hello'},{context:{keyword:'secondKeyword'},expected:'goodbye'},{context:{value2:'goodbye!'},expected:'goodbye!'},{context:{value1:"hello",value2:"goodbye",keyword:"myKeyword"},expected:'hello'}]});testComponent('Can shadow existing dynamic variable',{layout:'{{#-with-dynamic-vars myKeyword=@outer}}<div>{{-get-dynamic-var "myKeyword"}}</div>{{#-with-dynamic-vars myKeyword=@inner}}{{yield}}{{/-with-dynamic-vars}}<div>{{-get-dynamic-var "myKeyword"}}</div>{{/-with-dynamic-vars}}',invokeAs:{template:'<div>{{-get-dynamic-var "myKeyword"}}</div>',context:{outer:'original',inner:'shadowed'},args:{outer:'outer',inner:'inner'}},expected:'<div>original</div><div>shadowed</div><div>original</div>',updates:[{expected:'<div>original</div><div>shadowed</div><div>original</div>'},{context:{outer:'original2',inner:'shadowed'},expected:'<div>original2</div><div>shadowed</div><div>original2</div>'},{context:{outer:'original2',inner:'shadowed2'},expected:'<div>original2</div><div>shadowed2</div><div>original2</div>'}]});_module('Components - has-block-params helper');testComponent('parameterized has-block-params (subexpr, inverse) when inverse supplied without block params',{kind:'curly',layout:'{{#if (has-block-params "inverse")}}Yes{{else}}No{{/if}}',invokeAs:{template:'block here',inverse:'inverse here'},expected:'No'});testComponent('parameterized has-block-params (subexpr, inverse) when inverse not supplied',{layout:'{{#if (has-block-params "inverse")}}Yes{{else}}No{{/if}}',invokeAs:{template:'block here'},expected:'No'});testComponent('parameterized has-block-params (subexpr, default) when block supplied with block params',{kind:'curly',layout:'{{#if (has-block-params)}}Yes{{else}}No{{/if}}',invokeAs:{blockParams:['param'],template:'block here'},expected:'Yes'});testComponent('parameterized has-block-params (subexpr, default) when block supplied without block params',{layout:'{{#if (has-block-params)}}Yes{{else}}No{{/if}}',invokeAs:{template:'block here'},expected:'No'});testComponent('parameterized has-block-params (subexpr, default) when block not supplied',{kind:'curly',layout:'{{#if (has-block-params)}}Yes{{else}}No{{/if}}',expected:'No'});testComponent('parameterized has-block-params (content, inverse) when inverse supplied without block params',{kind:'curly',layout:'{{has-block-params "inverse"}}',invokeAs:{template:'block here',inverse:'inverse here'},expected:'false'});testComponent('parameterized has-block-params (content, inverse) when inverse not supplied',{layout:'{{has-block-params "inverse"}}',invokeAs:{template:'block here'},expected:'false'});testComponent('parameterized has-block-params (content, default) when block supplied with block params',{kind:'curly',layout:'{{has-block-params}}',invokeAs:{blockParams:['param'],template:'block here'},expected:'true'});testComponent('parameterized has-block-params (content, default) when block supplied without block params',{layout:'{{has-block-params}}',invokeAs:{template:'block here'},expected:'false'});testComponent('parameterized has-block-params (content, default) when block not supplied',{kind:'curly',layout:'{{has-block-params}}',expected:'false'});testComponent('parameterized has-block-params (prop, inverse) when inverse supplied without block params',{kind:'curly',layout:'<button name={{has-block-params "inverse"}}></button>',invokeAs:{template:'block here',inverse:'inverse here'},expected:'<button name="false"></button>'});testComponent('parameterized has-block-params (prop, inverse) when inverse not supplied',{layout:'<button name={{has-block-params "inverse"}}></button>',invokeAs:{template:'block here'},expected:'<button name="false"></button>'});testComponent('parameterized has-block-params (prop, default) when block supplied with block params',{kind:'curly',layout:'<button name={{has-block-params}}></button>',invokeAs:{blockParams:['param'],template:'block here'},expected:'<button name="true"></button>'});testComponent('parameterized has-block-params (prop, default) when block supplied without block params',{layout:'<button name={{has-block-params}}></button>',invokeAs:{template:'block here'},expected:'<button name="false"></button>'});testComponent('parameterized has-block-params (prop, default) when block not supplied',{kind:'curly',layout:'<button name={{has-block-params}}></button>',expected:'<button name="false"></button>'});testComponent('parameterized has-block-params (attr, inverse) when inverse supplied without block params',{kind:'curly',layout:'<button data-has-block-params="{{has-block-params "inverse"}}"></button>',invokeAs:{template:'block here',inverse:'inverse here'},expected:'<button data-has-block-params="false"></button>'});testComponent('parameterized has-block-params (attr, inverse) when inverse not supplied',{layout:'<button data-has-block-params="{{has-block-params "inverse"}}"></button>',invokeAs:{template:'block here'},expected:'<button data-has-block-params="false"></button>'});testComponent('parameterized has-block-params (attr, default) when block supplied with block params',{kind:'curly',layout:'<button data-has-block-params="{{has-block-params}}"></button>',invokeAs:{blockParams:['param'],template:'block here'},expected:'<button data-has-block-params="true"></button>'});testComponent('parameterized has-block-params (attr, default) when block supplied without block params',{layout:'<button data-has-block-params="{{has-block-params}}"></button>',invokeAs:{template:'block here'},expected:'<button data-has-block-params="false"></button>'});testComponent('parameterized has-block-params (attr, default) when block not supplied',{kind:'curly',layout:'<button data-has-block-params="{{has-block-params}}"></button>',expected:'<button data-has-block-params="false"></button>'});testComponent('parameterized has-block-params (concatted attr, inverse) when inverse supplied without block params',{kind:'curly',layout:'<button data-has-block-params="is-{{has-block-params "inverse"}}"></button>',invokeAs:{template:'block here',inverse:'inverse here'},expected:'<button data-has-block-params="is-false"></button>'});testComponent('parameterized has-block-params (concatted attr, inverse) when inverse not supplied',{layout:'<button data-has-block-params="is-{{has-block-params "inverse"}}"></button>',invokeAs:{template:'block here'},expected:'<button data-has-block-params="is-false"></button>'});testComponent('parameterized has-block-params (concatted attr, default) when block supplied with block params',{kind:'curly',layout:'<button data-has-block-params="is-{{has-block-params}}"></button>',invokeAs:{blockParams:['param'],template:'block here'},expected:'<button data-has-block-params="is-true"></button>'});testComponent('parameterized has-block-params (concatted attr, default) when block supplied without block params',{layout:'<button data-has-block-params="is-{{has-block-params}}"></button>',invokeAs:{template:'block here'},expected:'<button data-has-block-params="is-false"></button>'});testComponent('parameterized has-block-params (concatted attr, default) when block not supplied',{kind:'curly',layout:'<button data-has-block-params="is-{{has-block-params}}"></button>',expected:'<button data-has-block-params="is-false"></button>'});_module("Components - curlies - dynamic component");QUnit.test('initially missing, then present, then missing',function(assert){var FooBar=(function(_BasicComponent){_inherits(FooBar,_BasicComponent);function FooBar(attrs){_classCallCheck(this,FooBar);_BasicComponent.call(this,attrs);this.foo = 'foo';this.bar = 'bar';this.baz = null;this.baz = attrs['baz'] || 'baz';}return FooBar;})(_glimmerTestHelpers.BasicComponent);env.registerBasicComponent('foo-bar',FooBar,"<p>{{foo}} {{bar}} {{baz}}</p>");appendViewFor(_glimmerTestHelpers.stripTight(_templateObject),{something:undefined});_glimmerTestHelpers.equalsElement(view.element,'div',{},'<!---->');_glimmerObjectReference.setProperty(view,'something','foo-bar');rerender();_glimmerTestHelpers.equalsElement(view.element,'div',{},'<p>foo bar baz</p>');_glimmerObjectReference.setProperty(view,'something',undefined);rerender();_glimmerTestHelpers.equalsElement(view.element,'div',{},'<!---->');});QUnit.test('initially present, then missing, then present',function(assert){var FooBar=(function(_BasicComponent2){_inherits(FooBar,_BasicComponent2);function FooBar(attrs){_classCallCheck(this,FooBar);_BasicComponent2.call(this,attrs);this.foo = 'foo';this.bar = 'bar';this.baz = null;this.baz = attrs['baz'] || 'baz';}return FooBar;})(_glimmerTestHelpers.BasicComponent);env.registerBasicComponent('foo-bar',FooBar,"<p>{{foo}} {{bar}} {{baz}}</p>");appendViewFor(_glimmerTestHelpers.stripTight(_templateObject),{something:"foo-bar"});_glimmerTestHelpers.equalsElement(view.element,'div',{},'<p>foo bar baz</p>');_glimmerObjectReference.setProperty(view,'something',undefined);rerender();_glimmerTestHelpers.equalsElement(view.element,'div',{},'<!---->');_glimmerObjectReference.setProperty(view,'something','foo-bar');rerender();_glimmerTestHelpers.equalsElement(view.element,'div',{},'<p>foo bar baz</p>');});_module("Components - curlies - dynamic customizations");QUnit.test('dynamic tagName',function(assert){var FooBar=(function(_EmberishCurlyComponent){_inherits(FooBar,_EmberishCurlyComponent);function FooBar(){_classCallCheck(this,FooBar);_EmberishCurlyComponent.apply(this,arguments);this.tagName = 'aside';}return FooBar;})(_glimmerTestHelpers.EmberishCurlyComponent);env.registerEmberishCurlyComponent('foo-bar',FooBar,"Hello. It's me.");appendViewFor("{{foo-bar}}");assertEmberishElement('aside',{},"Hello. It's me.");rerender();assertEmberishElement('aside',{},"Hello. It's me.");});QUnit.test('dynamic tagless component',function(assert){var FooBar=(function(_EmberishCurlyComponent2){_inherits(FooBar,_EmberishCurlyComponent2);function FooBar(){_classCallCheck(this,FooBar);_EmberishCurlyComponent2.apply(this,arguments);this.tagName = '';}return FooBar;})(_glimmerTestHelpers.EmberishCurlyComponent);env.registerEmberishCurlyComponent('foo-bar',FooBar,"Michael Jordan says \"Go Tagless\"");appendViewFor("{{foo-bar}}");assertAppended('Michael Jordan says "Go Tagless"');rerender();assertAppended('Michael Jordan says "Go Tagless"');});QUnit.test('dynamic attribute bindings',function(assert){var fooBarInstance=null;var FooBar=(function(_EmberishCurlyComponent3){_inherits(FooBar,_EmberishCurlyComponent3);function FooBar(attrs){_classCallCheck(this,FooBar);_EmberishCurlyComponent3.call(this,attrs);this.attributeBindings = ['style'];this.style = null;this.style = 'color: red;';fooBarInstance = this;}return FooBar;})(_glimmerTestHelpers.EmberishCurlyComponent);env.registerEmberishCurlyComponent('foo-bar',FooBar,"Hello. It's me.");appendViewFor("{{foo-bar}}");assertEmberishElement('div',{'style':'color: red;'},"Hello. It's me.");rerender();assertEmberishElement('div',{'style':'color: red;'},"Hello. It's me.");fooBarInstance.style = 'color: green;';rerender();assertEmberishElement('div',{'style':'color: green;'},"Hello. It's me.");fooBarInstance.style = null;rerender();assertEmberishElement('div',{},"Hello. It's me.");fooBarInstance.style = 'color: red;';rerender();assertEmberishElement('div',{'style':'color: red;'},"Hello. It's me.");});_module("Components - generic - attrs");_module("Components - integration - scope");testComponent('correct scope - conflicting local names',{layout:_glimmerTestHelpers.stripTight(_templateObject2),invokeAs:{args:{a:'"A"',b:'"B"',c:'"C"'}},expected:'A: A, B: B, C: C'});testComponent('correct scope - conflicting block param and attr names',{layout:'Outer: {{@conflict}} {{#with @item as |conflict|}}Inner: {{@conflict}} Block: {{conflict}}{{/with}}',invokeAs:{args:{item:'"from block"',conflict:'"from attr"'}},expected:'Outer: from attr Inner: from attr Block: from block'});QUnit.test('correct scope - accessing local variable in yielded block (glimmer component)',function(assert){var FooBar=(function(_BasicComponent3){_inherits(FooBar,_BasicComponent3);function FooBar(){_classCallCheck(this,FooBar);_BasicComponent3.apply(this,arguments);}return FooBar;})(_glimmerTestHelpers.BasicComponent);env.registerBasicComponent('foo-bar',FooBar,"[Layout: {{zomg}}][Layout: {{lol}}][Layout: {{@foo}}]{{yield}}");appendViewFor(_glimmerTestHelpers.stripTight(_templateObject3),{zomg:"zomg"});_glimmerTestHelpers.equalsElement(view.element,'div',{},_glimmerTestHelpers.stripTight(_templateObject4));});QUnit.test('correct scope - accessing local variable in yielded block (curly component)',function(assert){var FooBar=(function(_EmberishCurlyComponent4){_inherits(FooBar,_EmberishCurlyComponent4);function FooBar(){_classCallCheck(this,FooBar);_EmberishCurlyComponent4.apply(this,arguments);this.tagName = '';}return FooBar;})(_glimmerTestHelpers.EmberishCurlyComponent);env.registerEmberishCurlyComponent('foo-bar',FooBar,"[Layout: {{zomg}}][Layout: {{lol}}][Layout: {{foo}}]{{yield}}");appendViewFor(_glimmerTestHelpers.stripTight(_templateObject5),{zomg:"zomg"});_glimmerTestHelpers.equalsElement(view.element,'div',{},_glimmerTestHelpers.stripTight(_templateObject4));});QUnit.test('correct scope - caller self can be threaded through (curly component)',function(assert){ // demonstrates ability for Ember to know the target object of curly component actions
var Base=(function(_EmberishCurlyComponent5){_inherits(Base,_EmberishCurlyComponent5);function Base(){_classCallCheck(this,Base);_EmberishCurlyComponent5.apply(this,arguments);this.tagName = '';}return Base;})(_glimmerTestHelpers.EmberishCurlyComponent);var FooBar=(function(_Base){_inherits(FooBar,_Base);function FooBar(){_classCallCheck(this,FooBar);_Base.apply(this,arguments);this.name = 'foo-bar';}return FooBar;})(Base);var QuxDerp=(function(_Base2){_inherits(QuxDerp,_Base2);function QuxDerp(){_classCallCheck(this,QuxDerp);_Base2.apply(this,arguments);this.name = 'qux-derp';}return QuxDerp;})(Base);env.registerEmberishCurlyComponent('foo-bar',FooBar,_glimmerTestHelpers.stripTight(_templateObject6));env.registerEmberishCurlyComponent('qux-derp',QuxDerp,"[Name: {{name}} | Target: {{targetObject.name}}]{{yield}}");appendViewFor("<div>{{foo-bar}}</div>",{name:'outer-scope'});_glimmerTestHelpers.equalsElement(view.element,'div',{},_glimmerTestHelpers.stripTight(_templateObject7));});QUnit.test('correct scope - self',function(assert){var FooBar=(function(_BasicComponent4){_inherits(FooBar,_BasicComponent4);function FooBar(attrs){_classCallCheck(this,FooBar);_BasicComponent4.call(this,attrs);this.foo = 'foo';this.bar = 'bar';this.baz = null;this.baz = attrs['baz'] || 'baz';}return FooBar;})(_glimmerTestHelpers.BasicComponent);env.registerBasicComponent('foo-bar',FooBar,"<p>{{foo}} {{bar}} {{baz}}</p>");appendViewFor(_glimmerTestHelpers.stripTight(_templateObject8),{zomg:"zomg"});_glimmerTestHelpers.equalsElement(view.element,'div',{},_glimmerTestHelpers.stripTight(_templateObject9));});QUnit.test('`false` class name do not render',function(assert){appendViewFor('<div class={{isFalse}}>FALSE</div>',{isFalse:false});assert.strictEqual(view.element.getAttribute('class'),null);assert.strictEqual(view.element.className,'');});QUnit.test('`null` class name do not render',function(assert){appendViewFor('<div class={{isNull}}>NULL</div>',{isNull:null});assert.strictEqual(view.element.getAttribute('class'),null);assert.strictEqual(view.element.className,'');});QUnit.test('`undefined` class name do not render',function(assert){appendViewFor('<div class={{isUndefined}}>UNDEFINED</div>',{isUndefined:undefined});assert.strictEqual(view.element.getAttribute('class'),null);assert.strictEqual(view.element.className,'');});QUnit.test('`0` class names do render',function(assert){appendViewFor('<div class={{isZero}}>ZERO</div>',{isZero:0});assert.strictEqual(view.element.getAttribute('class'),'0');assert.strictEqual(view.element.className,'0');});QUnit.test('component with slashed name',function(assert){var SampleComponent=_glimmerTestHelpers.EmberishCurlyComponent.extend();env.registerEmberishCurlyComponent('fizz-bar/baz-bar',SampleComponent,'{{@hey}}');appendViewFor('{{fizz-bar/baz-bar hey="hello"}}');assert.equal(view.element.textContent,'hello');});QUnit.test('correct scope - simple',function(assert){env.registerBasicComponent('sub-item',_glimmerTestHelpers.BasicComponent,"<p>{{@name}}</p>");var subitemId=0;var subitems=[];for(var i=0;i < 1;i++) {subitems.push({id:subitemId++});}appendViewFor(_glimmerTestHelpers.stripTight(_templateObject10),{items:subitems});_glimmerTestHelpers.equalsElement(view.element,'p',{},'0');});QUnit.test('correct scope - complex',function(assert){env.registerBasicComponent('sub-item',_glimmerTestHelpers.BasicComponent,"<p>{{@name}}</p>");env.registerBasicComponent('my-item',_glimmerTestHelpers.BasicComponent,_glimmerTestHelpers.stripTight(_templateObject11));var itemId=0;var items=[];for(var i=0;i < 3;i++) {var subitems=[];var subitemId=0;for(var j=0;j < 2;j++) {subitems.push({id:itemId + "." + subitemId++});}items.push({id:String(itemId++),visible:i % 2 === 0,subitems:subitems});}appendViewFor(_glimmerTestHelpers.stripTight(_templateObject12),{items:items});_glimmerTestHelpers.equalsElement(view.element,'article',{},_glimmerTestHelpers.stripTight(_templateObject13));});QUnit.test('correct scope - complex yield',function(assert){env.registerEmberishCurlyComponent('item-list',_glimmerTestHelpers.EmberishCurlyComponent.extend(),_glimmerTestHelpers.stripTight(_templateObject14));var items=[{id:'1',name:'Foo',description:'Foo!'},{id:'2',name:'Bar',description:'Bar!'},{id:'3',name:'Baz',description:'Baz!'}];appendViewFor(_glimmerTestHelpers.stripTight(_templateObject15),{items:items,showDescription:false});assertEmberishElement('div',_glimmerTestHelpers.stripTight(_templateObject16));view.rerender({items:items,showDescription:true});assertEmberishElement('div',_glimmerTestHelpers.stripTight(_templateObject17));});QUnit.test('correct scope - self',function(assert){var FooBar=(function(_BasicComponent5){_inherits(FooBar,_BasicComponent5);function FooBar(attrs){_classCallCheck(this,FooBar);_BasicComponent5.call(this,attrs);this.foo = 'foo';this.bar = 'bar';this.baz = null;this.baz = attrs['baz'] || 'baz';}return FooBar;})(_glimmerTestHelpers.BasicComponent);env.registerBasicComponent('foo-bar',FooBar,"<p>{{foo}} {{bar}} {{baz}}</p>");appendViewFor(_glimmerTestHelpers.stripTight(_templateObject8),{zomg:"zomg"});_glimmerTestHelpers.equalsElement(view.element,'div',{},_glimmerTestHelpers.stripTight(_templateObject9));});_module('Curly Components - smoke test dynamicScope access');QUnit.test('component has access to dynamic scope',function(){var SampleComponent=(function(_EmberishCurlyComponent6){_inherits(SampleComponent,_EmberishCurlyComponent6);function SampleComponent(){_classCallCheck(this,SampleComponent);_EmberishCurlyComponent6.apply(this,arguments);}return SampleComponent;})(_glimmerTestHelpers.EmberishCurlyComponent);SampleComponent.fromDynamicScope = ['theme'];SampleComponent[_glimmerObjectReference.CLASS_META].seal();env.registerEmberishCurlyComponent('sample-component',SampleComponent,'{{theme}}');appendViewFor('{{#-with-dynamic-vars theme="light"}}{{sample-component}}{{/-with-dynamic-vars}}');assertEmberishElement('div','light');});_module('Curly Components - positional arguments');QUnit.skip('static named positional parameters',function(){var SampleComponent=(function(_EmberishCurlyComponent7){_inherits(SampleComponent,_EmberishCurlyComponent7);function SampleComponent(){_classCallCheck(this,SampleComponent);_EmberishCurlyComponent7.apply(this,arguments);}return SampleComponent;})(_glimmerTestHelpers.EmberishCurlyComponent);SampleComponent.positionalParams = ['name','age'];SampleComponent[_glimmerObjectReference.CLASS_META].seal();env.registerEmberishCurlyComponent('sample-component',SampleComponent,'{{name}}{{age}}');appendViewFor('{{sample-component "Quint" 4}}');assertEmberishElement('div','Quint4');});QUnit.skip('dynamic named positional parameters',function(){var SampleComponent=_glimmerTestHelpers.EmberishCurlyComponent.extend();SampleComponent.reopenClass({positionalParams:['name','age']});env.registerEmberishCurlyComponent('sample-component',SampleComponent,'{{name}}{{age}}');appendViewFor('{{sample-component myName myAge}}',{myName:'Quint',myAge:4});assertEmberishElement('div','Quint4');_glimmerObjectReference.setProperty(view,'myName','Edward');_glimmerObjectReference.setProperty(view,'myAge',5);rerender();assertEmberishElement('div','Edward5');});QUnit.skip('if a value is passed as a non-positional parameter, it takes precedence over the named one',function(assert){var SampleComponent=_glimmerTestHelpers.EmberishCurlyComponent.extend();SampleComponent.reopenClass({positionalParams:['name']});env.registerEmberishCurlyComponent('sample-component',SampleComponent,'{{name}}');assert.throws(function(){appendViewFor('{{sample-component notMyName name=myName}}',{myName:'Quint',notMyName:'Sergio'});},"You cannot specify both a positional param (at position 0) and the hash argument `name`.");});QUnit.skip('static arbitrary number of positional parameters',function(){var SampleComponent=_glimmerTestHelpers.EmberishCurlyComponent.extend();SampleComponent.reopenClass({positionalParams:'names'});env.registerEmberishCurlyComponent('sample-component',SampleComponent,'{{#each names as |name|}}{{name}}{{/each}}');appendViewFor(_glimmerTestHelpers.stripTight(_templateObject18));var first=view.element.firstChild;var second=first.nextSibling; // let third = <Element>second.nextSibling;
assertElementIsEmberishElement(first,'div',{id:'args-3'},'Foo4Bar');assertElementIsEmberishElement(second,'div',{id:'args-5'},'Foo4Bar5Baz'); // equalsElement(third, ...emberishElement('div', { id: 'helper' }, 'Foo4Bar5Baz'));
});QUnit.skip('arbitrary positional parameter conflict with hash parameter is reported',function(assert){var SampleComponent=_glimmerTestHelpers.EmberishCurlyComponent.extend();SampleComponent.reopenClass({positionalParams:'names'});env.registerEmberishCurlyComponent('sample-component',SampleComponent,'{{#each attrs.names as |name|}}{{name}}{{/each}}');assert.throws(function(){appendViewFor('{{sample-component "Foo" 4 "Bar" names=numbers id="args-3"}}',{numbers:[1,2,3]});},"You cannot specify positional parameters and the hash argument `names`.");});QUnit.skip('can use hash parameter instead of arbitrary positional param [GH #12444]',function(){var SampleComponent=_glimmerTestHelpers.EmberishCurlyComponent.extend();SampleComponent.reopenClass({positionalParams:'names'});env.registerEmberishCurlyComponent('sample-component',SampleComponent,'{{#each names as |name|}}{{name}}{{/each}}');appendViewFor('{{sample-component names=things id="args-3"}}',{things:['Foo',4,'Bar']});assertEmberishElement('div',{id:'args-3'},'Foo4Bar');});QUnit.skip('can use hash parameter instead of positional param',function(){var SampleComponent=_glimmerTestHelpers.EmberishCurlyComponent.extend();SampleComponent.reopenClass({positionalParams:['first','second']});env.registerEmberishCurlyComponent('sample-component',SampleComponent,'{{first}} - {{second}}');appendViewFor("<div>\n    {{sample-component \"one\" \"two\" id=\"two-positional\"}}\n    {{sample-component \"one\" second=\"two\" id=\"one-positional\"}}\n    {{sample-component first=\"one\" second=\"two\" id=\"no-positional\"}}</div>\n  ",{things:['Foo',4,'Bar']});var first=view.element.firstElementChild;var second=first.nextElementSibling;var third=second.nextElementSibling;assertElementIsEmberishElement(first,'div',{id:'two-positional'},'one - two');assertElementIsEmberishElement(second,'div',{id:'one-positional'},'one - two');assertElementIsEmberishElement(third,'div',{id:'no-positional'},'one - two');});QUnit.skip('dynamic arbitrary number of positional parameters',function(){var SampleComponent=_glimmerTestHelpers.EmberishCurlyComponent.extend();SampleComponent.reopenClass({positionalParams:'n'});env.registerEmberishCurlyComponent('sample-component',SampleComponent,'{{#each attrs.n as |name|}}{{name}}{{/each}}');appendViewFor('<div>{{sample-component user1 user2 id="direct"}}{{!component "sample-component" user1 user2 id="helper"}}</div>',{user1:'Foo',user2:4});var first=view.element.firstElementChild; // let second = first.nextElementSibling;
assertElementIsEmberishElement(first,'div',{id:'direct'},'Foo4'); // assertElementIsEmberishElement(first, 'div', { id: 'helper' }, 'Foo4');
_glimmerObjectReference.setProperty(view,'user1',"Bar");_glimmerObjectReference.setProperty(view,'user2',"5");rerender();assertElementIsEmberishElement(first,'div',{id:'direct'},'Bar5'); // assertElementIsEmberishElement(second, 'div', { id: 'helper' }, 'Bar5');
_glimmerObjectReference.setProperty(view,'user2','6');rerender();assertElementIsEmberishElement(first,'div',{id:'direct'},'Bar6'); // assertElementIsEmberishElement(second, 'div', { id: 'helper' }, 'Bar6');
});QUnit.test('{{component}} helper works with positional params',function(){var SampleComponent=_glimmerTestHelpers.EmberishCurlyComponent.extend();SampleComponent.reopenClass({positionalParams:['name','age']});env.registerEmberishCurlyComponent('sample-component',SampleComponent,"{{attrs.name}}{{attrs.age}}");appendViewFor("{{component \"sample-component\" myName myAge}}",{myName:'Quint',myAge:4});assertEmberishElement('div','Quint4');_glimmerObjectReference.setProperty(view,'myName','Edward');_glimmerObjectReference.setProperty(view,'myAge','5');rerender();assertEmberishElement('div','Edward5');_glimmerObjectReference.setProperty(view,'myName','Quint');_glimmerObjectReference.setProperty(view,'myAge','4');rerender();assertEmberishElement('div','Quint4');});_module('Emberish closure components');QUnit.test('can handle aliased block components',function(assert){env.registerHelper('hash',function(params,hash){return hash;});env.registerEmberishCurlyComponent('foo-bar',null,'Hello {{arg1}} {{yield}}');appendViewFor(_glimmerTestHelpers.stripTight(_templateObject19));assertText('Hello World! Test1 Test2');});QUnit.test('can handle aliased inline components',function(assert){env.registerHelper('hash',function(params,hash){return hash;});env.registerEmberishCurlyComponent('foo-bar',null,'Hello {{arg1}}');appendViewFor(_glimmerTestHelpers.stripTight(_templateObject20));assertText('Hello World! Test');});QUnit.test('can handle higher order inline components',function(assert){env.registerHelper('hash',function(params,hash){return hash;});env.registerEmberishCurlyComponent('foo-bar',null,'{{yield (hash comp=(component "baz-bar"))}}');env.registerEmberishCurlyComponent('baz-bar',null,'Hello {{arg1}}');appendViewFor(_glimmerTestHelpers.stripTight(_templateObject21));assertText('Hello World! Test');});QUnit.test('can handle higher order block components',function(assert){env.registerHelper('hash',function(params,hash){return hash;});env.registerEmberishCurlyComponent('foo-bar',null,'{{yield (hash comp=(component "baz-bar"))}}');env.registerEmberishCurlyComponent('baz-bar',null,'Hello {{arg1}} {{yield}}');appendViewFor(_glimmerTestHelpers.stripTight(_templateObject22));assertText('Hello World! Test1 Test2');});_module("Emberish Components - parentView");QUnit.skip('components in template of a yielding component should have the proper parentView',function(){var outer=undefined,innerTemplate=undefined,innerLayout=undefined;var Outer=_glimmerTestHelpers.EmberishCurlyComponent.extend({init:function(){this._super.apply(this,arguments);outer = this;}});var InnerInTemplate=_glimmerTestHelpers.EmberishCurlyComponent.extend({init:function(){this._super.apply(this,arguments);innerTemplate = this;}});var InnerInLayout=_glimmerTestHelpers.EmberishCurlyComponent.extend({init:function(){this._super.apply(this,arguments);innerLayout = this;}});env.registerEmberishCurlyComponent('x-inner-in-layout',InnerInLayout,'');env.registerEmberishCurlyComponent('x-inner-in-template',InnerInTemplate,'');env.registerEmberishCurlyComponent('x-outer',Outer,"{{x-inner-in-layout}}{{yield}}");appendViewFor('{{#x-outer}}{{#x-inner-in-template}}{{/x-inner-in-template}}{{/x-outer}}');assertEmberishElement('div');equalObject(innerTemplate.parentView,outer,'receives the wrapping component as its parentView in template blocks');equalObject(innerLayout.parentView,outer,'receives the wrapping component as its parentView in layout');equalObject(outer.parentView,view,'x-outer receives the ambient scope as its parentView');});function inspect(obj){return obj && "<#Object:" + obj._guid + ">";}function equalObject(actual,expected,msg){strictEqual(inspect(actual),inspect(expected),msg);}QUnit.skip('newly-added sub-components get correct parentView',function(){var outer=undefined,inner=undefined;var Outer=_glimmerTestHelpers.EmberishCurlyComponent.extend({init:function(){this._super.apply(this,arguments);outer = this;}});var Inner=_glimmerTestHelpers.EmberishCurlyComponent.extend({init:function(){this._super.apply(this,arguments);inner = this;}});env.registerEmberishCurlyComponent('x-outer',Outer,"{{yield}}");env.registerEmberishCurlyComponent('x-inner',Inner,'');appendViewFor('{{#x-outer}}{{#if showInner}}{{x-inner}}{{/if}}{{/x-outer}}',{showInner:false});equalObject(outer.parentView,view,'x-outer receives the ambient scope as its parentView');_glimmerObjectReference.setProperty(view,'showInner',true);rerender();equalObject(inner.parentView,outer,'receives the wrapping component as its parentView in template blocks');equalObject(outer.parentView,view,'x-outer receives the ambient scope as its parentView');});_module('Emberish closure components');QUnit.test('can handle aliased block components with args',function(assert){env.registerHelper('hash',function(params,hash){return hash;});env.registerEmberishCurlyComponent('foo-bar',null,'Hello {{arg1}} {{yield}}');appendViewFor(_glimmerTestHelpers.stripTight(_templateObject19));assertText('Hello World! Test1 Test2');});QUnit.test('can handle aliased block components without args',function(assert){env.registerHelper('hash',function(params,hash){return hash;});env.registerEmberishCurlyComponent('foo-bar',null,'Hello {{yield}}');appendViewFor(_glimmerTestHelpers.stripTight(_templateObject23));assertText('Hello World! Test');});QUnit.test('can handle aliased inline components with args',function(assert){env.registerHelper('hash',function(params,hash){return hash;});env.registerEmberishCurlyComponent('foo-bar',null,'Hello {{arg1}}');appendViewFor(_glimmerTestHelpers.stripTight(_templateObject20));assertText('Hello World! Test');});QUnit.test('can handle aliased inline components without args',function(assert){env.registerHelper('hash',function(params,hash){return hash;});env.registerEmberishCurlyComponent('foo-bar',null,'Hello');appendViewFor(_glimmerTestHelpers.stripTight(_templateObject24));assertText('Hello World!');});QUnit.test('can handle higher order block components with args',function(assert){env.registerHelper('hash',function(params,hash){return hash;});env.registerEmberishCurlyComponent('foo-bar',null,'{{yield (hash comp=(component "baz-bar"))}}');env.registerEmberishCurlyComponent('baz-bar',null,'Hello {{arg1}} {{yield}}');appendViewFor(_glimmerTestHelpers.stripTight(_templateObject22));assertText('Hello World! Test1 Test2');});QUnit.test('can handle higher order block components without args',function(assert){env.registerHelper('hash',function(params,hash){return hash;});env.registerEmberishCurlyComponent('foo-bar',null,'{{yield (hash comp=(component "baz-bar"))}}');env.registerEmberishCurlyComponent('baz-bar',null,'Hello {{arg1}} {{yield}}');appendViewFor(_glimmerTestHelpers.stripTight(_templateObject25));assertText('Hello World! Test');});QUnit.test('can handle higher order inline components with args',function(assert){env.registerHelper('hash',function(params,hash){return hash;});env.registerEmberishCurlyComponent('foo-bar',null,'{{yield (hash comp=(component "baz-bar"))}}');env.registerEmberishCurlyComponent('baz-bar',null,'Hello {{arg1}}');appendViewFor(_glimmerTestHelpers.stripTight(_templateObject21));assertText('Hello World! Test');});QUnit.test('can handle higher order inline components without args',function(assert){env.registerHelper('hash',function(params,hash){return hash;});env.registerEmberishCurlyComponent('foo-bar',null,'{{yield (hash comp=(component "baz-bar"))}}');env.registerEmberishCurlyComponent('baz-bar',null,'Hello');appendViewFor(_glimmerTestHelpers.stripTight(_templateObject26));assertText('Hello World!');});QUnit.test('can handle higher order inline components without args',function(assert){env.registerHelper('hash',function(params,hash){return hash;});env.registerEmberishCurlyComponent('foo-bar',null,'{{yield (hash comp=(component "baz-bar"))}}');env.registerEmberishCurlyComponent('baz-bar',null,'Hello');appendViewFor(_glimmerTestHelpers.stripTight(_templateObject26));assertText('Hello World!');});QUnit.test('can handle higher order block components',function(assert){env.registerHelper('hash',function(params,hash){return hash;});env.registerEmberishCurlyComponent('foo-bar',null,'{{yield (hash comp=(component "baz-bar"))}}');env.registerEmberishCurlyComponent('baz-bar',null,'Hello {{arg1}} {{yield}}');appendViewFor(_glimmerTestHelpers.stripTight(_templateObject22));assertText('Hello World! Test1 Test2');});_module("Emberish Component - ids");QUnit.test('emberish component should have unique IDs',function(assert){env.registerEmberishCurlyComponent('x-curly',null,'');env.registerEmberishGlimmerComponent('x-glimmer',null,'<div></div>');appendViewFor(_glimmerTestHelpers.stripTight(_templateObject27));_glimmerTestHelpers.equalsElement(view.element.childNodes[0],'div',{id:_glimmerTestHelpers.regex(/^ember\d*$/),class:'ember-view'},'');_glimmerTestHelpers.equalsElement(view.element.childNodes[1],'div',{id:_glimmerTestHelpers.regex(/^ember\d*$/),class:'ember-view'},'');_glimmerTestHelpers.equalsElement(view.element.childNodes[2],'div',{id:_glimmerTestHelpers.regex(/^ember\d*$/),class:'ember-view'},'');_glimmerTestHelpers.equalsElement(view.element.childNodes[3],'div',{id:_glimmerTestHelpers.regex(/^ember\d*$/),class:'ember-view'},'');_glimmerTestHelpers.equalsElement(view.element.childNodes[4],'div',{id:_glimmerTestHelpers.regex(/^ember\d*$/),class:'ember-view'},'');_glimmerTestHelpers.equalsElement(view.element.childNodes[5],'div',{id:_glimmerTestHelpers.regex(/^ember\d*$/),class:'ember-view'},'');var IDs={};function markAsSeen(element){IDs[element.id] = (IDs[element.id] || 0) + 1;}markAsSeen(view.element.childNodes[0]);markAsSeen(view.element.childNodes[1]);markAsSeen(view.element.childNodes[2]);markAsSeen(view.element.childNodes[3]);markAsSeen(view.element.childNodes[4]);markAsSeen(view.element.childNodes[5]);equal(Object.keys(IDs).length,6,"Expected the components to each have a unique IDs");for(var id in IDs) {equal(IDs[id],1,"Expected ID " + id + " to be unique");}}); // QUnit.skip('non-block with each rendering child components', function() {
//   expect(2);
//   registry.register(
//     'template:components/non-block',
//     compile('In layout. {{#each attrs.items as |item|}}[{{child-non-block item=item}}]{{/each}}')
//   );
//   registry.register('template:components/child-non-block', compile('Child: {{attrs.item}}.'));
//   let items = emberA(['Tom', 'Dick', 'Harry']);
//   view = EmberView.extend({
//     template: compile('{{non-block items=view.items}}'),
//     container: container,
//     items: items
//   }).create();
//   runAppend(view);
//   equal(jQuery('#qunit-fixture').text(), 'In layout. [Child: Tom.][Child: Dick.][Child: Harry.]');
//   run(function() {
//     items.pushObject('James');
//   });
//   equal(jQuery('#qunit-fixture').text(), 'In layout. [Child: Tom.][Child: Dick.][Child: Harry.][Child: James.]');
// });
// QUnit.skip('specifying classNames results in correct class', function(assert) {
//   expect(3);
//   let clickyThing;
//   registry.register('component:some-clicky-thing', Component.extend({
//     tagName: 'button',
//     classNames: ['foo', 'bar'],
//     init() {
//       this._super(...arguments);
//       clickyThing = this;
//     }
//   }));
//   view = EmberView.extend({
//     template: compile('{{#some-clicky-thing classNames="baz"}}Click Me{{/some-clicky-thing}}'),
//     container: container
//   }).create();
//   runAppend(view);
//   let button = view.$('button');
//   ok(button.is('.foo.bar.baz.ember-view'), 'the element has the correct classes: ' + button.attr('class'));
//   let expectedClassNames = ['ember-view', 'foo', 'bar', 'baz'];
//   assert.deepEqual(clickyThing.get('classNames'),  expectedClassNames, 'classNames are properly combined');
//   let buttonClassNames = button.attr('class');
//   assert.deepEqual(buttonClassNames.split(' '), expectedClassNames, 'all classes are set 1:1 in DOM');
// });
// QUnit.skip('specifying custom concatenatedProperties avoids clobbering', function(assert) {
//   expect(1);
//   let clickyThing;
//   registry.register('component:some-clicky-thing', Component.extend({
//     concatenatedProperties: ['blahzz'],
//     blahzz: ['blark', 'pory'],
//     init() {
//       this._super(...arguments);
//       clickyThing = this;
//     }
//   }));
//   view = EmberView.extend({
//     template: compile('{{#some-clicky-thing blahzz="baz"}}Click Me{{/some-clicky-thing}}'),
//     container: container
//   }).create();
//   runAppend(view);
//   assert.deepEqual(clickyThing.get('blahzz'),  ['blark', 'pory', 'baz'], 'property is properly combined');
// });
// // jscs:disable validateIndentation
// if (isEnabled('ember-glimmer-component-generation')) {
//   QUnit.module('component - invocation (angle brackets)', {
//     setup() {
//       commonSetup();
//     },
//     teardown() {
//       commonTeardown();
//     }
//   });
//   QUnit.skip('legacy components cannot be invoked with angle brackets', function() {
//     registry.register('template:components/non-block', compile('In layout'));
//     registry.register('component:non-block', Component.extend());
//     expectAssertion(function() {
//       view = appendViewFor('<non-block />');
//     }, /cannot invoke the 'non-block' component with angle brackets/);
//   });
//   QUnit.skip('using a text-fragment in a GlimmerComponent layout gives an error', function() {
//     registry.register('template:components/non-block', compile('In layout'));
//     expectAssertion(() => {
//       view = appendViewFor('<non-block />');
//     }, `The <non-block> template must have a single top-level element because it is a GlimmerComponent.`);
//   });
//   QUnit.skip('having multiple top-level elements in a GlimmerComponent layout gives an error', function() {
//     registry.register('template:components/non-block', compile('<div>This is a</div><div>fragment</div>'));
//     expectAssertion(() => {
//       view = appendViewFor('<non-block />');
//     }, `The <non-block> template must have a single top-level element because it is a GlimmerComponent.`);
//   });
//   QUnit.skip('using a modifier in a GlimmerComponent layout gives an error', function() {
//     registry.register('template:components/non-block', compile('<div {{action "foo"}}></div>'));
//     expectAssertion(() => {
//       view = appendViewFor('<non-block />');
//     }, `You cannot use {{action ...}} in the top-level element of the <non-block> template because it is a GlimmerComponent.`);
//   });
//   QUnit.skip('using triple-curlies in a GlimmerComponent layout gives an error', function() {
//     registry.register('template:components/non-block', compile('<div style={{{bar}}}>This is a</div>'));
//     expectAssertion(() => {
//       view = appendViewFor('<non-block />');
//     }, strip`You cannot use triple curlies (e.g. style={{{ ... }}})
//       in the top-level element of the <non-block> template because it is a GlimmerComponent.`
//     );
//   });
_module("Glimmer Component - shadowing");testComponent('shadowing: normal outer attributes are reflected',{kind:'glimmer',layout:'In layout - someProp: {{@someProp}}',invokeAs:{args:{someProp:'"something here"'}},expected:{attrs:{},content:'In layout - someProp: something here'}});testComponent('shadowing - normal outer attributes clobber inner attributes',{kind:'glimmer',layout:{attributes:{'data-name':'Godfrey','data-foo':'foo'}},invokeAs:{attributes:{'data-name':'Godhuda','data-bar':'bar'}},expected:{attrs:{'data-name':'Godhuda','data-foo':'foo','data-bar':'bar'},content:''}});testComponent('shadowing: outer attributes with concat are reflected',{kind:'glimmer',layout:'In layout - someProp: {{@someProp}}',invokeAs:{context:{someProp:'something here'},args:{someProp:'someProp'}},expected:{attrs:{},content:'In layout - someProp: something here'},updates:[{expected:{attrs:{},content:'In layout - someProp: something here'}},{context:{someProp:'something else'},expected:{attrs:{},content:'In layout - someProp: something else'}},{context:{someProp:''},expected:{attrs:{},content:'In layout - someProp: '}},{context:{someProp:'something here'},expected:{attrs:{},content:'In layout - someProp: something here'}}]});testComponent('shadowing: outer attributes with concat clobber inner attributes',{kind:'glimmer',layout:{attributes:{'data-name':'Godfrey','data-foo':'foo'}},invokeAs:{context:{name:'Godhuda',foo:'foo'},attributes:{'data-name':'{{name}}','data-foo':'{{foo}}-bar'}},expected:{attrs:{'data-name':'Godhuda','data-foo':'foo-bar'},content:''},updates:[{expected:{attrs:{'data-name':'Godhuda','data-foo':'foo-bar'},content:''}},{context:{name:'Yehuda',foo:'baz'},expected:{attrs:{'data-name':'Yehuda','data-foo':'baz-bar'},content:''}},{context:{name:'',foo:''},expected:{attrs:{'data-name':'','data-foo':'-bar'},content:''}},{context:{name:'Godhuda',foo:'foo'},expected:{attrs:{'data-name':'Godhuda','data-foo':'foo-bar'},content:''}}]});testComponent('shadowing: outer attributes clobber inner attributes with concat',{kind:'glimmer',layout:{attributes:{'data-name':'{{@name}}','data-foo':'{{@foo}}-bar'}},invokeAs:{context:{name:'Godfrey',foo:'foo'},args:{name:'name',foo:'foo'},attributes:{'data-name':'Godhuda','data-foo':'foo-bar'}},expected:{attrs:{'data-name':'Godhuda','data-foo':'foo-bar'},content:''},updates:[{expected:{attrs:{'data-name':'Godhuda','data-foo':'foo-bar'},content:''}},{context:{name:'Yehuda',foo:'baz'},expected:{attrs:{'data-name':'Godhuda','data-foo':'foo-bar'},content:''}},{context:{name:'',foo:''},expected:{attrs:{'data-name':'Godhuda','data-foo':'foo-bar'},content:''}},{context:{name:'Godhuda',foo:'foo'},expected:{attrs:{'data-name':'Godhuda','data-foo':'foo-bar'},content:''}}]});_module("Glimmer Component");var styles=[{name:'a div',tagName:'div'},{name:'a web component',tagName:'not-an-ember-component'}];styles.forEach(function(style){QUnit.test("non-block without attributes replaced with " + style.name,function(){env.registerEmberishGlimmerComponent('non-block',null,"  <" + style.tagName + ">In layout</" + style.tagName + ">  ");appendViewFor('<non-block />');var node=view.element.firstChild;_glimmerTestHelpers.equalsElement(view.element,style.tagName,{class:'ember-view',id:_glimmerTestHelpers.regex(/^ember\d*$/)},'In layout');rerender();strictEqual(node,view.element.firstChild,'The inner element has not changed');_glimmerTestHelpers.equalsElement(view.element,style.tagName,{class:'ember-view',id:_glimmerTestHelpers.regex(/^ember\d*$/)},'In layout');});QUnit.test("non-block with attributes replaced with " + style.name,function(){env.registerEmberishGlimmerComponent('non-block',null,"  <" + style.tagName + " such=\"{{@stability}}\">In layout</" + style.tagName + ">  ");appendViewFor('<non-block @stability={{stability}} />',{stability:'stability'});var node=view.element;_glimmerTestHelpers.equalsElement(node,style.tagName,{such:'stability',class:'ember-view',id:_glimmerTestHelpers.regex(/^ember\d*$/)},'In layout');_glimmerObjectReference.setProperty(view,'stability','changed!!!');rerender();strictEqual(node.firstElementChild,view.element.firstElementChild,'The inner element has not changed');_glimmerTestHelpers.equalsElement(node,style.tagName,{such:'changed!!!',class:'ember-view',id:_glimmerTestHelpers.regex(/^ember\d*$/)},'In layout');});QUnit.skip("non-block replaced with " + style.name + " (regression with single element in the root element)",function(){env.registerEmberishGlimmerComponent('non-block',_glimmerTestHelpers.EmberishGlimmerComponent,"  <" + style.tagName + " such=\"{{attrs.stability}}\"><p>In layout</p></" + style.tagName + ">  ");appendViewFor('<non-block stability={{view.stability}} />',{stability:'stability'});var node=view.element;_glimmerTestHelpers.equalsElement(node,style.tagName,{such:'stability',class:'ember-view',id:_glimmerTestHelpers.regex(/^ember\d*$/)},'<p>In layout</p>');_glimmerObjectReference.setProperty(view,'stability','changed!!!');rerender();strictEqual(node.firstElementChild,view.element.firstElementChild,'The inner element has not changed');_glimmerTestHelpers.equalsElement(node,style.tagName,{such:'changed!!!',class:'ember-view',id:_glimmerTestHelpers.regex(/^ember\d*$/)},'<p>In layout</p>');});QUnit.skip("non-block with class replaced with " + style.name + " merges classes",function(){env.registerEmberishGlimmerComponent('non-block',_glimmerTestHelpers.EmberishGlimmerComponent,"<" + style.tagName + " class=\"inner-class\" />");appendViewFor('<non-block class="{{outer}}" />',{outer:'outer'});_glimmerTestHelpers.equalsElement(view.element,style.tagName,{class:_glimmerTestHelpers.classes('inner-class outer ember-view'),id:_glimmerTestHelpers.regex(/^ember\d*$/)},'');_glimmerObjectReference.setProperty(view,'outer','new-outer');rerender();_glimmerTestHelpers.equalsElement(view.element,style.tagName,{class:_glimmerTestHelpers.classes('inner-class new-outer ember-view'),id:_glimmerTestHelpers.regex(/^ember\d*$/)},'');});QUnit.skip("non-block with outer attributes replaced with " + style.name + " shadows inner attributes",function(){var component=undefined;var MyComponent=(function(_EmberishGlimmerComponent){_inherits(MyComponent,_EmberishGlimmerComponent);function MyComponent(attrs){_classCallCheck(this,MyComponent);_EmberishGlimmerComponent.call(this,attrs);component = this;}return MyComponent;})(_glimmerTestHelpers.EmberishGlimmerComponent);MyComponent[_glimmerObjectReference.CLASS_META].seal();env.registerEmberishGlimmerComponent('non-block',MyComponent,"<" + style.tagName + " data-static=\"static\" data-dynamic=\"{{internal}}\" />");appendViewFor('<non-block data-static="outer" data-dynamic="outer" />');_glimmerTestHelpers.equalsElement(view.element,style.tagName,{class:_glimmerTestHelpers.classes('ember-view'),id:_glimmerTestHelpers.regex(/^ember\d*$/),'data-static':'outer','data-dynamic':'outer'},'');_glimmerObjectReference.setProperty(component,'internal','changed');_glimmerTestHelpers.equalsElement(view.element,style.tagName,{class:_glimmerTestHelpers.classes('ember-view'),id:_glimmerTestHelpers.regex(/^ember\d*$/),'data-static':'outer','data-dynamic':'outer'},'');});QUnit.skip("non-block replaced with " + style.name + " should have correct scope",function(){var NonBlock=(function(_EmberishGlimmerComponent2){_inherits(NonBlock,_EmberishGlimmerComponent2);function NonBlock(){_classCallCheck(this,NonBlock);_EmberishGlimmerComponent2.apply(this,arguments);}NonBlock.prototype.init = function init(){this._super.apply(this,arguments);_glimmerObjectReference.setProperty(this,'internal','stuff');};return NonBlock;})(_glimmerTestHelpers.EmberishGlimmerComponent);NonBlock[_glimmerObjectReference.CLASS_META].seal();env.registerEmberishGlimmerComponent('non-block',NonBlock,"<" + style.tagName + ">{{internal}}</" + style.tagName + ">");appendViewFor('<non-block />');_glimmerTestHelpers.equalsElement(view.element,style.tagName,{class:_glimmerTestHelpers.classes('ember-view'),id:_glimmerTestHelpers.regex(/^ember\d*$/)},'stuff');});QUnit.skip("non-block replaced with " + style.name + " should have correct 'element'",function(){var component=undefined;var MyComponent=(function(_EmberishGlimmerComponent3){_inherits(MyComponent,_EmberishGlimmerComponent3);function MyComponent(attrs){_classCallCheck(this,MyComponent);_EmberishGlimmerComponent3.call(this,attrs);component = this;}return MyComponent;})(_glimmerTestHelpers.EmberishGlimmerComponent);MyComponent[_glimmerObjectReference.CLASS_META].seal();env.registerEmberishGlimmerComponent('non-block',MyComponent,"<" + style.tagName + " />");appendViewFor('<non-block />');_glimmerTestHelpers.equalsElement(view.element,style.tagName,{class:_glimmerTestHelpers.classes('ember-view'),id:_glimmerTestHelpers.regex(/^ember\d*$/)},'');});QUnit.skip("non-block replaced with " + style.name + " should have inner attributes",function(){var NonBlock=(function(_EmberishGlimmerComponent4){_inherits(NonBlock,_EmberishGlimmerComponent4);function NonBlock(){_classCallCheck(this,NonBlock);_EmberishGlimmerComponent4.apply(this,arguments);}NonBlock.prototype.init = function init(){this._super.apply(this,arguments);_glimmerObjectReference.setProperty(this,'internal','stuff');};return NonBlock;})(_glimmerTestHelpers.EmberishGlimmerComponent);NonBlock[_glimmerObjectReference.CLASS_META].seal();env.registerEmberishGlimmerComponent('non-block',NonBlock,"<" + style.tagName + " data-static=\"static\" data-dynamic=\"{{internal}}\" />");appendViewFor('<non-block />');_glimmerTestHelpers.equalsElement(view.element,style.tagName,{class:_glimmerTestHelpers.classes('ember-view'),id:_glimmerTestHelpers.regex(/^ember\d*$/),'data-static':'static','data-dynamic':'stuff'},'');});QUnit.skip("only text attributes are reflected on the underlying DOM element (" + style.name + ")",function(){env.registerEmberishGlimmerComponent('non-block',_glimmerTestHelpers.EmberishGlimmerComponent,"<" + style.tagName + ">In layout</" + style.tagName + ">");appendViewFor('<non-block static-prop="static text" concat-prop="{{view.dynamic}} text" dynamic-prop={{view.dynamic}} />',{dynamic:'dynamic'});_glimmerTestHelpers.equalsElement(view.element,style.tagName,{class:_glimmerTestHelpers.classes('ember-view'),id:_glimmerTestHelpers.regex(/^ember\d*$/),'static-prop':'static text','concat-prop':'dynamic text'},'In layout');});});QUnit.test("Glimmer component with element modifier",function(assert){env.registerEmberishGlimmerComponent('non-block',null,"  <div>In layout</div>  ");assert.throws(function(){appendViewFor('<non-block {{action}} />');},new Error("Compile Error: Element modifiers are not allowed in components"),"should throw error");});QUnit.skip('block without properties',function(){env.registerEmberishGlimmerComponent('with-block',_glimmerTestHelpers.EmberishGlimmerComponent,'<with-block>In layout - {{yield}}</with-block>');appendViewFor('<with-block>In template</with-block>');_glimmerTestHelpers.equalsElement(view.element,'with-block',{class:_glimmerTestHelpers.classes('ember-view'),id:_glimmerTestHelpers.regex(/^ember\d*$/)},'In layout - In template');});QUnit.skip('attributes are not installed on the top level',function(){var component=undefined;var NonBlock=(function(_EmberishGlimmerComponent5){_inherits(NonBlock,_EmberishGlimmerComponent5);function NonBlock(){_classCallCheck(this,NonBlock);_EmberishGlimmerComponent5.apply(this,arguments);}NonBlock.prototype.init = function init(){this._super.apply(this,arguments);component = this;};return NonBlock;})(_glimmerTestHelpers.EmberishGlimmerComponent);NonBlock[_glimmerObjectReference.CLASS_META].seal(); // This is specifically attempting to trigger a 1.x-era heuristic that only copied
// attrs that were present as defined properties on the component.
NonBlock.prototype['text'] = null;NonBlock.prototype['dynamic'] = null;env.registerEmberishGlimmerComponent('non-block',NonBlock,'<non-block>In layout - {{attrs.text}} -- {{text}}</non-block>');appendViewFor('<non-block text="texting" dynamic={{dynamic}} />',{dynamic:'dynamic'});_glimmerTestHelpers.equalsElement(view.element,'non-block',{class:_glimmerTestHelpers.classes('ember-view'),id:_glimmerTestHelpers.regex(/^ember\d*$/),text:'texting'},'In layout - texting -- null');equal(component.attrs['text'],'texting');equal(component.attrs['dynamic'],'dynamic');strictEqual(component['text'],null);strictEqual(component['dynamic'],null);rerender();_glimmerTestHelpers.equalsElement(view.element,'non-block',{class:_glimmerTestHelpers.classes('ember-view'),id:_glimmerTestHelpers.regex(/^ember\d*$/),text:'texting'},'In layout - texting -- <!---->');equal(component.attrs['text'],'texting');equal(component.attrs['dynamic'],'dynamic');strictEqual(component['text'],null);strictEqual(component['dynamic'],null);});QUnit.skip('non-block with properties on attrs and component class',function(){env.registerEmberishGlimmerComponent('non-block',_glimmerTestHelpers.EmberishGlimmerComponent,'<non-block>In layout - someProp: {{attrs.someProp}}</non-block>');appendViewFor('<non-block someProp="something here" />');assertEmberishElement('non-block',{someProp:'something here'},'In layout - someProp: something here');});QUnit.skip('block with properties on attrs',function(){env.registerEmberishGlimmerComponent('with-block',_glimmerTestHelpers.EmberishGlimmerComponent,'<with-block>In layout - someProp: {{attrs.someProp}} - {{yield}}</with-block>');appendViewFor('<with-block someProp="something here">In template</with-block>');assertEmberishElement('with-block',{someProp:'something here'},'In layout - someProp: something here - In template');});QUnit.skip('computed property alias on a static attr',function(){var ComputedAlias=_glimmerTestHelpers.EmberishGlimmerComponent.extend({otherProp:_glimmerObject.alias('attrs.someProp')});env.registerEmberishGlimmerComponent('computed-alias',ComputedAlias,'<computed-alias>{{otherProp}}</computed-alias>');appendViewFor('<computed-alias someProp="value"></computed-alias>',{someProp:'value'});assertEmberishElement('computed-alias',{someProp:'value'},'value');});QUnit.skip('computed property alias on a dynamic attr',function(){var ComputedAlias=_glimmerTestHelpers.EmberishGlimmerComponent.extend({otherProp:_glimmerObject.alias('attrs.someProp')});env.registerEmberishGlimmerComponent('computed-alias',ComputedAlias,'<computed-alias>{{otherProp}}</computed-alias>');appendViewFor('<computed-alias someProp="{{someProp}}"></computed-alias>',{someProp:'value'});assertEmberishElement('computed-alias',{someProp:'value'},'value');_glimmerObjectReference.setProperty(view,'someProp','other value');rerender();assertEmberishElement('computed-alias',{someProp:'other value'},'other value');});QUnit.skip('lookup of component takes priority over property',function(){expect(1);var MyComponent=(function(_EmberishCurlyComponent8){_inherits(MyComponent,_EmberishCurlyComponent8);function MyComponent(){_classCallCheck(this,MyComponent);_EmberishCurlyComponent8.apply(this,arguments);this['some-component'] = 'not-some-component';this['some-prop'] = 'some-prop';}return MyComponent;})(_glimmerTestHelpers.EmberishCurlyComponent);var SomeComponent=(function(_EmberishCurlyComponent9){_inherits(SomeComponent,_EmberishCurlyComponent9);function SomeComponent(){_classCallCheck(this,SomeComponent);_EmberishCurlyComponent9.apply(this,arguments);}return SomeComponent;})(_glimmerTestHelpers.EmberishCurlyComponent);env.registerEmberishCurlyComponent('my-component',MyComponent,'{{some-prop}} {{some-component}}');env.registerEmberishCurlyComponent('some-component',SomeComponent,'some-component');appendViewFor('{{my-component}}');assertAppended('<div>some-prop <div>some-component</div></div>');});QUnit.test('Curly component hooks (with attrs)',function(){var instance=undefined;var NonBlock=(function(_EmberishCurlyComponent10){_inherits(NonBlock,_EmberishCurlyComponent10);function NonBlock(){_classCallCheck(this,NonBlock);_EmberishCurlyComponent10.apply(this,arguments);}NonBlock.prototype.init = function init(){instance = this;};return NonBlock;})(_glimmerTestHelpers.EmberishCurlyComponent);env.registerEmberishCurlyComponent('non-block',_glimmerTestHelpers.inspectHooks(NonBlock),'In layout - someProp: {{@someProp}}');appendViewFor('{{non-block someProp=someProp}}',{someProp:'wycats'});assertFired(instance,'didReceiveAttrs');assertFired(instance,'willRender');assertFired(instance,'didInsertElement');assertFired(instance,'didRender');assertEmberishElement('div','In layout - someProp: wycats');_glimmerObjectReference.setProperty(view,'someProp','tomdale');rerender();assertEmberishElement('div','In layout - someProp: tomdale');assertFired(instance,'didReceiveAttrs',2);assertFired(instance,'willUpdate');assertFired(instance,'willRender',2);assertFired(instance,'didUpdate');assertFired(instance,'didRender',2);rerender();assertEmberishElement('div','In layout - someProp: tomdale');assertFired(instance,'didReceiveAttrs',3);assertFired(instance,'willUpdate',2);assertFired(instance,'willRender',3);assertFired(instance,'didUpdate',2);assertFired(instance,'didRender',3);});QUnit.test('Curly component hooks (attrs as self props)',function(){var instance=undefined;var NonBlock=(function(_EmberishCurlyComponent11){_inherits(NonBlock,_EmberishCurlyComponent11);function NonBlock(){_classCallCheck(this,NonBlock);_EmberishCurlyComponent11.apply(this,arguments);}NonBlock.prototype.init = function init(){instance = this;};return NonBlock;})(_glimmerTestHelpers.EmberishCurlyComponent);env.registerEmberishCurlyComponent('non-block',_glimmerTestHelpers.inspectHooks(NonBlock),'In layout - someProp: {{someProp}}');appendViewFor('{{non-block someProp=someProp}}',{someProp:'wycats'});assertFired(instance,'didReceiveAttrs');assertFired(instance,'willRender');assertFired(instance,'didInsertElement');assertFired(instance,'didRender');assertEmberishElement('div','In layout - someProp: wycats');_glimmerObjectReference.setProperty(view,'someProp','tomdale');rerender();assertEmberishElement('div','In layout - someProp: tomdale');assertFired(instance,'didReceiveAttrs',2);assertFired(instance,'willUpdate');assertFired(instance,'willRender',2);assertFired(instance,'didUpdate');assertFired(instance,'didRender',2);rerender();assertEmberishElement('div','In layout - someProp: tomdale');assertFired(instance,'didReceiveAttrs',3);assertFired(instance,'willUpdate',2);assertFired(instance,'willRender',3);assertFired(instance,'didUpdate',2);assertFired(instance,'didRender',3);});QUnit.test('Setting value attributeBinding to null results in empty string value',function(assert){var instance=undefined;var InputComponent=(function(_EmberishCurlyComponent12){_inherits(InputComponent,_EmberishCurlyComponent12);function InputComponent(){_classCallCheck(this,InputComponent);_EmberishCurlyComponent12.apply(this,arguments);this.tagName = 'input';this.attributeBindings = ['value'];}InputComponent.prototype.init = function init(){instance = this;};return InputComponent;})(_glimmerTestHelpers.EmberishCurlyComponent);env.registerEmberishCurlyComponent('input-component',_glimmerTestHelpers.inspectHooks(InputComponent),'input component');appendViewFor('{{input-component value=someProp}}',{someProp:null});assert.equal(instance.element.value,'');_glimmerObjectReference.setProperty(view,'someProp','wycats');rerender();assert.equal(instance.element.value,'wycats');_glimmerObjectReference.setProperty(view,'someProp',null);rerender();assert.equal(instance.element.value,'');});QUnit.test('Setting class attributeBinding does not clobber ember-view',function(assert){var instance=undefined;var FooBarComponent=(function(_EmberishCurlyComponent13){_inherits(FooBarComponent,_EmberishCurlyComponent13);function FooBarComponent(){_classCallCheck(this,FooBarComponent);_EmberishCurlyComponent13.apply(this,arguments);this.attributeBindings = ['class'];}FooBarComponent.prototype.init = function init(){instance = this;};return FooBarComponent;})(_glimmerTestHelpers.EmberishCurlyComponent);env.registerEmberishCurlyComponent('foo-bar',FooBarComponent,'FOO BAR');appendViewFor('{{foo-bar class=classes}}',{classes:"foo bar"});assertEmberishElement('div',{class:_glimmerTestHelpers.classes('ember-view foo bar')},'FOO BAR');rerender();assertEmberishElement('div',{class:_glimmerTestHelpers.classes('ember-view foo bar')},'FOO BAR');_glimmerObjectReference.setProperty(view,'classes','foo bar baz');rerender();assertEmberishElement('div',{class:_glimmerTestHelpers.classes('ember-view foo bar baz')},'FOO BAR');_glimmerObjectReference.setProperty(view,'classes','foo bar');rerender();assertEmberishElement('div',{class:_glimmerTestHelpers.classes('ember-view foo bar')},'FOO BAR');});QUnit.test('Curly component hooks (force recompute)',function(){var instance=undefined;var NonBlock=(function(_EmberishCurlyComponent14){_inherits(NonBlock,_EmberishCurlyComponent14);function NonBlock(){_classCallCheck(this,NonBlock);_EmberishCurlyComponent14.apply(this,arguments);}NonBlock.prototype.init = function init(){instance = this;};return NonBlock;})(_glimmerTestHelpers.EmberishCurlyComponent);env.registerEmberishCurlyComponent('non-block',_glimmerTestHelpers.inspectHooks(NonBlock),'In layout - someProp: {{@someProp}}');appendViewFor('{{non-block someProp="wycats"}}');assertFired(instance,'didReceiveAttrs',1);assertFired(instance,'willRender',1);assertFired(instance,'didInsertElement',1);assertFired(instance,'didRender',1);assertEmberishElement('div','In layout - someProp: wycats');rerender();assertEmberishElement('div','In layout - someProp: wycats');assertFired(instance,'didReceiveAttrs',1);assertFired(instance,'willRender',1);assertFired(instance,'didRender',1);instance.recompute();rerender();assertEmberishElement('div','In layout - someProp: wycats');assertFired(instance,'didReceiveAttrs',2);assertFired(instance,'willUpdate',1);assertFired(instance,'willRender',2);assertFired(instance,'didUpdate',1);assertFired(instance,'didRender',2);});QUnit.test('Glimmer component hooks',function(){var instance=undefined;var NonBlock=(function(_EmberishGlimmerComponent6){_inherits(NonBlock,_EmberishGlimmerComponent6);function NonBlock(){_classCallCheck(this,NonBlock);_EmberishGlimmerComponent6.apply(this,arguments);}NonBlock.prototype.init = function init(){instance = this;};return NonBlock;})(_glimmerTestHelpers.EmberishGlimmerComponent);env.registerEmberishGlimmerComponent('non-block',_glimmerTestHelpers.inspectHooks(NonBlock),'<div>In layout - someProp: {{@someProp}}</div>');appendViewFor('<non-block @someProp={{someProp}} />',{someProp:'wycats'});assertFired(instance,'didReceiveAttrs');assertFired(instance,'willRender');assertFired(instance,'didInsertElement');assertFired(instance,'didRender');assertEmberishElement('div','In layout - someProp: wycats');_glimmerObjectReference.setProperty(view,'someProp','tomdale');rerender();assertEmberishElement('div','In layout - someProp: tomdale');assertFired(instance,'didReceiveAttrs',2);assertFired(instance,'willUpdate');assertFired(instance,'willRender',2);assertFired(instance,'didUpdate');assertFired(instance,'didRender',2);rerender();assertEmberishElement('div','In layout - someProp: tomdale');assertFired(instance,'didReceiveAttrs',3);assertFired(instance,'willUpdate',2);assertFired(instance,'willRender',3);assertFired(instance,'didUpdate',2);assertFired(instance,'didRender',3);});QUnit.test('Glimmer component hooks (force recompute)',function(){var instance=undefined;var NonBlock=(function(_EmberishGlimmerComponent7){_inherits(NonBlock,_EmberishGlimmerComponent7);function NonBlock(){_classCallCheck(this,NonBlock);_EmberishGlimmerComponent7.apply(this,arguments);}NonBlock.prototype.init = function init(){instance = this;};return NonBlock;})(_glimmerTestHelpers.EmberishGlimmerComponent);env.registerEmberishGlimmerComponent('non-block',_glimmerTestHelpers.inspectHooks(NonBlock),'<div>In layout - someProp: {{@someProp}}</div>');appendViewFor('{{non-block someProp="wycats"}}');assertFired(instance,'didReceiveAttrs',1);assertFired(instance,'willRender',1);assertFired(instance,'didInsertElement',1);assertFired(instance,'didRender',1);assertEmberishElement('div','In layout - someProp: wycats');rerender();assertEmberishElement('div','In layout - someProp: wycats');assertFired(instance,'didReceiveAttrs',1);assertFired(instance,'willRender',1);assertFired(instance,'didRender',1);instance.recompute();rerender();assertEmberishElement('div','In layout - someProp: wycats');assertFired(instance,'didReceiveAttrs',2);assertFired(instance,'willUpdate',1);assertFired(instance,'willRender',2);assertFired(instance,'didUpdate',1);assertFired(instance,'didRender',2);}); // QUnit.skip('[DEPRECATED] non-block with properties on self', function() {
//   // TODO: attrs
//   // expectDeprecation("You accessed the `someProp` attribute directly. Please use `attrs.someProp` instead.");
//   registry.register('template:components/non-block', compile('In layout - someProp: {{someProp}}'));
//   view = EmberView.extend({
//     template: compile('{{non-block someProp="something here"}}'),
//     container: container
//   }).create();
//   runAppend(view);
//   equal(jQuery('#qunit-fixture').text(), 'In layout - someProp: something here');
// });
// QUnit.skip('[DEPRECATED] block with properties on self', function() {
//   // TODO: attrs
//   // expectDeprecation("You accessed the `someProp` attribute directly. Please use `attrs.someProp` instead.");
//   registry.register('template:components/with-block', compile('In layout - someProp: {{someProp}} - {{yield}}'));
//   view = EmberView.extend({
//     template: compile('{{#with-block someProp="something here"}}In template{{/with-block}}'),
//     container: container
//   }).create();
//   runAppend(view);
//   equal(jQuery('#qunit-fixture').text(), 'In layout - someProp: something here - In template');
// });
//   QUnit.skip('moduleName is available on _renderNode when a layout is present', function() {
//     expect(1);
//     let layoutModuleName = 'my-app-name/templates/components/sample-component';
//     let sampleComponentLayout = compile('<sample-component>Sample Component - {{yield}}</sample-component>', {
//       moduleName: layoutModuleName
//     });
//     registry.register('template:components/sample-component', sampleComponentLayout);
//     registry.register('component:sample-component', GlimmerComponent.extend({
//       didInsertElement: function() {
//         equal(this._renderNode.lastResult.template.meta.moduleName, layoutModuleName);
//       }
//     }));
//     view = EmberView.extend({
//       layout: compile('<sample-component />'),
//       container
//     }).create();
//     runAppend(view);
//   });
//   QUnit.skip('moduleName is available on _renderNode when no layout is present', function() {
//     expect(1);
//     let templateModuleName = 'my-app-name/templates/application';
//     registry.register('component:sample-component', Component.extend({
//       didInsertElement: function() {
//         equal(this._renderNode.lastResult.template.meta.moduleName, templateModuleName);
//       }
//     }));
//     view = EmberView.extend({
//       layout: compile('{{#sample-component}}Derp{{/sample-component}}', {
//         moduleName: templateModuleName
//       }),
//       container
//     }).create();
//     runAppend(view);
//   });
// QUnit.skip('component without dash is not looked up', function() {
//   expect(1);
//   registry.register('template:components/somecomponent', compile('somecomponent'));
//   view = EmberView.extend({
//     template: compile('{{somecomponent}}'),
//     container: container,
//     context: {
//       'somecomponent': 'notsomecomponent'
//     }
//   }).create();
//   runAppend(view);
//   equal(jQuery('#qunit-fixture').text(), 'notsomecomponent');
// });
// QUnit.skip(`partials templates should not be treated like a component layout for ${style.name}`, function() {
//   registry.register('template:_zomg', compile(`<p>In partial</p>`));
//   registry.register('template:components/non-block', compile(`<${style.tagName}>{{partial "zomg"}}</${style.tagName}>`));
//   view = appendViewFor('<non-block />');
//   let el = view.$(style.tagName).find('p');
//   equal(el.length, 1, 'precond - the partial was rendered');
//   equal(el.text(), 'In partial');
//   strictEqual(el.attr('id'), undefined, 'the partial should not get an id');
//   strictEqual(el.attr('class'), undefined, 'the partial should not get a class');
// });
//   QUnit.skip('[FRAGMENT] non-block rendering a fragment', function() {
//     registry.register('template:components/non-block', compile('<p>{{attrs.first}}</p><p>{{attrs.second}}</p>'));
//     view = appendViewFor('<non-block first={{view.first}} second={{view.second}} />', {
//       first: 'first1',
//       second: 'second1'
//     });
//     equal(view.$().html(), '<p>first1</p><p>second1</p>', 'No wrapping element was created');
//     run(view, 'setProperties', {
//       first: 'first2',
//       second: 'second2'
//     });
//     equal(view.$().html(), '<p>first2</p><p>second2</p>', 'The fragment was updated');
//   });
// // TODO: When un-skipping, fix this so it handles all styles
// QUnit.skip('non-block recursive invocations with outer attributes replaced with a div shadows inner attributes', function() {
//   registry.register('template:components/non-block-wrapper', compile('<non-block />'));
//   registry.register('template:components/non-block', compile('<div data-static="static" data-dynamic="{{internal}}" />'));
//   view = appendViewFor('<non-block-wrapper data-static="outer" data-dynamic="outer" />');
//   equal(view.$('div').attr('data-static'), 'outer', 'the outer-most attribute wins');
//   equal(view.$('div').attr('data-dynamic'), 'outer', 'the outer-most attribute wins');
//   let component = view.childViews[0].childViews[0]; // HAX
//   run(() => component.set('internal', 'changed'));
//   equal(view.$('div').attr('data-static'), 'outer', 'the outer-most attribute wins');
//   equal(view.$('div').attr('data-dynamic'), 'outer', 'the outer-most attribute wins');
// });
// QUnit.skip('components should receive the viewRegistry from the parent view', function() {
//   let outer, innerTemplate, innerLayout;
//   let viewRegistry = {};
//   registry.register('component:x-outer', Component.extend({
//     init() {
//       this._super(...arguments);
//       outer = this;
//     }
//   }));
//   registry.register('component:x-inner-in-template', Component.extend({
//     init() {
//       this._super(...arguments);
//       innerTemplate = this;
//     }
//   }));
//   registry.register('component:x-inner-in-layout', Component.extend({
//     init() {
//       this._super(...arguments);
//       innerLayout = this;
//     }
//   }));
//   registry.register('template:components/x-outer', compile('{{x-inner-in-layout}}{{yield}}'));
//   view = EmberView.extend({
//     _viewRegistry: viewRegistry,
//     template: compile('{{#x-outer}}{{x-inner-in-template}}{{/x-outer}}'),
//     container: container
//   }).create();
//   runAppend(view);
//   equal(innerTemplate._viewRegistry, viewRegistry);
//   equal(innerLayout._viewRegistry, viewRegistry);
//   equal(outer._viewRegistry, viewRegistry);
// });
// QUnit.skip('comopnent should rerender when a property is changed during children\'s rendering', function() {
//   expectDeprecation(/modified value twice in a single render/);
//   let outer, middle;
//   registry.register('component:x-outer', Component.extend({
//     value: 1,
//     grabReference: Ember.on('init', function() {
//       outer = this;
//     })
//   }));
//   registry.register('component:x-middle', Component.extend({
//     value: null,
//     grabReference: Ember.on('init', function() {
//       middle = this;
//     })
//   }));
//   registry.register('component:x-inner', Component.extend({
//     value: null,
//     pushDataUp: Ember.observer('value', function() {
//       middle.set('value', this.get('value'));
//     })
//   }));
//   registry.register('template:components/x-outer', compile('{{#x-middle}}{{x-inner value=value}}{{/x-middle}}'));
//   registry.register('template:components/x-middle', compile('<div id="middle-value">{{value}}</div>{{yield}}'));
//   registry.register('template:components/x-inner', compile('<div id="inner-value">{{value}}</div>'));
//   view = EmberView.extend({
//     template: compile('{{x-outer}}'),
//     container: container
//   }).create();
//   runAppend(view);
//   equal(view.$('#inner-value').text(), '1', 'initial render of inner');
//   equal(view.$('#middle-value').text(), '', 'initial render of middle (observers do not run during init)');
//   run(() => outer.set('value', 2));
//   equal(view.$('#inner-value').text(), '2', 'second render of inner');
//   equal(view.$('#middle-value').text(), '2', 'second render of middle');
//   run(() => outer.set('value', 3));
//   equal(view.$('#inner-value').text(), '3', 'third render of inner');
//   equal(view.$('#middle-value').text(), '3', 'third render of middle');
// });
// QUnit.skip('moduleName is available on _renderNode when a layout is present', function() {
//   expect(1);
//   let layoutModuleName = 'my-app-name/templates/components/sample-component';
//   let sampleComponentLayout = compile('Sample Component - {{yield}}', {
//     moduleName: layoutModuleName
//   });
//   registry.register('template:components/sample-component', sampleComponentLayout);
//   registry.register('component:sample-component', Component.extend({
//     didInsertElement: function() {
//       equal(this._renderNode.lastResult.template.meta.moduleName, layoutModuleName);
//     }
//   }));
//   view = EmberView.extend({
//     layout: compile('{{sample-component}}'),
//     container
//   }).create();
//   runAppend(view);
// });
// QUnit.skip('moduleName is available on _renderNode when no layout is present', function() {
//   expect(1);
//   let templateModuleName = 'my-app-name/templates/application';
//   registry.register('component:sample-component', Component.extend({
//     didInsertElement: function() {
//       equal(this._renderNode.lastResult.template.meta.moduleName, templateModuleName);
//     }
//   }));
//   view = EmberView.extend({
//     layout: compile('{{#sample-component}}Derp{{/sample-component}}', {
//       moduleName: templateModuleName
//     }),
//     container
//   }).create();
//   runAppend(view);
// });
// QUnit.skip('`template` specified in a component is overridden by block', function() {
//   expect(1);
//   registry.register('component:with-block', Component.extend({
//     layout: compile('{{yield}}'),
//     template: compile('Oh, noes!')
//   }));
//   view = EmberView.extend({
//     template: compile('{{#with-block}}Whoop, whoop!{{/with-block}}'),
//     container: container
//   }).create();
//   runAppend(view);
//   equal(view.$().text(), 'Whoop, whoop!', 'block provided always overrides template property');
// });
_module('Teardown');QUnit.test('curly components are destroyed',function(assert){var destroyed=0;var DestroyMeComponent=_glimmerTestHelpers.EmberishCurlyComponent.extend({destroy:function(){this._super();destroyed++;}});env.registerEmberishCurlyComponent('destroy-me',DestroyMeComponent,'destroy me!');appendViewFor("{{#if cond}}{{destroy-me}}{{/if}}",{cond:true});assert.strictEqual(destroyed,0,'destroy should not be called');view.rerender({cond:false});assert.strictEqual(destroyed,1,'destroy should be called exactly one');});QUnit.test('glimmer components are destroyed',function(assert){var destroyed=0;var DestroyMeComponent=_glimmerTestHelpers.EmberishGlimmerComponent.extend({destroy:function(){this._super();destroyed++;}});env.registerEmberishGlimmerComponent('destroy-me',DestroyMeComponent,'destroy me!');appendViewFor("{{#if cond}}<destroy-me />{{/if}}",{cond:true});assert.strictEqual(destroyed,0,'destroy should not be called');view.rerender({cond:false});assert.strictEqual(destroyed,1,'destroy should be called exactly one');});QUnit.test('component helpers component are destroyed',function(assert){var destroyed=0;var DestroyMeComponent=_glimmerTestHelpers.EmberishCurlyComponent.extend({destroy:function(){this._super();destroyed++;}});env.registerEmberishCurlyComponent('destroy-me',DestroyMeComponent,'destroy me!');var AnotherComponent=_glimmerTestHelpers.EmberishCurlyComponent.extend();env.registerEmberishCurlyComponent('another-component',AnotherComponent,'another thing!');appendViewFor("{{component componentName}}",{componentName:'destroy-me'});assert.strictEqual(destroyed,0,'destroy should not be called');view.rerender({componentName:'another-component'});assert.strictEqual(destroyed,1,'destroy should be called exactly one');});QUnit.test('components inside a list are destroyed',function(assert){var destroyed=[];var DestroyMeComponent=_glimmerTestHelpers.EmberishGlimmerComponent.extend({destroy:function(){this._super();destroyed.push(this.attrs.item);}});env.registerEmberishGlimmerComponent('destroy-me',DestroyMeComponent,'destroy me!');appendViewFor("{{#each list key='@primitive' as |item|}}<destroy-me @item={{item}} />{{/each}}",{list:[1,2,3,4,5]});assert.strictEqual(destroyed.length,0,'destroy should not be called');view.rerender({list:[1,2,3]});assert.deepEqual(destroyed,[4,5],'destroy should be called exactly twice');view.rerender({list:[3,2,1]});assert.deepEqual(destroyed,[4,5],'destroy should be called exactly twice');view.rerender({list:[]});assert.deepEqual(destroyed,[4,5,3,2,1],'destroy should be called for each item');});QUnit.test('components that are "destroyed twice" are destroyed once',function(assert){var destroyed=[];var DestroyMeComponent=_glimmerTestHelpers.EmberishCurlyComponent.extend({destroy:function(){this._super();destroyed.push(this.attrs.from);}});var DestroyMe2Component=_glimmerTestHelpers.EmberishCurlyComponent.extend({destroy:function(){this._super();destroyed.push(this.attrs.from);}});env.registerEmberishCurlyComponent('destroy-me',DestroyMeComponent,'{{#if @cond}}{{destroy-me-inner from="inner"}}{{/if}}');env.registerEmberishCurlyComponent('destroy-me-inner',DestroyMe2Component,'inner');appendViewFor("{{#if cond}}{{destroy-me from=\"root\" cond=child.cond}}{{/if}}",{cond:true,child:{cond:true}});assert.deepEqual(destroyed,[],'destroy should not be called');view.rerender({cond:false,child:{cond:false}});assert.deepEqual(destroyed,['root','inner'],'destroy should be called exactly once per component');});QUnit.test('deeply nested destructions',function(assert){var destroyed=[];var DestroyMe1Component=_glimmerTestHelpers.EmberishGlimmerComponent.extend({destroy:function(){this._super();destroyed.push("destroy-me1: " + this.attrs.item);}});var DestroyMe2Component=_glimmerTestHelpers.EmberishCurlyComponent.extend({destroy:function(){this._super();destroyed.push("destroy-me2: " + this.attrs.from + " - " + this.attrs.item);}});env.registerEmberishGlimmerComponent('destroy-me1',DestroyMe1Component,'<div>{{#destroy-me2 item=@item from="destroy-me1"}}{{yield}}{{/destroy-me2}}</div>');env.registerEmberishCurlyComponent('destroy-me2',DestroyMe2Component,'Destroy me! {{yield}}');appendViewFor("{{#each list key='@primitive' as |item|}}<destroy-me1 @item={{item}}>{{#destroy-me2 from=\"root\" item=item}}{{/destroy-me2}}</destroy-me1>{{/each}}",{list:[1,2,3,4,5]});assert.strictEqual(destroyed.length,0,'destroy should not be called');view.rerender({list:[1,2,3]});assert.deepEqual(destroyed,["destroy-me1: 4","destroy-me2: destroy-me1 - 4","destroy-me2: root - 4","destroy-me1: 5","destroy-me2: destroy-me1 - 5","destroy-me2: root - 5"],'destroy should be called exactly twice');destroyed = [];view.rerender({list:[3,2,1]});assert.deepEqual(destroyed,[],'destroy should be called exactly twice');view.rerender({list:[]});assert.deepEqual(destroyed,["destroy-me1: 3","destroy-me2: destroy-me1 - 3","destroy-me2: root - 3","destroy-me1: 2","destroy-me2: destroy-me1 - 2","destroy-me2: root - 2","destroy-me1: 1","destroy-me2: destroy-me1 - 1","destroy-me2: root - 1"],'destroy should be called for each item');});QUnit.test('components inside the root are destroyed when the render result is destroyed',function(assert){var glimmerDestroyed=false;var curlyDestroyed=false;var DestroyMe1Component=_glimmerTestHelpers.EmberishGlimmerComponent.extend({destroy:function(){this._super();glimmerDestroyed = true;}});var DestroyMe2Component=_glimmerTestHelpers.EmberishCurlyComponent.extend({destroy:function(){this._super();curlyDestroyed = true;}});env.registerEmberishGlimmerComponent('destroy-me1',DestroyMe1Component,'<div>Destry me!</div>');env.registerEmberishCurlyComponent('destroy-me2',DestroyMe2Component,'Destroy me too!');appendViewFor("<destroy-me1 id=\"destroy-me1\"/>{{destroy-me2 id=\"destroy-me2\"}}");assert.strictEqual(glimmerDestroyed,false,'the glimmer component should not be destroyed');assert.strictEqual(curlyDestroyed,false,'the curly component should not be destroyed');view.destroy();assert.strictEqual(glimmerDestroyed,true,'the glimmer component destroy hook was called');assert.strictEqual(curlyDestroyed,true,'the glimmer component destroy hook was called');assert.strictEqual(document.querySelectorAll('#destroy-me1').length,0,'component DOM node was removed from DOM');assert.strictEqual(document.querySelectorAll('#destroy-me2').length,0,'component DOM node was removed from DOM');assert.strictEqual(document.querySelector('#qunit-fixture').childElementCount,0,'root view was removed from DOM');});QUnit.test('tagless components render properly',function(assert){var FooBar=(function(_BasicComponent6){_inherits(FooBar,_BasicComponent6);function FooBar(){_classCallCheck(this,FooBar);_BasicComponent6.apply(this,arguments);}return FooBar;})(_glimmerTestHelpers.BasicComponent);env.registerStaticTaglessComponent('foo-bar',FooBar,"Michael Jordan says \"Go Tagless\"");appendViewFor("{{foo-bar}}");assertAppended('Michael Jordan says "Go Tagless"');rerender();assertAppended('Michael Jordan says "Go Tagless"');});_module('late bound layout');QUnit.test('can bind the layout late',function(assert){var FooBar=(function(_EmberishCurlyComponent15){_inherits(FooBar,_EmberishCurlyComponent15);function FooBar(){_classCallCheck(this,FooBar);_EmberishCurlyComponent15.apply(this,arguments);this.layout = 'Swap - {{yield}}';}return FooBar;})(_glimmerTestHelpers.EmberishCurlyComponent);env.registerEmberishCurlyComponent('foo-bar',FooBar,null);appendViewFor('{{#foo-bar}}YIELD{{/foo-bar}}');_glimmerTestHelpers.equalsElement(view.element,'div',{class:_glimmerTestHelpers.classes('ember-view'),id:_glimmerTestHelpers.regex(/^ember\d*$/)},'Swap - YIELD');});_module('appendable components');QUnit.test('it does not work on optimized appends',function(assert){var FooBar=(function(_EmberishCurlyComponent16){_inherits(FooBar,_EmberishCurlyComponent16);function FooBar(){_classCallCheck(this,FooBar);_EmberishCurlyComponent16.apply(this,arguments);}return FooBar;})(_glimmerTestHelpers.EmberishCurlyComponent);env.registerEmberishCurlyComponent('foo-bar',FooBar,'foo bar');var definition=env.getComponentDefinition(['foo-bar']);appendViewFor('{{foo}}',{foo:definition});assertAppended('[object Object]');rerender();assertAppended('[object Object]');view.rerender({foo:'foo'});assertAppended('foo');view.rerender({foo:definition});assertAppended('[object Object]');});QUnit.test('it works on unoptimized appends (dot paths)',function(assert){var FooBar=(function(_EmberishCurlyComponent17){_inherits(FooBar,_EmberishCurlyComponent17);function FooBar(){_classCallCheck(this,FooBar);_EmberishCurlyComponent17.apply(this,arguments);}return FooBar;})(_glimmerTestHelpers.EmberishCurlyComponent);env.registerEmberishCurlyComponent('foo-bar',FooBar,'foo bar');var definition=env.getComponentDefinition(['foo-bar']);appendViewFor('{{foo.bar}}',{foo:{bar:definition}});assertEmberishElement('div',{},'foo bar');rerender();assertEmberishElement('div',{},'foo bar');view.rerender({foo:{bar:'lol'}});assertAppended('lol');rerender();assertAppended('lol');view.rerender({foo:{bar:'omg'}});assertAppended('omg');view.rerender({foo:{bar:definition}});assertEmberishElement('div',{},'foo bar');});QUnit.test('it works on unoptimized appends (this paths)',function(assert){var FooBar=(function(_EmberishCurlyComponent18){_inherits(FooBar,_EmberishCurlyComponent18);function FooBar(){_classCallCheck(this,FooBar);_EmberishCurlyComponent18.apply(this,arguments);}return FooBar;})(_glimmerTestHelpers.EmberishCurlyComponent);env.registerEmberishCurlyComponent('foo-bar',FooBar,'foo bar');var definition=env.getComponentDefinition(['foo-bar']);appendViewFor('{{this.foo}}',{foo:definition});assertEmberishElement('div',{},'foo bar');rerender();assertEmberishElement('div',{},'foo bar');view.rerender({foo:'lol'});assertAppended('lol');rerender();assertAppended('lol');view.rerender({foo:'omg'});assertAppended('omg');view.rerender({foo:definition});assertEmberishElement('div',{},'foo bar');});QUnit.test('it works on unoptimized appends when initially not a component (dot paths)',function(assert){var FooBar=(function(_EmberishCurlyComponent19){_inherits(FooBar,_EmberishCurlyComponent19);function FooBar(){_classCallCheck(this,FooBar);_EmberishCurlyComponent19.apply(this,arguments);}return FooBar;})(_glimmerTestHelpers.EmberishCurlyComponent);env.registerEmberishCurlyComponent('foo-bar',FooBar,'foo bar');var definition=env.getComponentDefinition(['foo-bar']);appendViewFor('{{foo.bar}}',{foo:{bar:'lol'}});assertAppended('lol');rerender();assertAppended('lol');view.rerender({foo:{bar:definition}});assertEmberishElement('div',{},'foo bar');rerender();assertEmberishElement('div',{},'foo bar');view.rerender({foo:{bar:'lol'}});assertAppended('lol');});QUnit.test('it works on unoptimized appends when initially not a component (this paths)',function(assert){var FooBar=(function(_EmberishCurlyComponent20){_inherits(FooBar,_EmberishCurlyComponent20);function FooBar(){_classCallCheck(this,FooBar);_EmberishCurlyComponent20.apply(this,arguments);}return FooBar;})(_glimmerTestHelpers.EmberishCurlyComponent);env.registerEmberishCurlyComponent('foo-bar',FooBar,'foo bar');var definition=env.getComponentDefinition(['foo-bar']);appendViewFor('{{this.foo}}',{foo:'lol'});assertAppended('lol');rerender();assertAppended('lol');view.rerender({foo:definition});assertEmberishElement('div',{},'foo bar');rerender();assertEmberishElement('div',{},'foo bar');view.rerender({foo:'lol'});assertAppended('lol');});_module('bounds tracking');QUnit.test('it works for wrapped (curly) components',function(assert){var instance=undefined;var FooBar=(function(_EmberishCurlyComponent21){_inherits(FooBar,_EmberishCurlyComponent21);function FooBar(){_classCallCheck(this,FooBar);_EmberishCurlyComponent21.call(this);this.tagName = 'span';instance = this;}return FooBar;})(_glimmerTestHelpers.EmberishCurlyComponent);env.registerEmberishCurlyComponent('foo-bar',FooBar,'foo bar');appendViewFor('zomg {{foo-bar}} wow');assertEmberishElement('span',{},'foo bar');assert.equal(instance.bounds.parentElement(),document.querySelector('#qunit-fixture'));assert.equal(instance.bounds.firstNode(),instance.element);assert.equal(instance.bounds.lastNode(),instance.element);});QUnit.test('it works for tagless components',function(assert){var instance=undefined;var FooBar=(function(_EmberishCurlyComponent22){_inherits(FooBar,_EmberishCurlyComponent22);function FooBar(){_classCallCheck(this,FooBar);_EmberishCurlyComponent22.call(this);this.tagName = '';instance = this;}return FooBar;})(_glimmerTestHelpers.EmberishCurlyComponent);env.registerEmberishCurlyComponent('foo-bar',FooBar,'<span id="first-node">foo</span> <span id="before-last-node">bar</span>!');appendViewFor('zomg {{foo-bar}} wow');assertAppended('zomg <span id="first-node">foo</span> <span id="before-last-node">bar</span>! wow');assert.equal(instance.bounds.parentElement(),document.querySelector('#qunit-fixture'));assert.equal(instance.bounds.firstNode(),document.querySelector('#first-node'));assert.equal(instance.bounds.lastNode(),document.querySelector('#before-last-node').nextSibling);});QUnit.test('it works for unwrapped components',function(assert){var instance=undefined;var FooBar=(function(_EmberishGlimmerComponent8){_inherits(FooBar,_EmberishGlimmerComponent8);function FooBar(){_classCallCheck(this,FooBar);_EmberishGlimmerComponent8.call(this);instance = this;}return FooBar;})(_glimmerTestHelpers.EmberishGlimmerComponent);env.registerEmberishGlimmerComponent('foo-bar',FooBar,'<!-- ohhh --><span>foo bar!</span>');appendViewFor('zomg <foo-bar /> wow');assertEmberishElement('span',{},'foo bar!');assert.equal(instance.bounds.parentElement(),document.querySelector('#qunit-fixture'));assert.equal(instance.bounds.firstNode(),instance.element.previousSibling);assert.equal(instance.bounds.lastNode(),instance.element);});});

enifed('@glimmer/runtime/tests/ember-component-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/tests');
    QUnit.test('@glimmer/runtime/tests/ember-component-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/tests/ember-component-test.ts should pass tslint.');
    });
});

enifed("@glimmer/runtime/tests/extern", ["exports"], function (exports) {
  "use strict";
});

enifed('@glimmer/runtime/tests/extern.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/tests');
    QUnit.test('@glimmer/runtime/tests/extern.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/tests/extern.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/tests/in-element-test', ['exports', '@glimmer/test-helpers', '@glimmer/runtime/tests/ember-component-test', '@glimmer/object-reference'], function (exports, _glimmerTestHelpers, _glimmerRuntimeTestsEmberComponentTest, _glimmerObjectReference) {
    'use strict';

    var _templateObject = _taggedTemplateLiteralLoose(['{{#-in-element externalElement}}[{{foo}}]{{/-in-element}}'], ['{{#-in-element externalElement}}[{{foo}}]{{/-in-element}}']),
        _templateObject2 = _taggedTemplateLiteralLoose(['[Yippie!]'], ['[Yippie!]']),
        _templateObject3 = _taggedTemplateLiteralLoose(['[Double Yips!]'], ['[Double Yips!]']),
        _templateObject4 = _taggedTemplateLiteralLoose(['\n      |{{foo}}|\n      {{#-in-element first}}[{{foo}}]{{/-in-element}}\n      {{#-in-element second}}[{{foo}}]{{/-in-element}}\n    '], ['\n      |{{foo}}|\n      {{#-in-element first}}[{{foo}}]{{/-in-element}}\n      {{#-in-element second}}[{{foo}}]{{/-in-element}}\n    ']),
        _templateObject5 = _taggedTemplateLiteralLoose(['{{#-in-element targetElement}}[{{foo}}]{{/-in-element}}'], ['{{#-in-element targetElement}}[{{foo}}]{{/-in-element}}']),
        _templateObject6 = _taggedTemplateLiteralLoose(['\n      {{#if showFirst}}\n        {{#-in-element first}}[{{foo}}]{{/-in-element}}\n      {{/if}}\n      {{#if showSecond}}\n        {{#-in-element second}}[{{foo}}]{{/-in-element}}\n      {{/if}}\n    '], ['\n      {{#if showFirst}}\n        {{#-in-element first}}[{{foo}}]{{/-in-element}}\n      {{/if}}\n      {{#if showSecond}}\n        {{#-in-element second}}[{{foo}}]{{/-in-element}}\n      {{/if}}\n    ']),
        _templateObject7 = _taggedTemplateLiteralLoose([''], ['']),
        _templateObject8 = _taggedTemplateLiteralLoose(['\n      {{#-in-element firstElement}}\n        [{{foo}}]\n      {{/-in-element}}\n      {{#-in-element secondElement}}\n        [{{bar}}]\n      {{/-in-element}}\n      '], ['\n      {{#-in-element firstElement}}\n        [{{foo}}]\n      {{/-in-element}}\n      {{#-in-element secondElement}}\n        [{{bar}}]\n      {{/-in-element}}\n      ']),
        _templateObject9 = _taggedTemplateLiteralLoose(['[Hello!]'], ['[Hello!]']),
        _templateObject10 = _taggedTemplateLiteralLoose(['[World!]'], ['[World!]']),
        _templateObject11 = _taggedTemplateLiteralLoose(['[GoodBye!]'], ['[GoodBye!]']),
        _templateObject12 = _taggedTemplateLiteralLoose(['[Folks!]'], ['[Folks!]']),
        _templateObject13 = _taggedTemplateLiteralLoose(['\n      {{#-in-element firstElement}}\n        [{{foo}}]\n        {{#-in-element secondElement}}\n          [{{bar}}]\n        {{/-in-element}}\n      {{/-in-element}}\n      '], ['\n      {{#-in-element firstElement}}\n        [{{foo}}]\n        {{#-in-element secondElement}}\n          [{{bar}}]\n        {{/-in-element}}\n      {{/-in-element}}\n      ']),
        _templateObject14 = _taggedTemplateLiteralLoose(['[Hello!]<!---->'], ['[Hello!]<!---->']),
        _templateObject15 = _taggedTemplateLiteralLoose(['[GoodBye!]<!---->'], ['[GoodBye!]<!---->']),
        _templateObject16 = _taggedTemplateLiteralLoose(['\n      {{#if showExternal}}\n        {{#-in-element externalElement}}[{{destroy-me}}]{{/-in-element}}\n      {{/if}}\n    '], ['\n      {{#if showExternal}}\n        {{#-in-element externalElement}}[{{destroy-me}}]{{/-in-element}}\n      {{/if}}\n    ']);

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _taggedTemplateLiteralLoose(strings, raw) { strings.raw = raw; return strings; }

    var view = undefined,
        env = undefined;
    function rerender() {
        view.rerender();
    }
    function appendViewFor(template) {
        var context = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        var MyRootView = (function (_EmberishRootView) {
            _inherits(MyRootView, _EmberishRootView);

            function MyRootView() {
                _classCallCheck(this, MyRootView);

                _EmberishRootView.apply(this, arguments);
                this.env = env;
                this.template = env.compile(template);
            }

            return MyRootView;
        })(_glimmerRuntimeTestsEmberComponentTest.EmberishRootView);

        view = new MyRootView(context);
        MyRootView[_glimmerObjectReference.CLASS_META].seal();
        env.begin();
        view.appendTo('#qunit-fixture');
        env.commit();
        return view;
    }
    QUnit.module('Targeting a remote element', {
        setup: function () {
            env = new _glimmerTestHelpers.TestEnvironment();
        }
    });
    QUnit.test('basic', function (assert) {
        var externalElement = document.createElement('div');
        appendViewFor(_glimmerTestHelpers.stripTight(_templateObject), { externalElement: externalElement, foo: 'Yippie!' });
        _glimmerTestHelpers.equalsElement(externalElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject2));
        _glimmerObjectReference.setProperty(view, 'foo', 'Double Yips!');
        rerender();
        _glimmerTestHelpers.equalsElement(externalElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject3));
        _glimmerObjectReference.setProperty(view, 'foo', 'Yippie!');
        rerender();
        _glimmerTestHelpers.equalsElement(externalElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject2));
    });
    QUnit.test('changing to falsey', function (assert) {
        var first = document.createElement('div');
        var second = document.createElement('div');
        appendViewFor(_glimmerTestHelpers.stripTight(_templateObject4), { first: first, second: null, foo: 'Yippie!' });
        _glimmerTestHelpers.equalsElement(first, 'div', {}, '[Yippie!]');
        _glimmerTestHelpers.equalsElement(second, 'div', {}, '');
        _glimmerRuntimeTestsEmberComponentTest.assertAppended('|Yippie!|<!----><!---->');
        _glimmerObjectReference.setProperty(view, 'foo', 'Double Yips!');
        rerender();
        _glimmerTestHelpers.equalsElement(first, 'div', {}, '[Double Yips!]');
        _glimmerTestHelpers.equalsElement(second, 'div', {}, '');
        _glimmerRuntimeTestsEmberComponentTest.assertAppended('|Double Yips!|<!----><!---->');
        _glimmerObjectReference.setProperty(view, 'first', null);
        rerender();
        _glimmerTestHelpers.equalsElement(first, 'div', {}, '');
        _glimmerTestHelpers.equalsElement(second, 'div', {}, '');
        _glimmerRuntimeTestsEmberComponentTest.assertAppended('|Double Yips!|<!----><!---->');
        _glimmerObjectReference.setProperty(view, 'second', second);
        rerender();
        _glimmerTestHelpers.equalsElement(first, 'div', {}, '');
        _glimmerTestHelpers.equalsElement(second, 'div', {}, '[Double Yips!]');
        _glimmerRuntimeTestsEmberComponentTest.assertAppended('|Double Yips!|<!----><!---->');
        _glimmerObjectReference.setProperty(view, 'foo', 'Yippie!');
        rerender();
        _glimmerTestHelpers.equalsElement(first, 'div', {}, '');
        _glimmerTestHelpers.equalsElement(second, 'div', {}, '[Yippie!]');
        _glimmerRuntimeTestsEmberComponentTest.assertAppended('|Yippie!|<!----><!---->');
        _glimmerObjectReference.setProperty(view, 'first', first);
        _glimmerObjectReference.setProperty(view, 'second', null);
        rerender();
        _glimmerTestHelpers.equalsElement(first, 'div', {}, '[Yippie!]');
        _glimmerTestHelpers.equalsElement(second, 'div', {}, '');
        _glimmerRuntimeTestsEmberComponentTest.assertAppended('|Yippie!|<!----><!---->');
    });
    QUnit.test('with pre-existing content', function (assert) {
        var externalElement = document.createElement('div');
        var initialContent = externalElement.innerHTML = '<p>Hello there!</p>';
        appendViewFor(_glimmerTestHelpers.stripTight(_templateObject), { externalElement: externalElement, foo: 'Yippie!' });
        _glimmerRuntimeTestsEmberComponentTest.assertAppended('<!---->');
        _glimmerTestHelpers.equalsElement(externalElement, 'div', {}, initialContent + '[Yippie!]');
        _glimmerObjectReference.setProperty(view, 'foo', 'Double Yips!');
        rerender();
        _glimmerRuntimeTestsEmberComponentTest.assertAppended('<!---->');
        _glimmerTestHelpers.equalsElement(externalElement, 'div', {}, initialContent + '[Double Yips!]');
        _glimmerObjectReference.setProperty(view, 'foo', 'Yippie!');
        rerender();
        _glimmerRuntimeTestsEmberComponentTest.assertAppended('<!---->');
        _glimmerTestHelpers.equalsElement(externalElement, 'div', {}, initialContent + '[Yippie!]');
        _glimmerObjectReference.setProperty(view, 'externalElement', null);
        rerender();
        _glimmerRuntimeTestsEmberComponentTest.assertAppended('<!---->');
        _glimmerTestHelpers.equalsElement(externalElement, 'div', {}, '' + initialContent);
        _glimmerObjectReference.setProperty(view, 'externalElement', externalElement);
        rerender();
        _glimmerRuntimeTestsEmberComponentTest.assertAppended('<!---->');
        _glimmerTestHelpers.equalsElement(externalElement, 'div', {}, initialContent + '[Yippie!]');
    });
    QUnit.test('updating remote element', function (assert) {
        var first = document.createElement('div');
        var second = document.createElement('div');
        appendViewFor(_glimmerTestHelpers.stripTight(_templateObject5), {
            targetElement: first,
            foo: 'Yippie!'
        });
        _glimmerTestHelpers.equalsElement(first, 'div', {}, '[Yippie!]');
        _glimmerTestHelpers.equalsElement(second, 'div', {}, '');
        _glimmerObjectReference.setProperty(view, 'foo', 'Double Yips!');
        rerender();
        _glimmerTestHelpers.equalsElement(first, 'div', {}, '[Double Yips!]');
        _glimmerTestHelpers.equalsElement(second, 'div', {}, '');
        _glimmerObjectReference.setProperty(view, 'foo', 'Yippie!');
        rerender();
        _glimmerTestHelpers.equalsElement(first, 'div', {}, '[Yippie!]');
        _glimmerTestHelpers.equalsElement(second, 'div', {}, '');
        _glimmerObjectReference.setProperty(view, 'targetElement', second);
        rerender();
        _glimmerTestHelpers.equalsElement(first, 'div', {}, '');
        _glimmerTestHelpers.equalsElement(second, 'div', {}, '[Yippie!]');
        _glimmerObjectReference.setProperty(view, 'foo', 'Double Yips!');
        rerender();
        _glimmerTestHelpers.equalsElement(first, 'div', {}, '');
        _glimmerTestHelpers.equalsElement(second, 'div', {}, '[Double Yips!]');
        _glimmerObjectReference.setProperty(view, 'foo', 'Yippie!');
        rerender();
        _glimmerTestHelpers.equalsElement(first, 'div', {}, '');
        _glimmerTestHelpers.equalsElement(second, 'div', {}, '[Yippie!]');
    });
    QUnit.test('inside an `{{if}}', function (assert) {
        var first = document.createElement('div');
        var second = document.createElement('div');
        appendViewFor(_glimmerTestHelpers.stripTight(_templateObject6), {
            first: first,
            second: second,
            showFirst: true,
            showSecond: false,
            foo: 'Yippie!'
        });
        _glimmerTestHelpers.equalsElement(first, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject2));
        _glimmerTestHelpers.equalsElement(second, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject7));
        _glimmerObjectReference.setProperty(view, 'showFirst', false);
        rerender();
        _glimmerTestHelpers.equalsElement(first, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject7));
        _glimmerTestHelpers.equalsElement(second, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject7));
        _glimmerObjectReference.setProperty(view, 'showSecond', true);
        rerender();
        _glimmerTestHelpers.equalsElement(first, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject7));
        _glimmerTestHelpers.equalsElement(second, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject2));
        _glimmerObjectReference.setProperty(view, 'foo', 'Double Yips!');
        rerender();
        _glimmerTestHelpers.equalsElement(first, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject7));
        _glimmerTestHelpers.equalsElement(second, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject3));
        _glimmerObjectReference.setProperty(view, 'showSecond', false);
        rerender();
        _glimmerTestHelpers.equalsElement(first, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject7));
        _glimmerTestHelpers.equalsElement(second, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject7));
        _glimmerObjectReference.setProperty(view, 'showFirst', true);
        rerender();
        _glimmerTestHelpers.equalsElement(first, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject3));
        _glimmerTestHelpers.equalsElement(second, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject7));
        _glimmerObjectReference.setProperty(view, 'foo', 'Yippie!');
        rerender();
        _glimmerTestHelpers.equalsElement(first, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject2));
        _glimmerTestHelpers.equalsElement(second, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject7));
    });
    QUnit.test('multiple', function (assert) {
        var firstElement = document.createElement('div');
        var secondElement = document.createElement('div');
        appendViewFor(_glimmerTestHelpers.stripTight(_templateObject8), {
            firstElement: firstElement,
            secondElement: secondElement,
            foo: 'Hello!',
            bar: 'World!'
        });
        _glimmerTestHelpers.equalsElement(firstElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject9));
        _glimmerTestHelpers.equalsElement(secondElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject10));
        _glimmerObjectReference.setProperty(view, 'foo', 'GoodBye!');
        rerender();
        _glimmerTestHelpers.equalsElement(firstElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject11));
        _glimmerTestHelpers.equalsElement(secondElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject10));
        _glimmerObjectReference.setProperty(view, 'bar', 'Folks!');
        rerender();
        _glimmerTestHelpers.equalsElement(firstElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject11));
        _glimmerTestHelpers.equalsElement(secondElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject12));
        _glimmerObjectReference.setProperty(view, 'bar', 'World!');
        rerender();
        _glimmerTestHelpers.equalsElement(firstElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject11));
        _glimmerTestHelpers.equalsElement(secondElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject10));
        _glimmerObjectReference.setProperty(view, 'foo', 'Hello!');
        rerender();
        _glimmerTestHelpers.equalsElement(firstElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject9));
        _glimmerTestHelpers.equalsElement(secondElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject10));
    });
    QUnit.test('nesting', function (assert) {
        var firstElement = document.createElement('div');
        var secondElement = document.createElement('div');
        appendViewFor(_glimmerTestHelpers.stripTight(_templateObject13), {
            firstElement: firstElement,
            secondElement: secondElement,
            foo: 'Hello!',
            bar: 'World!'
        });
        _glimmerTestHelpers.equalsElement(firstElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject14));
        _glimmerTestHelpers.equalsElement(secondElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject10));
        _glimmerObjectReference.setProperty(view, 'foo', 'GoodBye!');
        rerender();
        _glimmerTestHelpers.equalsElement(firstElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject15));
        _glimmerTestHelpers.equalsElement(secondElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject10));
        _glimmerObjectReference.setProperty(view, 'bar', 'Folks!');
        rerender();
        _glimmerTestHelpers.equalsElement(firstElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject15));
        _glimmerTestHelpers.equalsElement(secondElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject12));
        _glimmerObjectReference.setProperty(view, 'bar', 'World!');
        rerender();
        _glimmerTestHelpers.equalsElement(firstElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject15));
        _glimmerTestHelpers.equalsElement(secondElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject10));
        _glimmerObjectReference.setProperty(view, 'foo', 'Hello!');
        rerender();
        _glimmerTestHelpers.equalsElement(firstElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject14));
        _glimmerTestHelpers.equalsElement(secondElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject10));
    });
    QUnit.test('components are destroyed', function (assert) {
        var destroyed = 0;
        var DestroyMeComponent = _glimmerTestHelpers.EmberishCurlyComponent.extend({
            destroy: function () {
                this._super();
                destroyed++;
            }
        });
        env.registerEmberishCurlyComponent('destroy-me', DestroyMeComponent, 'destroy me!');
        var externalElement = document.createElement('div');
        appendViewFor(_glimmerTestHelpers.stripTight(_templateObject16), {
            externalElement: externalElement,
            showExternal: false
        });
        _glimmerTestHelpers.equalsElement(externalElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject7));
        assert.equal(destroyed, 0, 'component was destroyed');
        _glimmerObjectReference.setProperty(view, 'showExternal', true);
        rerender();
        _glimmerRuntimeTestsEmberComponentTest.assertElementIsEmberishElement(externalElement.firstElementChild, 'div', {}, 'destroy me!');
        assert.equal(destroyed, 0, 'component was destroyed');
        _glimmerObjectReference.setProperty(view, 'showExternal', false);
        rerender();
        _glimmerTestHelpers.equalsElement(externalElement, 'div', {}, _glimmerTestHelpers.stripTight(_templateObject7));
        assert.equal(destroyed, 1, 'component was destroyed');
    });
});

enifed('@glimmer/runtime/tests/in-element-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/tests');
    QUnit.test('@glimmer/runtime/tests/in-element-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/tests/in-element-test.ts should pass tslint.');
    });
});

enifed('@glimmer/runtime/tests/initial-render-test', ['exports', '@glimmer/test-helpers', '@glimmer/runtime', '@glimmer/object-reference'], function (exports, _glimmerTestHelpers, _glimmerRuntime, _glimmerObjectReference) {
    'use strict';

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    var XLINK_NAMESPACE = 'http://www.w3.org/1999/xlink';
    var XHTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
    var env = undefined,
        root = undefined;
    function compile(template) {
        return env.compile(template);
    }
    function compilesTo(html) {
        var expected = arguments.length <= 1 || arguments[1] === undefined ? html : arguments[1];
        var context = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
        return (function () {
            var template = compile(html);
            root = rootElement();
            render(template, context);
            _glimmerTestHelpers.equalTokens(root, expected);
        })();
    }
    function rootElement() {
        return env.getDOM().createElement('div');
    }
    function commonSetup() {
        var customEnv = arguments.length <= 0 || arguments[0] === undefined ? new _glimmerTestHelpers.TestEnvironment() : arguments[0];

        env = customEnv; // TODO: Support SimpleDOM
        root = rootElement();
    }
    function render(template, self) {
        var result = undefined;
        env.begin();
        result = template.render(new _glimmerObjectReference.UpdatableReference(self), root, new _glimmerTestHelpers.TestDynamicScope());
        env.commit();
        return result;
    }
    function _module(name) {
        return QUnit.module(name, {
            setup: function () {
                commonSetup();
            }
        });
    }
    _module("Initial render - Simple HTML, inline expressions");
    test("HTML text content", function () {
        var template = compile("content");
        render(template, {});
        _glimmerTestHelpers.equalTokens(root, "content");
    });
    test("HTML tags", function () {
        var template = compile("<h1>hello!</h1><div>content</div>");
        render(template, {});
        _glimmerTestHelpers.equalTokens(root, "<h1>hello!</h1><div>content</div>");
    });
    test("HTML tags re-rendered", function () {
        var template = compile("<h1>hello!</h1><div>content</div>");
        var result = render(template, {});
        var oldFirstChild = root.firstChild;
        env.begin();
        result.rerender();
        env.commit();
        strictEqual(root.firstChild, oldFirstChild);
        _glimmerTestHelpers.equalTokens(root, "<h1>hello!</h1><div>content</div>");
    });
    test("HTML attributes", function () {
        var template = compile("<div class='foo' id='bar'>content</div>");
        render(template, {});
        _glimmerTestHelpers.equalTokens(root, '<div class="foo" id="bar">content</div>');
    });
    test("HTML tag with empty attribute", function () {
        var template = compile("<div class=''>content</div>");
        render(template, {});
        _glimmerTestHelpers.equalTokens(root, "<div class=''>content</div>");
    });
    test("HTML boolean attribute 'disabled'", function () {
        var template = compile('<input disabled>');
        render(template, {});
        ok(root.firstChild['disabled'], 'disabled without value set as property is true');
    });
    test("Quoted attribute null values do not disable", function () {
        var template = compile('<input disabled="{{isDisabled}}">');
        render(template, { isDisabled: null });
        equal(root.firstChild['disabled'], false);
        _glimmerTestHelpers.equalTokens(root, '<input />');
    });
    test("Unquoted attribute expression with null value is not coerced", function () {
        var template = compile('<input disabled={{isDisabled}}>');
        render(template, { isDisabled: null });
        _glimmerTestHelpers.equalTokens(root, '<input>');
    });
    test("Unquoted attribute values", function () {
        var template = compile('<input value=funstuff>');
        render(template, {});
        var inputNode = root.firstChild;
        equal(inputNode.tagName, 'INPUT', 'input tag');
        equal(inputNode.value, 'funstuff', 'value is set as property');
    });
    test("Unquoted attribute expression with string value is not coerced", function () {
        var template = compile('<input value={{funstuff}}>');
        render(template, { funstuff: "oh my" });
        var inputNode = root.firstChild;
        equal(inputNode.tagName, 'INPUT', 'input tag');
        equal(inputNode.value, 'oh my', 'string is set to property');
    });
    test("Unquoted img src attribute is rendered", function () {
        var template = compile('<img src={{someURL}}>');
        render(template, { someURL: "http://foo.com/foo.png" });
        var imgNode = root.firstChild;
        _glimmerTestHelpers.equalTokens(root, '<img src="http://foo.com/foo.png">');
        equal(imgNode.tagName, 'IMG', 'img tag');
        equal(imgNode.src, 'http://foo.com/foo.png', 'string is set to property');
    });
    test("Unquoted img src attribute is not rendered when set to `null`", function () {
        var template = compile('<img src={{someURL}}>');
        render(template, { someURL: null });
        _glimmerTestHelpers.equalTokens(root, '<img>');
    });
    test("Unquoted img src attribute is not rendered when set to `undefined`", function () {
        var template = compile('<img src={{someURL}}>');
        render(template, { someURL: undefined });
        _glimmerTestHelpers.equalTokens(root, '<img>');
    });
    test("Quoted img src attribute is rendered", function () {
        var template = compile('<img src="{{someURL}}">');
        render(template, { someURL: "http://foo.com/foo.png" });
        var imgNode = root.firstChild;
        equal(imgNode.tagName, 'IMG', 'img tag');
        equal(imgNode.src, 'http://foo.com/foo.png', 'string is set to property');
    });
    test("Quoted img src attribute is not rendered when set to `null`", function () {
        var template = compile('<img src="{{someURL}}">');
        render(template, { someURL: null });
        _glimmerTestHelpers.equalTokens(root, '<img>');
    });
    test("Quoted img src attribute is not rendered when set to `undefined`", function () {
        var template = compile('<img src="{{someURL}}">');
        render(template, { someURL: undefined });
        _glimmerTestHelpers.equalTokens(root, '<img>');
    });
    test("Unquoted a href attribute is not rendered when set to `null`", function () {
        var template = compile('<a href={{someURL}}></a>');
        render(template, { someURL: null });
        _glimmerTestHelpers.equalTokens(root, '<a></a>');
    });
    test("Unquoted img src attribute is not rendered when set to `undefined`", function () {
        var template = compile('<a href={{someURL}}></a>');
        render(template, { someURL: undefined });
        _glimmerTestHelpers.equalTokens(root, '<a></a>');
    });
    test("Attribute expression can be followed by another attribute", function () {
        var template = compile('<div foo="{{funstuff}}" name="Alice"></div>');
        render(template, { funstuff: "oh my" });
        _glimmerTestHelpers.equalTokens(root, '<div name="Alice" foo="oh my"></div>');
    });
    test("Unquoted attribute with expression throws an exception", function () {
        expect(4);
        QUnit.throws(function () {
            compile('<img class=foo{{bar}}>');
        }, expectedError(1));
        QUnit.throws(function () {
            compile('<img class={{foo}}{{bar}}>');
        }, expectedError(1));
        QUnit.throws(function () {
            compile('<img \nclass={{foo}}bar>');
        }, expectedError(2));
        QUnit.throws(function () {
            compile('<div \nclass\n=\n{{foo}}&amp;bar ></div>');
        }, expectedError(4));
        function expectedError(line) {
            return new Error('An unquoted attribute value must be a string or a mustache, ' + 'preceeded by whitespace or a \'=\' character, and ' + ('followed by whitespace, a \'>\' character, or \'/>\' (on line ' + line + ')'));
        }
    });
    test("HTML tag with data- attribute", function () {
        var template = compile("<div data-some-data='foo'>content</div>");
        render(template, {});
        _glimmerTestHelpers.equalTokens(root, '<div data-some-data="foo">content</div>');
    });
    test("<input> tag with 'checked' attribute", function () {
        var template = compile("<input checked=\"checked\">");
        render(template, {});
        var inputNode = root.firstChild;
        equal(inputNode.tagName, 'INPUT', 'input tag');
        equal(inputNode.checked, true, 'input tag is checked');
    });
    function shouldBeVoid(tagName) {
        root.innerHTML = "";
        var html = "<" + tagName + " data-foo='bar'><p>hello</p>";
        var template = compile(html);
        render(template, {});
        var tag = '<' + tagName + ' data-foo="bar">';
        var closing = '</' + tagName + '>';
        var extra = "<p>hello</p>";
        html = _glimmerTestHelpers.normalizeInnerHTML(root.innerHTML);
        root = rootElement();
        QUnit.push(html === tag + extra || html === tag + closing + extra, html, tag + closing + extra, tagName + " should be a void element");
    }
    test("Void elements are self-closing", function () {
        var voidElements = "area base br col command embed hr img input keygen link meta param source track wbr";
        voidElements.split(" ").forEach(function (tagName) {
            return shouldBeVoid(tagName);
        });
    });
    test("The compiler can handle nesting", function () {
        var html = '<div class="foo"><p><span id="bar" data-foo="bar">hi!</span></p></div>&nbsp;More content';
        var template = compile(html);
        render(template, {});
        _glimmerTestHelpers.equalTokens(root, html);
    });
    test("The compiler can handle quotes", function () {
        compilesTo('<div>"This is a title," we\'re on a boat</div>');
    });
    test("The compiler can handle backslashes", function () {
        compilesTo('<div>This is a backslash: \\</div>');
    });
    test("The compiler can handle newlines", function () {
        compilesTo("<div>common\n\nbro</div>");
    });
    test("The compiler can handle comments", function () {
        compilesTo("<div>{{! Better not break! }}content</div>", '<div>content</div>', {});
    });
    test("The compiler can handle HTML comments", function () {
        compilesTo('<div><!-- Just passing through --></div>');
    });
    test("The compiler can handle HTML comments with mustaches in them", function () {
        compilesTo('<div><!-- {{foo}} --></div>', '<div><!-- {{foo}} --></div>', { foo: 'bar' });
    });
    test("The compiler can handle HTML comments with complex mustaches in them", function () {
        compilesTo('<div><!-- {{foo bar baz}} --></div>', '<div><!-- {{foo bar baz}} --></div>', { foo: 'bar' });
    });
    test("The compiler can handle HTML comments with multi-line mustaches in them", function () {
        compilesTo('<div><!-- {{#each foo as |bar|}}\n{{bar}}\n\n{{/each}} --></div>');
    });
    test('The compiler can handle comments with no parent element', function () {
        compilesTo('<!-- {{foo}} -->');
    });
    // TODO: Revisit partial syntax.
    // test("The compiler can handle partials in handlebars partial syntax", function() {
    //   registerPartial('partial_name', "<b>Partial Works!</b>");
    //   compilesTo('<div>{{>partial_name}} Plaintext content</div>', '<div><b>Partial Works!</b> Plaintext content</div>', {});
    // });
    test("The compiler can handle simple handlebars", function () {
        compilesTo('<div>{{title}}</div>', '<div>hello</div>', { title: 'hello' });
    });
    test("The compiler can handle escaping HTML", function () {
        compilesTo('<div>{{title}}</div>', '<div>&lt;strong&gt;hello&lt;/strong&gt;</div>', { title: '<strong>hello</strong>' });
    });
    test("The compiler can handle unescaped HTML", function () {
        compilesTo('<div>{{{title}}}</div>', '<div><strong>hello</strong></div>', { title: '<strong>hello</strong>' });
    });
    test("The compiler can handle top-level unescaped HTML", function () {
        compilesTo('{{{html}}}', '<strong>hello</strong>', { html: '<strong>hello</strong>' });
    });
    function createElement(tag) {
        return env.getDOM().createElement(tag);
    }
    test("The compiler can handle top-level unescaped tr", function () {
        var template = compile('{{{html}}}');
        var context = { html: '<tr><td>Yo</td></tr>' };
        root = createElement('table');
        render(template, context);
        equal(root.firstChild['tagName'], 'TBODY', "root tbody is present");
    });
    test("The compiler can handle top-level unescaped td inside tr contextualElement", function () {
        var template = compile('{{{html}}}');
        var context = { html: '<td>Yo</td>' };
        root = createElement('tr');
        render(template, context);
        equal(root.firstChild['tagName'], 'TD', "root td is returned");
    });
    test("second render respects whitespace", function () {
        var template = compile('Hello {{ foo }} ');
        render(template, {});
        root = rootElement();
        render(template, {});
        equal(root.childNodes.length, 3, 'fragment contains 3 text nodes');
        equal(_glimmerTestHelpers.getTextContent(root.childNodes[0]), 'Hello ', 'first text node ends with one space character');
        equal(_glimmerTestHelpers.getTextContent(root.childNodes[2]), ' ', 'last text node contains one space character');
    });
    test("Morphs are escaped correctly", function () {
        env.registerHelper('testing-unescaped', function (params) {
            return params[0];
        });
        env.registerHelper('testing-escaped', function (params, hash) {
            return params[0];
        });
        compilesTo('<div>{{{testing-unescaped "<span>hi</span>"}}}</div>', '<div><span>hi</span></div>');
        compilesTo('<div>{{testing-escaped "<hi>"}}</div>', '<div>&lt;hi&gt;</div>');
    });
    test("Attributes can use computed values", function () {
        compilesTo('<a href="{{url}}">linky</a>', '<a href="linky.html">linky</a>', { url: 'linky.html' });
    });
    test("Mountain range of nesting", function () {
        var context = { foo: "FOO", bar: "BAR", baz: "BAZ", boo: "BOO", brew: "BREW", bat: "BAT", flute: "FLUTE", argh: "ARGH" };
        compilesTo('{{foo}}<span></span>', 'FOO<span></span>', context);
        compilesTo('<span></span>{{foo}}', '<span></span>FOO', context);
        compilesTo('<span>{{foo}}</span>{{foo}}', '<span>FOO</span>FOO', context);
        compilesTo('{{foo}}<span>{{foo}}</span>{{foo}}', 'FOO<span>FOO</span>FOO', context);
        compilesTo('{{foo}}<span></span>{{foo}}', 'FOO<span></span>FOO', context);
        compilesTo('{{foo}}<span></span>{{bar}}<span><span><span>{{baz}}</span></span></span>', 'FOO<span></span>BAR<span><span><span>BAZ</span></span></span>', context);
        compilesTo('{{foo}}<span></span>{{bar}}<span>{{argh}}<span><span>{{baz}}</span></span></span>', 'FOO<span></span>BAR<span>ARGH<span><span>BAZ</span></span></span>', context);
        compilesTo('{{foo}}<span>{{bar}}<a>{{baz}}<em>{{boo}}{{brew}}</em>{{bat}}</a></span><span><span>{{flute}}</span></span>{{argh}}', 'FOO<span>BAR<a>BAZ<em>BOOBREW</em>BAT</a></span><span><span>FLUTE</span></span>ARGH', context);
    });
    test("Static <div class> is preserved properly", function () {
        compilesTo('\n    <div class="hello world">1</div>\n    <div class="goodbye world">2</div>\n  ', '\n    <div class="hello world">1</div>\n    <div class="goodbye world">2</div>\n  ');
    });
    test("Static <option selected> is preserved properly", function () {
        var template = compile('\n    <select>\n      <option>1</option>\n      <option selected>2</option>\n      <option>3</option>\n    </select>\n  ');
        render(template, {});
        var selectNode = root.childNodes[1];
        equal(selectNode.selectedIndex, 1, 'second item is selected');
    });
    test("Static <option selected> for multi-select is preserved properly", function () {
        var template = compile('\n    <select multiple>\n      <option selected>1</option>\n      <option selected>2</option>\n      <option>3</option>\n    </select>\n  ');
        render(template, {});
        var selectNode = root.childNodes[1];
        var options = selectNode.querySelectorAll('option[selected]');
        equal(options.length, 2, 'two options are selected');
    });
    test("Dynamic <option selected> is preserved properly", function () {
        var template = compile('\n    <select>\n      <option>1</option>\n      <option selected={{selected}}>2</option>\n      <option>3</option>\n    </select>\n  ');
        render(template, { selected: true });
        var selectNode = root.childNodes[1];
        equal(selectNode.selectedIndex, 1, 'second item is selected');
    });
    test("Dynamic <option selected> for multi-select is preserved properly", function () {
        var template = compile('\n    <select multiple>\n      <option>0</option>\n      <option selected={{somethingTrue}}>1</option>\n      <option selected={{somethingTruthy}}>2</option>\n      <option selected={{somethingUndefined}}>3</option>\n      <option selected={{somethingNull}}>4</option>\n      <option selected={{somethingFalse}}>5</option>\n    </select>\n  ');
        render(template, {
            somethingTrue: true,
            somethingTruthy: 'is-true',
            somethingUndefined: undefined,
            somethingNull: null,
            somethingFalse: false
        });
        var selectNode = root.childNodes[1];
        var options = Array.prototype.slice.call(selectNode.querySelectorAll('option'));
        var selected = options.filter(function (option) {
            return option.selected;
        });
        equal(selected.length, 2, 'two options are selected');
        equal(selected[0].value, '1', 'first selected item is "1"');
        equal(selected[1].value, '2', 'second selected item is "2"');
    });
    _module("Initial render - simple blocks");
    test("The compiler can handle unescaped tr in top of content", function () {
        var template = compile('{{#identity}}{{{html}}}{{/identity}}');
        var context = { html: '<tr><td>Yo</td></tr>' };
        root = createElement('table');
        render(template, context);
        equal(root.firstChild['tagName'], 'TBODY', "root tbody is present");
    });
    test("The compiler can handle unescaped tr inside fragment table", function () {
        var template = compile('<table>{{#identity}}{{{html}}}{{/identity}}</table>');
        var context = { html: '<tr><td>Yo</td></tr>' };
        render(template, context);
        var tableNode = root.firstChild;
        equal(tableNode.firstChild['tagName'], 'TBODY', "root tbody is present");
    });
    _module("Initial render - inline helpers");
    test("The compiler can handle simple helpers", function () {
        env.registerHelper('testing', function (params) {
            return params[0];
        });
        compilesTo('<div>{{testing title}}</div>', '<div>hello</div>', { title: 'hello' });
    });
    test("GH#13999 The compiler can handle simple helpers with inline null parameter", function () {
        var value = undefined;
        env.registerHelper('say-hello', function (params) {
            value = params[0];
            return 'hello';
        });
        compilesTo('<div>{{say-hello null}}</div>', '<div>hello</div>');
        strictEqual(value, null, 'is null');
    });
    test("GH#13999 The compiler can handle simple helpers with inline string literal null parameter", function () {
        var value = undefined;
        env.registerHelper('say-hello', function (params) {
            value = params[0];
            return 'hello';
        });
        compilesTo('<div>{{say-hello "null"}}</div>', '<div>hello</div>');
        strictEqual(value, 'null', 'is null string literal');
    });
    test("GH#13999 The compiler can handle simple helpers with inline undefined parameter", function () {
        var value = 'PLACEHOLDER';
        var length = undefined;
        env.registerHelper('say-hello', function (params) {
            length = params.length;
            value = params[0];
            return 'hello';
        });
        compilesTo('<div>{{say-hello undefined}}</div>', '<div>hello</div>');
        strictEqual(length, 1);
        strictEqual(value, undefined, 'is undefined');
    });
    test("GH#13999 The compiler can handle simple helpers with positional parameter undefined string literal", function () {
        var value = 'PLACEHOLDER';
        var length = undefined;
        env.registerHelper('say-hello', function (params) {
            length = params.length;
            value = params[0];
            return 'hello';
        });
        compilesTo('<div>{{say-hello "undefined"}} undefined</div>', '<div>hello undefined</div>');
        strictEqual(length, 1);
        strictEqual(value, 'undefined', 'is undefined string literal');
    });
    test("GH#13999 The compiler can handle components with undefined named arguments", function () {
        var value = 'PLACEHOLDER';
        env.registerHelper('say-hello', function (_, hash) {
            value = hash['foo'];
            return 'hello';
        });
        compilesTo('<div>{{say-hello foo=undefined}}</div>', '<div>hello</div>');
        strictEqual(value, undefined, 'is undefined');
    });
    test("GH#13999 The compiler can handle components with undefined string literal named arguments", function () {
        var value = 'PLACEHOLDER';
        env.registerHelper('say-hello', function (_, hash) {
            value = hash['foo'];
            return 'hello';
        });
        compilesTo('<div>{{say-hello foo="undefined"}}</div>', '<div>hello</div>');
        strictEqual(value, 'undefined', 'is undefined string literal');
    });
    test("GH#13999 The compiler can handle components with null named arguments", function () {
        var value = undefined;
        env.registerHelper('say-hello', function (_, hash) {
            value = hash['foo'];
            return 'hello';
        });
        compilesTo('<div>{{say-hello foo=null}}</div>', '<div>hello</div>');
        strictEqual(value, null, 'is null');
    });
    test("GH#13999 The compiler can handle components with null string literal named arguments", function () {
        var value = undefined;
        env.registerHelper('say-hello', function (_, hash) {
            value = hash['foo'];
            return 'hello';
        });
        compilesTo('<div>{{say-hello foo="null"}}</div>', '<div>hello</div>');
        strictEqual(value, 'null', 'is null string literal');
    });
    test("GH#13999 The compiler can handle components with undefined named arguments", function () {
        env.registerHelper('say-hello', function () {
            return 'hello';
        });
        compilesTo('<div>{{say-hello foo=undefined}}</div>', '<div>hello</div>');
    });
    test("Null curly in attributes", function () {
        compilesTo('<div class="foo {{null}}">hello</div>', '<div class="foo ">hello</div>');
    });
    test("Null in primitive syntax", function () {
        compilesTo('{{#if null}}NOPE{{else}}YUP{{/if}}', 'YUP');
    });
    test("The compiler can handle sexpr helpers", function () {
        env.registerHelper('testing', function (params) {
            return params[0] + "!";
        });
        compilesTo('<div>{{testing (testing "hello")}}</div>', '<div>hello!!</div>', {});
    });
    test("The compiler can handle multiple invocations of sexprs", function () {
        env.registerHelper('testing', function (params) {
            return "" + params[0] + params[1];
        });
        compilesTo('<div>{{testing (testing "hello" foo) (testing (testing bar "lol") baz)}}</div>', '<div>helloFOOBARlolBAZ</div>', { foo: "FOO", bar: "BAR", baz: "BAZ" });
    });
    test("The compiler passes along the hash arguments", function () {
        env.registerHelper('testing', function (params, hash) {
            return hash['first'] + '-' + hash['second'];
        });
        compilesTo('<div>{{testing first="one" second="two"}}</div>', '<div>one-two</div>');
    });
    // test("Attributes can use computed paths", function() {
    //   compilesTo('<a href="{{post.url}}">linky</a>', '<a href="linky.html">linky</a>', { post: { url: 'linky.html' }});
    // });
    /*
    
    test("It is possible to use RESOLVE_IN_ATTR for data binding", function() {
      let callback;
    
      registerHelper('RESOLVE_IN_ATTR', function(parts, options) {
        return boundValue(function(c) {
          callback = c;
          return this[parts[0]];
        }, this);
      });
    
      let object = { url: 'linky.html' };
      let fragment = compilesTo('<a href="{{url}}">linky</a>', '<a href="linky.html">linky</a>', object);
    
      object.url = 'clippy.html';
      callback();
    
      equalTokens(fragment, '<a href="clippy.html">linky</a>');
    
      object.url = 'zippy.html';
      callback();
    
      equalTokens(fragment, '<a href="zippy.html">linky</a>');
    });
    */
    test("Attributes can be populated with helpers that generate a string", function () {
        env.registerHelper('testing', function (params) {
            return params[0];
        });
        compilesTo('<a href="{{testing url}}">linky</a>', '<a href="linky.html">linky</a>', { url: 'linky.html' });
    });
    /*
    test("A helper can return a stream for the attribute", function() {
      env.registerHelper('testing', function(path, options) {
        return streamValue(this[path]);
      });
    
      compilesTo('<a href="{{testing url}}">linky</a>', '<a href="linky.html">linky</a>', { url: 'linky.html'});
    });
    */
    test("Attribute helpers take a hash", function () {
        env.registerHelper('testing', function (params, hash) {
            return hash['path'];
        });
        compilesTo('<a href="{{testing path=url}}">linky</a>', '<a href="linky.html">linky</a>', { url: 'linky.html' });
    });
    /*
    test("Attribute helpers can use the hash for data binding", function() {
      let callback;
    
      env.registerHelper('testing', function(path, hash, options) {
        return boundValue(function(c) {
          callback = c;
          return this[path] ? hash.truthy : hash.falsy;
        }, this);
      });
    
      let object = { on: true };
      let fragment = compilesTo('<div class="{{testing on truthy="yeah" falsy="nope"}}">hi</div>', '<div class="yeah">hi</div>', object);
    
      object.on = false;
      callback();
      equalTokens(fragment, '<div class="nope">hi</div>');
    });
    */
    test("Attributes containing multiple helpers are treated like a block", function () {
        env.registerHelper('testing', function (params) {
            return params[0];
        });
        compilesTo('<a href="http://{{foo}}/{{testing bar}}/{{testing "baz"}}">linky</a>', '<a href="http://foo.com/bar/baz">linky</a>', { foo: 'foo.com', bar: 'bar' });
    });
    test("Attributes containing a helper are treated like a block", function () {
        expect(2);
        env.registerHelper('testing', function (params) {
            deepEqual(params, [123]);
            return "example.com";
        });
        compilesTo('<a href="http://{{testing 123}}/index.html">linky</a>', '<a href="http://example.com/index.html">linky</a>', { person: { url: 'example.com' } });
    });
    /*
    test("It is possible to trigger a re-render of an attribute from a child resolution", function() {
      let callback;
    
      env.registerHelper('RESOLVE_IN_ATTR', function(path, options) {
        return boundValue(function(c) {
          callback = c;
          return this[path];
        }, this);
      });
    
      let context = { url: "example.com" };
      let fragment = compilesTo('<a href="http://{{url}}/index.html">linky</a>', '<a href="http://example.com/index.html">linky</a>', context);
    
      context.url = "www.example.com";
      callback();
    
      equalTokens(fragment, '<a href="http://www.example.com/index.html">linky</a>');
    });
    
    test("A child resolution can pass contextual information to the parent", function() {
      let callback;
    
      registerHelper('RESOLVE_IN_ATTR', function(path, options) {
        return boundValue(function(c) {
          callback = c;
          return this[path];
        }, this);
      });
    
      let context = { url: "example.com" };
      let fragment = compilesTo('<a href="http://{{url}}/index.html">linky</a>', '<a href="http://example.com/index.html">linky</a>', context);
    
      context.url = "www.example.com";
      callback();
    
      equalTokens(fragment, '<a href="http://www.example.com/index.html">linky</a>');
    });
    
    test("Attribute runs can contain helpers", function() {
      let callbacks = [];
    
      registerHelper('RESOLVE_IN_ATTR', function(path, options) {
        return boundValue(function(c) {
          callbacks.push(c);
          return this[path];
        }, this);
      });
    
      registerHelper('testing', function(path, options) {
        return boundValue(function(c) {
          callbacks.push(c);
    
          if (options.paramTypes[0] === 'id') {
            return this[path] + '.html';
          } else {
            return path;
          }
        }, this);
      });
    
      let context = { url: "example.com", path: 'index' };
      let fragment = compilesTo(
        '<a href="http://{{url}}/{{testing path}}/{{testing "linky"}}">linky</a>',
        '<a href="http://example.com/index.html/linky">linky</a>',
        context
      );
    
      context.url = "www.example.com";
      context.path = "yep";
      forEach(callbacks, function(callback) { callback(); });
    
      equalTokens(fragment, '<a href="http://www.example.com/yep.html/linky">linky</a>');
    
      context.url = "nope.example.com";
      context.path = "nope";
      forEach(callbacks, function(callback) { callback(); });
    
      equalTokens(fragment, '<a href="http://nope.example.com/nope.html/linky">linky</a>');
    });
    */
    test("Elements inside a yielded block", function () {
        compilesTo('{{#identity}}<div id="test">123</div>{{/identity}}', '<div id="test">123</div>');
    });
    test("A simple block helper can return text", function () {
        compilesTo('{{#identity}}test{{else}}not shown{{/identity}}', 'test');
    });
    test("A block helper can have an else block", function () {
        compilesTo('{{#render-inverse}}Nope{{else}}<div id="test">123</div>{{/render-inverse}}', '<div id="test">123</div>');
    });
    _module("Initial render - miscellaneous");
    test('Components - Unknown helpers fall back to elements', function () {
        var object = { size: 'med', foo: 'b' };
        compilesTo('<x-bar class="btn-{{size}}">a{{foo}}c</x-bar>', '<x-bar class="btn-med">abc</x-bar>', object);
    });
    test('Components - Text-only attributes work', function () {
        var object = { foo: 'qux' };
        compilesTo('<x-bar id="test">{{foo}}</x-bar>', '<x-bar id="test">qux</x-bar>', object);
    });
    test('Components - Empty components work', function () {
        compilesTo('<x-bar></x-bar>', '<x-bar></x-bar>', {});
    });
    test('Components - Text-only dashed attributes work', function () {
        var object = { foo: 'qux' };
        compilesTo('<x-bar aria-label="foo" id="test">{{foo}}</x-bar>', '<x-bar aria-label="foo" id="test">qux</x-bar>', object);
    });
    test('Repaired text nodes are ensured in the right place', function () {
        var object = { a: "A", b: "B", c: "C", d: "D" };
        compilesTo('{{a}} {{b}}', 'A B', object);
        compilesTo('<div>{{a}}{{b}}{{c}}wat{{d}}</div>', '<div>ABCwatD</div>', object);
        compilesTo('{{a}}{{b}}<img><img><img><img>', 'AB<img><img><img><img>', object);
    });
    test("Simple elements can have dashed attributes", function () {
        var template = compile("<div aria-label='foo'>content</div>");
        render(template, {});
        _glimmerTestHelpers.equalTokens(root, '<div aria-label="foo">content</div>');
    });
    test('Block params in HTML syntax - Throws exception if given zero parameters', function () {
        expect(2);
        QUnit.throws(function () {
            compile('<x-bar as ||>foo</x-bar>');
        }, /Cannot use zero block parameters: 'as \|\|'/);
        QUnit.throws(function () {
            compile('<x-bar as | |>foo</x-bar>');
        }, /Cannot use zero block parameters: 'as \| \|'/);
    });
    test("Block params in HTML syntax - Throws an error on invalid block params syntax", function () {
        expect(3);
        QUnit.throws(function () {
            compile('<x-bar as |x y>{{x}},{{y}}</x-bar>');
        }, /Invalid block parameters syntax: 'as |x y'/);
        QUnit.throws(function () {
            compile('<x-bar as |x| y>{{x}},{{y}}</x-bar>');
        }, /Invalid block parameters syntax: 'as \|x\| y'/);
        QUnit.throws(function () {
            compile('<x-bar as |x| y|>{{x}},{{y}}</x-bar>');
        }, /Invalid block parameters syntax: 'as \|x\| y\|'/);
    });
    test("Block params in HTML syntax - Throws an error on invalid identifiers for params", function () {
        expect(3);
        QUnit.throws(function () {
            compile('<x-bar as |x foo.bar|></x-bar>');
        }, /Invalid identifier for block parameters: 'foo\.bar' in 'as \|x foo\.bar|'/);
        QUnit.throws(function () {
            compile('<x-bar as |x "foo"|></x-bar>');
        }, /Syntax error at line 1 col 17: " is not a valid character within attribute names/);
        QUnit.throws(function () {
            compile('<x-bar as |foo[bar]|></x-bar>');
        }, /Invalid identifier for block parameters: 'foo\[bar\]' in 'as \|foo\[bar\]\|'/);
    });
    _module("Initial render (invalid HTML)");
    test("A helpful error message is provided for unclosed elements", function () {
        expect(2);
        QUnit.throws(function () {
            compile('\n<div class="my-div" \n foo={{bar}}>\n<span>\n</span>\n');
        }, /Unclosed element `div` \(on line 2\)\./);
        QUnit.throws(function () {
            compile('\n<div class="my-div">\n<span>\n');
        }, /Unclosed element `span` \(on line 3\)\./);
    });
    test("A helpful error message is provided for unmatched end tags", function () {
        expect(2);
        QUnit.throws(function () {
            compile("</p>");
        }, /Closing tag `p` \(on line 1\) without an open tag\./);
        QUnit.throws(function () {
            compile("<em>{{ foo }}</em> \n {{ bar }}\n</div>");
        }, /Closing tag `div` \(on line 3\) without an open tag\./);
    });
    test("A helpful error message is provided for end tags for void elements", function () {
        expect(3);
        QUnit.throws(function () {
            compile("<input></input>");
        }, /Invalid end tag `input` \(on line 1\) \(void elements cannot have end tags\)./);
        QUnit.throws(function () {
            compile("<div>\n  <input></input>\n</div>");
        }, /Invalid end tag `input` \(on line 2\) \(void elements cannot have end tags\)./);
        QUnit.throws(function () {
            compile("\n\n</br>");
        }, /Invalid end tag `br` \(on line 3\) \(void elements cannot have end tags\)./);
    });
    test("A helpful error message is provided for end tags with attributes", function () {
        QUnit.throws(function () {
            compile('<div>\nSomething\n\n</div foo="bar">');
        }, /Invalid end tag: closing tag must not have attributes, in `div` \(on line 4\)\./);
    });
    test("A helpful error message is provided for mismatched start/end tags", function () {
        QUnit.throws(function () {
            compile("<div>\n<p>\nSomething\n\n</div>");
        }, /Closing tag `div` \(on line 5\) did not match last open tag `p` \(on line 2\)\./);
    });
    test("error line numbers include comment lines", function () {
        QUnit.throws(function () {
            compile("<div>\n<p>\n{{! some comment}}\n\n</div>");
        }, /Closing tag `div` \(on line 5\) did not match last open tag `p` \(on line 2\)\./);
    });
    test("error line numbers include mustache only lines", function () {
        QUnit.throws(function () {
            compile("<div>\n<p>\n{{someProp}}\n\n</div>");
        }, /Closing tag `div` \(on line 5\) did not match last open tag `p` \(on line 2\)\./);
    });
    test("error line numbers include block lines", function () {
        QUnit.throws(function () {
            compile("<div>\n<p>\n{{#some-comment}}\n{{/some-comment}}\n</div>");
        }, /Closing tag `div` \(on line 5\) did not match last open tag `p` \(on line 2\)\./);
    });
    test("error line numbers include whitespace control mustaches", function () {
        QUnit.throws(function () {
            compile("<div>\n<p>\n{{someProp~}}\n\n</div>{{some-comment}}");
        }, /Closing tag `div` \(on line 5\) did not match last open tag `p` \(on line 2\)\./);
    });
    test("error line numbers include multiple mustache lines", function () {
        QUnit.throws(function () {
            compile("<div>\n<p>\n{{some-comment}}</div>{{some-comment}}");
        }, /Closing tag `div` \(on line 3\) did not match last open tag `p` \(on line 2\)\./);
    });
    _module("Initial render of namespaced HTML");
    test("Namespaced attribute", function () {
        compilesTo("<svg xlink:title='svg-title'>content</svg>");
        var svg = root.firstChild;
        equal(svg.namespaceURI, SVG_NAMESPACE);
        equal(svg.attributes[0].namespaceURI, XLINK_NAMESPACE);
    });
    test("<svg> tag with case-sensitive attribute", function () {
        var viewBox = '0 0 0 0';
        compilesTo('<svg viewBox="' + viewBox + '"></svg>');
        var svg = root.firstChild;
        equal(svg.namespaceURI, SVG_NAMESPACE);
        equal(svg.getAttribute('viewBox'), viewBox);
    });
    test("nested element in the SVG namespace", function () {
        var d = 'M 0 0 L 100 100';
        compilesTo('<svg><path d="' + d + '"></path></svg>');
        var svg = root.firstChild;
        var path = svg.firstChild;
        equal(svg.namespaceURI, SVG_NAMESPACE);
        equal(path.namespaceURI, SVG_NAMESPACE, "creates the path element with a namespace");
        equal(path.getAttribute('d'), d);
    });
    test("<foreignObject> tag has an SVG namespace", function () {
        compilesTo('<svg><foreignObject>Hi</foreignObject></svg>');
        var svg = root.firstChild;
        var foreignObject = svg.firstChild;
        equal(svg.namespaceURI, SVG_NAMESPACE);
        equal(foreignObject.namespaceURI, SVG_NAMESPACE, "creates the foreignObject element with a namespace");
    });
    test("Namespaced and non-namespaced elements as siblings", function () {
        compilesTo('<svg></svg><svg></svg><div></div>');
        equal(root.childNodes[0].namespaceURI, SVG_NAMESPACE, "creates the first svg element with a namespace");
        equal(root.childNodes[1].namespaceURI, SVG_NAMESPACE, "creates the second svg element with a namespace");
        equal(root.childNodes[2].namespaceURI, XHTML_NAMESPACE, "creates the div element without a namespace");
    });
    test("Namespaced and non-namespaced elements with nesting", function () {
        compilesTo('<div><svg></svg></div><div></div>');
        var firstDiv = root.firstChild;
        var secondDiv = root.lastChild;
        var svg = firstDiv.firstChild;
        equal(firstDiv.namespaceURI, XHTML_NAMESPACE, "first div's namespace is xhtmlNamespace");
        equal(svg.namespaceURI, SVG_NAMESPACE, "svg's namespace is svgNamespace");
        equal(secondDiv.namespaceURI, XHTML_NAMESPACE, "last div's namespace is xhtmlNamespace");
    });
    test("Case-sensitive tag has capitalization preserved", function () {
        compilesTo('<svg><linearGradient id="gradient"></linearGradient></svg>');
    });
    var warnings = 0;

    var StyleAttribute = (function (_AttributeManager) {
        _inherits(StyleAttribute, _AttributeManager);

        function StyleAttribute() {
            _classCallCheck(this, StyleAttribute);

            _AttributeManager.apply(this, arguments);
        }

        StyleAttribute.prototype.setAttribute = function setAttribute(dom, element, value) {
            warnings++;
            _AttributeManager.prototype.setAttribute.call(this, dom, element, value);
        };

        StyleAttribute.prototype.updateAttribute = function updateAttribute() {};

        return StyleAttribute;
    })(_glimmerRuntime.AttributeManager);

    var STYLE_ATTRIBUTE = new StyleAttribute('style');
    QUnit.module('Style attributes', {
        setup: function () {
            var StyleEnv = (function (_TestEnvironment) {
                _inherits(StyleEnv, _TestEnvironment);

                function StyleEnv() {
                    _classCallCheck(this, StyleEnv);

                    _TestEnvironment.apply(this, arguments);
                }

                StyleEnv.prototype.attributeFor = function attributeFor(element, attr, isTrusting, namespace) {
                    if (attr === 'style' && !isTrusting) {
                        return STYLE_ATTRIBUTE;
                    }
                    return _TestEnvironment.prototype.attributeFor.call(this, element, attr, isTrusting);
                };

                return StyleEnv;
            })(_glimmerTestHelpers.TestEnvironment);

            commonSetup(new StyleEnv());
        },
        teardown: function () {
            warnings = 0;
        }
    });
    test('using a static inline style on an element does not give you a warning', function (assert) {
        var template = compile('<div style="background: red">Thing</div>');
        render(template, {});
        assert.strictEqual(warnings, 0);
        _glimmerTestHelpers.equalTokens(root, '<div style="background: red">Thing</div>', "initial render");
    });
    test('triple curlies are trusted', function (assert) {
        var template = compile('<div foo={{foo}} style={{{styles}}}>Thing</div>');
        render(template, { styles: 'background: red' });
        assert.strictEqual(warnings, 0);
        _glimmerTestHelpers.equalTokens(root, '<div style="background: red">Thing</div>', "initial render");
    });
    test('using a static inline style on an namespaced element does not give you a warning', function (assert) {
        var template = compile('<svg xmlns:svg="http://www.w3.org/2000/svg" style="background: red" />');
        render(template, {});
        assert.strictEqual(warnings, 0);
        _glimmerTestHelpers.equalTokens(root, '<svg xmlns:svg="http://www.w3.org/2000/svg" style="background: red"></svg>', "initial render");
    });
});

enifed('@glimmer/runtime/tests/initial-render-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/tests');
    QUnit.test('@glimmer/runtime/tests/initial-render-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/tests/initial-render-test.ts should pass tslint.');
    });
});

enifed("@glimmer/runtime/tests/partial-test", ["exports", "@glimmer/test-helpers", "@glimmer/object-reference"], function (exports, _glimmerTestHelpers, _glimmerObjectReference) {
    "use strict";

    var _templateObject = _taggedTemplateLiteralLoose(["\n    <foo-bar>a block</foo-bar>\n    <foo-bar />\n    <foo-bar-baz>a block</foo-bar-baz>\n    <foo-bar-baz />\n  "], ["\n    <foo-bar>a block</foo-bar>\n    <foo-bar />\n    <foo-bar-baz>a block</foo-bar-baz>\n    <foo-bar-baz />\n  "]),
        _templateObject2 = _taggedTemplateLiteralLoose(["\n    <p>true-false</p>\n    <p>true-false</p>\n    <p>true-false-true-false</p>\n    <p>true-false-true-false</p>\n  "], ["\n    <p>true-false</p>\n    <p>true-false</p>\n    <p>true-false-true-false</p>\n    <p>true-false-true-false</p>\n  "]),
        _templateObject3 = _taggedTemplateLiteralLoose(["\n    {{#foo-bar}}a block{{/foo-bar}}\n    {{#foo-bar}}a block{{else}}inverse{{/foo-bar}}\n    {{foo-bar}}\n    {{#foo-bar-baz}}a block{{/foo-bar-baz}}\n    {{#foo-bar-baz}}a block{{else}}inverse{{/foo-bar-baz}}\n    {{foo-bar-baz}}\n  "], ["\n    {{#foo-bar}}a block{{/foo-bar}}\n    {{#foo-bar}}a block{{else}}inverse{{/foo-bar}}\n    {{foo-bar}}\n    {{#foo-bar-baz}}a block{{/foo-bar-baz}}\n    {{#foo-bar-baz}}a block{{else}}inverse{{/foo-bar-baz}}\n    {{foo-bar-baz}}\n  "]),
        _templateObject4 = _taggedTemplateLiteralLoose(["\n    <p>true-false</p>\n    <p>true-true</p>\n    <p>false-false</p>\n    <p>true-false-true-false</p>\n    <p>true-true-true-true</p>\n    <p>false-false-false-false</p>\n  "], ["\n    <p>true-false</p>\n    <p>true-true</p>\n    <p>false-false</p>\n    <p>true-false-true-false</p>\n    <p>true-true-true-true</p>\n    <p>false-false-false-false</p>\n  "]),
        _templateObject5 = _taggedTemplateLiteralLoose(["\n    <foo-bar as |x|>a block</foo-bar>\n    <foo-bar>a block</foo-bar>\n    <foo-bar />\n    <foo-bar-baz as |x|>a block</foo-bar-baz>\n    <foo-bar-baz>a block</foo-bar-baz>\n    <foo-bar-baz />\n  "], ["\n    <foo-bar as |x|>a block</foo-bar>\n    <foo-bar>a block</foo-bar>\n    <foo-bar />\n    <foo-bar-baz as |x|>a block</foo-bar-baz>\n    <foo-bar-baz>a block</foo-bar-baz>\n    <foo-bar-baz />\n  "]),
        _templateObject6 = _taggedTemplateLiteralLoose(["\n    <p>true-false</p>\n    <p>false-false</p>\n    <p>false-false</p>\n    <p>true-false-true-false</p>\n    <p>false-false-false-false</p>\n    <p>false-false-false-false</p>\n  "], ["\n    <p>true-false</p>\n    <p>false-false</p>\n    <p>false-false</p>\n    <p>true-false-true-false</p>\n    <p>false-false-false-false</p>\n    <p>false-false-false-false</p>\n  "]),
        _templateObject7 = _taggedTemplateLiteralLoose(["\n    {{#foo-bar as |x|}}a block{{/foo-bar}}\n    {{#foo-bar}}a block{{else}}inverse{{/foo-bar}}\n    {{#foo-bar}}a block{{/foo-bar}}\n    {{foo-bar}}\n    {{#foo-bar-baz as |x|}}a block{{/foo-bar-baz}}\n    {{#foo-bar-baz}}a block{{else}}inverse{{/foo-bar-baz}}\n    {{#foo-bar-baz}}a block{{/foo-bar-baz}}\n    {{foo-bar-baz}}\n  "], ["\n    {{#foo-bar as |x|}}a block{{/foo-bar}}\n    {{#foo-bar}}a block{{else}}inverse{{/foo-bar}}\n    {{#foo-bar}}a block{{/foo-bar}}\n    {{foo-bar}}\n    {{#foo-bar-baz as |x|}}a block{{/foo-bar-baz}}\n    {{#foo-bar-baz}}a block{{else}}inverse{{/foo-bar-baz}}\n    {{#foo-bar-baz}}a block{{/foo-bar-baz}}\n    {{foo-bar-baz}}\n  "]),
        _templateObject8 = _taggedTemplateLiteralLoose(["\n    <p>true-false</p>\n    <p>false-false</p>\n    <p>false-false</p>\n    <p>false-false</p>\n    <p>true-false-true-false</p>\n    <p>false-false-false-false</p>\n    <p>false-false-false-false</p>\n    <p>false-false-false-false</p>\n  "], ["\n    <p>true-false</p>\n    <p>false-false</p>\n    <p>false-false</p>\n    <p>false-false</p>\n    <p>true-false-true-false</p>\n    <p>false-false-false-false</p>\n    <p>false-false-false-false</p>\n    <p>false-false-false-false</p>\n  "]),
        _templateObject9 = _taggedTemplateLiteralLoose(["\n    <foo-bar as |source|>from {{source}}</foo-bar>\n    <foo-bar />\n    <foo-bar-baz as |source|>from {{source}}</foo-bar-baz>\n    <foo-bar-baz />\n  "], ["\n    <foo-bar as |source|>from {{source}}</foo-bar>\n    <foo-bar />\n    <foo-bar-baz as |source|>from {{source}}</foo-bar-baz>\n    <foo-bar-baz />\n  "]),
        _templateObject10 = _taggedTemplateLiteralLoose(["\n    <p>from partial-</p>\n    <p>-</p>\n    <p>from partial--from layout-</p>\n    <p>---</p>\n  "], ["\n    <p>from partial-</p>\n    <p>-</p>\n    <p>from partial--from layout-</p>\n    <p>---</p>\n  "]),
        _templateObject11 = _taggedTemplateLiteralLoose(["\n    {{#foo-bar as |source|}}from {{source}}{{/foo-bar}}\n    {{#foo-bar as |source|}}from {{source}}{{else}}inverse{{/foo-bar}}\n    {{foo-bar}}\n    {{#foo-bar-baz as |source|}}from {{source}}{{/foo-bar-baz}}\n    {{#foo-bar-baz as |source|}}from {{source}}{{else}}inverse{{/foo-bar-baz}}\n    {{foo-bar-baz}}\n  "], ["\n    {{#foo-bar as |source|}}from {{source}}{{/foo-bar}}\n    {{#foo-bar as |source|}}from {{source}}{{else}}inverse{{/foo-bar}}\n    {{foo-bar}}\n    {{#foo-bar-baz as |source|}}from {{source}}{{/foo-bar-baz}}\n    {{#foo-bar-baz as |source|}}from {{source}}{{else}}inverse{{/foo-bar-baz}}\n    {{foo-bar-baz}}\n  "]),
        _templateObject12 = _taggedTemplateLiteralLoose(["\n    <p>from partial-</p>\n    <p>from partial-inverse</p>\n    <p>-</p>\n    <p>from partial--from layout-</p>\n    <p>from partial-inverse-from layout-inverse</p>\n    <p>---</p>\n  "], ["\n    <p>from partial-</p>\n    <p>from partial-inverse</p>\n    <p>-</p>\n    <p>from partial--from layout-</p>\n    <p>from partial-inverse-from layout-inverse</p>\n    <p>---</p>\n  "]),
        _templateObject13 = _taggedTemplateLiteralLoose(["Partial found with no arguments. You must specify a template name."], ["Partial found with no arguments. You must specify a template name."]),
        _templateObject14 = _taggedTemplateLiteralLoose(["Partial found with more than one argument. You can only specify a single template."], ["Partial found with more than one argument. You can only specify a single template."]);

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _taggedTemplateLiteralLoose(strings, raw) { strings.raw = raw; return strings; }

    var env = undefined,
        root = undefined,
        result = undefined,
        self = undefined;
    function rootElement() {
        return env.getDOM().createElement('div');
    }
    function compile(template) {
        return env.compile(template);
    }
    function commonSetup() {
        env = new _glimmerTestHelpers.TestEnvironment(); // TODO: Support SimpleDOM
        root = rootElement();
    }
    function render(template) {
        var context = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        self = new _glimmerObjectReference.UpdatableReference(context);
        env.begin();
        result = template.render(self, root, new _glimmerTestHelpers.TestDynamicScope());
        env.commit();
        assertInvariants(result);
        return result;
    }
    function rerender() {
        var context = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
        var params = arguments.length <= 1 || arguments[1] === undefined ? { assertStable: false } : arguments[1];

        var snapshot = undefined;
        if (params.assertStable) {
            snapshot = _glimmerTestHelpers.generateSnapshot(root);
        }
        if (context !== null) self.update(context);
        env.begin();
        result.rerender();
        env.commit();
        if (params.assertStable) {
            _glimmerTestHelpers.equalSnapshots(_glimmerTestHelpers.generateSnapshot(root), snapshot);
        }
    }
    function assertInvariants(result) {
        strictEqual(result.firstNode(), root.firstChild, "The firstNode of the result is the same as the root's firstChild");
        strictEqual(result.lastNode(), root.lastChild, "The lastNode of the result is the same as the root's lastChild");
    }
    QUnit.module("Partials", {
        setup: commonSetup
    });
    QUnit.test('static partial with static content', function (assert) {
        var template = compile("Before {{partial 'test'}} After");
        env.registerPartial('test', "<div>Testing</div>");
        render(template);
        _glimmerTestHelpers.equalTokens(root, "Before <div>Testing</div> After");
        rerender(null, { assertStable: true });
        _glimmerTestHelpers.equalTokens(root, "Before <div>Testing</div> After");
    });
    QUnit.test('static partial with self reference', function (assert) {
        var template = compile("{{partial 'birdman'}}");
        env.registerPartial('birdman', "Respeck my {{item}}. When my {{item}} come up put some respeck on it.");
        render(template, { item: 'name' });
        rerender(null, { assertStable: true });
        _glimmerTestHelpers.equalTokens(root, "Respeck my name. When my name come up put some respeck on it.");
        rerender({ item: 'name' }, { assertStable: true });
        _glimmerTestHelpers.equalTokens(root, "Respeck my name. When my name come up put some respeck on it.");
    });
    QUnit.test('static partial with local reference', function (assert) {
        var template = compile("{{#each qualities key='id' as |quality|}}{{partial 'test'}}. {{/each}}");
        env.registerPartial('test', "You {{quality.value}}");
        render(template, { qualities: [{ id: 1, value: 'smaht' }, { id: 2, value: 'loyal' }] });
        rerender(null, { assertStable: true });
        _glimmerTestHelpers.equalTokens(root, "You smaht. You loyal. ");
        rerender({ qualities: [{ id: 1, value: 'smaht' }, { id: 2, value: 'loyal' }] }, { assertStable: true });
        _glimmerTestHelpers.equalTokens(root, "You smaht. You loyal. ");
    });
    QUnit.test('static partial with named arguments', function (assert) {
        env.registerBasicComponent('foo-bar', _glimmerTestHelpers.BasicComponent, "<p>{{@foo}}-{{partial 'test'}}</p>");
        var template = compile("<foo-bar @foo={{foo}} @bar={{bar}} />");
        env.registerPartial('test', "{{@foo}}-{{@bar}}");
        render(template, { foo: 'foo', bar: 'bar' });
        _glimmerTestHelpers.equalTokens(root, "<p>foo-foo-bar</p>");
        rerender(null, { assertStable: true });
        rerender({ foo: 'FOO', bar: 'BAR' }, { assertStable: true });
        _glimmerTestHelpers.equalTokens(root, "<p>FOO-FOO-BAR</p>");
        rerender({ foo: 'foo', bar: 'bar' }, { assertStable: true });
        _glimmerTestHelpers.equalTokens(root, "<p>foo-foo-bar</p>");
    });
    QUnit.test('static partial with has-block in basic component', function (assert) {
        env.registerBasicComponent('foo-bar', _glimmerTestHelpers.BasicComponent, "<p>{{partial 'test'}}</p>");
        env.registerBasicComponent('foo-bar-baz', _glimmerTestHelpers.BasicComponent, "<p>{{partial 'test'}}-{{has-block}}-{{has-block 'inverse'}}</p>");
        env.registerPartial('test', "{{has-block}}-{{has-block 'inverse'}}");
        render(compile(_glimmerTestHelpers.strip(_templateObject)));
        _glimmerTestHelpers.equalTokens(root, _glimmerTestHelpers.strip(_templateObject2));
        rerender(null, { assertStable: true });
    });
    QUnit.test('static partial with has-block in curly component', function (assert) {
        var TaglessComponent = (function (_EmberishCurlyComponent) {
            _inherits(TaglessComponent, _EmberishCurlyComponent);

            function TaglessComponent() {
                _classCallCheck(this, TaglessComponent);

                _EmberishCurlyComponent.apply(this, arguments);
                this.tagName = '';
            }

            return TaglessComponent;
        })(_glimmerTestHelpers.EmberishCurlyComponent);

        env.registerEmberishCurlyComponent('foo-bar', TaglessComponent, "<p>{{partial 'test'}}</p>");
        env.registerEmberishCurlyComponent('foo-bar-baz', TaglessComponent, "<p>{{partial 'test'}}-{{has-block}}-{{has-block 'inverse'}}</p>");
        env.registerPartial('test', "{{has-block}}-{{has-block 'inverse'}}");
        render(compile(_glimmerTestHelpers.strip(_templateObject3)));
        _glimmerTestHelpers.equalTokens(root, _glimmerTestHelpers.strip(_templateObject4));
        rerender(null, { assertStable: true });
    });
    QUnit.test('static partial with has-block-params in basic component', function (assert) {
        env.registerBasicComponent('foo-bar', _glimmerTestHelpers.BasicComponent, "<p>{{partial 'test'}}</p>");
        env.registerBasicComponent('foo-bar-baz', _glimmerTestHelpers.BasicComponent, "<p>{{partial 'test'}}-{{has-block-params}}-{{has-block-params \"inverse\"}}</p>");
        env.registerPartial('test', "{{has-block-params}}-{{has-block-params \"inverse\"}}");
        render(compile(_glimmerTestHelpers.strip(_templateObject5)));
        _glimmerTestHelpers.equalTokens(root, _glimmerTestHelpers.strip(_templateObject6));
        rerender(null, { assertStable: true });
    });
    QUnit.test('static partial with has-block-params in curly component', function (assert) {
        var TaglessComponent = (function (_EmberishCurlyComponent2) {
            _inherits(TaglessComponent, _EmberishCurlyComponent2);

            function TaglessComponent() {
                _classCallCheck(this, TaglessComponent);

                _EmberishCurlyComponent2.apply(this, arguments);
                this.tagName = '';
            }

            return TaglessComponent;
        })(_glimmerTestHelpers.EmberishCurlyComponent);

        env.registerEmberishCurlyComponent('foo-bar', TaglessComponent, "<p>{{partial 'test'}}</p>");
        env.registerEmberishCurlyComponent('foo-bar-baz', TaglessComponent, "<p>{{partial 'test'}}-{{has-block-params}}-{{has-block-params \"inverse\"}}</p>");
        env.registerPartial('test', "{{has-block-params}}-{{has-block-params \"inverse\"}}");
        render(compile(_glimmerTestHelpers.strip(_templateObject7)));
        _glimmerTestHelpers.equalTokens(root, _glimmerTestHelpers.strip(_templateObject8));
        rerender(null, { assertStable: true });
    });
    QUnit.test('static partial with yield in basic component', function (assert) {
        env.registerBasicComponent('foo-bar', _glimmerTestHelpers.BasicComponent, "<p>{{partial 'test'}}</p>");
        env.registerBasicComponent('foo-bar-baz', _glimmerTestHelpers.BasicComponent, "<p>{{partial 'test'}}-{{yield \"layout\"}}-{{yield to='inverse'}}</p>");
        env.registerPartial('test', "{{yield \"partial\"}}-{{yield to='inverse'}}");
        render(compile(_glimmerTestHelpers.strip(_templateObject9)));
        _glimmerTestHelpers.equalTokens(root, _glimmerTestHelpers.strip(_templateObject10));
        rerender(null, { assertStable: true });
    });
    QUnit.test('static partial with yield in curly component', function (assert) {
        var TaglessComponent = (function (_EmberishCurlyComponent3) {
            _inherits(TaglessComponent, _EmberishCurlyComponent3);

            function TaglessComponent() {
                _classCallCheck(this, TaglessComponent);

                _EmberishCurlyComponent3.apply(this, arguments);
                this.tagName = '';
            }

            return TaglessComponent;
        })(_glimmerTestHelpers.EmberishCurlyComponent);

        env.registerEmberishCurlyComponent('foo-bar', TaglessComponent, "<p>{{partial 'test'}}</p>");
        env.registerEmberishCurlyComponent('foo-bar-baz', TaglessComponent, "<p>{{partial 'test'}}-{{yield \"layout\"}}-{{yield to='inverse'}}</p>");
        env.registerPartial('test', "{{yield \"partial\"}}-{{yield to='inverse'}}");
        render(compile(_glimmerTestHelpers.strip(_templateObject11)));
        _glimmerTestHelpers.equalTokens(root, _glimmerTestHelpers.strip(_templateObject12));
        rerender(null, { assertStable: true });
    });
    QUnit.test('dynamic partial with static content', function (assert) {
        var template = compile("Before {{partial name}} After");
        env.registerPartial('test', "<div>Testing</div>");
        render(template, { name: 'test' });
        _glimmerTestHelpers.equalTokens(root, "Before <div>Testing</div> After");
        rerender({ name: 'test' }, { assertStable: true });
        _glimmerTestHelpers.equalTokens(root, "Before <div>Testing</div> After");
    });
    QUnit.test('nested dynamic partial with dynamic content', function (assert) {
        var template = compile("Before {{partial name}} After");
        env.registerPartial('test', "<div>Testing {{wat}} {{partial nest}}</div>");
        env.registerPartial('nested', "<div>Nested {{lol}}</div>");
        render(template, { name: 'test', nest: 'nested', wat: 'wat are', lol: 'you doing?' });
        _glimmerTestHelpers.equalTokens(root, "Before <div>Testing wat are <div>Nested you doing?</div></div> After");
        rerender({ name: 'test', nest: 'nested', wat: 'wat are', lol: 'you doing?' }, { assertStable: true });
        _glimmerTestHelpers.equalTokens(root, "Before <div>Testing wat are <div>Nested you doing?</div></div> After");
    });
    QUnit.test('dynamic partial with falsy value does not render', function (assert) {
        var template = compile("Before {{partial name}} After");
        render(template, { name: false });
        _glimmerTestHelpers.equalTokens(root, "Before <!----> After");
        rerender({ name: false }, { assertStable: true });
        _glimmerTestHelpers.equalTokens(root, "Before <!----> After");
    });
    QUnit.test('static partial that does not exist asserts', function (assert) {
        var template = compile("Before {{partial 'test'}} After");
        assert.throws(function () {
            render(template);
        }, /Could not find a partial named "test"/);
    });
    QUnit.test('dynamic partial that does not exist does not render', function (assert) {
        var template = compile("Before {{partial name}} After");
        assert.throws(function () {
            render(template, { name: 'illuminati' });
        }, /Could not find a partial named "illuminati"/);
    });
    QUnit.test('dynamic partial with can change from falsy to real template', function (assert) {
        var template = compile("Before {{partial name}} After");
        env.registerPartial('test', "<div>Testing</div>");
        render(template, { name: false });
        _glimmerTestHelpers.equalTokens(root, "Before <!----> After");
        rerender({ name: false }, { assertStable: true });
        rerender({ name: 'test' });
        _glimmerTestHelpers.equalTokens(root, "Before <div>Testing</div> After");
        rerender({ name: false });
        _glimmerTestHelpers.equalTokens(root, "Before <!----> After");
        rerender({ name: 'test' });
        _glimmerTestHelpers.equalTokens(root, "Before <div>Testing</div> After");
        rerender({ name: null });
        _glimmerTestHelpers.equalTokens(root, "Before <!----> After");
        rerender({ name: 'test' });
        _glimmerTestHelpers.equalTokens(root, "Before <div>Testing</div> After");
        rerender({ name: undefined });
        _glimmerTestHelpers.equalTokens(root, "Before <!----> After");
    });
    QUnit.test('dynamic partial with self reference', function (assert) {
        var template = compile("{{partial name}}");
        env.registerPartial('test', "I know {{item}}. I have the best {{item}}s.");
        render(template, { name: 'test', item: 'partial' });
        _glimmerTestHelpers.equalTokens(root, "I know partial. I have the best partials.");
        rerender({ name: 'test', item: 'partial' }, { assertStable: true });
        _glimmerTestHelpers.equalTokens(root, "I know partial. I have the best partials.");
    });
    QUnit.test('changing dynamic partial with self reference', function (assert) {
        var template = compile("{{partial name}}");
        env.registerPartial('weezy', "Ain't my birthday but I got my {{item}} on the cake.");
        env.registerPartial('birdman', "Respeck my {{item}}. When my {{item}} come up put some respeck on it.");
        render(template, { name: 'weezy', item: 'name' });
        _glimmerTestHelpers.equalTokens(root, "Ain't my birthday but I got my name on the cake.");
        rerender({ name: 'birdman', item: 'name' });
        _glimmerTestHelpers.equalTokens(root, "Respeck my name. When my name come up put some respeck on it.");
        rerender({ name: 'birdman', item: 'name' }, { assertStable: true });
        _glimmerTestHelpers.equalTokens(root, "Respeck my name. When my name come up put some respeck on it.");
    });
    QUnit.test('changing dynamic partial and changing reference values', function (assert) {
        var template = compile("{{partial name}}");
        env.registerPartial('weezy', "Ain't my birthday but I got my {{item}} on the cake.");
        env.registerPartial('birdman', "Respeck my {{item}}. When my {{item}} come up put some respeck on it.");
        render(template, { name: 'weezy', item: 'partial' });
        _glimmerTestHelpers.equalTokens(root, "Ain't my birthday but I got my partial on the cake.");
        rerender({ name: 'birdman', item: 'name' });
        _glimmerTestHelpers.equalTokens(root, "Respeck my name. When my name come up put some respeck on it.");
        rerender({ name: 'birdman', item: 'name' }, { assertStable: true });
        _glimmerTestHelpers.equalTokens(root, "Respeck my name. When my name come up put some respeck on it.");
    });
    QUnit.test('changing dynamic partial and changing references', function (assert) {
        var template = compile("{{partial name}}");
        env.registerPartial('weezy', "Ain't my birthday but I got my {{item}} on the cake.");
        env.registerPartial('birdman', "Respeck my {{noun}}. When my {{noun}} come up put some respeck on it.");
        render(template, { name: 'weezy', item: 'partial' });
        _glimmerTestHelpers.equalTokens(root, "Ain't my birthday but I got my partial on the cake.");
        rerender({ name: 'birdman', noun: 'name' });
        _glimmerTestHelpers.equalTokens(root, "Respeck my name. When my name come up put some respeck on it.");
        rerender({ name: 'birdman', noun: 'name' }, { assertStable: true });
        _glimmerTestHelpers.equalTokens(root, "Respeck my name. When my name come up put some respeck on it.");
    });
    QUnit.skip('FIXME (bug?) dynamic partial with local reference', function (assert) {
        var template = compile("{{#each qualities key='id' as |quality|}}{{partial name}}. {{/each}}");
        env.registerPartial('test', "You {{quality}}");
        render(template, { name: 'test', qualities: ['smaht', 'loyal'] });
        _glimmerTestHelpers.equalTokens(root, "You smaht. You loyal. ");
        rerender({ name: 'test', qualities: ['smaht', 'loyal'] }, { assertStable: true });
        _glimmerTestHelpers.equalTokens(root, "You smaht. You loyal. ");
    });
    QUnit.test('partial without arguments throws', function (assert) {
        assert.throws(function () {
            compile("Before {{partial}} After");
        }, _glimmerTestHelpers.strip(_templateObject13));
    });
    QUnit.test('partial with more than one argument throws', function (assert) {
        assert.throws(function () {
            compile("Before {{partial 'turnt' 'up'}} After");
        }, _glimmerTestHelpers.strip(_templateObject14));
    });
});

enifed('@glimmer/runtime/tests/partial-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/tests');
    QUnit.test('@glimmer/runtime/tests/partial-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/tests/partial-test.ts should pass tslint.');
    });
});

enifed("@glimmer/runtime/tests/rendering/content-test", ["exports", "@glimmer/test-helpers"], function (exports, _glimmerTestHelpers) {
    "use strict";

    var _templateObject = _taggedTemplateLiteralLoose(["\n    <div class=\"world\">\n      <h1>Hello World!</h1>\n      <p>This is just a paragraph</p>\n      <a href=\"http://linkedin.com\">Some Link</a>\n    </div>\n    "], ["\n    <div class=\"world\">\n      <h1>Hello World!</h1>\n      <p>This is just a paragraph</p>\n      <a href=\"http://linkedin.com\">Some Link</a>\n    </div>\n    "]),
        _templateObject2 = _taggedTemplateLiteralLoose(["\n    <div class=\"world\">\n      <h1>Hello World!</h1>\n      <p>This is just a paragraph</p>\n      <a href=\"http://linkedin.com\">Some Link</a>\n    </div>\n  "], ["\n    <div class=\"world\">\n      <h1>Hello World!</h1>\n      <p>This is just a paragraph</p>\n      <a href=\"http://linkedin.com\">Some Link</a>\n    </div>\n  "]);

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _taggedTemplateLiteralLoose(strings, raw) { strings.raw = raw; return strings; }

    var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    var StaticContentTests = (function (_RenderingTest) {
        _inherits(StaticContentTests, _RenderingTest);

        function StaticContentTests() {
            _classCallCheck(this, StaticContentTests);

            _RenderingTest.apply(this, arguments);
        }

        StaticContentTests.prototype[_a = 'renders text'] = function () {
            this.render({});
            this.assertContent("Hello World!");
            this.assertStableRerender();
        };

        StaticContentTests.prototype[_b = 'renders static element'] = function () {
            this.render({});
            this.assertContent("<h1>Hello World!</h1>");
            this.assertStableRerender();
        };

        StaticContentTests.prototype[_c = 'renders custom elements'] = function () {
            this.render({});
            this.assertContent("<use-the-platform></use-the-platform>");
            this.assertStableRerender();
        };

        StaticContentTests.prototype[_d = 'renders static template'] = function () {
            this.render({});
            this.assertContent(_glimmerTestHelpers.strip(_templateObject));
            this.assertStableRerender();
        };

        return StaticContentTests;
    })(_glimmerTestHelpers.RenderingTest);
    __decorate([_glimmerTestHelpers.template("Hello World!")], StaticContentTests.prototype, _a, null);
    __decorate([_glimmerTestHelpers.template("<h1>Hello World!</h1>")], StaticContentTests.prototype, _b, null);
    __decorate([_glimmerTestHelpers.template("<use-the-platform />")], StaticContentTests.prototype, _c, null);
    __decorate([_glimmerTestHelpers.template(_glimmerTestHelpers.strip(_templateObject2))], StaticContentTests.prototype, _d, null);
    StaticContentTests = __decorate([_glimmerTestHelpers.testModule('Static Content Tests')], StaticContentTests);
    var DynamicContentTests = (function (_RenderingTest2) {
        _inherits(DynamicContentTests, _RenderingTest2);

        function DynamicContentTests() {
            _classCallCheck(this, DynamicContentTests);

            _RenderingTest2.apply(this, arguments);
        }

        DynamicContentTests.prototype[_a = 'renders simple curly'] = function (assert) {
            var _this = this;

            this.render({ value: 'hello world' });
            this.assertContent('<div><p>hello world</p></div>');
            this.assertStableRerender();
            this.runTask(function () {
                return _this.context.set('value', "goodbye world");
            });
            this.assertContent('<div><p>goodbye world</p></div>');
            this.assertInvariants();
            this.runTask(function () {
                return _this.context.update({ value: 'hello world' });
            });
            this.assertContent('<div><p>hello world</p></div>');
            this.assertInvariants();
        };

        DynamicContentTests.prototype[_b = 'renders simple curly with sibling'] = function (assert) {
            var _this2 = this;

            this.render({ value: 'hello' });
            this.assertContent('<div><p>hello world</p></div>');
            this.assertStableRerender();
            this.runTask(function () {
                return _this2.context.set('value', "goodbye");
            });
            this.assertContent('<div><p>goodbye world</p></div>');
            this.assertInvariants();
            this.runTask(function () {
                return _this2.context.update({ value: 'hello' });
            });
            this.assertContent('<div><p>hello world</p></div>');
            this.assertInvariants();
        };

        DynamicContentTests.prototype[_c = 'null and undefined produces empty text nodes'] = function (assert) {
            var _this3 = this;

            this.render({ v1: null, v2: undefined });
            this.assertContent('<div><p></p><p></p></div>');
            this.assertStableRerender();
            this.runTask(function () {
                _this3.context.set('v1', "hello");
                _this3.context.set('v2', "world");
            });
            this.assertContent('<div><p>hello</p><p>world</p></div>');
            this.assertInvariants();
            this.runTask(function () {
                _this3.context.update({ v1: null, v2: undefined });
            });
            this.assertContent('<div><p></p><p></p></div>');
            this.assertInvariants();
        };

        DynamicContentTests.prototype[_d = 'renders path expression'] = function () {
            var _this4 = this;

            this.render({ foo: { bar: { baz: 'Hello World' } } });
            this.assertStableRerender();
            this.assertContent('<div>Hello World</div>');
            this.runTask(function () {
                return _this4.context.set('foo', { bar: { baz: 'WOOT' } });
            });
            this.assertContent('<div>WOOT</div>');
            this.runTask(function () {
                return _this4.context.set('foo', { bar: { baz: 'Hello World' } });
            });
            this.assertContent('<div>Hello World</div>');
        };

        DynamicContentTests.prototype[_e = 'updating a single trusting curly'] = function () {
            var _this5 = this;

            this.render({ value: '<p>hello world</p>' });
            this.assertStableRerender();
            this.assertContent('<div><p>hello world</p></div>');
            this.runTask(function () {
                return _this5.context.set('value', '<h1>WORD</h1>');
            });
            this.assertContent('<div><h1>WORD</h1></div>');
            this.runTask(function () {
                return _this5.context.update({ value: '<p>hello world</p>' });
            });
            this.assertContent('<div><p>hello world</p></div>');
        };

        return DynamicContentTests;
    })(_glimmerTestHelpers.RenderingTest);
    __decorate([_glimmerTestHelpers.template("<div><p>{{value}}</p></div>")], DynamicContentTests.prototype, _a, null);
    __decorate([_glimmerTestHelpers.template("<div><p>{{value}} world</p></div>")], DynamicContentTests.prototype, _b, null);
    __decorate([_glimmerTestHelpers.template("<div><p>{{v1}}</p><p>{{v2}}</p></div>")], DynamicContentTests.prototype, _c, null);
    __decorate([_glimmerTestHelpers.template("<div>{{foo.bar.baz}}</div>")], DynamicContentTests.prototype, _d, null);
    __decorate([_glimmerTestHelpers.template("<div>{{{value}}}</div>")], DynamicContentTests.prototype, _e, null);
    DynamicContentTests = __decorate([_glimmerTestHelpers.testModule('Content Tests')], DynamicContentTests);
    var _a, _b, _c, _d, _a, _b, _c, _d, _e;
});

enifed('@glimmer/runtime/tests/rendering/content-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/tests/rendering');
    QUnit.test('@glimmer/runtime/tests/rendering/content-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/tests/rendering/content-test.ts should pass tslint.');
    });
});

enifed("@glimmer/runtime/tests/template-test", ["exports", "@glimmer/test-helpers", "@glimmer/runtime", "@glimmer/compiler"], function (exports, _glimmerTestHelpers, _glimmerRuntime, _glimmerCompiler) {
    "use strict";

    var env = undefined;
    var serializedTemplate = undefined;
    var serializedTemplateNoId = undefined;
    QUnit.module("templateFactory", {
        setup: function () {
            env = new _glimmerTestHelpers.TestEnvironment();
            var templateJs = _glimmerCompiler.precompile("<div>{{name}}</div>", {
                meta: {
                    version: 12,
                    lang: 'es',
                    moduleName: "template/module/name"
                }
            });
            serializedTemplate = JSON.parse(templateJs);
            serializedTemplate.id = 'server-id-1';
            serializedTemplateNoId = JSON.parse(templateJs);
            serializedTemplateNoId.id = null;
        }
    });
    QUnit.test("id of serialized template is exposed on the factory", function (assert) {
        var factory = _glimmerRuntime.templateFactory(serializedTemplate);
        assert.ok(factory.id, 'is present');
        assert.equal(factory.id, serializedTemplate.id, 'id matches serialized template id');
    });
    QUnit.test("generates id if no id is on the serialized template", function (assert) {
        var factory1 = _glimmerRuntime.templateFactory(serializedTemplateNoId);
        var factory2 = _glimmerRuntime.templateFactory(serializedTemplateNoId);
        assert.ok(factory1.id, 'is present');
        assert.ok(factory2.id, 'is present');
        assert.notEqual(factory1.id, factory2.id, 'factories without underlying id create new id per factory');
    });
    QUnit.test("id of template matches factory", function (assert) {
        var factory = _glimmerRuntime.templateFactory(serializedTemplate);
        var template = factory.create(env);
        assert.ok(template.id, 'is present');
        assert.equal(template.id, factory.id, 'template id matches factory id');
    });
    QUnit.test("meta is accessible from factory", function (assert) {
        var factory = _glimmerRuntime.templateFactory(serializedTemplate);
        assert.deepEqual(factory.meta, {
            version: 12,
            lang: 'es',
            moduleName: "template/module/name"
        });
    });
    QUnit.test("meta is accessible from template", function (assert) {
        var factory = _glimmerRuntime.templateFactory(serializedTemplate);
        var template = factory.create(env);
        assert.deepEqual(template.meta, {
            version: 12,
            lang: 'es',
            moduleName: "template/module/name"
        }, 'template has expected meta');
    });
    QUnit.test("can inject per environment things into meta", function (assert) {
        var owner = {};
        var factory = _glimmerRuntime.templateFactory(serializedTemplate);
        var template = factory.create(env, { owner: owner });
        assert.strictEqual(template.meta.owner, owner, 'is owner');
        assert.deepEqual(template.meta, {
            version: 12,
            lang: 'es',
            moduleName: "template/module/name",
            owner: owner
        }, 'template has expected meta');
    });
});

enifed('@glimmer/runtime/tests/template-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/tests');
    QUnit.test('@glimmer/runtime/tests/template-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/tests/template-test.ts should pass tslint.');
    });
});

enifed("@glimmer/runtime/tests/updating-test", ["exports", "@glimmer/runtime", "@glimmer/test-helpers", "@glimmer/reference", "@glimmer/object-reference"], function (exports, _glimmerRuntime, _glimmerTestHelpers, _glimmerReference, _glimmerObjectReference) {
    "use strict";

    var _templateObject = _taggedTemplateLiteralLoose(["\n    <div>\n      [{{[]}}]\n      [{{[1]}}]\n      [{{[undefined]}}]\n      [{{[null]}}]\n      [{{[true]}}]\n      [{{[false]}}]\n      [{{[this]}}]\n      [{{[foo.bar]}}]\n\n      [{{nested.[]}}]\n      [{{nested.[1]}}]\n      [{{nested.[undefined]}}]\n      [{{nested.[null]}}]\n      [{{nested.[true]}}]\n      [{{nested.[false]}}]\n      [{{nested.[this]}}]\n      [{{nested.[foo.bar]}}]\n    </div>\n  "], ["\n    <div>\n      [{{[]}}]\n      [{{[1]}}]\n      [{{[undefined]}}]\n      [{{[null]}}]\n      [{{[true]}}]\n      [{{[false]}}]\n      [{{[this]}}]\n      [{{[foo.bar]}}]\n\n      [{{nested.[]}}]\n      [{{nested.[1]}}]\n      [{{nested.[undefined]}}]\n      [{{nested.[null]}}]\n      [{{nested.[true]}}]\n      [{{nested.[false]}}]\n      [{{nested.[this]}}]\n      [{{nested.[foo.bar]}}]\n    </div>\n  "]),
        _templateObject2 = _taggedTemplateLiteralLoose(["\n    [empty string]\n    [1]\n    [undefined]\n    [null]\n    [true]\n    [false]\n    [this]\n    [foo.bar]\n\n    [empty string]\n    [1]\n    [undefined]\n    [null]\n    [true]\n    [false]\n    [this]\n    [foo.bar]\n  "], ["\n    [empty string]\n    [1]\n    [undefined]\n    [null]\n    [true]\n    [false]\n    [this]\n    [foo.bar]\n\n    [empty string]\n    [1]\n    [undefined]\n    [null]\n    [true]\n    [false]\n    [this]\n    [foo.bar]\n  "]),
        _templateObject3 = _taggedTemplateLiteralLoose(["\n    [EMPTY STRING]\n    [ONE]\n    [UNDEFINED]\n    [NULL]\n    [TRUE]\n    [FALSE]\n    [THIS]\n    [FOO.BAR]\n\n    [EMPTY STRING]\n    [ONE]\n    [UNDEFINED]\n    [NULL]\n    [TRUE]\n    [FALSE]\n    [THIS]\n    [FOO.BAR]\n  "], ["\n    [EMPTY STRING]\n    [ONE]\n    [UNDEFINED]\n    [NULL]\n    [TRUE]\n    [FALSE]\n    [THIS]\n    [FOO.BAR]\n\n    [EMPTY STRING]\n    [ONE]\n    [UNDEFINED]\n    [NULL]\n    [TRUE]\n    [FALSE]\n    [THIS]\n    [FOO.BAR]\n  "]),
        _templateObject4 = _taggedTemplateLiteralLoose(["\n    <div>\n      foo: \"{{foo}}\";\n      bar: \"{{bar}}\";\n      value: \"{{value}}\";\n      echo foo: \"{{echo foo}}\";\n      echo bar: \"{{echo bar}}\";\n      echo value: \"{{echo value}}\";\n\n      -----\n\n      {{#with value as |foo|}}\n        foo: \"{{foo}}\";\n        bar: \"{{bar}}\";\n        value: \"{{value}}\";\n        echo foo: \"{{echo foo}}\";\n        echo bar: \"{{echo bar}}\";\n        echo value: \"{{echo value}}\";\n\n        -----\n\n        {{#with foo as |bar|}}\n          foo: \"{{foo}}\";\n          bar: \"{{bar}}\";\n          value: \"{{value}}\";\n          echo foo: \"{{echo foo}}\";\n          echo bar: \"{{echo bar}}\";\n          echo value: \"{{echo value}}\";\n        {{/with}}\n      {{/with}}\n\n      -----\n\n      {{#with value as |bar|}}\n        foo: \"{{foo}}\";\n        bar: \"{{bar}}\";\n        value: \"{{value}}\";\n        echo foo: \"{{echo foo}}\";\n        echo bar: \"{{echo bar}}\";\n        echo value: \"{{echo value}}\";\n      {{/with}}\n    </div>\n  "], ["\n    <div>\n      foo: \"{{foo}}\";\n      bar: \"{{bar}}\";\n      value: \"{{value}}\";\n      echo foo: \"{{echo foo}}\";\n      echo bar: \"{{echo bar}}\";\n      echo value: \"{{echo value}}\";\n\n      -----\n\n      {{#with value as |foo|}}\n        foo: \"{{foo}}\";\n        bar: \"{{bar}}\";\n        value: \"{{value}}\";\n        echo foo: \"{{echo foo}}\";\n        echo bar: \"{{echo bar}}\";\n        echo value: \"{{echo value}}\";\n\n        -----\n\n        {{#with foo as |bar|}}\n          foo: \"{{foo}}\";\n          bar: \"{{bar}}\";\n          value: \"{{value}}\";\n          echo foo: \"{{echo foo}}\";\n          echo bar: \"{{echo bar}}\";\n          echo value: \"{{echo value}}\";\n        {{/with}}\n      {{/with}}\n\n      -----\n\n      {{#with value as |bar|}}\n        foo: \"{{foo}}\";\n        bar: \"{{bar}}\";\n        value: \"{{value}}\";\n        echo foo: \"{{echo foo}}\";\n        echo bar: \"{{echo bar}}\";\n        echo value: \"{{echo value}}\";\n      {{/with}}\n    </div>\n  "]),
        _templateObject5 = _taggedTemplateLiteralLoose(["\n    <div>\n      foo: \"foo-helper\";\n      bar: \"bar-helper\";\n      value: \"value-value\";\n      echo foo: \"foo-value\";\n      echo bar: \"bar-value\";\n      echo value: \"value-value\";\n\n      -----\n\n      foo: \"value-value\";\n      bar: \"bar-helper\";\n      value: \"value-value\";\n      echo foo: \"value-value\";\n      echo bar: \"bar-value\";\n      echo value: \"value-value\";\n\n      -----\n\n      foo: \"value-value\";\n      bar: \"value-value\";\n      value: \"value-value\";\n      echo foo: \"value-value\";\n      echo bar: \"value-value\";\n      echo value: \"value-value\";\n\n      -----\n\n      foo: \"foo-helper\";\n      bar: \"value-value\";\n      value: \"value-value\";\n      echo foo: \"foo-value\";\n      echo bar: \"value-value\";\n      echo value: \"value-value\";\n    </div>"], ["\n    <div>\n      foo: \"foo-helper\";\n      bar: \"bar-helper\";\n      value: \"value-value\";\n      echo foo: \"foo-value\";\n      echo bar: \"bar-value\";\n      echo value: \"value-value\";\n\n      -----\n\n      foo: \"value-value\";\n      bar: \"bar-helper\";\n      value: \"value-value\";\n      echo foo: \"value-value\";\n      echo bar: \"bar-value\";\n      echo value: \"value-value\";\n\n      -----\n\n      foo: \"value-value\";\n      bar: \"value-value\";\n      value: \"value-value\";\n      echo foo: \"value-value\";\n      echo bar: \"value-value\";\n      echo value: \"value-value\";\n\n      -----\n\n      foo: \"foo-helper\";\n      bar: \"value-value\";\n      value: \"value-value\";\n      echo foo: \"foo-value\";\n      echo bar: \"value-value\";\n      echo value: \"value-value\";\n    </div>"]),
        _templateObject6 = _taggedTemplateLiteralLoose(["\n    <div>\n      foo: \"foo-helper\";\n      bar: \"bar-helper\";\n      value: \"NEW-VALUE\";\n      echo foo: \"foo-value\";\n      echo bar: \"bar-value\";\n      echo value: \"NEW-VALUE\";\n\n      -----\n\n      foo: \"NEW-VALUE\";\n      bar: \"bar-helper\";\n      value: \"NEW-VALUE\";\n      echo foo: \"NEW-VALUE\";\n      echo bar: \"bar-value\";\n      echo value: \"NEW-VALUE\";\n\n      -----\n\n      foo: \"NEW-VALUE\";\n      bar: \"NEW-VALUE\";\n      value: \"NEW-VALUE\";\n      echo foo: \"NEW-VALUE\";\n      echo bar: \"NEW-VALUE\";\n      echo value: \"NEW-VALUE\";\n\n      -----\n\n      foo: \"foo-helper\";\n      bar: \"NEW-VALUE\";\n      value: \"NEW-VALUE\";\n      echo foo: \"foo-value\";\n      echo bar: \"NEW-VALUE\";\n      echo value: \"NEW-VALUE\";\n    </div>"], ["\n    <div>\n      foo: \"foo-helper\";\n      bar: \"bar-helper\";\n      value: \"NEW-VALUE\";\n      echo foo: \"foo-value\";\n      echo bar: \"bar-value\";\n      echo value: \"NEW-VALUE\";\n\n      -----\n\n      foo: \"NEW-VALUE\";\n      bar: \"bar-helper\";\n      value: \"NEW-VALUE\";\n      echo foo: \"NEW-VALUE\";\n      echo bar: \"bar-value\";\n      echo value: \"NEW-VALUE\";\n\n      -----\n\n      foo: \"NEW-VALUE\";\n      bar: \"NEW-VALUE\";\n      value: \"NEW-VALUE\";\n      echo foo: \"NEW-VALUE\";\n      echo bar: \"NEW-VALUE\";\n      echo value: \"NEW-VALUE\";\n\n      -----\n\n      foo: \"foo-helper\";\n      bar: \"NEW-VALUE\";\n      value: \"NEW-VALUE\";\n      echo foo: \"foo-value\";\n      echo bar: \"NEW-VALUE\";\n      echo value: \"NEW-VALUE\";\n    </div>"]),
        _templateObject7 = _taggedTemplateLiteralLoose(["\n    <div>\n      [{{#with person as |name|}}{{this.name}}{{/with}}]\n      [{{#with person as |name|}}{{#with this.name as |test|}}{{test}}{{/with}}{{/with}}]\n      [{{#with person as |name|}}{{#with (noop this.name) as |test|}}{{test}}{{/with}}{{/with}}]\n    </div>"], ["\n    <div>\n      [{{#with person as |name|}}{{this.name}}{{/with}}]\n      [{{#with person as |name|}}{{#with this.name as |test|}}{{test}}{{/with}}{{/with}}]\n      [{{#with person as |name|}}{{#with (noop this.name) as |test|}}{{test}}{{/with}}{{/with}}]\n    </div>"]),
        _templateObject8 = _taggedTemplateLiteralLoose(["<ul>\n      <li class='mmun'>Martin Muoz<p class='index-0'>0</p></li>\n      <li class='krisselden'>Kristoph Selden<p class='index-1'>1</p></li>\n      <li class='mixonic'>Matthew Beale<p class='index-2'>2</p></li></ul>"], ["<ul>\n      <li class='mmun'>Martin Muoz<p class='index-0'>0</p></li>\n      <li class='krisselden'>Kristoph Selden<p class='index-1'>1</p></li>\n      <li class='mixonic'>Matthew Beale<p class='index-2'>2</p></li></ul>"]),
        _templateObject9 = _taggedTemplateLiteralLoose(["<ul>\n      <li class='mmun'>Martin Muoz<p class='index-0'>0</p></li>\n      <li class='stefanpenner'>Stefan Penner<p class='index-1'>1</p></li>\n      <li class='rwjblue'>Robert Jackson<p class='index-2'>2</p></li></ul>"], ["<ul>\n      <li class='mmun'>Martin Muoz<p class='index-0'>0</p></li>\n      <li class='stefanpenner'>Stefan Penner<p class='index-1'>1</p></li>\n      <li class='rwjblue'>Robert Jackson<p class='index-2'>2</p></li></ul>"]),
        _templateObject10 = _taggedTemplateLiteralLoose(["<ul><li class='mmun'>Martin Muoz</li><li class='krisselden'>Kristoph Selden</li>\n        <li class='mixonic'>Matthew Beale</li></ul>"], ["<ul><li class='mmun'>Martin Muoz</li><li class='krisselden'>Kristoph Selden</li>\n        <li class='mixonic'>Matthew Beale</li></ul>"]),
        _templateObject11 = _taggedTemplateLiteralLoose(["<ul><li class='mmun'>Martin Muoz</li><li class='stefanpenner'>Stefan Penner</li>\n        <li class='rwjblue'>Robert Jackson</li></ul>"], ["<ul><li class='mmun'>Martin Muoz</li><li class='stefanpenner'>Stefan Penner</li>\n        <li class='rwjblue'>Robert Jackson</li></ul>"]);

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _taggedTemplateLiteralLoose(strings, raw) { strings.raw = raw; return strings; }

    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    var XLINK_NAMESPACE = 'http://www.w3.org/1999/xlink';
    var XHTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
    /*
     * Phantom 1.9 does not serialize namespaced attributes correctly. The namespace
     * prefix is incorrectly stripped off.
     */
    var serializesNSAttributesCorrectly = (function () {
        var div = document.createElement('div');
        var span = document.createElement('span');
        span.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:lang', 'en-uk');
        div.appendChild(span);
        return div.innerHTML === '<span xml:lang="en-uk"></span>';
    })();
    var hooks = undefined,
        root = undefined;
    var env = undefined;
    var self = undefined;
    var result = undefined;
    function compile(template) {
        return env.compile(template);
    }
    function rootElement() {
        return env.getDOM().createElement('div');
    }
    function commonSetup() {
        env = new _glimmerTestHelpers.TestEnvironment(); // TODO: Support SimpleDOM
        root = rootElement();
        root.setAttribute('debug-root', 'true');
    }
    function render(template) {
        var context = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
        var view = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

        self = new _glimmerObjectReference.UpdatableReference(context);
        env.begin();
        result = template.render(self, root, new _glimmerTestHelpers.TestDynamicScope());
        env.commit();
        assertInvariants(result);
        return result;
    }
    function rerender() {
        var context = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

        if (context !== null) self.update(context);
        env.begin();
        result.rerender();
        env.commit();
    }
    function getNodeByClassName(className) {
        var itemNode = root.querySelector("." + className);
        ok(itemNode, "Expected node with class='" + className + "'");
        return itemNode;
    }
    function getFirstChildOfNode(className) {
        var itemNode = getNodeByClassName(className);
        ok(itemNode, "Expected child node of node with class='" + className + "', but no parent node found");
        var childNode = itemNode && itemNode.firstChild;
        ok(childNode, "Expected child node of node with class='" + className + "', but not child node found");
        return childNode;
    }
    QUnit.module("Updating", {
        setup: commonSetup
    });
    test("updating a single curly", function () {
        var object = { value: 'hello world' };
        var template = compile('<div><p>{{value}}</p></div>');
        render(template, object);
        var valueNode = root.firstChild.firstChild.firstChild;
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello world</p></div>', "Initial render");
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello world</p></div>', "no change");
        strictEqual(root.firstChild.firstChild.firstChild, valueNode, "The text node was not blown away");
        object.value = 'goodbye world';
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>goodbye world</p></div>', "After updating and dirtying");
        strictEqual(root.firstChild.firstChild.firstChild, valueNode, "The text node was not blown away");
    });
    test("updating a single curly with siblings", function () {
        var value = 'brave new ';
        var context = { value: value };
        var getDiv = function () {
            return root.firstChild;
        };
        var template = compile('<div>hello {{value}}world</div>');
        render(template, context);
        equal(getDiv().firstChild.textContent, 'hello ');
        equal(getDiv().childNodes[1].textContent, 'brave new ');
        equal(getDiv().lastChild.textContent, 'world');
        rerender();
        equal(getDiv().firstChild.textContent, 'hello ');
        equal(getDiv().childNodes[1].textContent, 'brave new ');
        equal(getDiv().lastChild.textContent, 'world');
        context.value = 'another ';
        rerender();
        equal(getDiv().firstChild.textContent, 'hello ');
        equal(getDiv().childNodes[1].textContent, 'another ');
        equal(getDiv().lastChild.textContent, 'world');
        rerender({ value: value });
        equal(getDiv().firstChild.textContent, 'hello ');
        equal(getDiv().childNodes[1].textContent, 'brave new ');
        equal(getDiv().lastChild.textContent, 'world');
    });
    test("null and undefined produces empty text nodes", function () {
        var object = { v1: null, v2: undefined };
        var template = compile('<div><p>{{v1}}</p><p>{{v2}}</p></div>');
        render(template, object);
        var valueNode1 = root.firstChild.firstChild.firstChild;
        var valueNode2 = root.firstChild.lastChild.firstChild;
        _glimmerTestHelpers.equalTokens(root, '<div><p></p><p></p></div>', "Initial render");
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p></p><p></p></div>', "no change");
        strictEqual(root.firstChild.firstChild.firstChild, valueNode1, "The text node was not blown away");
        strictEqual(root.firstChild.lastChild.firstChild, valueNode2, "The text node was not blown away");
        object.v1 = 'hello';
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello</p><p></p></div>', "After updating and dirtying");
        strictEqual(root.firstChild.firstChild.firstChild, valueNode1, "The text node was not blown away");
        strictEqual(root.firstChild.lastChild.firstChild, valueNode2, "The text node was not blown away");
        object.v2 = 'world';
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello</p><p>world</p></div>', "After updating and dirtying");
        strictEqual(root.firstChild.firstChild.firstChild, valueNode1, "The text node was not blown away");
        strictEqual(root.firstChild.lastChild.firstChild, valueNode2, "The text node was not blown away");
        object.v1 = null;
        object.v2 = undefined;
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p></p><p></p></div>', "Reset");
        strictEqual(root.firstChild.firstChild.firstChild, valueNode1, "The text node was not blown away");
        strictEqual(root.firstChild.lastChild.firstChild, valueNode2, "The text node was not blown away");
    });
    test("weird paths", function () {
        var context = {
            "": "empty string",
            "1": "1",
            "undefined": "undefined",
            "null": "null",
            "true": "true",
            "false": "false",
            "this": "this",
            "foo.bar": "foo.bar",
            "nested": null
        };
        context.nested = context;
        var getDiv = function () {
            return root.firstChild;
        };
        var template = compile(_glimmerTestHelpers.stripTight(_templateObject));
        render(template, context);
        equal(getDiv().textContent, _glimmerTestHelpers.stripTight(_templateObject2));
        rerender();
        equal(getDiv().textContent, _glimmerTestHelpers.stripTight(_templateObject2));
        context[""] = "EMPTY STRING";
        context["1"] = "ONE";
        context["undefined"] = "UNDEFINED";
        context["null"] = "NULL";
        context["true"] = "TRUE";
        context["false"] = "FALSE";
        context["this"] = "THIS";
        context["foo.bar"] = "FOO.BAR";
        rerender();
        equal(getDiv().textContent, _glimmerTestHelpers.stripTight(_templateObject3));
        context = {
            "": "empty string",
            "1": "1",
            "undefined": "undefined",
            "null": "null",
            "true": "true",
            "false": "false",
            "this": "this",
            "foo.bar": "foo.bar",
            "nested": null
        };
        context.nested = context;
        rerender(context);
        equal(getDiv().textContent, _glimmerTestHelpers.stripTight(_templateObject2));
    });
    test("updating a single trusting curly", function () {
        var value = '<p>hello world</p>';
        var object = { value: value };
        var template = compile('<div>{{{value}}}</div>');
        render(template, object);
        var valueNode = root.firstChild.firstChild.firstChild;
        _glimmerTestHelpers.equalTokens(root, "<div>" + value + "</div>", "Initial render");
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello world</p></div>', "no change");
        strictEqual(root.firstChild.firstChild.firstChild, valueNode, "The text node was not blown away");
        object.value = '<span>goodbye world</span>';
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div>" + object.value + "</div>", "After updating and dirtying");
        notStrictEqual(root.firstChild.firstChild.firstChild, valueNode, "The text node was blown away");
        object.value = 'a <span>good man</span> is hard to <b>fund</b>';
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div>" + object.value + "</div>", "After updating with many nodes and dirtying");
        rerender({ value: value });
        _glimmerTestHelpers.equalTokens(root, "<div>" + value + "</div>", "no change");
    });
    test("updating a single trusting curly with siblings", function () {
        var value = '<b>brave new </b>';
        var context = { value: value };
        var getDiv = function () {
            return root.firstChild;
        };
        var template = compile('<div>hello {{{value}}}world</div>');
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, '<div>hello <b>brave new </b>world</div>', 'Initial render');
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div>hello <b>brave new </b>world</div>', 'rerender');
        context.value = 'big <b>wide</b> ';
        rerender();
        equal(getDiv().firstChild.textContent, 'hello ');
        equal(getDiv().childNodes[1].textContent, 'big ');
        equal(getDiv().childNodes[2].innerHTML, 'wide');
        equal(getDiv().childNodes[3].textContent, ' ');
        equal(getDiv().lastChild.textContent, 'world');
        context.value = 'another ';
        rerender();
        equal(getDiv().firstChild.textContent, 'hello ');
        equal(getDiv().childNodes[1].textContent, 'another ');
        equal(getDiv().lastChild.textContent, 'world');
        rerender({ value: value });
        _glimmerTestHelpers.equalTokens(root, '<div>hello <b>brave new </b>world</div>', 'rerender');
    });
    test("updating a single trusting curly with previous sibling", function () {
        var value = '<b>brave new </b>';
        var context = { value: value };
        var getDiv = function () {
            return root.firstChild;
        };
        var template = compile('<div>hello {{{value}}}</div>');
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, '<div>hello <b>brave new </b></div>', 'Initial render');
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div>hello <b>brave new </b></div>', 'rerender');
        context.value = 'another ';
        rerender();
        equal(getDiv().firstChild.textContent, 'hello ');
        _glimmerTestHelpers.equalTokens(getDiv().lastChild.textContent, 'another ');
        rerender({ value: value });
        _glimmerTestHelpers.equalTokens(root, '<div>hello <b>brave new </b></div>', 'rerender');
    });
    // This is to catch a regression about not caching lastValue correctly
    test("Cycling between two values in a trusting curly", function () {
        var a = '<p>A</p>';
        var b = '<p>B</p>';
        var object = { value: a };
        var template = compile('<div>{{{value}}}</div>');
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, '<div><p>A</p></div>', "Initial render");
        object.value = b;
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>B</p></div>', "Updating");
        // Change it back
        object.value = a;
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>A</p></div>', "Updating");
        // Change it back
        object.value = b;
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>B</p></div>', "Updating");
    });
    test("updating a curly with a safe and unsafe string", function () {
        var safeString = {
            string: '<p>hello world</p>',
            toHTML: function () {
                return this.string;
            },
            toString: function () {
                return this.string;
            }
        };
        var unsafeString = '<b>Big old world!</b>';
        var object = {
            value: safeString
        };
        var template = compile('<div>{{value}}</div>');
        render(template, object);
        var valueNode = root.firstChild.firstChild.firstChild;
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello world</p></div>', "Initial render");
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello world</p></div>', "no change");
        strictEqual(root.firstChild.firstChild.firstChild, valueNode, "The text node was not blown away");
        object.value = unsafeString;
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div>&lt;b&gt;Big old world!&lt;/b&gt;</div>', "After replacing with unsafe string");
        notStrictEqual(root.firstChild.firstChild, valueNode, "The text node was blown away");
        object.value = safeString;
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello world</p></div>', "original input causes no problem");
    });
    function makeSafeString(value) {
        return {
            string: value,
            toHTML: function () {
                return this.string;
            },
            toString: function () {
                return this.string;
            }
        };
    }
    // Test cases to matrix:
    // const helper returns const SafeString
    // non-const
    // safe string
    // unsafe string
    // swapping between safe and unsafe
    // swapping between unsafe and safe
    function makeElement(tag, content) {
        var el = document.createElement(tag);
        el.appendChild(document.createTextNode(content));
        return el;
    }
    function makeFragment(nodes) {
        var frag = document.createDocumentFragment();
        nodes.forEach(function (node) {
            return frag.appendChild(node);
        });
        return frag;
    }
    [{
        name: 'double curlies',
        template: '<div>{{value}}</div>',
        values: [{
            input: 'hello',
            expected: '<div>hello</div>',
            description: 'plain string'
        }, {
            input: '<b>hello</b>',
            expected: '<div>&lt;b&gt;hello&lt;/b&gt;</div>',
            description: 'string containing HTML'
        }, {
            input: null,
            expected: '<div></div>',
            description: 'null literal'
        }, {
            input: undefined,
            expected: '<div></div>',
            description: 'undefined literal'
        }, {
            input: makeSafeString('<b>hello</b>'),
            expected: '<div><b>hello</b></div>',
            description: 'safe string containing HTML'
        }, {
            input: makeElement('p', 'hello'),
            expected: '<div><p>hello</p></div>',
            description: 'DOM node containing and element with text'
        }, {
            input: makeFragment([makeElement('p', 'one'), makeElement('p', 'two')]),
            expected: '<div><p>one</p><p>two</p></div>',
            description: 'DOM fragment containing multiple nodes'
        }, {
            input: 'not modified',
            expected: '<div>not modified</div>',
            description: 'plain string (not modified, first render)'
        }, {
            input: 'not modified',
            expected: '<div>not modified</div>',
            description: 'plain string (not modified, second render)'
        }, {
            input: 0,
            expected: '<div>0</div>',
            description: 'number literal (0)'
        }, {
            input: true,
            expected: '<div>true</div>',
            description: 'boolean literal (true)'
        }, {
            input: {
                toString: function () {
                    return 'I am an Object';
                }
            },
            expected: '<div>I am an Object</div>',
            description: 'object with a toString function'
        }]
    }, {
        name: 'triple curlies',
        template: '<div>{{{value}}}</div>',
        values: [{
            input: 'hello',
            expected: '<div>hello</div>',
            description: 'plain string'
        }, {
            input: '<b>hello</b>',
            expected: '<div><b>hello</b></div>',
            description: 'string containing HTML'
        }, {
            input: null,
            expected: '<div></div>',
            description: 'null literal'
        }, {
            input: undefined,
            expected: '<div></div>',
            description: 'undefined literal'
        }, {
            input: makeSafeString('<b>hello</b>'),
            expected: '<div><b>hello</b></div>',
            description: 'safe string containing HTML'
        }, {
            input: makeElement('p', 'hello'),
            expected: '<div><p>hello</p></div>',
            description: 'DOM node containing and element with text'
        }, {
            input: makeFragment([makeElement('p', 'one'), makeElement('p', 'two')]),
            expected: '<div><p>one</p><p>two</p></div>',
            description: 'DOM fragment containing multiple nodes'
        }, {
            input: 'not modified',
            expected: '<div>not modified</div>',
            description: 'plain string (not modified, first render)'
        }, {
            input: 'not modified',
            expected: '<div>not modified</div>',
            description: 'plain string (not modified, second render)'
        }, {
            input: 0,
            expected: '<div>0</div>',
            description: 'number literal (0)'
        }, {
            input: true,
            expected: '<div>true</div>',
            description: 'boolean literal (true)'
        }, {
            input: {
                toString: function () {
                    return 'I am an Object';
                }
            },
            expected: '<div>I am an Object</div>',
            description: 'object with a toString function'
        }]
    }].forEach(function (config) {
        test("updating " + config.name + " produces expected result", function () {
            var template = compile(config.template);
            var context = {
                value: undefined
            };
            config.values.forEach(function (testCase, index) {
                context.value = testCase.input;
                if (index === 0) {
                    render(template, context);
                    _glimmerTestHelpers.equalTokens(root, testCase.expected, "expected initial render (" + testCase.description + ")");
                } else {
                    rerender();
                    _glimmerTestHelpers.equalTokens(root, testCase.expected, "expected updated render (" + testCase.description + ")");
                }
            });
        });
    });
    test("updating a triple curly with a safe and unsafe string", function () {
        var safeString = makeSafeString('<p>hello world</p>');
        var unsafeString = '<b>Big old world!</b>';
        var object = {
            value: safeString
        };
        var template = compile('<div>{{{value}}}</div>');
        render(template, object);
        var valueNode = root.firstChild.firstChild.firstChild;
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello world</p></div>', "Initial render");
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello world</p></div>', "no change");
        strictEqual(root.firstChild.firstChild.firstChild, valueNode, "The nodes were not blown away");
        object.value = unsafeString;
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><b>Big old world!</b></div>', "Normal strings may contain HTML");
        notStrictEqual(root.firstChild.firstChild.firstChild, valueNode, "The nodes were blown away");
        object.value = safeString;
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello world</p></div>', "original input causes no problem");
    });
    test("triple curlies with empty string initial value", function (assert) {
        var input = {
            value: ''
        };
        var template = compile('<div>{{{value}}}</div>');
        render(template, input);
        _glimmerTestHelpers.equalTokens(root, '<div></div>', "Initial render");
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div></div>', "no change");
        input.value = '<b>Bold and spicy</b>';
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><b>Bold and spicy</b></div>', "markup is updated");
        input.value = '';
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div></div>', "back to empty string");
    });

    var ValueReference = (function (_ConstReference) {
        _inherits(ValueReference, _ConstReference);

        function ValueReference() {
            _classCallCheck(this, ValueReference);

            _ConstReference.apply(this, arguments);
        }

        ValueReference.prototype.get = function get() {
            return _glimmerRuntime.UNDEFINED_REFERENCE;
        };

        return ValueReference;
    })(_glimmerReference.ConstReference);

    test("double curlies with const SafeString", function (assert) {
        var rawString = '<b>bold</b> and spicy';
        env.registerInternalHelper('const-foobar', function (vm, args) {
            return new ValueReference(makeSafeString(rawString));
        });
        var template = compile('<div>{{const-foobar}}</div>');
        var input = {};
        render(template, input);
        var valueNode = root.firstChild.firstChild;
        _glimmerTestHelpers.equalTokens(root, '<div><b>bold</b> and spicy</div>', "initial render");
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><b>bold</b> and spicy</div>', "no change");
        strictEqual(root.firstChild.firstChild, valueNode, "The nodes were not blown away");
    });
    test("double curlies with const Node", function (assert) {
        var rawString = '<b>bold</b> and spicy';
        env.registerInternalHelper('const-foobar', function (vm, args) {
            return new ValueReference(document.createTextNode(rawString));
        });
        var template = compile('<div>{{const-foobar}}</div>');
        var input = {};
        render(template, input);
        var valueNode = root.firstChild.firstChild;
        _glimmerTestHelpers.equalTokens(root, '<div>&lt;b&gt;bold&lt;/b&gt; and spicy</div>', "initial render");
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div>&lt;b&gt;bold&lt;/b&gt; and spicy</div>', "no change");
        strictEqual(root.firstChild.firstChild, valueNode, "The node was not blown away");
    });
    test("triple curlies with const SafeString", function (assert) {
        var rawString = '<b>bold</b> and spicy';
        env.registerInternalHelper('const-foobar', function (vm, args) {
            return new ValueReference(makeSafeString(rawString));
        });
        var template = compile('<div>{{{const-foobar}}}</div>');
        var input = {};
        render(template, input);
        var valueNode = root.firstChild.firstChild;
        _glimmerTestHelpers.equalTokens(root, '<div><b>bold</b> and spicy</div>', "initial render");
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><b>bold</b> and spicy</div>', "no change");
        strictEqual(root.firstChild.firstChild, valueNode, "The nodes were not blown away");
    });
    test("triple curlies with const Node", function (assert) {
        var rawString = '<b>bold</b> and spicy';
        env.registerInternalHelper('const-foobar', function (vm, args) {
            return new ValueReference(document.createTextNode(rawString));
        });
        var template = compile('<div>{{{const-foobar}}}</div>');
        var input = {};
        render(template, input);
        var valueNode = root.firstChild;
        _glimmerTestHelpers.equalTokens(root, '<div>&lt;b&gt;bold&lt;/b&gt; and spicy</div>', "initial render");
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div>&lt;b&gt;bold&lt;/b&gt; and spicy</div>', "no change");
        strictEqual(root.firstChild, valueNode, "The node was not blown away");
    });
    test("helpers can add destroyables", function (assert) {
        var destroyable = {
            count: 0,
            destroy: function () {
                this.count++;
            }
        };
        env.registerInternalHelper('destroy-me', function (vm, args) {
            vm.newDestroyable(destroyable);
            return _glimmerRuntime.PrimitiveReference.create('destroy me!');
        });
        var template = compile('<div>{{destroy-me}}</div>');
        render(template, {});
        _glimmerTestHelpers.equalTokens(root, '<div>destroy me!</div>', 'initial render');
        strictEqual(destroyable.count, 0, 'not destroyed');
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div>destroy me!</div>', 'no change');
        strictEqual(destroyable.count, 0, 'not destroyed');
        result.destroy();
        strictEqual(destroyable.count, 1, 'is destroyed');
    });
    test("helpers passed as arguments to {{#if}} are not torn down when switching between blocks", function (assert) {
        var options = {
            template: '{{#if (stateful-foo)}}Yes{{/if}}',
            truthyValue: true,
            falsyValue: false
        };
        testStatefulHelper(assert, options);
    });
    test("helpers passed as arguments to {{#unless}} are not torn down when switching between blocks", function (assert) {
        var options = {
            template: '{{#unless (stateful-foo)}}Yes{{/unless}}',
            truthyValue: false,
            falsyValue: true
        };
        testStatefulHelper(assert, options);
    });
    test("helpers passed as arguments to {{#with}} are not torn down when switching between blocks", function (assert) {
        var options = {
            template: '{{#with (stateful-foo) as |unused|}}Yes{{/with}}',
            truthyValue: {},
            falsyValue: null
        };
        testStatefulHelper(assert, options);
    });
    test("helpers passed as arguments to {{#each}} are not torn down when switching between blocks", function (assert) {
        var options = {
            template: '{{#each (stateful-foo) key="@index" as |unused|}}Yes{{/each}}',
            truthyValue: [1],
            falsyValue: null
        };
        testStatefulHelper(assert, options);
    });
    test("helpers passed as arguments to {{partial}} are not torn down when switching between blocks", function (assert) {
        env.registerPartial('yasss', 'Yes');
        env.registerPartial('noooo', '');
        var options = {
            template: '{{partial (stateful-foo)}}',
            truthyValue: 'yasss',
            falsyValue: 'noooo'
        };
        testStatefulHelper(assert, options);
    });
    test("helpers passed as arguments to {{component}} are not torn down when switching between blocks", function (assert) {
        env.registerBasicComponent('x-yasss', _glimmerTestHelpers.BasicComponent, 'Yes');
        var options = {
            template: '{{component (stateful-foo)}}',
            truthyValue: 'x-yasss',
            falsyValue: null
        };
        testStatefulHelper(assert, options);
    });
    test("helpers passed as arguments to {{#-in-element}} are not torn down when switching between blocks", function (assert) {
        var externalElement = document.createElement('div');
        var options = {
            template: '{{#-in-element (stateful-foo)}}Yes{{/-in-element}}',
            truthyValue: externalElement,
            falsyValue: null,
            element: externalElement
        };
        testStatefulHelper(assert, options);
    });
    function testStatefulHelper(assert, _ref) {
        var template = _ref.template;
        var truthyValue = _ref.truthyValue;
        var falsyValue = _ref.falsyValue;
        var _ref$element = _ref.element;
        var element = _ref$element === undefined ? root : _ref$element;

        var didCreate = 0;
        var didDestroy = 0;
        var reference = undefined;
        env.registerInternalHelper('stateful-foo', function (vm, args) {
            didCreate++;
            vm.newDestroyable({
                destroy: function () {
                    didDestroy++;
                }
            });
            return reference = new _glimmerObjectReference.UpdatableReference(truthyValue);
        });
        assert.strictEqual(didCreate, 0, 'didCreate: before render');
        assert.strictEqual(didDestroy, 0, 'didDestroy: before render');
        render(compile(template), {});
        assert.equal(element.textContent, 'Yes', 'initial render');
        assert.strictEqual(didCreate, 1, 'didCreate: after initial render');
        assert.strictEqual(didDestroy, 0, 'didDestroy: after initial render');
        rerender();
        assert.equal(element.textContent, 'Yes', 'after no-op re-render');
        assert.strictEqual(didCreate, 1, 'didCreate: after no-op re-render');
        assert.strictEqual(didDestroy, 0, 'didDestroy: after no-op re-render');
        reference.update(falsyValue);
        rerender();
        assert.strictEqual(element.textContent, '', 'after switching to falsy');
        assert.strictEqual(didCreate, 1, 'didCreate: after switching to falsy');
        assert.strictEqual(didDestroy, 0, 'didDestroy: after switching to falsy');
        reference.update(truthyValue);
        rerender();
        assert.equal(element.textContent, 'Yes', 'after reset');
        assert.strictEqual(didCreate, 1, 'didCreate: after reset');
        assert.strictEqual(didDestroy, 0, 'didDestroy: after reset');
    }
    test("updating a curly with this", function () {
        var object = { value: 'hello world' };
        var template = compile('<div><p>{{this.value}}</p></div>');
        render(template, object);
        var valueNode = root.firstChild.firstChild.firstChild;
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello world</p></div>', "Initial render");
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello world</p></div>', "no change");
        strictEqual(root.firstChild.firstChild.firstChild, valueNode, "The text node was not blown away");
        object.value = 'goodbye world';
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>goodbye world</p></div>', "After updating and dirtying");
        strictEqual(root.firstChild.firstChild.firstChild, valueNode, "The text node was not blown away");
    });
    test("a simple implementation of a dirtying rerender", function () {
        var object = { condition: true, value: 'hello world' };
        var template = compile('<div>{{#if condition}}<p>{{value}}</p>{{else}}<p>Nothing</p>{{/if}}</div>');
        render(template, object);
        var valueNode = root.firstChild.firstChild.firstChild;
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello world</p></div>', "Initial render");
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello world</p></div>', "After dirtying but not updating");
        strictEqual(root.firstChild.firstChild.firstChild, valueNode, "The text node was not blown away");
        // Even though the #if was stable, a dirty child node is updated
        object.value = 'goodbye world';
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>goodbye world</p></div>', "After updating and dirtying");
        strictEqual(root.firstChild.firstChild.firstChild, valueNode, "The text node was not blown away");
        object.condition = false;
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>Nothing</p></div>', "And then dirtying");
        QUnit.notStrictEqual(root.firstChild.firstChild.firstChild, valueNode, "The text node was not blown away");
    });
    test('The if helper should consider an empty array falsy', function () {
        var object = { condition: [], value: 'hello world' };
        var template = compile('<div>{{#if condition}}<p>{{value}}</p>{{else}}<p>Nothing</p>{{/if}}</div>');
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, '<div><p>Nothing</p></div>');
        object.condition.push('thing');
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello world</p></div>', "Initial render");
        object.condition.pop();
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>Nothing</p></div>');
    });
    test("a simple implementation of a dirtying rerender without inverse", function () {
        var object = { condition: true, value: 'hello world' };
        var template = compile('<div>{{#if condition}}<p>{{value}}</p>{{/if}}</div>');
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello world</p></div>', "Initial render");
        object.condition = false;
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><!----></div>', "If the condition is false, the morph becomes empty");
        object.condition = true;
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello world</p></div>', "If the condition is true, the morph repopulates");
    });
    test('The unless helper without inverse', function () {
        var object = { condition: true, value: 'hello world' };
        var template = compile('<div>{{#unless condition}}<p>{{value}}</p>{{/unless}}</div>');
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, '<div><!----></div>', "Initial render");
        object.condition = false;
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello world</p></div>', "If the condition is false, the morph becomes populated");
        object.condition = true;
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><!----></div>', "If the condition is true, the morph unpopulated");
    });
    test('The unless helper with inverse', function () {
        var object = { condition: true, value: 'hello world' };
        var template = compile('<div>{{#unless condition}}<p>{{value}}</p>{{else}}<p>Nothing</p>{{/unless}}</div>');
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, '<div><p>Nothing</p></div>', "Initial render");
        object.condition = false;
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello world</p></div>', "If the condition is false, the default renders");
        object.condition = true;
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>Nothing</p></div>', "If the condition is true, the inverse renders");
    });
    test('The unless helper should consider an empty array falsy', function () {
        var object = { condition: [], value: 'hello world' };
        var template = compile('<div>{{#unless condition}}<p>{{value}}</p>{{else}}<p>Nothing</p>{{/unless}}</div>');
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello world</p></div>', "Initial render");
        object.condition.push(1);
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>Nothing</p></div>', "If the condition is true, the inverse renders");
        object.condition.pop();
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello world</p></div>', "If the condition is false, the default renders");
    });
    test("a conditional that is false on the first run", function (assert) {
        var object = { condition: false, value: 'hello world' };
        var template = compile('<div>{{#if condition}}<p>{{value}}</p>{{/if}}</div>');
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, '<div><!----></div>', "Initial render");
        object.condition = true;
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><p>hello world</p></div>', "If the condition is true, the morph populates");
        object.condition = false;
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div><!----></div>', "If the condition is false, the morph is empty");
    });
    test("block arguments", function (assert) {
        var template = compile("<div>{{#with person.name.first as |f|}}{{f}}{{/with}}</div>");
        var object = { person: { name: { first: "Godfrey", last: "Chan" } } };
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, '<div>Godfrey</div>', "Initial render");
        object.person.name.first = "Godfreak";
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div>Godfreak</div>', "After updating");
        rerender({ person: { name: { first: "Godfrey", last: "Chan" } } });
        _glimmerTestHelpers.equalTokens(root, '<div>Godfrey</div>', "After reset");
    });
    test("block arguments should have higher presedence than helpers", function (assert) {
        env.registerHelper('foo', function () {
            return 'foo-helper';
        });
        env.registerHelper('bar', function () {
            return 'bar-helper';
        });
        env.registerHelper('echo', function (args) {
            return args[0];
        });
        var template = compile(_glimmerTestHelpers.trimLines(_templateObject4));
        var object = { foo: 'foo-value', bar: 'bar-value', value: 'value-value' };
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, _glimmerTestHelpers.trimLines(_templateObject5), 'Initial render');
        rerender();
        _glimmerTestHelpers.equalTokens(root, _glimmerTestHelpers.trimLines(_templateObject5), 'After no-op re-render');
        object.value = 'NEW-VALUE';
        rerender();
        _glimmerTestHelpers.equalTokens(root, _glimmerTestHelpers.trimLines(_templateObject6), 'After update');
        rerender({ foo: 'foo-value', bar: 'bar-value', value: 'value-value' });
        _glimmerTestHelpers.equalTokens(root, _glimmerTestHelpers.trimLines(_templateObject5), 'After reset');
    });
    test("block arguments (ensure balanced push/pop)", function (assert) {
        var template = compile("<div>{{#with person.name.first as |f|}}{{f}}{{/with}}{{f}}</div>");
        var object = { person: { name: { first: "Godfrey", last: "Chan" } }, f: "Outer" };
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, '<div>GodfreyOuter</div>', "Initial render");
        object.person.name.first = "Godfreak";
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div>GodfreakOuter</div>', "After updating");
    });
    test("block arguments cannot be accessed through {{this}}", function (assert) {
        env.registerHelper('noop', function (params) {
            return params[0];
        });
        var template = compile(_glimmerTestHelpers.stripTight(_templateObject7));
        var object = { person: "Yehuda", name: "Godfrey" };
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, '<div>[Godfrey][Godfrey][Godfrey]</div>', "Initial render");
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div>[Godfrey][Godfrey][Godfrey]</div>', "Initial render");
        object.name = "Godfreak";
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div>[Godfreak][Godfreak][Godfreak]</div>', "After update");
        object.name = "Godfrey";
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div>[Godfrey][Godfrey][Godfrey]</div>', "After reset");
    });
    test("The with helper should consider an empty array falsy", function (assert) {
        var object = { condition: [] };
        var template = compile("<div>{{#with condition as |c|}}{{c.length}}{{/with}}</div>");
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, '<div><!----></div>', "Initial render");
        object.condition.push(1);
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div>1</div>', "After updating");
    });
    test("block helpers whose template has a morph at the edge", function () {
        var template = compile("{{#identity}}{{value}}{{/identity}}");
        var object = { value: "hello world" };
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, 'hello world');
        var firstNode = result.firstNode();
        equal(firstNode.nodeType, 3, "the first node of the helper should be a text node");
        equal(firstNode.nodeValue, "hello world", "its content should be hello world");
        strictEqual(firstNode.nextSibling, null, "there should only be one nodes");
    });
    function assertInvariants(result, msg) {
        strictEqual(result.firstNode(), root.firstChild, "The firstNode of the result is the same as the root's firstChild" + (msg ? ': ' + msg : ''));
        strictEqual(result.lastNode(), root.lastChild, "The lastNode of the result is the same as the root's lastChild" + (msg ? ': ' + msg : ''));
    }
    test("clean content doesn't get blown away", function () {
        var template = compile("<div>{{value}}</div>");
        var object = { value: "hello" };
        render(template, object);
        var textNode = result.firstNode().firstChild;
        equal(textNode.nodeValue, "hello");
        object.value = "goodbye";
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div>goodbye</div>');
        object.value = "hello";
        rerender();
        textNode = root.firstChild.firstChild;
        equal(textNode.nodeValue, "hello");
    });
    test("helper calls follow the normal dirtying rules", function () {
        env.registerHelper('capitalize', function (params) {
            return params[0].toUpperCase();
        });
        var template = compile("<div>{{capitalize value}}</div>");
        var object = { value: "hello" };
        render(template, object);
        var textNode = result.firstNode().firstChild;
        equal(textNode.nodeValue, "HELLO");
        object.value = "goodbye";
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div>GOODBYE</div>');
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div>GOODBYE</div>');
        // Checks normalized value, not raw value
        object.value = "GoOdByE";
        rerender();
        textNode = root.firstChild.firstChild;
        equal(textNode.nodeValue, "GOODBYE");
    });
    test("class attribute follow the normal dirtying rules", function () {
        var template = compile("<div class='{{value}}'>hello</div>");
        var object = { value: "world" };
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, "<div class='world'>hello</div>", "Initial render");
        object.value = "universe";
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div class='universe'>hello</div>", "Revalidating without dirtying");
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div class='universe'>hello</div>", "Revalidating after dirtying");
        object.value = "world";
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div class='world'>hello</div>", "Revalidating after dirtying");
    });
    test("class attribute w/ concat follow the normal dirtying rules", function () {
        var template = compile("<div class='hello {{value}}'>hello</div>");
        var object = { value: "world" };
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, "<div class='hello world'>hello</div>");
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div class='hello world'>hello</div>");
        object.value = "universe";
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div class='hello universe'>hello</div>");
        object.value = null;
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div class='hello '>hello</div>");
        object.value = "world";
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div class='hello world'>hello</div>");
    });
    test("class attribute is removed if the binding becomes null or undefined", function () {
        var template = compile("<div class={{value}}>hello</div>");
        var object = { value: "foo" };
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, "<div class='foo'>hello</div>");
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div class='foo'>hello</div>");
        object.value = null;
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div>hello</div>");
        object.value = 0;
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div class='0'>hello</div>");
        object.value = undefined;
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div>hello</div>");
        object.value = 'foo';
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div class='foo'>hello</div>");
    });
    test("attribute nodes follow the normal dirtying rules", function () {
        var template = compile("<div data-value='{{value}}'>hello</div>");
        var object = { value: "world" };
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, "<div data-value='world'>hello</div>", "Initial render");
        object.value = "universe";
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div data-value='universe'>hello</div>", "Revalidating without dirtying");
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div data-value='universe'>hello</div>", "Revalidating after dirtying");
        object.value = null;
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div>hello</div>", "Revalidating after dirtying");
        object.value = "world";
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div data-value='world'>hello</div>", "Revalidating after dirtying");
    });
    test("attribute nodes w/ concat follow the normal dirtying rules", function () {
        var template = compile("<div data-value='hello {{value}}'>hello</div>");
        var object = { value: "world" };
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, "<div data-value='hello world'>hello</div>");
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div data-value='hello world'>hello</div>");
        object.value = "universe";
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div data-value='hello universe'>hello</div>");
        object.value = null;
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div data-value='hello '>hello</div>");
        object.value = "world";
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div data-value='hello world'>hello</div>");
    });
    test("attributes values are normalized correctly", function () {
        var template = compile("<div data-value={{value}}>hello</div>");
        var object = { value: { toString: function () {
                    return "world";
                } } };
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, "<div data-value='world'>hello</div>", "Initial render");
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div data-value='world'>hello</div>", "Initial render");
        object.value = 123;
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div data-value='123'>hello</div>", "Revalidating without dirtying");
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div data-value='123'>hello</div>", "Revalidating after dirtying");
        object.value = false;
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div>hello</div>", "Revalidating after dirtying");
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div>hello</div>", "Revalidating after dirtying");
        object.value = { toString: function () {
                return "world";
            } };
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div data-value='world'>hello</div>", "Revalidating after dirtying");
    });
    if (serializesNSAttributesCorrectly) {
        test("namespaced attribute nodes follow the normal dirtying rules", function () {
            var template = compile("<div xml:lang='{{lang}}'>hello</div>");
            var object = { lang: "en-us" };
            render(template, object);
            _glimmerTestHelpers.equalTokens(root, "<div xml:lang='en-us'>hello</div>", "Initial render");
            object.lang = "en-uk";
            rerender();
            _glimmerTestHelpers.equalTokens(root, "<div xml:lang='en-uk'>hello</div>", "Revalidating without dirtying");
            rerender();
            _glimmerTestHelpers.equalTokens(root, "<div xml:lang='en-uk'>hello</div>", "Revalidating after dirtying");
        });
        test("namespaced attribute nodes w/ concat follow the normal dirtying rules", function () {
            var template = compile("<div xml:lang='en-{{locale}}'>hello</div>");
            var object = { locale: "us" };
            render(template, object);
            _glimmerTestHelpers.equalTokens(root, "<div xml:lang='en-us'>hello</div>", "Initial render");
            rerender();
            _glimmerTestHelpers.equalTokens(root, "<div xml:lang='en-us'>hello</div>", "No-op rerender");
            object.locale = "uk";
            rerender();
            _glimmerTestHelpers.equalTokens(root, "<div xml:lang='en-uk'>hello</div>", "After update");
            object.locale = null;
            rerender();
            _glimmerTestHelpers.equalTokens(root, "<div xml:lang='en-'>hello</div>", "After updating to null");
            object.locale = "us";
            rerender();
            _glimmerTestHelpers.equalTokens(root, "<div xml:lang='en-us'>hello</div>", "After reset");
        });
    }
    test("non-standard namespaced attribute nodes follow the normal dirtying rules", function () {
        var template = compile("<div epub:type='{{type}}'>hello</div>");
        var object = { type: "dedication" };
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, "<div epub:type='dedication'>hello</div>", "Initial render");
        object.type = "backmatter";
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div epub:type='backmatter'>hello</div>", "Revalidating without dirtying");
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div epub:type='backmatter'>hello</div>", "Revalidating after dirtying");
    });
    test("non-standard namespaced attribute nodes w/ concat follow the normal dirtying rules", function () {
        var template = compile("<div epub:type='dedication {{type}}'>hello</div>");
        var object = { type: "backmatter" };
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, "<div epub:type='dedication backmatter'>hello</div>", "Initial render");
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div epub:type='dedication backmatter'>hello</div>", "No-op rerender");
        object.type = "index";
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div epub:type='dedication index'>hello</div>", "After update");
        object.type = null;
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div epub:type='dedication '>hello</div>", "After updating to null");
        object.type = "backmatter";
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div epub:type='dedication backmatter'>hello</div>", "After reset");
    });
    test("<option selected> is normalized and updated correctly", function () {
        function assertSelected(expectedSelected, label) {
            var options = root.querySelectorAll('option');
            var actualSelected = [];
            for (var i = 0; i < options.length; i++) {
                var option = options[i];
                if (option.selected) {
                    actualSelected.push(option.value);
                }
            }
            deepEqual(actualSelected, expectedSelected, label);
        }
        var template = compile("\n    <select multiple>\n      <option>0</option>\n      <option selected={{one}}>1</option>\n      <option selected={{two}}>2</option>\n      <option selected={{three}}>3</option>\n      <option selected={{four}}>4</option>\n      <option selected={{five}}>5</option>\n    </select>");
        var object = {
            one: true,
            two: 'is-true',
            three: undefined,
            four: null,
            five: false
        };
        render(template, object);
        var expectedInitialTokens = "\n    <select multiple=\"\">\n      <option>0</option>\n      <option>1</option>\n      <option>2</option>\n      <option>3</option>\n      <option>4</option>\n      <option>5</option>\n    </select>";
        _glimmerTestHelpers.equalTokens(root, expectedInitialTokens, 'initial render tokens');
        assertSelected(['1', '2'], 'selection after initial render');
        rerender();
        assertSelected(['1', '2'], 'selection after no-op re-render');
        object.one = false;
        object.two = false;
        rerender();
        assertSelected([], 'selection after update to all falsey');
        object.three = true;
        object.four = 'asdf';
        rerender();
        assertSelected(['3', '4'], 'selection after update 3 & 4 to truthy');
        object.three = null;
        object.four = undefined;
        rerender();
        assertSelected([], 'selection after update 3 & 4 back to falsey');
    });
    test("top-level bounds are correct when swapping order", function (assert) {
        var template = compile("{{#each list key='key' as |item|}}{{item.name}}{{/each}}");
        var tom = { key: "1", name: "Tom Dale", "class": "tomdale" };
        var yehuda = { key: "2", name: "Yehuda Katz", "class": "wycats" };
        var object = { list: [tom, yehuda] };
        render(template, object);
        assertInvariants(result, "initial render");
        rerender();
        assertInvariants(result, "after no-op rerender");
        object = { list: [yehuda, tom] };
        rerender(object);
        assertInvariants(result, "after reordering");
        object = { list: [tom] };
        rerender(object);
        assertInvariants(result, "after deleting from the front");
        object = { list: [] };
        rerender(object);
        assertInvariants(result, "after emptying the list");
    });
    test("top-level bounds are correct when toggling conditionals", function (assert) {
        var template = compile("{{#if item}}{{item.name}}{{/if}}");
        var tom = { name: "Tom Dale" };
        var yehuda = { name: "Yehuda Katz" };
        var object = { item: tom };
        render(template, object);
        assertInvariants(result, "initial render");
        rerender();
        assertInvariants(result, "after no-op rerender");
        object = { item: yehuda };
        rerender(object);
        assertInvariants(result, "after replacement");
        object = { item: null };
        rerender(object);
        assertInvariants(result, "after nulling");
    });
    test("top-level bounds are correct when changing innerHTML", function (assert) {
        var template = compile("{{{html}}}");
        var object = { html: "<b>inner</b>-<b>before</b>" };
        render(template, object);
        assertInvariants(result, "initial render");
        rerender();
        assertInvariants(result, "after no-op rerender");
        object = { html: "<p>inner-after</p>" };
        rerender(object);
        assertInvariants(result, "after replacement");
        object = { html: "" };
        rerender(object);
        assertInvariants(result, "after emptying");
    });
    testEachHelper("An implementation of #each using block params", "<ul>{{#each list key='key' as |item|}}<li class='{{item.class}}'>{{item.name}}</li>{{/each}}</ul>");
    testEachHelper("An implementation of #each using a self binding", "<ul>{{#each list}}<li class={{class}}>{{name}}</li>{{/each}}</ul>", QUnit.skip);
    test('The each helper with inverse', function () {
        var object = { list: [] };
        var template = compile("<ul>{{#each list key='name' as |item|}}<li class=\"{{item.class}}\">{{item.name}}</li>{{else}}<li class=\"none\">none</li>{{/each}}</ul>");
        render(template, object);
        var itemNode = getNodeByClassName('none');
        var textNode = getFirstChildOfNode('none');
        _glimmerTestHelpers.equalTokens(root, "<ul><li class=\"none\">none</li></none");
        rerender(object);
        assertStableNodes('none', 'after no-op rerender');
        object = { list: [{ name: 'Foo Bar', class: "foobar" }] };
        rerender(object);
        _glimmerTestHelpers.equalTokens(root, '<ul><li class="foobar">Foo Bar</li></ul>');
        object = { list: [] };
        rerender(object);
        _glimmerTestHelpers.equalTokens(root, '<ul><li class="none">none</li></ul>');
        function assertStableNodes(className, message) {
            strictEqual(getNodeByClassName(className), itemNode, "The item node has not changed " + message);
            strictEqual(getFirstChildOfNode(className), textNode, "The text node has not changed " + message);
        }
    });
    test('The each helper yields the index of the current item current item when using the @index key', function () {
        var tom = { name: "Tom Dale", "class": "tomdale" };
        var yehuda = { name: "Yehuda Katz", "class": "wycats" };
        var object = { list: [tom, yehuda] };
        var template = compile("<ul>{{#each list key='@index' as |item index|}}<li class='{{item.class}}'>{{item.name}}<p class='index-{{index}}'>{{index}}</p></li>{{/each}}</ul>");
        render(template, object);
        var itemNode = getNodeByClassName('tomdale');
        var indexNode = getNodeByClassName('index-0');
        var nameNode = getFirstChildOfNode('tomdale');
        _glimmerTestHelpers.equalTokens(root, "<ul><li class='tomdale'>Tom Dale<p class='index-0'>0</p></li><li class='wycats'>Yehuda Katz<p class='index-1'>1</p></li></ul>", "Initial render");
        rerender();
        assertStableNodes('tomdale', 0, 'after no-op rerender');
        _glimmerTestHelpers.equalTokens(root, "<ul><li class='tomdale'>Tom Dale<p class='index-0'>0</p></li><li class='wycats'>Yehuda Katz<p class='index-1'>1</p></li></ul>", "After no-op render");
        rerender();
        assertStableNodes('tomdale', 0, 'after non-dirty rerender');
        _glimmerTestHelpers.equalTokens(root, "<ul><li class='tomdale'>Tom Dale<p class='index-0'>0</p></li><li class='wycats'>Yehuda Katz<p class='index-1'>1</p></li></ul>", "After non-dirty render");
        object = { list: [yehuda, tom] };
        rerender(object);
        _glimmerTestHelpers.equalTokens(root, "<ul><li class='wycats'>Yehuda Katz<p class='index-0'>0</p></li><li class='tomdale'>Tom Dale<p class='index-1'>1</p></li></ul>", "After changing list order");
        strictEqual(getNodeByClassName("index-0"), indexNode, "The index node has not changed after changing list order");
        object = { list: [{ name: "Martin Muoz", class: "mmun" }, { name: "Kris Selden", class: "krisselden" }] };
        rerender(object);
        assertStableNodes('mmun', 0, "after changing the list entries, but with stable keys");
        _glimmerTestHelpers.equalTokens(root, "<ul><li class='mmun'>Martin Muoz<p class='index-0'>0</p></li><li class='krisselden'>Kris Selden<p class='index-1'>1</p></li></ul>", "After changing the list entries, but with stable keys");
        object = { list: [{ name: "Martin Muoz", class: "mmun" }, { name: "Kristoph Selden", class: "krisselden" }, { name: "Matthew Beale", class: "mixonic" }] };
        rerender(object);
        assertStableNodes('mmun', 0, "after adding an additional entry");
        _glimmerTestHelpers.equalTokens(root, _glimmerTestHelpers.stripTight(_templateObject8), "After adding an additional entry");
        object = { list: [{ name: "Martin Muoz", class: "mmun" }, { name: "Matthew Beale", class: "mixonic" }] };
        rerender(object);
        assertStableNodes('mmun', 0, "after removing the middle entry");
        _glimmerTestHelpers.equalTokens(root, "<ul><li class='mmun'>Martin Muoz<p class='index-0'>0</p></li><li class='mixonic'>Matthew Beale<p class='index-1'>1</p></li></ul>", "after removing the middle entry");
        object = { list: [{ name: "Martin Muoz", class: "mmun" }, { name: "Stefan Penner", class: "stefanpenner" }, { name: "Robert Jackson", class: "rwjblue" }] };
        rerender(object);
        assertStableNodes('mmun', 0, "after adding two more entries");
        _glimmerTestHelpers.equalTokens(root, _glimmerTestHelpers.stripTight(_templateObject9), "After adding two more entries");
        // New node for stability check
        itemNode = getNodeByClassName('rwjblue');
        nameNode = getFirstChildOfNode('rwjblue');
        indexNode = getNodeByClassName('index-2');
        object = { list: [{ name: "Robert Jackson", class: "rwjblue" }] };
        rerender(object);
        _glimmerTestHelpers.equalTokens(root, "<ul><li class='rwjblue'>Robert Jackson<p class='index-0'>0</p></li></ul>", "After removing two entries");
        object = { list: [{ name: "Martin Muoz", class: "mmun" }, { name: "Stefan Penner", class: "stefanpenner" }, { name: "Robert Jackson", class: "rwjblue" }] };
        rerender(object);
        _glimmerTestHelpers.equalTokens(root, _glimmerTestHelpers.stripTight(_templateObject9), "After adding back entries");
        // New node for stability check
        itemNode = getNodeByClassName('mmun');
        nameNode = getFirstChildOfNode('mmun');
        indexNode = getNodeByClassName('index-0');
        object = { list: [{ name: "Martin Muoz", class: "mmun" }] };
        rerender(object);
        assertStableNodes('mmun', 0, "after removing from the back");
        _glimmerTestHelpers.equalTokens(root, "<ul><li class='mmun'>Martin Muoz<p class='index-0'>0</p></li></ul>", "After removing from the back");
        object = { list: [] };
        rerender(object);
        strictEqual(root.firstChild.firstChild.nodeType, 8, "there are no li's after removing the remaining entry");
        _glimmerTestHelpers.equalTokens(root, "<ul><!----></ul>", "After removing the remaining entries");
        function assertStableNodes(className, index, message) {
            strictEqual(getNodeByClassName(className), itemNode, "The item node has not changed " + message);
            strictEqual(getNodeByClassName("index-" + index), indexNode, "The index node has not changed " + message);
            strictEqual(getFirstChildOfNode(className), nameNode, "The name node has not changed " + message);
        }
    });
    test('The each helper yields the index of the current item when using a non-@index key', function () {
        var tom = { key: "1", name: "Tom Dale", class: "tomdale" };
        var yehuda = { key: "2", name: "Yehuda Katz", class: "wycats" };
        var object = { list: [tom, yehuda] };
        var template = compile("<ul>{{#each list key='key' as |item index|}}<li class='{{item.class}}'>{{item.name}}<p class='index-{{index}}'>{{index}}</p></li>{{/each}}</ul>");
        render(template, object);
        var itemNode = getNodeByClassName('tomdale');
        var indexNode = getNodeByClassName('index-0');
        var nameNode = getFirstChildOfNode('tomdale');
        _glimmerTestHelpers.equalTokens(root, "<ul><li class='tomdale'>Tom Dale<p class='index-0'>0</p></li><li class='wycats'>Yehuda Katz<p class='index-1'>1</p></li></ul>", "Initial render");
        rerender();
        assertStableNodes('tomdale', 0, 'after no-op rerender');
        _glimmerTestHelpers.equalTokens(root, "<ul><li class='tomdale'>Tom Dale<p class='index-0'>0</p></li><li class='wycats'>Yehuda Katz<p class='index-1'>1</p></li></ul>", "After no-op render");
        rerender();
        assertStableNodes('tomdale', 0, 'after non-dirty rerender');
        _glimmerTestHelpers.equalTokens(root, "<ul><li class='tomdale'>Tom Dale<p class='index-0'>0</p></li><li class='wycats'>Yehuda Katz<p class='index-1'>1</p></li></ul>", "After non-dirty render");
        object = { list: [yehuda, tom] };
        rerender(object);
        _glimmerTestHelpers.equalTokens(root, "<ul><li class='wycats'>Yehuda Katz<p class='index-0'>0</p></li><li class='tomdale'>Tom Dale<p class='index-1'>1</p></li></ul>", "After changing list order");
        strictEqual(getNodeByClassName('index-1'), indexNode, "The index node has been moved after changing list order");
        object = { list: [{ key: "1", name: "Martin Muoz", class: "mmun" }, { key: "2", name: "Kris Selden", class: "krisselden" }] };
        rerender(object);
        assertStableNodes('mmun', 0, "after changing the list entries, but with stable keys");
        _glimmerTestHelpers.equalTokens(root, "<ul><li class='mmun'>Martin Muoz<p class='index-0'>0</p></li><li class='krisselden'>Kris Selden<p class='index-1'>1</p></li></ul>", "After changing the list entries, but with stable keys");
        object = { list: [{ key: "1", name: "Martin Muoz", class: "mmun" }, { key: "2", name: "Kristoph Selden", class: "krisselden" }, { key: "3", name: "Matthew Beale", class: "mixonic" }] };
        rerender(object);
        assertStableNodes('mmun', 0, "after adding an additional entry");
        _glimmerTestHelpers.equalTokens(root, _glimmerTestHelpers.stripTight(_templateObject8), "After adding an additional entry");
        object = { list: [{ key: "1", name: "Martin Muoz", class: "mmun" }, { key: "3", name: "Matthew Beale", class: "mixonic" }] };
        rerender(object);
        assertStableNodes('mmun', 0, "after removing the middle entry");
        _glimmerTestHelpers.equalTokens(root, "<ul><li class='mmun'>Martin Muoz<p class='index-0'>0</p></li><li class='mixonic'>Matthew Beale<p class='index-1'>1</p></li></ul>", "after removing the middle entry");
        object = { list: [{ key: "1", name: "Martin Muoz", class: "mmun" }, { key: "4", name: "Stefan Penner", class: "stefanpenner" }, { key: "5", name: "Robert Jackson", class: "rwjblue" }] };
        rerender(object);
        assertStableNodes('mmun', 0, "after adding two more entries");
        _glimmerTestHelpers.equalTokens(root, _glimmerTestHelpers.stripTight(_templateObject9), "After adding two more entries");
        // New node for stability check
        itemNode = getNodeByClassName('rwjblue');
        nameNode = getFirstChildOfNode('rwjblue');
        indexNode = getNodeByClassName('index-2');
        object = { list: [{ key: "5", name: "Robert Jackson", class: "rwjblue" }] };
        rerender(object);
        assertStableNodes('rwjblue', 0, "after removing two entries");
        _glimmerTestHelpers.equalTokens(root, "<ul><li class='rwjblue'>Robert Jackson<p class='index-0'>0</p></li></ul>", "After removing two entries");
        object = { list: [{ key: "1", name: "Martin Muoz", class: "mmun" }, { key: "4", name: "Stefan Penner", class: "stefanpenner" }, { key: "5", name: "Robert Jackson", class: "rwjblue" }] };
        rerender(object);
        assertStableNodes('rwjblue', 2, "after adding back entries");
        _glimmerTestHelpers.equalTokens(root, _glimmerTestHelpers.stripTight(_templateObject9), "After adding back entries");
        // New node for stability check
        itemNode = getNodeByClassName('mmun');
        nameNode = getFirstChildOfNode('mmun');
        indexNode = getNodeByClassName('index-0');
        object = { list: [{ key: "1", name: "Martin Muoz", class: "mmun" }] };
        rerender(object);
        assertStableNodes('mmun', 0, "after removing from the back");
        _glimmerTestHelpers.equalTokens(root, "<ul><li class='mmun'>Martin Muoz<p class='index-0'>0</p></li></ul>", "After removing from the back");
        object = { list: [] };
        rerender(object);
        strictEqual(root.firstChild.firstChild.nodeType, 8, "there are no li's after removing the remaining entry");
        _glimmerTestHelpers.equalTokens(root, "<ul><!----></ul>", "After removing the remaining entries");
        function assertStableNodes(className, index, message) {
            strictEqual(getNodeByClassName(className), itemNode, "The item node has not changed " + message);
            strictEqual(getNodeByClassName("index-" + index), indexNode, "The index node has not changed " + message);
            strictEqual(getFirstChildOfNode(className), nameNode, "The name node has not changed " + message);
        }
    });
    // TODO: port https://github.com/emberjs/ember.js/pull/14082
    function testEachHelper(testName, templateSource) {
        var testMethod = arguments.length <= 2 || arguments[2] === undefined ? QUnit.test : arguments[2];

        testMethod(testName, function () {
            var template = compile(templateSource);
            var tom = { key: "1", name: "Tom Dale", class: "tomdale" };
            var yehuda = { key: "2", name: "Yehuda Katz", class: "wycats" };
            var object = { list: [tom, yehuda] };
            render(template, object);
            var itemNode = getNodeByClassName('tomdale');
            var nameNode = getFirstChildOfNode('tomdale');
            _glimmerTestHelpers.equalTokens(root, "<ul><li class='tomdale'>Tom Dale</li><li class='wycats'>Yehuda Katz</li></ul>", "Initial render");
            rerender();
            assertStableNodes('tomdale', "after no-op rerender");
            _glimmerTestHelpers.equalTokens(root, "<ul><li class='tomdale'>Tom Dale</li><li class='wycats'>Yehuda Katz</li></ul>", "After no-op re-render");
            rerender();
            assertStableNodes('tomdale', "after non-dirty rerender");
            _glimmerTestHelpers.equalTokens(root, "<ul><li class='tomdale'>Tom Dale</li><li class='wycats'>Yehuda Katz</li></ul>", "After non-dirty re-render");
            object = { list: [yehuda, tom] };
            rerender(object);
            assertStableNodes('tomdale', "after changing the list order");
            _glimmerTestHelpers.equalTokens(root, "<ul><li class='wycats'>Yehuda Katz</li><li class='tomdale'>Tom Dale</li></ul>", "After changing the list order");
            object = { list: [{ key: "1", name: "Martin Muoz", "class": "mmun" }, { key: "2", name: "Kris Selden", "class": "krisselden" }] };
            rerender(object);
            assertStableNodes('mmun', "after changing the list entries, but with stable keys");
            _glimmerTestHelpers.equalTokens(root, "<ul><li class='mmun'>Martin Muoz</li><li class='krisselden'>Kris Selden</li></ul>", "After changing the list entries, but with stable keys");
            object = { list: [{ key: "1", name: "Martin Muoz", "class": "mmun" }, { key: "2", name: "Kristoph Selden", "class": "krisselden" }, { key: "3", name: "Matthew Beale", "class": "mixonic" }] };
            rerender(object);
            assertStableNodes('mmun', "after adding an additional entry");
            _glimmerTestHelpers.equalTokens(root, _glimmerTestHelpers.stripTight(_templateObject10), "After adding an additional entry");
            object = { list: [{ key: "1", name: "Martin Muoz", "class": "mmun" }, { key: "3", name: "Matthew Beale", "class": "mixonic" }] };
            rerender(object);
            assertStableNodes('mmun', "after removing the middle entry");
            _glimmerTestHelpers.equalTokens(root, "<ul><li class='mmun'>Martin Muoz</li><li class='mixonic'>Matthew Beale</li></ul>", "after removing the middle entry");
            object = { list: [{ key: "1", name: "Martin Muoz", "class": "mmun" }, { key: "4", name: "Stefan Penner", "class": "stefanpenner" }, { key: "5", name: "Robert Jackson", "class": "rwjblue" }] };
            rerender(object);
            assertStableNodes('mmun', "after adding two more entries");
            _glimmerTestHelpers.equalTokens(root, _glimmerTestHelpers.stripTight(_templateObject11), "After adding two more entries");
            // New node for stability check
            itemNode = getNodeByClassName('rwjblue');
            nameNode = getFirstChildOfNode('rwjblue');
            object = { list: [{ key: "5", name: "Robert Jackson", "class": "rwjblue" }] };
            rerender(object);
            assertStableNodes('rwjblue', "after removing two entries");
            _glimmerTestHelpers.equalTokens(root, "<ul><li class='rwjblue'>Robert Jackson</li></ul>", "After removing two entries");
            object = { list: [{ key: "1", name: "Martin Muoz", "class": "mmun" }, { key: "4", name: "Stefan Penner", "class": "stefanpenner" }, { key: "5", name: "Robert Jackson", "class": "rwjblue" }] };
            rerender(object);
            assertStableNodes('rwjblue', "after adding back entries");
            _glimmerTestHelpers.equalTokens(root, _glimmerTestHelpers.stripTight(_templateObject11), "After adding back entries");
            // New node for stability check
            itemNode = getNodeByClassName('mmun');
            nameNode = getFirstChildOfNode('mmun');
            object = { list: [{ key: "1", name: "Martin Muoz", "class": "mmun" }] };
            rerender(object);
            assertStableNodes('mmun', "after removing from the back");
            _glimmerTestHelpers.equalTokens(root, "<ul><li class='mmun'>Martin Muoz</li></ul>", "After removing from the back");
            object = { list: [] };
            rerender(object);
            strictEqual(root.firstChild.firstChild.nodeType, 8, "there are no li's after removing the remaining entry");
            _glimmerTestHelpers.equalTokens(root, "<ul><!----></ul>", "After removing the remaining entries");
            function assertStableNodes(className, message) {
                strictEqual(getNodeByClassName(className), itemNode, "The item node has not changed " + message);
                strictEqual(getFirstChildOfNode(className), nameNode, "The name node has not changed " + message);
            }
        });
    }
    var destroyedRenderNodeCount = undefined;
    var destroyedRenderNode = undefined;
    QUnit.module("HTML-based compiler (dirtying) - pruning", {
        setup: function () {
            commonSetup();
            destroyedRenderNodeCount = 0;
            destroyedRenderNode = null;
            hooks.destroyRenderNode = function (renderNode) {
                destroyedRenderNode = renderNode;
                destroyedRenderNodeCount++;
            };
        }
    });
    QUnit.skip("Pruned render nodes invoke a cleanup hook when replaced", function () {
        var object = { condition: true, value: 'hello world', falsy: "Nothing" };
        var template = compile('<div>{{#if condition}}<p>{{value}}</p>{{else}}<p>{{falsy}}</p>{{/if}}</div>');
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, "<div><p>hello world</p></div>");
        object.condition = false;
        rerender();
        strictEqual(destroyedRenderNodeCount, 1, "cleanup hook was invoked once");
        strictEqual(destroyedRenderNode.lastValue, 'hello world', "The correct render node is passed in");
        object.condition = true;
        rerender();
        strictEqual(destroyedRenderNodeCount, 2, "cleanup hook was invoked again");
        strictEqual(destroyedRenderNode.lastValue, 'Nothing', "The correct render node is passed in");
    });
    QUnit.skip("MorphLists in childMorphs are properly cleared", function () {
        var object = {
            condition: true,
            falsy: "Nothing",
            list: [{ key: "1", word: 'Hello' }, { key: "2", word: 'World' }]
        };
        var template = compile('<div>{{#if condition}}{{#each list as |item|}}<p>{{item.word}}</p>{{/each}}{{else}}<p>{{falsy}}</p>{{/if}}</div>');
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, "<div><p>Hello</p><p>World</p></div>");
        object.condition = false;
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div><p>Nothing</p></div>");
        strictEqual(destroyedRenderNodeCount, 5, "cleanup hook was invoked for each morph");
        object.condition = true;
        rerender();
        strictEqual(destroyedRenderNodeCount, 6, "cleanup hook was invoked again");
    });
    QUnit.skip("Pruned render nodes invoke a cleanup hook when cleared", function () {
        var object = { condition: true, value: 'hello world' };
        var template = compile('<div>{{#if condition}}<p>{{value}}</p>{{/if}}</div>');
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, "<div><p>hello world</p></div>");
        object.condition = false;
        rerender();
        strictEqual(destroyedRenderNodeCount, 1, "cleanup hook was invoked once");
        strictEqual(destroyedRenderNode.lastValue, 'hello world', "The correct render node is passed in");
        object.condition = true;
        rerender();
        strictEqual(destroyedRenderNodeCount, 1, "cleanup hook was not invoked again");
    });
    QUnit.skip("Pruned lists invoke a cleanup hook when removing elements", function () {
        var object = { list: [{ key: "1", word: "hello" }, { key: "2", word: "world" }] };
        var template = compile('<div>{{#each list as |item|}}<p>{{item.word}}</p>{{/each}}</div>');
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, "<div><p>hello</p><p>world</p></div>");
        object.list.pop();
        rerender();
        strictEqual(destroyedRenderNodeCount, 2, "cleanup hook was invoked once for the wrapper morph and once for the {{item.word}}");
        strictEqual(destroyedRenderNode.lastValue, "world", "The correct render node is passed in");
        object.list.pop();
        rerender();
        strictEqual(destroyedRenderNodeCount, 4, "cleanup hook was invoked once for the wrapper morph and once for the {{item.word}}");
        strictEqual(destroyedRenderNode.lastValue, "hello", "The correct render node is passed in");
    });
    QUnit.skip("Pruned lists invoke a cleanup hook on their subtrees when removing elements", function () {
        var object = { list: [{ key: "1", word: "hello" }, { key: "2", word: "world" }] };
        var template = compile('<div>{{#each list as |item|}}<p>{{#if item.word}}{{item.word}}{{/if}}</p>{{/each}}</div>');
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, "<div><p>hello</p><p>world</p></div>");
        object.list.pop();
        rerender();
        strictEqual(destroyedRenderNodeCount, 3, "cleanup hook was invoked once for the wrapper morph and once for the {{item.word}}");
        strictEqual(destroyedRenderNode.lastValue, "world", "The correct render node is passed in");
        object.list.pop();
        rerender();
        strictEqual(destroyedRenderNodeCount, 6, "cleanup hook was invoked once for the wrapper morph and once for the {{item.word}}");
        strictEqual(destroyedRenderNode.lastValue, "hello", "The correct render node is passed in");
    });
    QUnit.module("Updating SVG", {
        setup: commonSetup
    });
    test("HTML namespace from root element is continued to child templates", function () {
        var object = { hasCircle: true };
        var getSvg = function () {
            return root.firstChild;
        };
        var getCircle = function () {
            return getSvg().firstChild;
        };
        var template = compile('<svg>{{#if hasCircle}}<circle />{{/if}}</svg>');
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, "<svg><circle /></svg>");
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        equal(getCircle().namespaceURI, SVG_NAMESPACE);
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<svg><circle /></svg>");
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        equal(getCircle().namespaceURI, SVG_NAMESPACE);
        object.hasCircle = false;
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<svg><!----></svg>");
        rerender({ hasCircle: true });
        _glimmerTestHelpers.equalTokens(root, "<svg><circle /></svg>");
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        equal(getCircle().namespaceURI, SVG_NAMESPACE);
    });
    test("root <foreignObject> tag is SVG namespaced", function () {
        var object = { hasForeignObject: true };
        var getForeignObject = function () {
            return root.firstChild;
        };
        var getDiv = function () {
            return getForeignObject().firstChild;
        };
        var template = compile('{{#if hasForeignObject}}<foreignObject><div></div></foreignObject>{{/if}}');
        // Add an SVG node on the root that can be rendered into
        root.appendChild(env.getDOM().createElement('svg'));
        root = root.firstChild;
        render(template, object);
        _glimmerTestHelpers.equalTokens(root.parentNode, "<svg><foreignObject><div></div></foreignObject></svg>");
        equal(getForeignObject().namespaceURI, SVG_NAMESPACE);
        equal(getDiv().namespaceURI, XHTML_NAMESPACE);
        rerender();
        _glimmerTestHelpers.equalTokens(root.parentNode, "<svg><foreignObject><div></div></foreignObject></svg>");
        equal(getForeignObject().namespaceURI, SVG_NAMESPACE);
        equal(getDiv().namespaceURI, XHTML_NAMESPACE);
        object.hasForeignObject = false;
        rerender();
        _glimmerTestHelpers.equalTokens(root.parentNode, "<svg><!----></svg>");
        rerender({ hasForeignObject: true });
        _glimmerTestHelpers.equalTokens(root.parentNode, "<svg><foreignObject><div></div></foreignObject></svg>");
        equal(getForeignObject().namespaceURI, SVG_NAMESPACE);
        equal(getDiv().namespaceURI, XHTML_NAMESPACE);
    });
    test("elements nested inside <foreignObject> have an XHTML namespace", function () {
        var object = { hasDiv: true };
        var getSvg = function () {
            return root.firstChild;
        };
        var getForeignObject = function () {
            return getSvg().firstChild;
        };
        var getDiv = function () {
            return getForeignObject().firstChild;
        };
        var template = compile('<svg><foreignObject>{{#if hasDiv}}<div></div>{{/if}}</foreignObject></svg>');
        render(template, object);
        _glimmerTestHelpers.equalTokens(root, "<svg><foreignObject><div></div></foreignObject></svg>");
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        equal(getForeignObject().namespaceURI, SVG_NAMESPACE);
        equal(getDiv().namespaceURI, XHTML_NAMESPACE);
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<svg><foreignObject><div></div></foreignObject></svg>");
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        equal(getForeignObject().namespaceURI, SVG_NAMESPACE);
        equal(getDiv().namespaceURI, XHTML_NAMESPACE);
        object.hasDiv = false;
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<svg><foreignObject><!----></foreignObject></svg>");
        rerender({ hasDiv: true });
        _glimmerTestHelpers.equalTokens(root, "<svg><foreignObject><div></div></foreignObject></svg>");
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        equal(getForeignObject().namespaceURI, SVG_NAMESPACE);
        equal(getDiv().namespaceURI, XHTML_NAMESPACE);
    });
    test("Namespaced attribute with a quoted expression", function () {
        var title = 'svg-title';
        var context = { title: title };
        var getSvg = function () {
            return root.firstChild;
        };
        var getXlinkAttr = function () {
            return getSvg().attributes[0];
        };
        var template = compile('<svg xlink:title="{{title}}">content</svg>');
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, "<svg xlink:title=\"" + title + "\">content</svg>");
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        equal(getXlinkAttr().namespaceURI, XLINK_NAMESPACE);
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<svg xlink:title=\"" + title + "\">content</svg>");
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        equal(getXlinkAttr().namespaceURI, XLINK_NAMESPACE);
        context.title = 'mmun';
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<svg xlink:title=\"" + context.title + "\">content</svg>");
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        equal(getXlinkAttr().namespaceURI, XLINK_NAMESPACE);
        rerender({ title: title });
        _glimmerTestHelpers.equalTokens(root, "<svg xlink:title=\"" + title + "\">content</svg>");
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        equal(getXlinkAttr().namespaceURI, XLINK_NAMESPACE);
    });
    test("<svg> tag and expression as sibling", function () {
        var name = 'svg-title';
        var context = { name: name };
        var getSvg = function () {
            return root.firstChild;
        };
        var template = compile('<svg></svg>{{name}}');
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, "<svg></svg>" + name);
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<svg></svg>" + name);
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        context.name = null;
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<svg></svg>");
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        rerender({ name: name });
        _glimmerTestHelpers.equalTokens(root, "<svg></svg>" + name);
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
    });
    test("<svg> tag and unsafe expression as sibling", function () {
        var name = '<i>Biff</i>';
        var context = { name: name };
        var getSvg = function () {
            return root.firstChild;
        };
        var getItalic = function () {
            return root.lastChild;
        };
        var template = compile('<svg></svg>{{{name}}}');
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, "<svg></svg>" + name);
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        equal(getItalic().namespaceURI, XHTML_NAMESPACE);
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<svg></svg>" + name);
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        equal(getItalic().namespaceURI, XHTML_NAMESPACE);
        context.name = 'ef4';
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<svg></svg>" + context.name);
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        rerender({ name: name });
        _glimmerTestHelpers.equalTokens(root, "<svg></svg>" + name);
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        equal(getItalic().namespaceURI, XHTML_NAMESPACE);
    });
    test("unsafe expression nested inside a namespace", function () {
        var content = '<path></path>';
        var context = { content: content };
        var getSvg = function () {
            return root.firstChild;
        };
        var getPath = function () {
            return getSvg().firstChild;
        };
        var getDiv = function () {
            return root.lastChild;
        };
        var template = compile('<svg>{{{content}}}</svg><div></div>');
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, "<svg>" + content + "</svg><div></div>");
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        equal(getDiv().namespaceURI, XHTML_NAMESPACE);
        equal(getPath().namespaceURI, SVG_NAMESPACE, 'initial render path has SVG namespace');
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<svg>" + content + "</svg><div></div>");
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        equal(getDiv().namespaceURI, XHTML_NAMESPACE);
        equal(getPath().namespaceURI, SVG_NAMESPACE, 'path has SVG namespace');
        context.content = '<foreignObject><span></span></foreignObject>';
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<svg>" + context.content + "</svg><div></div>");
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        equal(getDiv().namespaceURI, XHTML_NAMESPACE);
        equal(getSvg().firstChild.namespaceURI, SVG_NAMESPACE, 'foreignObject has SVG NS');
        equal(getSvg().firstChild.firstChild.namespaceURI, XHTML_NAMESPACE, 'span has XHTML NS');
        context.content = '<path></path><circle></circle>';
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<svg>" + context.content + "</svg><div></div>");
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        equal(getDiv().namespaceURI, XHTML_NAMESPACE);
        equal(getSvg().firstChild.namespaceURI, SVG_NAMESPACE);
        equal(getSvg().lastChild.namespaceURI, SVG_NAMESPACE);
        rerender({ content: content });
        _glimmerTestHelpers.equalTokens(root, "<svg>" + content + "</svg><div></div>");
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        equal(getDiv().namespaceURI, XHTML_NAMESPACE);
        equal(getPath().namespaceURI, SVG_NAMESPACE);
    });
    test("expression nested inside a namespace", function () {
        var content = 'Milly';
        var context = { content: content };
        var getDiv = function () {
            return root.firstChild;
        };
        var getSvg = function () {
            return getDiv().firstChild;
        };
        var template = compile('<div><svg>{{content}}</svg></div>');
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, "<div><svg>" + content + "</svg></div>");
        equal(getDiv().namespaceURI, XHTML_NAMESPACE);
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div><svg>" + content + "</svg></div>");
        equal(getDiv().namespaceURI, XHTML_NAMESPACE);
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        context.content = 'Moe';
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div><svg>" + context.content + "</svg></div>");
        equal(getDiv().namespaceURI, XHTML_NAMESPACE);
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        rerender({ content: content });
        _glimmerTestHelpers.equalTokens(root, "<div><svg>" + content + "</svg></div>");
        equal(getDiv().namespaceURI, XHTML_NAMESPACE);
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
    });
    test("expression nested inside a namespaced root element", function () {
        var content = 'Maurice';
        var context = { content: content };
        var getSvg = function () {
            return root.firstChild;
        };
        var template = compile('<svg>{{content}}</svg>');
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, "<svg>" + content + "</svg>");
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<svg>" + content + "</svg>");
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        context.content = null;
        rerender();
        equal(getSvg().tagName, 'svg');
        ok(getSvg().firstChild.textContent === '');
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        rerender({ content: content });
        _glimmerTestHelpers.equalTokens(root, "<svg>" + content + "</svg>");
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
    });
    test("HTML namespace is created in child templates", function () {
        var isTrue = true;
        var context = { isTrue: isTrue };
        var template = compile('{{#if isTrue}}<svg></svg>{{else}}<div><svg></svg></div>{{/if}}');
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, "<svg></svg>");
        equal(root.firstChild.namespaceURI, SVG_NAMESPACE);
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<svg></svg>");
        equal(root.firstChild.namespaceURI, SVG_NAMESPACE);
        context.isTrue = false;
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div><svg></svg></div>");
        equal(root.firstChild.namespaceURI, XHTML_NAMESPACE);
        equal(root.firstChild.firstChild.namespaceURI, SVG_NAMESPACE);
        rerender({ isTrue: isTrue });
        _glimmerTestHelpers.equalTokens(root, "<svg></svg>");
        equal(root.firstChild.namespaceURI, SVG_NAMESPACE);
    });
    test("HTML namespace is continued to child templates", function () {
        var isTrue = true;
        var context = { isTrue: isTrue };
        var getDiv = function () {
            return root.firstChild;
        };
        var getSvg = function () {
            return getDiv().firstChild;
        };
        var template = compile('<div><svg>{{#if isTrue}}<circle />{{/if}}</svg></div>');
        render(template, context);
        _glimmerTestHelpers.equalTokens(root, "<div><svg><circle /></svg></div>");
        equal(getDiv().namespaceURI, XHTML_NAMESPACE);
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        equal(getSvg().firstChild.namespaceURI, SVG_NAMESPACE);
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div><svg><circle /></svg></div>");
        equal(getDiv().namespaceURI, XHTML_NAMESPACE);
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        equal(getSvg().firstChild.namespaceURI, SVG_NAMESPACE);
        context.isTrue = false;
        rerender();
        _glimmerTestHelpers.equalTokens(root, "<div><svg><!----></svg></div>");
        equal(getDiv().namespaceURI, XHTML_NAMESPACE);
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        rerender({ isTrue: isTrue });
        _glimmerTestHelpers.equalTokens(root, "<div><svg><circle /></svg></div>");
        equal(getDiv().namespaceURI, XHTML_NAMESPACE);
        equal(getSvg().namespaceURI, SVG_NAMESPACE);
        equal(getSvg().firstChild.namespaceURI, SVG_NAMESPACE);
    });
    QUnit.module("Updating Element Modifiers", {
        setup: commonSetup
    });
    test("Updating a element modifier", function (assert) {
        var manager = new _glimmerTestHelpers.TestModifierManager();
        env.registerModifier('foo', manager);
        var template = compile('<div {{foo bar}}></div>');
        var input = {
            bar: 'Super Metroid'
        };
        render(template, input);
        var valueNode = root.firstChild;
        _glimmerTestHelpers.equalTokens(root, '<div data-modifier="installed - Super Metroid"></div>', "initial render");
        equal(manager.installedElements.length, 1);
        equal(valueNode, manager.installedElements[0]);
        equal(manager.updatedElements.length, 0);
        equal(manager.destroyedModifiers.length, 0);
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div data-modifier="updated - Super Metroid"></div>', "modifier updated");
        equal(manager.installedElements.length, 1);
        equal(valueNode, manager.installedElements[0]);
        equal(manager.updatedElements.length, 1);
        equal(valueNode, manager.updatedElements[0]);
        equal(manager.destroyedModifiers.length, 0);
        input.bar = 'Super Mario';
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div data-modifier="updated - Super Mario"></div>', "no change");
        equal(manager.installedElements.length, 1);
        equal(valueNode, manager.installedElements[0]);
        equal(manager.updatedElements.length, 2);
        equal(valueNode, manager.updatedElements[1]);
        equal(manager.destroyedModifiers.length, 0);
    });
    test("Const input doesn't trigger update in a element modifier", function (assert) {
        var manager = new _glimmerTestHelpers.TestModifierManager();
        env.registerModifier('foo', manager);
        var template = compile('<div {{foo "bar"}}></div>');
        var input = {};
        render(template, input);
        var valueNode = root.firstChild;
        _glimmerTestHelpers.equalTokens(root, '<div data-modifier="installed - bar"></div>', "initial render");
        equal(manager.installedElements.length, 1);
        equal(valueNode, manager.installedElements[0]);
        equal(manager.updatedElements.length, 0);
        equal(manager.destroyedModifiers.length, 0);
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div data-modifier="installed - bar"></div>', "no change");
        equal(manager.installedElements.length, 1);
        equal(valueNode, manager.installedElements[0]);
        equal(manager.updatedElements.length, 0);
        equal(manager.destroyedModifiers.length, 0);
    });
    test("Destructor is triggered on element modifiers", function (assert) {
        var manager = new _glimmerTestHelpers.TestModifierManager();
        env.registerModifier('foo', manager);
        var template = compile('{{#if bar}}<div {{foo bar}}></div>{{else}}<div></div>{{/if}}');
        var input = {
            bar: true
        };
        render(template, input);
        var valueNode = root.firstChild;
        _glimmerTestHelpers.equalTokens(root, '<div data-modifier="installed - true"></div>', "initial render");
        equal(manager.installedElements.length, 1);
        equal(valueNode, manager.installedElements[0]);
        equal(manager.updatedElements.length, 0);
        equal(manager.destroyedModifiers.length, 0);
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div data-modifier="updated - true"></div>', "modifier updated");
        equal(manager.installedElements.length, 1);
        equal(valueNode, manager.installedElements[0]);
        equal(manager.updatedElements.length, 1);
        equal(manager.destroyedModifiers.length, 0);
        input.bar = false;
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div></div>', "no more modifier");
        equal(manager.destroyedModifiers.length, 1);
        input.bar = true;
        rerender();
        _glimmerTestHelpers.equalTokens(root, '<div data-modifier="installed - true"></div>', "back to default render");
        equal(manager.installedElements.length, 2);
        equal(manager.destroyedModifiers.length, 1);
    });
});

enifed('@glimmer/runtime/tests/updating-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/runtime/tests');
    QUnit.test('@glimmer/runtime/tests/updating-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/runtime/tests/updating-test.ts should pass tslint.');
    });
});

enifed('@glimmer/syntax/index.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/syntax');
    QUnit.test('@glimmer/syntax/index.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/syntax/index.ts should pass tslint.');
    });
});

enifed('@glimmer/syntax/lib/builders.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/syntax/lib');
    QUnit.test('@glimmer/syntax/lib/builders.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/syntax/lib/builders.ts should pass tslint.');
    });
});

enifed('@glimmer/syntax/lib/generation/print.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/syntax/lib/generation');
    QUnit.test('@glimmer/syntax/lib/generation/print.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/syntax/lib/generation/print.ts should pass tslint.');
    });
});

enifed('@glimmer/syntax/lib/parser.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/syntax/lib');
    QUnit.test('@glimmer/syntax/lib/parser.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/syntax/lib/parser.ts should pass tslint.');
    });
});

enifed('@glimmer/syntax/lib/parser/handlebars-node-visitors.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/syntax/lib/parser');
    QUnit.test('@glimmer/syntax/lib/parser/handlebars-node-visitors.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/syntax/lib/parser/handlebars-node-visitors.ts should pass tslint.');
    });
});

enifed('@glimmer/syntax/lib/parser/tokenizer-event-handlers.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/syntax/lib/parser');
    QUnit.test('@glimmer/syntax/lib/parser/tokenizer-event-handlers.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/syntax/lib/parser/tokenizer-event-handlers.ts should pass tslint.');
    });
});

enifed('@glimmer/syntax/lib/traversal/errors.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/syntax/lib/traversal');
    QUnit.test('@glimmer/syntax/lib/traversal/errors.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/syntax/lib/traversal/errors.ts should pass tslint.');
    });
});

enifed('@glimmer/syntax/lib/traversal/traverse.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/syntax/lib/traversal');
    QUnit.test('@glimmer/syntax/lib/traversal/traverse.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/syntax/lib/traversal/traverse.ts should pass tslint.');
    });
});

enifed('@glimmer/syntax/lib/traversal/walker.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/syntax/lib/traversal');
    QUnit.test('@glimmer/syntax/lib/traversal/walker.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/syntax/lib/traversal/walker.ts should pass tslint.');
    });
});

enifed('@glimmer/syntax/lib/types/visitor-keys.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/syntax/lib/types');
    QUnit.test('@glimmer/syntax/lib/types/visitor-keys.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/syntax/lib/types/visitor-keys.ts should pass tslint.');
    });
});

enifed('@glimmer/syntax/lib/utils.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/syntax/lib');
    QUnit.test('@glimmer/syntax/lib/utils.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/syntax/lib/utils.ts should pass tslint.');
    });
});

enifed("@glimmer/syntax/tests/builders-test", ["exports", "@glimmer/syntax", "@glimmer/syntax/tests/support"], function (exports, _glimmerSyntax, _glimmerSyntaxTestsSupport) {
    "use strict";

    QUnit.module('[glimmer-syntax] AST Builders');
    test('element uses comments as loc when comments is not an array', function () {
        var actual = _glimmerSyntax.builders.element('div', [], [], [], _glimmerSyntax.builders.loc(1, 1, 1, 1));
        var expected = _glimmerSyntax.builders.element('div', [], [], [], [], _glimmerSyntax.builders.loc(1, 1, 1, 1));
        _glimmerSyntaxTestsSupport.astEqual(actual, expected);
    });
});

enifed('@glimmer/syntax/tests/builders-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/syntax/tests');
    QUnit.test('@glimmer/syntax/tests/builders-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/syntax/tests/builders-test.ts should pass tslint.');
    });
});

enifed('@glimmer/syntax/tests/generation/print-test', ['exports', '@glimmer/syntax'], function (exports, _glimmerSyntax) {
    'use strict';

    function printTransform(template) {
        return _glimmerSyntax.print(_glimmerSyntax.preprocess(template));
    }
    function printEqual(template) {
        equal(printTransform(template), template);
    }
    QUnit.module('[glimmer-syntax] Code generation');
    test('ElementNode: tag', function () {
        printEqual('<h1></h1>');
    });
    test('ElementNode: nested tags with indent', function () {
        printEqual('<div>\n  <p>Test</p>\n</div>');
    });
    test('ElementNode: attributes', function () {
        printEqual('<h1 class="foo" id="title"></h1>');
    });
    test('TextNode: chars', function () {
        printEqual('<h1>Test</h1>');
    });
    test('MustacheStatement: slash in path', function () {
        printEqual('{{namespace/foo "bar" baz="qux"}}');
    });
    test('MustacheStatement: path', function () {
        printEqual('<h1>{{model.title}}</h1>');
    });
    test('MustacheStatement: StringLiteral param', function () {
        printEqual('<h1>{{link-to "Foo"}}</h1>');
    });
    test('MustacheStatement: hash', function () {
        printEqual('<h1>{{link-to "Foo" class="bar"}}</h1>');
    });
    test('MustacheStatement: as element attribute', function () {
        printEqual('<h1 class={{if foo "foo" "bar"}}>Test</h1>');
    });
    test('MustacheStatement: as element attribute with path', function () {
        printEqual('<h1 class={{color}}>Test</h1>');
    });
    test('ConcatStatement: in element attribute string', function () {
        printEqual('<h1 class="{{if active "active" "inactive"}} foo">Test</h1>');
    });
    test('ElementModifierStatement', function () {
        printEqual('<p {{action "activate"}} {{someting foo="bar"}}>Test</p>');
    });
    test('PartialStatement', function () {
        printEqual('<p>{{>something "param"}}</p>');
    });
    test('SubExpression', function () {
        printEqual('<p>{{my-component submit=(action (mut model.name) (full-name model.firstName "Smith"))}}</p>');
    });
    test('BlockStatement: multiline', function () {
        printEqual('<ul>{{#each foos as |foo index|}}\n  <li>{{foo}}: {{index}}</li>\n{{/each}}</ul>');
    });
    test('BlockStatement: inline', function () {
        printEqual('{{#if foo}}<p>{{foo}}</p>{{/if}}');
    });
    test('UndefinedLiteral', function () {
        var ast = _glimmerSyntax.builders.program([_glimmerSyntax.builders.mustache(_glimmerSyntax.builders.undefined())]);
        equal(_glimmerSyntax.print(ast), '{{undefined}}');
    });
    test('NumberLiteral', function () {
        var ast = _glimmerSyntax.builders.program([_glimmerSyntax.builders.mustache('foo', null, _glimmerSyntax.builders.hash([_glimmerSyntax.builders.pair('bar', _glimmerSyntax.builders.number(5))]))]);
        equal(_glimmerSyntax.print(ast), '{{foo bar=5}}');
    });
    test('BooleanLiteral', function () {
        var ast = _glimmerSyntax.builders.program([_glimmerSyntax.builders.mustache('foo', null, _glimmerSyntax.builders.hash([_glimmerSyntax.builders.pair('bar', _glimmerSyntax.builders.boolean(true))]))]);
        equal(_glimmerSyntax.print(ast), '{{foo bar=true}}');
    });
    test('HTML comment', function () {
        printEqual('<!-- foo -->');
    });
    test('Handlebars comment', function () {
        equal(printTransform('{{! foo }}'), '{{!-- foo --}}');
    });
    test('Handlebars comment: in ElementNode', function () {
        printEqual('<div {{!-- foo --}}></div>');
    });
    test('Handlebars comment: in ElementNode children', function () {
        printEqual('<div>{{!-- foo bar --}}<b></b></div>');
    });
    test('Handlebars in handlebar comment', function () {
        printEqual('{{!-- {{foo-bar}} --}}');
    });
});

enifed('@glimmer/syntax/tests/generation/print-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/syntax/tests/generation');
    QUnit.test('@glimmer/syntax/tests/generation/print-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/syntax/tests/generation/print-test.ts should pass tslint.');
    });
});

enifed("@glimmer/syntax/tests/loc-node-test", ["exports", "@glimmer/syntax"], function (exports, _glimmerSyntax) {
  "use strict";

  QUnit.module("[glimmer-syntax] Parser - Location Info");
  function locEqual(node, startLine, startColumn, endLine, endColumn) {
    var message = arguments.length <= 5 || arguments[5] === undefined ? JSON.stringify(node) : arguments[5];
    return (function () {
      var expected = {
        source: null,
        start: { line: startLine, column: startColumn },
        end: { line: endLine, column: endColumn }
      };
      deepEqual(node.loc, expected, message);
    })();
  }
  test("programs", function () {
    var ast = _glimmerSyntax.preprocess("\n  {{#if foo}}\n    {{bar}}\n       {{/if}}\n    ");
    locEqual(ast, 1, 0, 5, 4, 'outer program');
    // startColumn should be 13 not 2.
    // This should be fixed upstream in Handlebars.
    locEqual(ast.body[1].program, 2, 2, 4, 7, 'nested program');
  });
  test("blocks", function () {
    var ast = _glimmerSyntax.preprocess("\n  {{#if foo}}\n    {{#if bar}}\n        test\n        {{else}}\n      test\n  {{/if    }}\n       {{/if\n      }}\n    ");
    var _ast$body = ast.body;
    var block = _ast$body[1];
    var _block$program$body = block.program.body;
    var nestedBlock = _block$program$body[0];
    var _nestedBlock$program$body = nestedBlock.program.body;
    var nestedBlockText = _nestedBlock$program$body[0];

    var nestedInverse = nestedBlock.inverse;
    locEqual(block, 2, 2, 9, 8, 'outer block');
    locEqual(nestedBlock, 3, 4, 7, 13, 'nested block');
    locEqual(nestedBlockText, 4, 0, 5, 0);
    locEqual(nestedInverse, 5, 8, 7, 2);
  });
  test("mustache", function () {
    var ast = _glimmerSyntax.preprocess("\n    {{foo}}\n    {{#if foo}}\n      bar: {{bar\n        }}\n    {{/if}}\n  ");
    var _ast$body2 = ast.body;
    var foo = _ast$body2[1];
    var innerBlock = _ast$body2[3];
    var _innerBlock$program$body = innerBlock.program.body;
    var barText = _innerBlock$program$body[0];
    var bar = _innerBlock$program$body[1];

    locEqual(foo, 2, 4, 2, 11, 'outer mustache');
    locEqual(barText, 4, 0, 4, 11);
    locEqual(bar, 4, 11, 5, 10, 'inner mustache');
  });
  test("element modifier", function () {
    var ast = _glimmerSyntax.preprocess("\n    <div {{bind-attr\n      foo\n      bar=wat}}></div>\n  ");
    locEqual(ast.body[1].modifiers[0], 2, 9, 4, 15, 'element modifier');
  });
  test("html elements", function () {
    var ast = _glimmerSyntax.preprocess("\n    <section>\n      <br>\n      <div>\n        <hr />\n      </div>\n    </section>\n  ");
    var _ast$body3 = ast.body;
    var section = _ast$body3[1];
    var _section$children = section.children;
    var br = _section$children[1];
    var div = _section$children[3];
    var _div$children = div.children;
    var hr = _div$children[1];

    locEqual(section, 2, 4, 7, 14, 'section element');
    locEqual(br, 3, 6, 3, 10, 'br element');
    locEqual(div, 4, 6, 6, 12, 'div element');
    locEqual(hr, 5, 8, 5, 14, 'hr element');
  });
  test("html elements with nested blocks", function () {
    var ast = _glimmerSyntax.preprocess("\n    <div>\n      {{#if isSingleError}}\n        Single error here!\n      {{else if errors}}\n        Multiple errors here!\n      {{else}}\n        No errors found!\n      {{/if}} <p>Hi there!</p>\n    </div>\n  ");
    var _ast$body4 = ast.body;
    var div = _ast$body4[1];
    var _div$children2 = div.children;
    var ifBlock = _div$children2[1];
    var p = _div$children2[3];

    var inverseBlock = ifBlock.inverse;
    var _inverseBlock$body = inverseBlock.body;
    var nestedIfBlock = _inverseBlock$body[0];

    var nestedIfInverseBlock = nestedIfBlock.inverse;
    locEqual(div, 2, 4, 10, 10, 'div element');
    locEqual(ifBlock, 3, 6, 9, 13, 'outer if block');
    locEqual(inverseBlock, 5, 6, 9, 6, 'inverse block');
    locEqual(nestedIfBlock, 5, 6, 9, 6, 'nested if block');
    locEqual(nestedIfInverseBlock, 7, 6, 9, 6, 'nested inverse block');
    locEqual(p, 9, 14, 9, 30, 'p');
  });
  test("block + newline + element ", function () {
    var ast = _glimmerSyntax.preprocess("\n    {{#if stuff}}\n    {{/if}}\n    <p>Hi!</p>\n  ");
    var _ast$body5 = ast.body;
    var ifBlock = _ast$body5[1];
    var p = _ast$body5[3];

    locEqual(ifBlock, 2, 4, 3, 11, 'if block');
    locEqual(p, 4, 4, 4, 14, 'p element');
  });
  test("mustache + newline + element ", function () {
    var ast = _glimmerSyntax.preprocess("\n    {{foo}}\n    <p>Hi!</p>\n  ");
    var _ast$body6 = ast.body;
    var fooMustache = _ast$body6[1];
    var p = _ast$body6[3];

    locEqual(fooMustache, 2, 4, 2, 11, 'if block');
    locEqual(p, 3, 4, 3, 14, 'p element');
  });
  test("blocks with nested html elements", function () {
    var ast = _glimmerSyntax.preprocess("\n    {{#foo-bar}}<div>Foo</div>{{/foo-bar}} <p>Hi!</p>\n  ");
    var block = ast.body[1].program;
    var _block$body = block.body;
    var div = _block$body[0];

    var p = ast.body[3];
    locEqual(p, 2, 43, 2, 53, 'p element');
    locEqual(div, 2, 16, 2, 30, 'div element');
  });
  test("html elements after mustache", function () {
    var ast = _glimmerSyntax.preprocess("\n    {{foo-bar}} <p>Hi!</p>\n  ");
    var _ast$body7 = ast.body;
    var mustache = _ast$body7[1];
    var p = _ast$body7[3];

    locEqual(mustache, 2, 4, 2, 15, '{{foo-bar}}');
    locEqual(p, 2, 16, 2, 26, 'div element');
  });
  test("text", function () {
    var ast = _glimmerSyntax.preprocess("\n    foo!\n    <div>blah</div>\n  ");
    var _ast$body8 = ast.body;
    var fooText = _ast$body8[0];
    var div = _ast$body8[1];
    var _div$children3 = div.children;
    var blahText = _div$children3[0];

    locEqual(fooText, 1, 0, 3, 4);
    locEqual(blahText, 3, 9, 3, 13);
  });
  test("comment", function () {
    var ast = _glimmerSyntax.preprocess("\n    <div><!-- blah blah blah blah -->\n      <!-- derp herky --><div></div>\n    </div>\n  ");
    var _ast$body9 = ast.body;
    var div = _ast$body9[1];
    var _div$children4 = div.children;
    var comment1 = _div$children4[0];
    var comment2 = _div$children4[2];
    var trailingDiv = _div$children4[3];

    locEqual(comment1, 2, 9, 2, 37);
    locEqual(comment2, 3, 6, 3, 25);
    locEqual(trailingDiv, 3, 25, 3, 36);
  });
  test("handlebars comment", function () {
    var ast = _glimmerSyntax.preprocess("\n    <div>{{!-- blah blah blah blah --}}\n      {{!-- derp herky --}}<div></div>\n    </div>\n    <span {{! derpy }}></span>\n  ");
    var _ast$body10 = ast.body;
    var div = _ast$body10[1];
    var span = _ast$body10[3];
    var _div$children5 = div.children;
    var comment1 = _div$children5[0];
    var comment2 = _div$children5[2];
    var trailingDiv = _div$children5[3];
    var _span$comments = span.comments;
    var comment3 = _span$comments[0];

    locEqual(comment1, 2, 9, 2, 39);
    locEqual(comment2, 3, 6, 3, 27);
    locEqual(trailingDiv, 3, 27, 3, 38);
    locEqual(span, 5, 4, 5, 30);
    locEqual(comment3, 5, 10, 5, 22);
  });
  test("element attribute", function () {
    var ast = _glimmerSyntax.preprocess("\n    <div data-foo=\"blah\"\n      data-derp=\"lolol\"\ndata-barf=\"herpy\"\n  data-qux=lolnoquotes\n    data-hurky=\"some {{thing}} here\">\n      Hi, fivetanley!\n    </div>\n  ");
    var _ast$body11 = ast.body;
    var div = _ast$body11[1];
    var _div$attributes = div.attributes;
    var dataFoo = _div$attributes[0];
    var dataDerp = _div$attributes[1];
    var dataBarf = _div$attributes[2];
    var dataQux = _div$attributes[3];
    var dataHurky = _div$attributes[4];

    locEqual(dataFoo, 2, 9, 2, 24);
    locEqual(dataDerp, 3, 6, 3, 23);
    locEqual(dataBarf, 4, 0, 4, 17);
    locEqual(dataQux, 5, 2, 5, 22);
    locEqual(dataFoo.value, 2, 18, 2, 24);
    locEqual(dataDerp.value, 3, 16, 3, 23);
    locEqual(dataBarf.value, 4, 10, 4, 17);
    locEqual(dataQux.value, 5, 11, 5, 22);
    locEqual(dataHurky.value, 6, 15, 6, 36);
  });
  test("char references", function () {
    var ast = _glimmerSyntax.preprocess("\n    &gt;<div>&lt;<p>\n      Hi, danmcclain &excl;</p>\n    </div>\n  ");
    var _ast$body12 = ast.body;
    var div = _ast$body12[1];
    var _div$children6 = div.children;
    var text1 = _div$children6[0];
    var p = _div$children6[1];
    var _p$children = p.children;
    var text2 = _p$children[0];

    locEqual(div, 2, 8, 4, 10);
    locEqual(text1, 2, 13, 2, 17);
    locEqual(p, 2, 17, 3, 31);
    locEqual(text2, 2, 20, 3, 27);
  });
  test("whitespace control - trailing", function () {
    var ast = _glimmerSyntax.preprocess("\n  {{#if foo~}}\n    <div></div>\n  {{else~}}\n    {{bar}}\n  {{/if}}");
    var _ast$body13 = ast.body;
    var ifBlock = _ast$body13[1];
    var _ifBlock$program$body = ifBlock.program.body;
    var div = _ifBlock$program$body[0];

    locEqual(ifBlock, 2, 2, 6, 9, 'if block');
    locEqual(div, 3, 4, 3, 15, 'div inside truthy if block');
  });
  test("whitespace control - 'else if' trailing", function () {
    var ast = _glimmerSyntax.preprocess("\n  {{#if foo}}\n    {{bar}}\n  {{else if baz~}}\n    <div></div>\n  {{/if}}");
    var _ast$body14 = ast.body;
    var ifBlock = _ast$body14[1];
    var _ifBlock$inverse$body = ifBlock.inverse.body;
    var nestedIfBlock = _ifBlock$inverse$body[0];
    var _nestedIfBlock$program$body = nestedIfBlock.program.body;
    var div = _nestedIfBlock$program$body[0];

    locEqual(ifBlock, 2, 2, 6, 9, 'if block');
    locEqual(div, 5, 4, 5, 15, 'div inside truthy else if block');
  });
  test("whitespace control - leading", function () {
    var ast = _glimmerSyntax.preprocess("\n  {{~#if foo}}\n    <div></div>\n  {{~else}}\n    {{bar}}\n  {{~/if}}");
    var _ast$body15 = ast.body;
    var ifBlock = _ast$body15[0];
    var _ifBlock$program$body2 = ifBlock.program.body;
    var div = _ifBlock$program$body2[1];

    locEqual(ifBlock, 2, 2, 6, 10, 'if block');
    locEqual(div, 3, 4, 3, 15, 'div inside truthy if block');
  });
});

enifed('@glimmer/syntax/tests/loc-node-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/syntax/tests');
    QUnit.test('@glimmer/syntax/tests/loc-node-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/syntax/tests/loc-node-test.ts should pass tslint.');
    });
});

enifed("@glimmer/syntax/tests/parser-node-test", ["exports", "handlebars/compiler/base", "@glimmer/syntax", "@glimmer/syntax/tests/support"], function (exports, _handlebarsCompilerBase, _glimmerSyntax, _glimmerSyntaxTestsSupport) {
    "use strict";

    QUnit.module("[glimmer-syntax] Parser - AST");
    test("a simple piece of content", function () {
        var t = 'some content';
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.text('some content')]));
    });
    test("allow simple AST to be passed", function () {
        var ast = _glimmerSyntax.preprocess(_handlebarsCompilerBase.parse("simple"));
        _glimmerSyntaxTestsSupport.astEqual(ast, _glimmerSyntax.builders.program([_glimmerSyntax.builders.text("simple")]));
    });
    test("allow an AST with mustaches to be passed", function () {
        var ast = _glimmerSyntax.preprocess(_handlebarsCompilerBase.parse("<h1>some</h1> ast {{foo}}"));
        _glimmerSyntaxTestsSupport.astEqual(ast, _glimmerSyntax.builders.program([_glimmerSyntax.builders.element("h1", [], [], [_glimmerSyntax.builders.text("some")]), _glimmerSyntax.builders.text(" ast "), _glimmerSyntax.builders.mustache(_glimmerSyntax.builders.path('foo'))]));
    });
    test("self-closed element", function () {
        var t = '<g />';
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.element("g")]));
    });
    test("elements can have empty attributes", function () {
        var t = '<img id="">';
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.element("img", [_glimmerSyntax.builders.attr("id", _glimmerSyntax.builders.text(""))])]));
    });
    test("disallowed quote in element space is rejected", function (assert) {
        var t = '<img foo="bar"" >';
        assert.throws(function () {
            _glimmerSyntax.preprocess(t);
        }, /Syntax error at line 1 col 14: " is not a valid character within attribute names/);
    });
    test("disallowed equals sign in element space is rejected", function (assert) {
        var t = '<img =foo >';
        assert.throws(function () {
            _glimmerSyntax.preprocess(t);
        }, /Syntax error at line 1 col 5: attribute name cannot start with equals sign/);
    });
    test("svg content", function () {
        var t = "<svg></svg>";
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.element("svg")]));
    });
    test("html content with html content inline", function () {
        var t = '<div><p></p></div>';
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.element("div", [], [], [_glimmerSyntax.builders.element("p")])]));
    });
    test("html content with svg content inline", function () {
        var t = '<div><svg></svg></div>';
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.element("div", [], [], [_glimmerSyntax.builders.element("svg")])]));
    });
    var integrationPoints = ['foreignObject', 'desc', 'title'];
    function buildIntegrationPointTest(integrationPoint) {
        return function integrationPointTest() {
            var t = '<svg><' + integrationPoint + '><div></div></' + integrationPoint + '></svg>';
            _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.element("svg", [], [], [_glimmerSyntax.builders.element(integrationPoint, [], [], [_glimmerSyntax.builders.element("div")])])]));
        };
    }
    for (var i = 0, _length = integrationPoints.length; i < _length; i++) {
        test("svg content with html content inline for " + integrationPoints[i], buildIntegrationPointTest(integrationPoints[i]));
    }
    test("a piece of content with HTML", function () {
        var t = 'some <div>content</div> done';
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.text("some "), _glimmerSyntax.builders.element("div", [], [], [_glimmerSyntax.builders.text("content")]), _glimmerSyntax.builders.text(" done")]));
    });
    test("a piece of Handlebars with HTML", function () {
        var t = 'some <div>{{content}}</div> done';
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.text("some "), _glimmerSyntax.builders.element("div", [], [], [_glimmerSyntax.builders.mustache(_glimmerSyntax.builders.path('content'))]), _glimmerSyntax.builders.text(" done")]));
    });
    test("Handlebars embedded in an attribute (quoted)", function () {
        var t = 'some <div class="{{foo}}">content</div> done';
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.text("some "), _glimmerSyntax.builders.element("div", [_glimmerSyntax.builders.attr("class", _glimmerSyntax.builders.concat([_glimmerSyntax.builders.mustache('foo')]))], [], [_glimmerSyntax.builders.text("content")]), _glimmerSyntax.builders.text(" done")]));
    });
    test("Handlebars embedded in an attribute (unquoted)", function () {
        var t = 'some <div class={{foo}}>content</div> done';
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.text("some "), _glimmerSyntax.builders.element("div", [_glimmerSyntax.builders.attr("class", _glimmerSyntax.builders.mustache(_glimmerSyntax.builders.path('foo')))], [], [_glimmerSyntax.builders.text("content")]), _glimmerSyntax.builders.text(" done")]));
    });
    test("Handlebars embedded in an attribute of a self-closing tag (unqouted)", function () {
        var t = '<input value={{foo}}/>';
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.element("input", [_glimmerSyntax.builders.attr("value", _glimmerSyntax.builders.mustache(_glimmerSyntax.builders.path('foo')))], [], [])]));
    });
    test("Handlebars embedded in an attribute (sexprs)", function () {
        var t = 'some <div class="{{foo (foo "abc")}}">content</div> done';
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.text("some "), _glimmerSyntax.builders.element("div", [_glimmerSyntax.builders.attr("class", _glimmerSyntax.builders.concat([_glimmerSyntax.builders.mustache(_glimmerSyntax.builders.path('foo'), [_glimmerSyntax.builders.sexpr(_glimmerSyntax.builders.path('foo'), [_glimmerSyntax.builders.string('abc')])])]))], [], [_glimmerSyntax.builders.text("content")]), _glimmerSyntax.builders.text(" done")]));
    });
    test("Handlebars embedded in an attribute with other content surrounding it", function () {
        var t = 'some <a href="http://{{link}}/">content</a> done';
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.text("some "), _glimmerSyntax.builders.element("a", [_glimmerSyntax.builders.attr("href", _glimmerSyntax.builders.concat([_glimmerSyntax.builders.text("http://"), _glimmerSyntax.builders.mustache('link'), _glimmerSyntax.builders.text("/")]))], [], [_glimmerSyntax.builders.text("content")]), _glimmerSyntax.builders.text(" done")]));
    });
    test("A more complete embedding example", function () {
        var t = "{{embed}} {{some 'content'}} " + "<div class='{{foo}} {{bind-class isEnabled truthy='enabled'}}'>{{ content }}</div>" + " {{more 'embed'}}";
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.mustache(_glimmerSyntax.builders.path('embed')), _glimmerSyntax.builders.text(' '), _glimmerSyntax.builders.mustache(_glimmerSyntax.builders.path('some'), [_glimmerSyntax.builders.string('content')]), _glimmerSyntax.builders.text(' '), _glimmerSyntax.builders.element("div", [_glimmerSyntax.builders.attr("class", _glimmerSyntax.builders.concat([_glimmerSyntax.builders.mustache('foo'), _glimmerSyntax.builders.text(' '), _glimmerSyntax.builders.mustache('bind-class', [_glimmerSyntax.builders.path('isEnabled')], _glimmerSyntax.builders.hash([_glimmerSyntax.builders.pair('truthy', _glimmerSyntax.builders.string('enabled'))]))]))], [], [_glimmerSyntax.builders.mustache(_glimmerSyntax.builders.path('content'))]), _glimmerSyntax.builders.text(' '), _glimmerSyntax.builders.mustache(_glimmerSyntax.builders.path('more'), [_glimmerSyntax.builders.string('embed')])]));
    });
    test("Simple embedded block helpers", function () {
        var t = "{{#if foo}}<div>{{content}}</div>{{/if}}";
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.block(_glimmerSyntax.builders.path('if'), [_glimmerSyntax.builders.path('foo')], _glimmerSyntax.builders.hash(), _glimmerSyntax.builders.program([_glimmerSyntax.builders.element('div', [], [], [_glimmerSyntax.builders.mustache(_glimmerSyntax.builders.path('content'))])]))]));
    });
    test("Involved block helper", function () {
        var t = '<p>hi</p> content {{#testing shouldRender}}<p>Appears!</p>{{/testing}} more <em>content</em> here';
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.element('p', [], [], [_glimmerSyntax.builders.text('hi')]), _glimmerSyntax.builders.text(' content '), _glimmerSyntax.builders.block(_glimmerSyntax.builders.path('testing'), [_glimmerSyntax.builders.path('shouldRender')], _glimmerSyntax.builders.hash(), _glimmerSyntax.builders.program([_glimmerSyntax.builders.element('p', [], [], [_glimmerSyntax.builders.text('Appears!')])])), _glimmerSyntax.builders.text(' more '), _glimmerSyntax.builders.element('em', [], [], [_glimmerSyntax.builders.text('content')]), _glimmerSyntax.builders.text(' here')]));
    });
    test("Element modifiers", function () {
        var t = "<p {{action 'boom'}} class='bar'>Some content</p>";
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.element('p', [_glimmerSyntax.builders.attr('class', _glimmerSyntax.builders.text('bar'))], [_glimmerSyntax.builders.elementModifier(_glimmerSyntax.builders.path('action'), [_glimmerSyntax.builders.string('boom')])], [_glimmerSyntax.builders.text('Some content')])]));
    });
    test("Tokenizer: MustacheStatement encountered in tagName state", function () {
        var t = "<input{{bar}}>";
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.element('input', [], [_glimmerSyntax.builders.elementModifier(_glimmerSyntax.builders.path('bar'))])]));
    });
    test("Tokenizer: MustacheStatement encountered in beforeAttributeName state", function () {
        var t = "<input {{bar}}>";
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.element('input', [], [_glimmerSyntax.builders.elementModifier(_glimmerSyntax.builders.path('bar'))])]));
    });
    test("Tokenizer: MustacheStatement encountered in attributeName state", function () {
        var t = "<input foo{{bar}}>";
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.element('input', [_glimmerSyntax.builders.attr('foo', _glimmerSyntax.builders.text(''))], [_glimmerSyntax.builders.elementModifier(_glimmerSyntax.builders.path('bar'))])]));
    });
    test("Tokenizer: MustacheStatement encountered in afterAttributeName state", function () {
        var t = "<input foo {{bar}}>";
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.element('input', [_glimmerSyntax.builders.attr('foo', _glimmerSyntax.builders.text(''))], [_glimmerSyntax.builders.elementModifier(_glimmerSyntax.builders.path('bar'))])]));
    });
    test("Tokenizer: MustacheStatement encountered in afterAttributeValue state", function () {
        var t = "<input foo=1 {{bar}}>";
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.element('input', [_glimmerSyntax.builders.attr('foo', _glimmerSyntax.builders.text('1'))], [_glimmerSyntax.builders.elementModifier(_glimmerSyntax.builders.path('bar'))])]));
    });
    test("Tokenizer: MustacheStatement encountered in afterAttributeValueQuoted state", function () {
        var t = "<input foo='1'{{bar}}>";
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.element('input', [_glimmerSyntax.builders.attr('foo', _glimmerSyntax.builders.text('1'))], [_glimmerSyntax.builders.elementModifier(_glimmerSyntax.builders.path('bar'))])]));
    });
    test("Stripping - mustaches", function () {
        var t = "foo {{~content}} bar";
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.text('foo'), _glimmerSyntax.builders.mustache(_glimmerSyntax.builders.path('content')), _glimmerSyntax.builders.text(' bar')]));
        t = "foo {{content~}} bar";
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.text('foo '), _glimmerSyntax.builders.mustache(_glimmerSyntax.builders.path('content')), _glimmerSyntax.builders.text('bar')]));
    });
    test("Stripping - blocks", function () {
        var t = "foo {{~#wat}}{{/wat}} bar";
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.text('foo'), _glimmerSyntax.builders.block(_glimmerSyntax.builders.path('wat'), [], _glimmerSyntax.builders.hash(), _glimmerSyntax.builders.program()), _glimmerSyntax.builders.text(' bar')]));
        t = "foo {{#wat}}{{/wat~}} bar";
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.text('foo '), _glimmerSyntax.builders.block(_glimmerSyntax.builders.path('wat'), [], _glimmerSyntax.builders.hash(), _glimmerSyntax.builders.program()), _glimmerSyntax.builders.text('bar')]));
    });
    test("Stripping - programs", function () {
        var t = "{{#wat~}} foo {{else}}{{/wat}}";
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.block(_glimmerSyntax.builders.path('wat'), [], _glimmerSyntax.builders.hash(), _glimmerSyntax.builders.program([_glimmerSyntax.builders.text('foo ')]), _glimmerSyntax.builders.program())]));
        t = "{{#wat}} foo {{~else}}{{/wat}}";
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.block(_glimmerSyntax.builders.path('wat'), [], _glimmerSyntax.builders.hash(), _glimmerSyntax.builders.program([_glimmerSyntax.builders.text(' foo')]), _glimmerSyntax.builders.program())]));
        t = "{{#wat}}{{else~}} foo {{/wat}}";
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.block(_glimmerSyntax.builders.path('wat'), [], _glimmerSyntax.builders.hash(), _glimmerSyntax.builders.program(), _glimmerSyntax.builders.program([_glimmerSyntax.builders.text('foo ')]))]));
        t = "{{#wat}}{{else}} foo {{~/wat}}";
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.block(_glimmerSyntax.builders.path('wat'), [], _glimmerSyntax.builders.hash(), _glimmerSyntax.builders.program(), _glimmerSyntax.builders.program([_glimmerSyntax.builders.text(' foo')]))]));
    });
    test("Stripping - removes unnecessary text nodes", function () {
        var t = "{{#each~}}\n  <li> foo </li>\n{{~/each}}";
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.block(_glimmerSyntax.builders.path('each'), [], _glimmerSyntax.builders.hash(), _glimmerSyntax.builders.program([_glimmerSyntax.builders.element('li', [], [], [_glimmerSyntax.builders.text(' foo ')])]))]));
    });
    // TODO: Make these throw an error.
    //test("Awkward mustache in unquoted attribute value", function() {
    //  let t = "<div class=a{{foo}}></div>";
    //  astEqual(t, b.program([
    //    b.element('div', [ b.attr('class', concat([b.string("a"), b.sexpr([b.path('foo')])])) ])
    //  ]));
    //
    //  t = "<div class=a{{foo}}b></div>";
    //  astEqual(t, b.program([
    //    b.element('div', [ b.attr('class', concat([b.string("a"), b.sexpr([b.path('foo')]), b.string("b")])) ])
    //  ]));
    //
    //  t = "<div class={{foo}}b></div>";
    //  astEqual(t, b.program([
    //    b.element('div', [ b.attr('class', concat([b.sexpr([b.path('foo')]), b.string("b")])) ])
    //  ]));
    //});
    test("an HTML comment", function () {
        var t = 'before <!-- some comment --> after';
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.text("before "), _glimmerSyntax.builders.comment(" some comment "), _glimmerSyntax.builders.text(" after")]));
    });
    test("a Handlebars comment inside an HTML comment", function () {
        var t = 'before <!-- some {{! nested thing }} comment --> after';
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.text("before "), _glimmerSyntax.builders.comment(" some {{! nested thing }} comment "), _glimmerSyntax.builders.text(" after")]));
    });
    test("a Handlebars comment", function () {
        var t = 'before {{! some comment }} after';
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.text("before "), _glimmerSyntax.builders.mustacheComment(" some comment "), _glimmerSyntax.builders.text(" after")]));
    });
    test("a Handlebars comment in proper element space", function () {
        var t = 'before <div {{! some comment }} data-foo="bar" {{! other comment }}></div> after';
        _glimmerSyntaxTestsSupport.astEqual(t, _glimmerSyntax.builders.program([_glimmerSyntax.builders.text("before "), _glimmerSyntax.builders.element('div', [_glimmerSyntax.builders.attr('data-foo', _glimmerSyntax.builders.text('bar'))], [], [], [_glimmerSyntax.builders.mustacheComment(" some comment "), _glimmerSyntax.builders.mustacheComment(" other comment ")]), _glimmerSyntax.builders.text(" after")]));
    });
    test("a Handlebars comment in invalid element space", function (assert) {
        assert.throws(function () {
            _glimmerSyntax.preprocess('\nbefore <div \n  a{{! some comment }} data-foo="bar"></div> after');
        }, /Using a Handlebars comment when in the `attributeName` state is not supported: " some comment " on line 3:3/);
        assert.throws(function () {
            _glimmerSyntax.preprocess('\nbefore <div \n  a={{! some comment }} data-foo="bar"></div> after');
        }, /Using a Handlebars comment when in the `beforeAttributeValue` state is not supported: " some comment " on line 3:4/);
        assert.throws(function () {
            _glimmerSyntax.preprocess('\nbefore <div \n  a="{{! some comment }}" data-foo="bar"></div> after');
        }, /Using a Handlebars comment when in the `attributeValueDoubleQuoted` state is not supported: " some comment " on line 3:5/);
    });
    test("allow {{null}} to be passed as helper name", function () {
        var ast = _glimmerSyntax.preprocess("{{null}}");
        _glimmerSyntaxTestsSupport.astEqual(ast, _glimmerSyntax.builders.program([_glimmerSyntax.builders.mustache(_glimmerSyntax.builders.null())]));
    });
    test("allow {{null}} to be passed as a param", function () {
        var ast = _glimmerSyntax.preprocess("{{foo null}}");
        _glimmerSyntaxTestsSupport.astEqual(ast, _glimmerSyntax.builders.program([_glimmerSyntax.builders.mustache(_glimmerSyntax.builders.path('foo'), [_glimmerSyntax.builders.null()])]));
    });
    test("allow {{undefined}} to be passed as helper name", function () {
        var ast = _glimmerSyntax.preprocess("{{undefined}}");
        _glimmerSyntaxTestsSupport.astEqual(ast, _glimmerSyntax.builders.program([_glimmerSyntax.builders.mustache(_glimmerSyntax.builders.undefined())]));
    });
    test("allow {{undefined}} to be passed as a param", function () {
        var ast = _glimmerSyntax.preprocess("{{foo undefined}}");
        _glimmerSyntaxTestsSupport.astEqual(ast, _glimmerSyntax.builders.program([_glimmerSyntax.builders.mustache(_glimmerSyntax.builders.path('foo'), [_glimmerSyntax.builders.undefined()])]));
    });
});

enifed('@glimmer/syntax/tests/parser-node-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/syntax/tests');
    QUnit.test('@glimmer/syntax/tests/parser-node-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/syntax/tests/parser-node-test.ts should pass tslint.');
    });
});

enifed('@glimmer/syntax/tests/plugin-node-test', ['exports', '@glimmer/syntax'], function (exports, _glimmerSyntax) {
    'use strict';

    QUnit.module('[glimmer-syntax] Plugins - AST Transforms');
    test('AST plugins can be provided to the compiler', function () {
        expect(1);
        function Plugin() {}
        Plugin.prototype.transform = function () {
            ok(true, 'transform was called!');
        };
        _glimmerSyntax.preprocess('<div></div>', {
            plugins: {
                ast: [Plugin]
            }
        });
    });
    test('provides syntax package as `syntax` prop if value is null', function () {
        expect(1);
        function Plugin() {}
        Plugin.prototype.transform = function () {
            equal(this.syntax.Walker, _glimmerSyntax.Walker);
        };
        _glimmerSyntax.preprocess('<div></div>', {
            plugins: {
                ast: [Plugin]
            }
        });
    });
    test('AST plugins can modify the AST', function () {
        expect(1);
        var expected = "OOOPS, MESSED THAT UP!";
        function Plugin() {}
        Plugin.prototype.transform = function () {
            return expected;
        };
        var ast = _glimmerSyntax.preprocess('<div></div>', {
            plugins: {
                ast: [Plugin]
            }
        });
        equal(ast, expected, 'return value from AST transform is used');
    });
    test('AST plugins can be chained', function () {
        expect(2);
        var expected = "OOOPS, MESSED THAT UP!";
        function Plugin() {}
        Plugin.prototype.transform = function () {
            return expected;
        };
        function SecondaryPlugin() {}
        SecondaryPlugin.prototype.transform = function (ast) {
            equal(ast, expected, 'return value from AST transform is used');
            return 'BOOM!';
        };
        var ast = _glimmerSyntax.preprocess('<div></div>', {
            plugins: {
                ast: [Plugin, SecondaryPlugin]
            }
        });
        equal(ast, 'BOOM!', 'return value from last AST transform is used');
    });
});

enifed('@glimmer/syntax/tests/plugin-node-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/syntax/tests');
    QUnit.test('@glimmer/syntax/tests/plugin-node-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/syntax/tests/plugin-node-test.ts should pass tslint.');
    });
});

enifed('@glimmer/syntax/tests/support', ['exports', '@glimmer/syntax'], function (exports, _glimmerSyntax) {
    'use strict';

    exports.astEqual = astEqual;

    function normalizeNode(obj) {
        if (obj && typeof obj === 'object') {
            var newObj = undefined;
            if (obj.splice) {
                newObj = new Array(obj.length);
                for (var i = 0; i < obj.length; i++) {
                    newObj[i] = normalizeNode(obj[i]);
                }
            } else {
                newObj = {};
                for (var key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        newObj[key] = normalizeNode(obj[key]);
                    }
                }
                if (newObj.type) {
                    newObj._type = newObj.type;
                    delete newObj.type;
                }
                delete newObj.loc;
            }
            return newObj;
        } else {
            return obj;
        }
    }

    function astEqual(actual, expected, message) {
        if (typeof actual === 'string') {
            actual = _glimmerSyntax.preprocess(actual);
        }
        if (typeof expected === 'string') {
            expected = _glimmerSyntax.preprocess(expected);
        }
        actual = normalizeNode(actual);
        expected = normalizeNode(expected);
        deepEqual(actual, expected, message);
    }
});

enifed('@glimmer/syntax/tests/support.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/syntax/tests');
    QUnit.test('@glimmer/syntax/tests/support.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/syntax/tests/support.ts should pass tslint.');
    });
});

enifed('@glimmer/syntax/tests/traversal/manipulating-node-test', ['exports', '@glimmer/syntax/tests/support', '@glimmer/syntax', '@glimmer/syntax/lib/traversal/errors'], function (exports, _glimmerSyntaxTestsSupport, _glimmerSyntax, _glimmerSyntaxLibTraversalErrors) {
    'use strict';

    QUnit.module('[glimmer-syntax] Traversal - manipulating');
    ['enter', 'exit'].forEach(function (eventName) {
        QUnit.test('[' + eventName + '] Replacing self in a key (returning null)', function (assert) {
            var ast = _glimmerSyntax.preprocess('<x y={{z}} />');
            var attr = ast.body[0].attributes[0];
            assert.throws(function () {
                var _MustacheStatement;

                _glimmerSyntax.traverse(ast, {
                    MustacheStatement: (_MustacheStatement = {}, _MustacheStatement[eventName] = function (node) {
                        if (node.path.parts[0] === 'z') {
                            return null;
                        }
                    }, _MustacheStatement)
                });
            }, _glimmerSyntaxLibTraversalErrors.cannotRemoveNode(attr.value, attr, 'value'));
        });
        QUnit.test('[' + eventName + '] Replacing self in a key (returning an empty array)', function (assert) {
            var ast = _glimmerSyntax.preprocess('<x y={{z}} />');
            var attr = ast.body[0].attributes[0];
            assert.throws(function () {
                var _MustacheStatement2;

                _glimmerSyntax.traverse(ast, {
                    MustacheStatement: (_MustacheStatement2 = {}, _MustacheStatement2[eventName] = function (node) {
                        if (node.path.parts[0] === 'z') {
                            return [];
                        }
                    }, _MustacheStatement2)
                });
            }, _glimmerSyntaxLibTraversalErrors.cannotRemoveNode(attr.value, attr, 'value'));
        });
        QUnit.test('[' + eventName + '] Replacing self in a key (returning a node)', function () {
            var _MustacheStatement3;

            var ast = _glimmerSyntax.preprocess('<x y={{z}} />');
            _glimmerSyntax.traverse(ast, {
                MustacheStatement: (_MustacheStatement3 = {}, _MustacheStatement3[eventName] = function (node) {
                    if (node.path.parts[0] === 'z') {
                        return _glimmerSyntax.builders.mustache('a');
                    }
                }, _MustacheStatement3)
            });
            _glimmerSyntaxTestsSupport.astEqual(ast, '<x y={{a}} />');
        });
        QUnit.test('[' + eventName + '] Replacing self in a key (returning an array with a single node)', function () {
            var _MustacheStatement4;

            var ast = _glimmerSyntax.preprocess('<x y={{z}} />');
            _glimmerSyntax.traverse(ast, {
                MustacheStatement: (_MustacheStatement4 = {}, _MustacheStatement4[eventName] = function (node) {
                    if (node.path.parts[0] === 'z') {
                        return [_glimmerSyntax.builders.mustache('a')];
                    }
                }, _MustacheStatement4)
            });
            _glimmerSyntaxTestsSupport.astEqual(ast, '<x y={{a}} />');
        });
        QUnit.test('[' + eventName + '] Replacing self in a key (returning an array with multiple nodes)', function (assert) {
            var ast = _glimmerSyntax.preprocess('<x y={{z}} />');
            var attr = ast.body[0].attributes[0];
            assert.throws(function () {
                var _MustacheStatement5;

                _glimmerSyntax.traverse(ast, {
                    MustacheStatement: (_MustacheStatement5 = {}, _MustacheStatement5[eventName] = function (node) {
                        if (node.path.parts[0] === 'z') {
                            return [_glimmerSyntax.builders.mustache('a'), _glimmerSyntax.builders.mustache('b'), _glimmerSyntax.builders.mustache('c')];
                        }
                    }, _MustacheStatement5)
                });
            }, _glimmerSyntaxLibTraversalErrors.cannotReplaceNode(attr.value, attr, 'value'));
        });
        QUnit.test('[' + eventName + '] Replacing self in an array (returning null)', function () {
            var _MustacheStatement6;

            var ast = _glimmerSyntax.preprocess('{{x}}{{y}}{{z}}');
            _glimmerSyntax.traverse(ast, {
                MustacheStatement: (_MustacheStatement6 = {}, _MustacheStatement6[eventName] = function (node) {
                    if (node.path.parts[0] === 'y') {
                        return null;
                    }
                }, _MustacheStatement6)
            });
            _glimmerSyntaxTestsSupport.astEqual(ast, '{{x}}{{z}}');
        });
        QUnit.test('[' + eventName + '] Replacing self in an array (returning an empty array)', function () {
            var _MustacheStatement7;

            var ast = _glimmerSyntax.preprocess('{{x}}{{y}}{{z}}');
            _glimmerSyntax.traverse(ast, {
                MustacheStatement: (_MustacheStatement7 = {}, _MustacheStatement7[eventName] = function (node) {
                    if (node.path.parts[0] === 'y') {
                        return [];
                    }
                }, _MustacheStatement7)
            });
            _glimmerSyntaxTestsSupport.astEqual(ast, '{{x}}{{z}}');
        });
        QUnit.test('[' + eventName + '] Replacing self in an array (returning a node)', function () {
            var _MustacheStatement8;

            var ast = _glimmerSyntax.preprocess('{{x}}{{y}}{{z}}');
            _glimmerSyntax.traverse(ast, {
                MustacheStatement: (_MustacheStatement8 = {}, _MustacheStatement8[eventName] = function (node) {
                    if (node.path.parts[0] === 'y') {
                        return _glimmerSyntax.builders.mustache('a');
                    }
                }, _MustacheStatement8)
            });
            _glimmerSyntaxTestsSupport.astEqual(ast, '{{x}}{{a}}{{z}}');
        });
        QUnit.test('[' + eventName + '] Replacing self in an array (returning an array with a single node)', function () {
            var _MustacheStatement9;

            var ast = _glimmerSyntax.preprocess('{{x}}{{y}}{{z}}');
            _glimmerSyntax.traverse(ast, {
                MustacheStatement: (_MustacheStatement9 = {}, _MustacheStatement9[eventName] = function (node) {
                    if (node.path.parts[0] === 'y') {
                        return [_glimmerSyntax.builders.mustache('a')];
                    }
                }, _MustacheStatement9)
            });
            _glimmerSyntaxTestsSupport.astEqual(ast, '{{x}}{{a}}{{z}}');
        });
        QUnit.test('[' + eventName + '] Replacing self in an array (returning an array with multiple nodes)', function () {
            var _MustacheStatement10;

            var ast = _glimmerSyntax.preprocess('{{x}}{{y}}{{z}}');
            _glimmerSyntax.traverse(ast, {
                MustacheStatement: (_MustacheStatement10 = {}, _MustacheStatement10[eventName] = function (node) {
                    if (node.path.parts[0] === 'y') {
                        return [_glimmerSyntax.builders.mustache('a'), _glimmerSyntax.builders.mustache('b'), _glimmerSyntax.builders.mustache('c')];
                    }
                }, _MustacheStatement10)
            });
            _glimmerSyntaxTestsSupport.astEqual(ast, '{{x}}{{a}}{{b}}{{c}}{{z}}');
        });
    });
    QUnit.module('[glimmer-syntax] Traversal - manipulating (edge cases)');
    QUnit.test('Inside of a block', function () {
        var ast = _glimmerSyntax.preprocess('{{y}}{{#w}}{{x}}{{y}}{{z}}{{/w}}');
        _glimmerSyntax.traverse(ast, {
            MustacheStatement: function (node) {
                if (node.path.parts[0] === 'y') {
                    return [_glimmerSyntax.builders.mustache('a'), _glimmerSyntax.builders.mustache('b'), _glimmerSyntax.builders.mustache('c')];
                }
            }
        });
        _glimmerSyntaxTestsSupport.astEqual(ast, '{{a}}{{b}}{{c}}{{#w}}{{x}}{{a}}{{b}}{{c}}{{z}}{{/w}}');
    });
    QUnit.test('Should recurrsively walk the transformed node', function (assert) {
        var ast = _glimmerSyntax.preprocess('{{x}}{{y}}{{z}}');
        _glimmerSyntax.traverse(ast, {
            MustacheStatement: function (node) {
                if (node.path.original === 'x') {
                    return _glimmerSyntax.builders.mustache('y');
                } else if (node.path.original === 'y') {
                    return _glimmerSyntax.builders.mustache('z');
                }
            }
        });
        _glimmerSyntaxTestsSupport.astEqual(ast, '{{z}}{{z}}{{z}}');
    });
    QUnit.test('Should recurrsively walk the keys in the transformed node', function (assert) {
        var ast = _glimmerSyntax.preprocess('{{#foo}}{{#bar}}{{baz}}{{/bar}}{{else}}{{#bar}}{{bat}}{{/bar}}{{/foo}}');
        _glimmerSyntax.traverse(ast, {
            BlockStatement: function (node) {
                if (node.path.original === 'foo') {
                    return _glimmerSyntax.builders.block(_glimmerSyntax.builders.path('x-foo'), node.params, node.hash, node.program, node.inverse, node.loc);
                } else if (node.path.original === 'bar') {
                    return _glimmerSyntax.builders.block(_glimmerSyntax.builders.path('x-bar'), node.params, node.hash, node.program, node.inverse, node.loc);
                }
            },
            MustacheStatement: function (node) {
                if (node.path.original === 'baz') {
                    return _glimmerSyntax.builders.mustache('x-baz');
                } else if (node.path.original === 'bat') {
                    return _glimmerSyntax.builders.mustache('x-bat');
                }
            }
        });
        _glimmerSyntaxTestsSupport.astEqual(ast, '{{#x-foo}}{{#x-bar}}{{x-baz}}{{/x-bar}}{{else}}{{#x-bar}}{{x-bat}}{{/x-bar}}{{/x-foo}}');
    });
    QUnit.test('Exit event is not triggered if the node is replaced during the enter event', function (assert) {
        var ast = _glimmerSyntax.preprocess('{{x}}');
        var entered = [];
        var exited = [];
        _glimmerSyntax.traverse(ast, {
            MustacheStatement: {
                enter: function (node) {
                    entered.push(node.path.original);
                    return _glimmerSyntax.builders.mustache('y');
                },
                exit: function (node) {
                    exited.push(node.path.original);
                }
            }
        });
        assert.deepEqual(entered, ['x', 'y']);
        assert.deepEqual(exited, ['y']);
    });
});

enifed('@glimmer/syntax/tests/traversal/manipulating-node-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/syntax/tests/traversal');
    QUnit.test('@glimmer/syntax/tests/traversal/manipulating-node-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/syntax/tests/traversal/manipulating-node-test.ts should pass tslint.');
    });
});

enifed('@glimmer/syntax/tests/traversal/visiting-keys-node-test', ['exports', '@glimmer/syntax'], function (exports, _glimmerSyntax) {
    'use strict';

    function traversalEqual(node, expectedTraversal) {
        var actualTraversal = [];
        _glimmerSyntax.traverse(node, {
            All: {
                enter: function (node) {
                    actualTraversal.push(['enter', node]);
                },
                exit: function (node) {
                    actualTraversal.push(['exit', node]);
                },
                keys: {
                    All: {
                        enter: function (node, key) {
                            actualTraversal.push(['enter:' + key, node]);
                        },
                        exit: function (node, key) {
                            actualTraversal.push(['exit:' + key, node]);
                        }
                    }
                }
            }
        });
        deepEqual(actualTraversal.map(function (a) {
            return a[0] + ' ' + a[1].type;
        }), expectedTraversal.map(function (a) {
            return a[0] + ' ' + a[1].type;
        }));
        var nodesEqual = true;
        for (var i = 0; i < actualTraversal.length; i++) {
            if (actualTraversal[i][1] !== expectedTraversal[i][1]) {
                nodesEqual = false;
                break;
            }
        }
        ok(nodesEqual, "Actual nodes match expected nodes");
    }
    QUnit.module('[glimmer-syntax] Traversal - visiting keys');
    test('Blocks', function () {
        var ast = _glimmerSyntax.preprocess('{{#block param1 param2 key1=value key2=value}}<b></b><b></b>{{/block}}');
        traversalEqual(ast, [['enter', ast], ['enter:body', ast], ['enter', ast.body[0]], ['enter:path', ast.body[0]], ['enter', ast.body[0].path], ['exit', ast.body[0].path], ['exit:path', ast.body[0]], ['enter:params', ast.body[0]], ['enter', ast.body[0].params[0]], ['exit', ast.body[0].params[0]], ['enter', ast.body[0].params[1]], ['exit', ast.body[0].params[1]], ['exit:params', ast.body[0]], ['enter:hash', ast.body[0]], ['enter', ast.body[0].hash], ['enter:pairs', ast.body[0].hash], ['enter', ast.body[0].hash.pairs[0]], ['enter:value', ast.body[0].hash.pairs[0]], ['enter', ast.body[0].hash.pairs[0].value], ['exit', ast.body[0].hash.pairs[0].value], ['exit:value', ast.body[0].hash.pairs[0]], ['exit', ast.body[0].hash.pairs[0]], ['enter', ast.body[0].hash.pairs[1]], ['enter:value', ast.body[0].hash.pairs[1]], ['enter', ast.body[0].hash.pairs[1].value], ['exit', ast.body[0].hash.pairs[1].value], ['exit:value', ast.body[0].hash.pairs[1]], ['exit', ast.body[0].hash.pairs[1]], ['exit:pairs', ast.body[0].hash], ['exit', ast.body[0].hash], ['exit:hash', ast.body[0]], ['enter:program', ast.body[0]], ['enter', ast.body[0].program], ['enter:body', ast.body[0].program], ['enter', ast.body[0].program.body[0]], ['enter:attributes', ast.body[0].program.body[0]], ['exit:attributes', ast.body[0].program.body[0]], ['enter:modifiers', ast.body[0].program.body[0]], ['exit:modifiers', ast.body[0].program.body[0]], ['enter:children', ast.body[0].program.body[0]], ['exit:children', ast.body[0].program.body[0]], ['enter:comments', ast.body[0].program.body[0]], ['exit:comments', ast.body[0].program.body[0]], ['exit', ast.body[0].program.body[0]], ['enter', ast.body[0].program.body[1]], ['enter:attributes', ast.body[0].program.body[1]], ['exit:attributes', ast.body[0].program.body[1]], ['enter:modifiers', ast.body[0].program.body[1]], ['exit:modifiers', ast.body[0].program.body[1]], ['enter:children', ast.body[0].program.body[1]], ['exit:children', ast.body[0].program.body[1]], ['enter:comments', ast.body[0].program.body[1]], ['exit:comments', ast.body[0].program.body[1]], ['exit', ast.body[0].program.body[1]], ['exit:body', ast.body[0].program], ['exit', ast.body[0].program], ['exit:program', ast.body[0]], ['exit', ast.body[0]], ['exit:body', ast], ['exit', ast]]);
    });
});

enifed('@glimmer/syntax/tests/traversal/visiting-keys-node-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/syntax/tests/traversal');
    QUnit.test('@glimmer/syntax/tests/traversal/visiting-keys-node-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/syntax/tests/traversal/visiting-keys-node-test.ts should pass tslint.');
    });
});

enifed('@glimmer/syntax/tests/traversal/visiting-node-test', ['exports', '@glimmer/syntax'], function (exports, _glimmerSyntax) {
    'use strict';

    function traversalEqual(node, expectedTraversal) {
        var actualTraversal = [];
        _glimmerSyntax.traverse(node, {
            All: {
                enter: function (node) {
                    actualTraversal.push(['enter', node]);
                },
                exit: function (node) {
                    actualTraversal.push(['exit', node]);
                }
            }
        });
        deepEqual(actualTraversal.map(function (a) {
            return a[0] + ' ' + a[1].type;
        }), expectedTraversal.map(function (a) {
            return a[0] + ' ' + a[1].type;
        }));
        var nodesEqual = true;
        for (var i = 0; i < actualTraversal.length; i++) {
            if (actualTraversal[i][1] !== expectedTraversal[i][1]) {
                nodesEqual = false;
                break;
            }
        }
        ok(nodesEqual, "Actual nodes match expected nodes");
    }
    QUnit.module('[glimmer-syntax] Traversal - visiting');
    test('Elements and attributes', function () {
        var ast = _glimmerSyntax.preprocess('<div id="id" class="large {{classes}}" value={{value}}><b></b><b></b></div>');
        traversalEqual(ast, [['enter', ast], ['enter', ast.body[0]], ['enter', ast.body[0].attributes[0]], ['enter', ast.body[0].attributes[0].value], ['exit', ast.body[0].attributes[0].value], ['exit', ast.body[0].attributes[0]], ['enter', ast.body[0].attributes[1]], ['enter', ast.body[0].attributes[1].value], ['enter', ast.body[0].attributes[1].value.parts[0]], ['exit', ast.body[0].attributes[1].value.parts[0]], ['enter', ast.body[0].attributes[1].value.parts[1]], ['enter', ast.body[0].attributes[1].value.parts[1].path], ['exit', ast.body[0].attributes[1].value.parts[1].path], ['enter', ast.body[0].attributes[1].value.parts[1].hash], ['exit', ast.body[0].attributes[1].value.parts[1].hash], ['exit', ast.body[0].attributes[1].value.parts[1]], ['exit', ast.body[0].attributes[1].value], ['exit', ast.body[0].attributes[1]], ['enter', ast.body[0].attributes[2]], ['enter', ast.body[0].attributes[2].value], ['enter', ast.body[0].attributes[2].value.path], ['exit', ast.body[0].attributes[2].value.path], ['enter', ast.body[0].attributes[2].value.hash], ['exit', ast.body[0].attributes[2].value.hash], ['exit', ast.body[0].attributes[2].value], ['exit', ast.body[0].attributes[2]], ['enter', ast.body[0].children[0]], ['exit', ast.body[0].children[0]], ['enter', ast.body[0].children[1]], ['exit', ast.body[0].children[1]], ['exit', ast.body[0]], ['exit', ast]]);
    });
    test('Element modifiers', function () {
        var ast = _glimmerSyntax.preprocess('<div {{modifier}}{{modifier param1 param2 key1=value key2=value}}></div>');
        traversalEqual(ast, [['enter', ast], ['enter', ast.body[0]], ['enter', ast.body[0].modifiers[0]], ['enter', ast.body[0].modifiers[0].path], ['exit', ast.body[0].modifiers[0].path], ['enter', ast.body[0].modifiers[0].hash], ['exit', ast.body[0].modifiers[0].hash], ['exit', ast.body[0].modifiers[0]], ['enter', ast.body[0].modifiers[1]], ['enter', ast.body[0].modifiers[1].path], ['exit', ast.body[0].modifiers[1].path], ['enter', ast.body[0].modifiers[1].params[0]], ['exit', ast.body[0].modifiers[1].params[0]], ['enter', ast.body[0].modifiers[1].params[1]], ['exit', ast.body[0].modifiers[1].params[1]], ['enter', ast.body[0].modifiers[1].hash], ['enter', ast.body[0].modifiers[1].hash.pairs[0]], ['enter', ast.body[0].modifiers[1].hash.pairs[0].value], ['exit', ast.body[0].modifiers[1].hash.pairs[0].value], ['exit', ast.body[0].modifiers[1].hash.pairs[0]], ['enter', ast.body[0].modifiers[1].hash.pairs[1]], ['enter', ast.body[0].modifiers[1].hash.pairs[1].value], ['exit', ast.body[0].modifiers[1].hash.pairs[1].value], ['exit', ast.body[0].modifiers[1].hash.pairs[1]], ['exit', ast.body[0].modifiers[1].hash], ['exit', ast.body[0].modifiers[1]], ['exit', ast.body[0]], ['exit', ast]]);
    });
    test('Blocks', function () {
        var ast = _glimmerSyntax.preprocess('{{#block}}{{/block}}' + '{{#block param1 param2 key1=value key2=value}}<b></b><b></b>{{/block}}');
        traversalEqual(ast, [['enter', ast], ['enter', ast.body[0]], ['enter', ast.body[0].path], ['exit', ast.body[0].path], ['enter', ast.body[0].hash], ['exit', ast.body[0].hash], ['enter', ast.body[0].program], ['exit', ast.body[0].program], ['exit', ast.body[0]], ['enter', ast.body[1]], ['enter', ast.body[1].path], ['exit', ast.body[1].path], ['enter', ast.body[1].params[0]], ['exit', ast.body[1].params[0]], ['enter', ast.body[1].params[1]], ['exit', ast.body[1].params[1]], ['enter', ast.body[1].hash], ['enter', ast.body[1].hash.pairs[0]], ['enter', ast.body[1].hash.pairs[0].value], ['exit', ast.body[1].hash.pairs[0].value], ['exit', ast.body[1].hash.pairs[0]], ['enter', ast.body[1].hash.pairs[1]], ['enter', ast.body[1].hash.pairs[1].value], ['exit', ast.body[1].hash.pairs[1].value], ['exit', ast.body[1].hash.pairs[1]], ['exit', ast.body[1].hash], ['enter', ast.body[1].program], ['enter', ast.body[1].program.body[0]], ['exit', ast.body[1].program.body[0]], ['enter', ast.body[1].program.body[1]], ['exit', ast.body[1].program.body[1]], ['exit', ast.body[1].program], ['exit', ast.body[1]], ['exit', ast]]);
    });
    test('Mustaches', function () {
        var ast = _glimmerSyntax.preprocess('{{mustache}}' + '{{mustache param1 param2 key1=value key2=value}}');
        traversalEqual(ast, [['enter', ast], ['enter', ast.body[0]], ['enter', ast.body[0].path], ['exit', ast.body[0].path], ['enter', ast.body[0].hash], ['exit', ast.body[0].hash], ['exit', ast.body[0]], ['enter', ast.body[1]], ['enter', ast.body[1].path], ['exit', ast.body[1].path], ['enter', ast.body[1].params[0]], ['exit', ast.body[1].params[0]], ['enter', ast.body[1].params[1]], ['exit', ast.body[1].params[1]], ['enter', ast.body[1].hash], ['enter', ast.body[1].hash.pairs[0]], ['enter', ast.body[1].hash.pairs[0].value], ['exit', ast.body[1].hash.pairs[0].value], ['exit', ast.body[1].hash.pairs[0]], ['enter', ast.body[1].hash.pairs[1]], ['enter', ast.body[1].hash.pairs[1].value], ['exit', ast.body[1].hash.pairs[1].value], ['exit', ast.body[1].hash.pairs[1]], ['exit', ast.body[1].hash], ['exit', ast.body[1]], ['exit', ast]]);
    });
    test('Nested helpers', function () {
        var ast = _glimmerSyntax.preprocess('{{helper\n    (helper param1 param2 key1=value key2=value)\n    key1=(helper param)\n    key2=(helper key=(helper param))\n  }}');
        traversalEqual(ast, [['enter', ast], ['enter', ast.body[0]], ['enter', ast.body[0].path], ['exit', ast.body[0].path], ['enter', ast.body[0].params[0]], ['enter', ast.body[0].params[0].path], ['exit', ast.body[0].params[0].path], ['enter', ast.body[0].params[0].params[0]], ['exit', ast.body[0].params[0].params[0]], ['enter', ast.body[0].params[0].params[1]], ['exit', ast.body[0].params[0].params[1]], ['enter', ast.body[0].params[0].hash], ['enter', ast.body[0].params[0].hash.pairs[0]], ['enter', ast.body[0].params[0].hash.pairs[0].value], ['exit', ast.body[0].params[0].hash.pairs[0].value], ['exit', ast.body[0].params[0].hash.pairs[0]], ['enter', ast.body[0].params[0].hash.pairs[1]], ['enter', ast.body[0].params[0].hash.pairs[1].value], ['exit', ast.body[0].params[0].hash.pairs[1].value], ['exit', ast.body[0].params[0].hash.pairs[1]], ['exit', ast.body[0].params[0].hash], ['exit', ast.body[0].params[0]], ['enter', ast.body[0].hash], ['enter', ast.body[0].hash.pairs[0]], ['enter', ast.body[0].hash.pairs[0].value], ['enter', ast.body[0].hash.pairs[0].value.path], ['exit', ast.body[0].hash.pairs[0].value.path], ['enter', ast.body[0].hash.pairs[0].value.params[0]], ['exit', ast.body[0].hash.pairs[0].value.params[0]], ['enter', ast.body[0].hash.pairs[0].value.hash], ['exit', ast.body[0].hash.pairs[0].value.hash], ['exit', ast.body[0].hash.pairs[0].value], ['exit', ast.body[0].hash.pairs[0]], ['enter', ast.body[0].hash.pairs[1]], ['enter', ast.body[0].hash.pairs[1].value], ['enter', ast.body[0].hash.pairs[1].value.path], ['exit', ast.body[0].hash.pairs[1].value.path], ['enter', ast.body[0].hash.pairs[1].value.hash], ['enter', ast.body[0].hash.pairs[1].value.hash.pairs[0]], ['enter', ast.body[0].hash.pairs[1].value.hash.pairs[0].value], ['enter', ast.body[0].hash.pairs[1].value.hash.pairs[0].value.path], ['exit', ast.body[0].hash.pairs[1].value.hash.pairs[0].value.path], ['enter', ast.body[0].hash.pairs[1].value.hash.pairs[0].value.params[0]], ['exit', ast.body[0].hash.pairs[1].value.hash.pairs[0].value.params[0]], ['enter', ast.body[0].hash.pairs[1].value.hash.pairs[0].value.hash], ['exit', ast.body[0].hash.pairs[1].value.hash.pairs[0].value.hash], ['exit', ast.body[0].hash.pairs[1].value.hash.pairs[0].value], ['exit', ast.body[0].hash.pairs[1].value.hash.pairs[0]], ['exit', ast.body[0].hash.pairs[1].value.hash], ['exit', ast.body[0].hash.pairs[1].value], ['exit', ast.body[0].hash.pairs[1]], ['exit', ast.body[0].hash], ['exit', ast.body[0]], ['exit', ast]]);
    });
    test('Comments', function () {
        var ast = _glimmerSyntax.preprocess('<!-- HTML comment -->{{!-- Handlebars comment --}}<div {{! Other Comment }}></div>');
        traversalEqual(ast, [['enter', ast], ['enter', ast.body[0]], ['exit', ast.body[0]], ['enter', ast.body[1]], ['exit', ast.body[1]], ['enter', ast.body[2]], ['enter', ast.body[2].comments[0]], ['exit', ast.body[2].comments[0]], ['exit', ast.body[2]], ['exit', ast]]);
    });
});

enifed('@glimmer/syntax/tests/traversal/visiting-node-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/syntax/tests/traversal');
    QUnit.test('@glimmer/syntax/tests/traversal/visiting-node-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/syntax/tests/traversal/visiting-node-test.ts should pass tslint.');
    });
});

enifed('@glimmer/syntax/tests/traversal/walker-node-test', ['exports', '@glimmer/syntax'], function (exports, _glimmerSyntax) {
    'use strict';

    function compareWalkedNodes(html, expected) {
        var ast = _glimmerSyntax.preprocess(html);
        var walker = new _glimmerSyntax.Walker();
        var nodes = [];
        walker.visit(ast, function (node) {
            nodes.push(node.type);
        });
        deepEqual(nodes, expected);
    }
    QUnit.module('[glimmer-syntax] (Legacy) Traversal - Walker');
    test('walks elements', function () {
        compareWalkedNodes('<div><li></li></div>', ['Program', 'ElementNode', 'ElementNode']);
    });
    test('walks blocks', function () {
        compareWalkedNodes('{{#foo}}<li></li>{{/foo}}', ['Program', 'BlockStatement', 'Program', 'ElementNode']);
    });
});

enifed('@glimmer/syntax/tests/traversal/walker-node-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/syntax/tests/traversal');
    QUnit.test('@glimmer/syntax/tests/traversal/walker-node-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/syntax/tests/traversal/walker-node-test.ts should pass tslint.');
    });
});

enifed('@glimmer/test-helpers/index', ['exports', '@glimmer/test-helpers/lib/helpers', '@glimmer/test-helpers/lib/environment', '@glimmer/test-helpers/lib/abstract-test-case'], function (exports, _glimmerTestHelpersLibHelpers, _glimmerTestHelpersLibEnvironment, _glimmerTestHelpersLibAbstractTestCase) {
  'use strict';

  exports.compile = _glimmerTestHelpersLibHelpers.compile;
  exports.compileLayout = _glimmerTestHelpersLibHelpers.compileLayout;
  exports.equalInnerHTML = _glimmerTestHelpersLibHelpers.equalInnerHTML;
  exports.equalHTML = _glimmerTestHelpersLibHelpers.equalHTML;
  exports.equalTokens = _glimmerTestHelpersLibHelpers.equalTokens;
  exports.generateSnapshot = _glimmerTestHelpersLibHelpers.generateSnapshot;
  exports.equalSnapshots = _glimmerTestHelpersLibHelpers.equalSnapshots;
  exports.normalizeInnerHTML = _glimmerTestHelpersLibHelpers.normalizeInnerHTML;
  exports.isCheckedInputHTML = _glimmerTestHelpersLibHelpers.isCheckedInputHTML;
  exports.getTextContent = _glimmerTestHelpersLibHelpers.getTextContent;
  exports.strip = _glimmerTestHelpersLibHelpers.strip;
  exports.stripTight = _glimmerTestHelpersLibHelpers.stripTight;
  exports.trimLines = _glimmerTestHelpersLibHelpers.trimLines;
  exports.Attrs = _glimmerTestHelpersLibEnvironment.Attrs;
  exports.BasicComponent = _glimmerTestHelpersLibEnvironment.BasicComponent;
  exports.EmberishCurlyComponent = _glimmerTestHelpersLibEnvironment.EmberishCurlyComponent;
  exports.EmberishGlimmerComponent = _glimmerTestHelpersLibEnvironment.EmberishGlimmerComponent;
  exports.TestModifierManager = _glimmerTestHelpersLibEnvironment.TestModifierManager;
  exports.TestEnvironment = _glimmerTestHelpersLibEnvironment.TestEnvironment;
  exports.TestDynamicScope = _glimmerTestHelpersLibEnvironment.TestDynamicScope;
  exports.equalsElement = _glimmerTestHelpersLibEnvironment.equalsElement;
  exports.inspectHooks = _glimmerTestHelpersLibEnvironment.inspectHooks;
  exports.regex = _glimmerTestHelpersLibEnvironment.regex;
  exports.classes = _glimmerTestHelpersLibEnvironment.classes;
  exports.VersionedObject = _glimmerTestHelpersLibAbstractTestCase.VersionedObject;
  exports.testModule = _glimmerTestHelpersLibAbstractTestCase.testModule;
  exports.template = _glimmerTestHelpersLibAbstractTestCase.template;
  exports.RenderingTest = _glimmerTestHelpersLibAbstractTestCase.RenderingTest;
  exports.SimpleRootReference = _glimmerTestHelpersLibAbstractTestCase.SimpleRootReference;
});

enifed('@glimmer/test-helpers/index.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/test-helpers');
    QUnit.test('@glimmer/test-helpers/index.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/test-helpers/index.ts should pass tslint.');
    });
});

enifed('@glimmer/test-helpers/lib/abstract-test-case', ['exports', '@glimmer/reference', '@glimmer/test-helpers/lib/environment', '@glimmer/test-helpers/lib/helpers'], function (exports, _glimmerReference, _glimmerTestHelpersLibEnvironment, _glimmerTestHelpersLibHelpers) {
    'use strict';

    exports.skip = skip;
    exports.testModule = testModule;
    exports.template = template;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function skip(target, name, descriptor) {
        descriptor.value['skip'] = true;
    }

    var VersionedObject = (function () {
        function VersionedObject(value) {
            _classCallCheck(this, VersionedObject);

            this.tag = new _glimmerReference.DirtyableTag();
            _glimmerTestHelpersLibHelpers.assign(this, value);
        }

        VersionedObject.prototype.update = function update(value) {
            _glimmerTestHelpersLibHelpers.assign(this, value);
            this.dirty();
        };

        VersionedObject.prototype.set = function set(key, value) {
            this[key] = value;
            this.dirty();
        };

        VersionedObject.prototype.dirty = function dirty() {
            this.tag.dirty();
        };

        return VersionedObject;
    })();

    exports.VersionedObject = VersionedObject;

    var SimpleRootReference = (function () {
        function SimpleRootReference(object) {
            _classCallCheck(this, SimpleRootReference);

            this.object = object;
            this.tag = object.tag;
        }

        SimpleRootReference.prototype.get = function get(key) {
            return new SimplePathReference(this, key);
        };

        SimpleRootReference.prototype.value = function value() {
            return this.object;
        };

        return SimpleRootReference;
    })();

    exports.SimpleRootReference = SimpleRootReference;

    var SimplePathReference = (function () {
        function SimplePathReference(parent, key) {
            _classCallCheck(this, SimplePathReference);

            this.parent = parent;
            this.key = key;
            this.tag = parent.tag;
        }

        SimplePathReference.prototype.get = function get(key) {
            return new SimplePathReference(this, key);
        };

        SimplePathReference.prototype.value = function value() {
            return this.parent.value()[this.key];
        };

        return SimplePathReference;
    })();

    function isMarker(node) {
        if (node instanceof Comment && node.textContent === '') {
            return true;
        }
        if (node instanceof Text && node.textContent === '') {
            return true;
        }
        return false;
    }

    var RenderingTest = (function () {
        function RenderingTest(env, template, appendTo) {
            if (env === undefined) env = new _glimmerTestHelpersLibEnvironment.TestEnvironment();

            _classCallCheck(this, RenderingTest);

            this.env = env;
            this.appendTo = appendTo;
            this.context = null;
            this.result = null;
            this.template = this.env.compile(template);
            this.assert = QUnit.config.current.assert;
        }

        RenderingTest.prototype.teardown = function teardown() {};

        RenderingTest.prototype.render = function render(context) {
            this.env.begin();
            var dynamicScope = new _glimmerTestHelpersLibEnvironment.TestDynamicScope();
            var appendTo = this.appendTo;
            var rootObject = new VersionedObject(context);
            var root = new SimpleRootReference(rootObject);
            this.context = rootObject;
            this.result = this.template.render(root, appendTo, dynamicScope);
            this.env.commit();
            this.element = document.getElementById('qunit-fixture').firstChild;
        };

        RenderingTest.prototype.assertContent = function assertContent(expected, message) {
            var actual = document.getElementById('qunit-fixture').innerHTML;
            QUnit.equal(actual, expected);
        };

        RenderingTest.prototype.takeSnapshot = function takeSnapshot() {
            var snapshot = this.snapshot = [];
            var node = this.element.firstChild;
            while (node) {
                if (!isMarker(node)) {
                    snapshot.push(node);
                }
                node = node.nextSibling;
            }
            return snapshot;
        };

        RenderingTest.prototype.assertStableRerender = function assertStableRerender() {
            this.takeSnapshot();
            this.rerender();
            this.assertInvariants();
        };

        RenderingTest.prototype.rerender = function rerender() {
            this.result.rerender();
        };

        RenderingTest.prototype.assertInvariants = function assertInvariants(oldSnapshot, newSnapshot) {
            oldSnapshot = oldSnapshot || this.snapshot;
            newSnapshot = newSnapshot || this.takeSnapshot();
            this.assert.strictEqual(newSnapshot.length, oldSnapshot.length, 'Same number of nodes');
            for (var i = 0; i < oldSnapshot.length; i++) {
                this.assertSameNode(newSnapshot[i], oldSnapshot[i]);
            }
        };

        RenderingTest.prototype.assertSameNode = function assertSameNode(actual, expected) {
            this.assert.strictEqual(actual, expected, 'DOM node stability');
        };

        RenderingTest.prototype.runTask = function runTask(callback) {
            callback();
            this.env.begin();
            this.result.rerender();
            this.env.commit();
        };

        return RenderingTest;
    })();

    exports.RenderingTest = RenderingTest;

    function testModule(description) {
        return function (TestClass) {
            var context = undefined;
            QUnit.module('[Browser] ' + (description || TestClass.name), {
                afterEach: function () {
                    context.teardown();
                }
            });
            var keys = Object.getOwnPropertyNames(TestClass.prototype);
            keys.forEach(function (key) {
                if (key === 'constructor') return;
                var value = Object.getOwnPropertyDescriptor(TestClass.prototype, key).value;
                var isSkipped = value.skip;
                if (typeof value === 'function' && !isSkipped) {
                    QUnit.test(key, function (assert) {
                        var env = new _glimmerTestHelpersLibEnvironment.TestEnvironment();
                        context = new TestClass(env, value['template'], document.getElementById('qunit-fixture'));
                        value.call(context, assert);
                    });
                } else if (isSkipped) {
                    QUnit.skip(key, function () {});
                }
            });
        };
    }

    function template(t) {
        return function template(target, name, descriptor) {
            if (typeof descriptor.value !== 'function') {
                throw new Error("Can't decorator a non-function with the @template decorator");
            }
            descriptor.value['template'] = t;
        };
    }
});

enifed('@glimmer/test-helpers/lib/abstract-test-case.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/test-helpers/lib');
    QUnit.test('@glimmer/test-helpers/lib/abstract-test-case.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/test-helpers/lib/abstract-test-case.ts should pass tslint.');
    });
});

enifed("@glimmer/test-helpers/lib/environment", ["exports", "@glimmer/runtime", "@glimmer/test-helpers/lib/helpers", "@glimmer/util", "@glimmer/object", "@glimmer/reference", "@glimmer/object-reference"], function (exports, _glimmerRuntime, _glimmerTestHelpersLibHelpers, _glimmerUtil, _glimmerObject, _glimmerReference, _glimmerObjectReference) {
    "use strict";

    exports.inspectHooks = inspectHooks;
    exports.equalsElement = equalsElement;
    exports.equalsAttr = equalsAttr;
    exports.equals = equals;
    exports.regex = regex;
    exports.classes = classes;

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var ArrayIterator = (function () {
        function ArrayIterator(array, keyFor) {
            _classCallCheck(this, ArrayIterator);

            this.position = 0;
            this.array = array;
            this.keyFor = keyFor;
        }

        ArrayIterator.prototype.isEmpty = function isEmpty() {
            return this.array.length === 0;
        };

        ArrayIterator.prototype.next = function next() {
            var position = this.position;
            var array = this.array;
            var keyFor = this.keyFor;

            if (position >= array.length) return null;
            var value = array[position];
            var key = keyFor(value, position);
            var memo = position;
            this.position++;
            return { key: key, value: value, memo: memo };
        };

        return ArrayIterator;
    })();

    var ObjectKeysIterator = (function () {
        function ObjectKeysIterator(keys, values, keyFor) {
            _classCallCheck(this, ObjectKeysIterator);

            this.position = 0;
            this.keys = keys;
            this.values = values;
            this.keyFor = keyFor;
        }

        ObjectKeysIterator.prototype.isEmpty = function isEmpty() {
            return this.keys.length === 0;
        };

        ObjectKeysIterator.prototype.next = function next() {
            var position = this.position;
            var keys = this.keys;
            var values = this.values;
            var keyFor = this.keyFor;

            if (position >= keys.length) return null;
            var value = values[position];
            var memo = keys[position];
            var key = keyFor(value, memo);
            this.position++;
            return { key: key, value: value, memo: memo };
        };

        return ObjectKeysIterator;
    })();

    var EmptyIterator = (function () {
        function EmptyIterator() {
            _classCallCheck(this, EmptyIterator);
        }

        EmptyIterator.prototype.isEmpty = function isEmpty() {
            return true;
        };

        EmptyIterator.prototype.next = function next() {
            throw new Error("Cannot call next() on an empty iterator");
        };

        return EmptyIterator;
    })();

    var EMPTY_ITERATOR = new EmptyIterator();

    var Iterable = (function () {
        function Iterable(ref, keyFor) {
            _classCallCheck(this, Iterable);

            this.tag = ref.tag;
            this.ref = ref;
            this.keyFor = keyFor;
        }

        Iterable.prototype.iterate = function iterate() {
            var ref = this.ref;
            var keyFor = this.keyFor;

            var iterable = ref.value();
            if (Array.isArray(iterable)) {
                return iterable.length > 0 ? new ArrayIterator(iterable, keyFor) : EMPTY_ITERATOR;
            } else if (iterable === undefined || iterable === null) {
                return EMPTY_ITERATOR;
            } else if (iterable.forEach !== undefined) {
                var _ret = (function () {
                    var array = [];
                    iterable.forEach(function (item) {
                        array.push(item);
                    });
                    return {
                        v: array.length > 0 ? new ArrayIterator(array, keyFor) : EMPTY_ITERATOR
                    };
                })();

                if (typeof _ret === "object") return _ret.v;
            } else if (typeof iterable === 'object') {
                var _keys = Object.keys(iterable);
                return _keys.length > 0 ? new ObjectKeysIterator(_keys, _keys.map(function (key) {
                    return iterable[key];
                }), keyFor) : EMPTY_ITERATOR;
            } else {
                throw new Error("Don't know how to {{#each " + iterable + "}}");
            }
        };

        Iterable.prototype.valueReferenceFor = function valueReferenceFor(item) {
            return new _glimmerObjectReference.UpdatableReference(item.value);
        };

        Iterable.prototype.updateValueReference = function updateValueReference(reference, item) {
            reference.update(item.value);
        };

        Iterable.prototype.memoReferenceFor = function memoReferenceFor(item) {
            return new _glimmerObjectReference.UpdatableReference(item.memo);
        };

        Iterable.prototype.updateMemoReference = function updateMemoReference(reference, item) {
            reference.update(item.memo);
        };

        return Iterable;
    })();

    var BasicComponent = function BasicComponent(attrs) {
        _classCallCheck(this, BasicComponent);

        this.attrs = attrs;
    };

    exports.BasicComponent = BasicComponent;

    var EmberishCurlyComponent = (function (_GlimmerObject) {
        _inherits(EmberishCurlyComponent, _GlimmerObject);

        function EmberishCurlyComponent() {
            _classCallCheck(this, EmberishCurlyComponent);

            _GlimmerObject.apply(this, arguments);
            this.dirtinessTag = new _glimmerReference.DirtyableTag();
            this.tagName = null;
            this.attributeBindings = null;
            this.parentView = null;
        }

        EmberishCurlyComponent.create = function create(args) {
            return _GlimmerObject.create.call(this, args);
        };

        EmberishCurlyComponent.prototype.recompute = function recompute() {
            this.dirtinessTag.dirty();
        };

        EmberishCurlyComponent.prototype.didInitAttrs = function didInitAttrs(options) {};

        EmberishCurlyComponent.prototype.didUpdateAttrs = function didUpdateAttrs(diff) {};

        EmberishCurlyComponent.prototype.didReceiveAttrs = function didReceiveAttrs(diff) {};

        EmberishCurlyComponent.prototype.willInsertElement = function willInsertElement() {};

        EmberishCurlyComponent.prototype.willUpdate = function willUpdate() {};

        EmberishCurlyComponent.prototype.willRender = function willRender() {};

        EmberishCurlyComponent.prototype.didInsertElement = function didInsertElement() {};

        EmberishCurlyComponent.prototype.didUpdate = function didUpdate() {};

        EmberishCurlyComponent.prototype.didRender = function didRender() {};

        return EmberishCurlyComponent;
    })(_glimmerObject.default);

    exports.EmberishCurlyComponent = EmberishCurlyComponent;

    var EmberishGlimmerComponent = (function (_GlimmerObject2) {
        _inherits(EmberishGlimmerComponent, _GlimmerObject2);

        function EmberishGlimmerComponent() {
            _classCallCheck(this, EmberishGlimmerComponent);

            _GlimmerObject2.apply(this, arguments);
            this.dirtinessTag = new _glimmerReference.DirtyableTag();
            this.parentView = null;
        }

        EmberishGlimmerComponent.create = function create(args) {
            return _GlimmerObject2.create.call(this, args);
        };

        EmberishGlimmerComponent.prototype.recompute = function recompute() {
            this.dirtinessTag.dirty();
        };

        EmberishGlimmerComponent.prototype.didInitAttrs = function didInitAttrs(options) {};

        EmberishGlimmerComponent.prototype.didUpdateAttrs = function didUpdateAttrs(diff) {};

        EmberishGlimmerComponent.prototype.didReceiveAttrs = function didReceiveAttrs(diff) {};

        EmberishGlimmerComponent.prototype.willInsertElement = function willInsertElement() {};

        EmberishGlimmerComponent.prototype.willUpdate = function willUpdate() {};

        EmberishGlimmerComponent.prototype.willRender = function willRender() {};

        EmberishGlimmerComponent.prototype.didInsertElement = function didInsertElement() {};

        EmberishGlimmerComponent.prototype.didUpdate = function didUpdate() {};

        EmberishGlimmerComponent.prototype.didRender = function didRender() {};

        return EmberishGlimmerComponent;
    })(_glimmerObject.default);

    exports.EmberishGlimmerComponent = EmberishGlimmerComponent;

    var BasicComponentManager = (function () {
        function BasicComponentManager() {
            _classCallCheck(this, BasicComponentManager);
        }

        BasicComponentManager.prototype.prepareArgs = function prepareArgs(definition, args) {
            return args;
        };

        BasicComponentManager.prototype.create = function create(environment, definition, args) {
            var klass = definition.ComponentClass || BasicComponent;
            return new klass(args.named.value());
        };

        BasicComponentManager.prototype.layoutFor = function layoutFor(definition, component, env) {
            var layout = env.compiledLayouts[definition.name];
            if (layout) {
                return layout;
            }
            return env.compiledLayouts[definition.name] = _glimmerRuntime.compileLayout(new BasicComponentLayoutCompiler(definition.layoutString), env);
        };

        BasicComponentManager.prototype.getSelf = function getSelf(component) {
            return new _glimmerObjectReference.UpdatableReference(component);
        };

        BasicComponentManager.prototype.didCreateElement = function didCreateElement(component, element) {
            component.element = element;
        };

        BasicComponentManager.prototype.didRenderLayout = function didRenderLayout(component, bounds) {
            component.bounds = bounds;
        };

        BasicComponentManager.prototype.didCreate = function didCreate() {};

        BasicComponentManager.prototype.getTag = function getTag() {
            return null;
        };

        BasicComponentManager.prototype.update = function update(component, attrs) {
            component.attrs = attrs.named.value();
        };

        BasicComponentManager.prototype.didUpdateLayout = function didUpdateLayout() {};

        BasicComponentManager.prototype.didUpdate = function didUpdate() {};

        BasicComponentManager.prototype.getDestructor = function getDestructor() {
            return null;
        };

        return BasicComponentManager;
    })();

    var BASIC_COMPONENT_MANAGER = new BasicComponentManager();

    var StaticTaglessComponentManager = (function (_BasicComponentManager) {
        _inherits(StaticTaglessComponentManager, _BasicComponentManager);

        function StaticTaglessComponentManager() {
            _classCallCheck(this, StaticTaglessComponentManager);

            _BasicComponentManager.apply(this, arguments);
        }

        StaticTaglessComponentManager.prototype.layoutFor = function layoutFor(definition, component, env) {
            var layout = env.compiledLayouts[definition.name];
            if (layout) {
                return layout;
            }
            return env.compiledLayouts[definition.name] = _glimmerRuntime.compileLayout(new StaticTaglessComponentLayoutCompiler(definition.layoutString), env);
        };

        return StaticTaglessComponentManager;
    })(BasicComponentManager);

    var STATIC_TAGLESS_COMPONENT_MANAGER = new StaticTaglessComponentManager();
    var BaseEmberishGlimmerComponent = EmberishGlimmerComponent.extend();

    var EmberishGlimmerComponentManager = (function () {
        function EmberishGlimmerComponentManager() {
            _classCallCheck(this, EmberishGlimmerComponentManager);
        }

        EmberishGlimmerComponentManager.prototype.prepareArgs = function prepareArgs(definition, args) {
            return args;
        };

        EmberishGlimmerComponentManager.prototype.create = function create(environment, definition, args, dynamicScope, callerSelf, hasDefaultBlock) {
            var klass = definition.ComponentClass || BaseEmberishGlimmerComponent;
            var attrs = args.named.value();
            var component = klass.create({ attrs: attrs });
            component.didInitAttrs({ attrs: attrs });
            component.didReceiveAttrs({ oldAttrs: null, newAttrs: attrs });
            component.willInsertElement();
            component.willRender();
            return component;
        };

        EmberishGlimmerComponentManager.prototype.layoutFor = function layoutFor(definition, component, env) {
            if (env.compiledLayouts[definition.name]) {
                return env.compiledLayouts[definition.name];
            }
            return env.compiledLayouts[definition.name] = _glimmerRuntime.compileLayout(new EmberishGlimmerComponentLayoutCompiler(definition.layoutString), env);
        };

        EmberishGlimmerComponentManager.prototype.getSelf = function getSelf(component) {
            return new _glimmerObjectReference.UpdatableReference(component);
        };

        EmberishGlimmerComponentManager.prototype.didCreateElement = function didCreateElement(component, element) {
            component.element = element;
        };

        EmberishGlimmerComponentManager.prototype.didRenderLayout = function didRenderLayout(component, bounds) {
            component.bounds = bounds;
        };

        EmberishGlimmerComponentManager.prototype.didCreate = function didCreate(component) {
            component.didInsertElement();
            component.didRender();
        };

        EmberishGlimmerComponentManager.prototype.getTag = function getTag(component) {
            return component.dirtinessTag;
        };

        EmberishGlimmerComponentManager.prototype.update = function update(component, args) {
            var oldAttrs = component.attrs;
            var newAttrs = args.named.value();
            component.set('attrs', newAttrs);
            component.didUpdateAttrs({ oldAttrs: oldAttrs, newAttrs: newAttrs });
            component.didReceiveAttrs({ oldAttrs: oldAttrs, newAttrs: newAttrs });
            component.willUpdate();
            component.willRender();
        };

        EmberishGlimmerComponentManager.prototype.didUpdateLayout = function didUpdateLayout() {};

        EmberishGlimmerComponentManager.prototype.didUpdate = function didUpdate(component) {
            component.didUpdate();
            component.didRender();
        };

        EmberishGlimmerComponentManager.prototype.getDestructor = function getDestructor(component) {
            return {
                destroy: function () {
                    component.destroy();
                }
            };
        };

        return EmberishGlimmerComponentManager;
    })();

    var ProcessedArgs = (function () {
        function ProcessedArgs(args, positionalParamsDefinition) {
            _classCallCheck(this, ProcessedArgs);

            this.tag = args.tag;
            this.named = args.named;
            this.positional = args.positional;
            this.positionalParamNames = positionalParamsDefinition;
        }

        ProcessedArgs.prototype.value = function value() {
            var named = this.named;
            var positional = this.positional;
            var positionalParamNames = this.positionalParamNames;

            var merged = Object.assign({}, named.value());
            if (positionalParamNames && positionalParamNames.length) {
                for (var i = 0; i < positionalParamNames.length; i++) {
                    var _name = positionalParamNames[i];
                    var reference = positional.at(i);
                    merged[_name] = reference.value();
                }
            }
            return {
                attrs: merged,
                props: merged
            };
        };

        return ProcessedArgs;
    })();

    exports.ProcessedArgs = ProcessedArgs;

    function processArgs(args, positionalParamsDefinition) {
        return new ProcessedArgs(args, positionalParamsDefinition);
    }
    var EMBERISH_GLIMMER_COMPONENT_MANAGER = new EmberishGlimmerComponentManager();
    var BaseEmberishCurlyComponent = EmberishCurlyComponent.extend();

    var EmberishCurlyComponentManager = (function () {
        function EmberishCurlyComponentManager() {
            _classCallCheck(this, EmberishCurlyComponentManager);
        }

        EmberishCurlyComponentManager.prototype.prepareArgs = function prepareArgs(definition, args, dynamicScope) {
            var dyn = definition.ComponentClass ? definition.ComponentClass['fromDynamicScope'] : null;
            if (dyn) {
                (function () {
                    var map = _glimmerUtil.assign({}, args.named.map);
                    dyn.forEach(function (name) {
                        return map[name] = dynamicScope.get(name);
                    });
                    args = _glimmerRuntime.EvaluatedArgs.create(args.positional, _glimmerRuntime.EvaluatedNamedArgs.create(map), args.blocks);
                })();
            }
            return args;
        };

        EmberishCurlyComponentManager.prototype.create = function create(environment, definition, args, dynamicScope, callerSelf) {
            var klass = definition.ComponentClass || BaseEmberishCurlyComponent;
            var processedArgs = processArgs(args, klass['positionalParams']);

            var _processedArgs$value = processedArgs.value();

            var attrs = _processedArgs$value.attrs;

            var self = callerSelf.value();
            var merged = _glimmerUtil.assign({}, attrs, { attrs: attrs }, { args: processedArgs }, { targetObject: self });
            var component = klass.create(merged);
            component.didInitAttrs({ attrs: attrs });
            component.didReceiveAttrs({ oldAttrs: null, newAttrs: attrs });
            component.willInsertElement();
            component.willRender();
            return component;
        };

        EmberishCurlyComponentManager.prototype.layoutFor = function layoutFor(definition, component, env) {
            var layout = env.compiledLayouts[definition.name];
            if (layout) {
                return layout;
            }
            var layoutString = definition.layoutString;
            var lateBound = !layoutString;
            if (!layoutString && layoutString !== '') {
                layoutString = component['layout'];
            }
            layout = _glimmerRuntime.compileLayout(new EmberishCurlyComponentLayoutCompiler(layoutString), env);
            return lateBound ? layout : env.compiledLayouts[definition.name] = layout;
        };

        EmberishCurlyComponentManager.prototype.getSelf = function getSelf(component) {
            return new _glimmerObjectReference.UpdatableReference(component);
        };

        EmberishCurlyComponentManager.prototype.didCreateElement = function didCreateElement(component, element, operations) {
            component.element = element;
            var bindings = component.attributeBindings;
            var rootRef = new _glimmerObjectReference.UpdatableReference(component);
            if (bindings) {
                for (var i = 0; i < bindings.length; i++) {
                    var attribute = bindings[i];
                    var reference = rootRef.get(attribute);
                    operations.addDynamicAttribute(element, attribute, reference, false);
                }
            }
        };

        EmberishCurlyComponentManager.prototype.didRenderLayout = function didRenderLayout(component, bounds) {
            component.bounds = bounds;
        };

        EmberishCurlyComponentManager.prototype.didCreate = function didCreate(component) {
            component.didInsertElement();
            component.didRender();
        };

        EmberishCurlyComponentManager.prototype.getTag = function getTag(component) {
            return component.dirtinessTag;
        };

        EmberishCurlyComponentManager.prototype.update = function update(component, args) {
            var oldAttrs = component.attrs;
            var newAttrs = component.args.value().attrs;
            var merged = _glimmerUtil.assign({}, newAttrs, { attrs: newAttrs });
            component.setProperties(merged);
            component.didUpdateAttrs({ oldAttrs: oldAttrs, newAttrs: newAttrs });
            component.didReceiveAttrs({ oldAttrs: oldAttrs, newAttrs: newAttrs });
            component.willUpdate();
            component.willRender();
        };

        EmberishCurlyComponentManager.prototype.didUpdateLayout = function didUpdateLayout() {};

        EmberishCurlyComponentManager.prototype.didUpdate = function didUpdate(component) {
            component.didUpdate();
            component.didRender();
        };

        EmberishCurlyComponentManager.prototype.getDestructor = function getDestructor(component) {
            return {
                destroy: function () {
                    component.destroy();
                }
            };
        };

        return EmberishCurlyComponentManager;
    })();

    var EMBERISH_CURLY_COMPONENT_MANAGER = new EmberishCurlyComponentManager();
    function emberToBool(value) {
        if (Array.isArray(value)) {
            return value.length > 0;
        } else {
            return !!value;
        }
    }

    var EmberishConditionalReference = (function (_ConditionalReference) {
        _inherits(EmberishConditionalReference, _ConditionalReference);

        function EmberishConditionalReference() {
            _classCallCheck(this, EmberishConditionalReference);

            _ConditionalReference.apply(this, arguments);
        }

        EmberishConditionalReference.prototype.toBool = function toBool(value) {
            return emberToBool(value);
        };

        return EmberishConditionalReference;
    })(_glimmerRuntime.ConditionalReference);

    var SimplePathReference = (function () {
        function SimplePathReference(parent, property) {
            _classCallCheck(this, SimplePathReference);

            this.tag = _glimmerReference.VOLATILE_TAG;
            this.parent = parent;
            this.property = property;
        }

        SimplePathReference.prototype.value = function value() {
            return this.parent.value()[this.property];
        };

        SimplePathReference.prototype.get = function get(prop) {
            return new SimplePathReference(this, prop);
        };

        return SimplePathReference;
    })();

    exports.SimplePathReference = SimplePathReference;

    var HelperReference = (function () {
        function HelperReference(helper, args) {
            _classCallCheck(this, HelperReference);

            this.tag = _glimmerReference.VOLATILE_TAG;
            this.helper = helper;
            this.args = args;
        }

        HelperReference.prototype.value = function value() {
            var helper = this.helper;
            var _args = this.args;
            var positional = _args.positional;
            var named = _args.named;

            return helper(positional.value(), named.value());
        };

        HelperReference.prototype.get = function get(prop) {
            return new SimplePathReference(this, prop);
        };

        return HelperReference;
    })();

    var InertModifierManager = (function () {
        function InertModifierManager() {
            _classCallCheck(this, InertModifierManager);
        }

        InertModifierManager.prototype.create = function create() {};

        InertModifierManager.prototype.install = function install(modifier) {};

        InertModifierManager.prototype.update = function update(modifier) {};

        InertModifierManager.prototype.getDestructor = function getDestructor(modifier) {
            return null;
        };

        return InertModifierManager;
    })();

    var TestModifier = function TestModifier(element, args, dom) {
        _classCallCheck(this, TestModifier);

        this.element = element;
        this.args = args;
        this.dom = dom;
    };

    exports.TestModifier = TestModifier;

    var TestModifierManager = (function () {
        function TestModifierManager() {
            _classCallCheck(this, TestModifierManager);

            this.installedElements = [];
            this.updatedElements = [];
            this.destroyedModifiers = [];
        }

        TestModifierManager.prototype.create = function create(element, args, dynamicScope, dom) {
            return new TestModifier(element, args, dom);
        };

        TestModifierManager.prototype.install = function install(_ref) {
            var element = _ref.element;
            var args = _ref.args;
            var dom = _ref.dom;

            this.installedElements.push(element);
            var param = args.positional.at(0).value();
            dom.setAttribute(element, 'data-modifier', "installed - " + param);
            return;
        };

        TestModifierManager.prototype.update = function update(_ref2) {
            var element = _ref2.element;
            var args = _ref2.args;
            var dom = _ref2.dom;

            this.updatedElements.push(element);
            var param = args.positional.at(0).value();
            dom.setAttribute(element, 'data-modifier', "updated - " + param);
            return;
        };

        TestModifierManager.prototype.getDestructor = function getDestructor(modifier) {
            var _this = this;

            return {
                destroy: function () {
                    _this.destroyedModifiers.push(modifier);
                    var element = modifier.element;
                    var dom = modifier.dom;

                    dom.removeAttribute(element, 'data-modifier');
                }
            };
        };

        return TestModifierManager;
    })();

    exports.TestModifierManager = TestModifierManager;

    var TestEnvironment = (function (_Environment) {
        _inherits(TestEnvironment, _Environment);

        function TestEnvironment() {
            var options = arguments.length <= 0 || arguments[0] === undefined ? {
                document: document,
                appendOperations: new _glimmerRuntime.DOMTreeConstruction(document)
            } : arguments[0];

            _classCallCheck(this, TestEnvironment);

            _Environment.call(this, { appendOperations: options.appendOperations, updateOperations: new _glimmerRuntime.DOMChanges(options.document) });
            this.helpers = _glimmerUtil.dict();
            this.modifiers = _glimmerUtil.dict();
            this.partials = _glimmerUtil.dict();
            this.components = _glimmerUtil.dict();
            this.compiledLayouts = _glimmerUtil.dict();
            this.uselessAnchor = options.document.createElement('a');
            this.registerHelper("if", function (_ref3) {
                var cond = _ref3[0];
                var yes = _ref3[1];
                var no = _ref3[2];
                return cond ? yes : no;
            });
            this.registerHelper("unless", function (_ref4) {
                var cond = _ref4[0];
                var yes = _ref4[1];
                var no = _ref4[2];
                return cond ? no : yes;
            });
            this.registerInternalHelper("-get-dynamic-var", _glimmerRuntime.getDynamicVar);
            this.registerModifier("action", new InertModifierManager());
            this.registerInternalHelper("component", function (vm, args, symbolTable) {
                return new DynamicComponentReference(args.positional.at(0), vm.env, symbolTable);
            });
            this.registerInternalHelper("hash", function (vm, args) {
                return args.named;
            });
        }

        TestEnvironment.prototype.protocolForURL = function protocolForURL(url) {
            this.uselessAnchor.href = url;
            return this.uselessAnchor.protocol;
        };

        TestEnvironment.prototype.registerHelper = function registerHelper(name, helper) {
            this.helpers[name] = function (vm, args) {
                return new HelperReference(helper, args);
            };
        };

        TestEnvironment.prototype.registerInternalHelper = function registerInternalHelper(name, helper) {
            this.helpers[name] = helper;
        };

        TestEnvironment.prototype.registerModifier = function registerModifier(name, modifier) {
            this.modifiers[name] = modifier;
        };

        TestEnvironment.prototype.registerPartial = function registerPartial(name, source) {
            this.partials[name] = new _glimmerRuntime.PartialDefinition(name, _glimmerTestHelpersLibHelpers.compile(source, { env: this }));
        };

        TestEnvironment.prototype.registerComponent = function registerComponent(name, definition) {
            this.components[name] = definition;
            return definition;
        };

        TestEnvironment.prototype.registerBasicComponent = function registerBasicComponent(name, Component, layout) {
            var definition = new BasicComponentDefinition(name, BASIC_COMPONENT_MANAGER, Component, layout);
            return this.registerComponent(name, definition);
        };

        TestEnvironment.prototype.registerStaticTaglessComponent = function registerStaticTaglessComponent(name, Component, layout) {
            var definition = new StaticTaglessComponentDefinition(name, STATIC_TAGLESS_COMPONENT_MANAGER, Component, layout);
            return this.registerComponent(name, definition);
        };

        TestEnvironment.prototype.registerEmberishCurlyComponent = function registerEmberishCurlyComponent(name, Component, layout) {
            var definition = new EmberishCurlyComponentDefinition(name, EMBERISH_CURLY_COMPONENT_MANAGER, Component, layout);
            return this.registerComponent(name, definition);
        };

        TestEnvironment.prototype.registerEmberishGlimmerComponent = function registerEmberishGlimmerComponent(name, Component, layout) {
            var definition = new EmberishGlimmerComponentDefinition(name, EMBERISH_GLIMMER_COMPONENT_MANAGER, Component, layout);
            return this.registerComponent(name, definition);
        };

        TestEnvironment.prototype.toConditionalReference = function toConditionalReference(reference) {
            if (_glimmerReference.isConst(reference)) {
                return _glimmerRuntime.PrimitiveReference.create(emberToBool(reference.value()));
            }
            return new EmberishConditionalReference(reference);
        };

        TestEnvironment.prototype.macros = function macros() {
            var macros = _Environment.prototype.macros.call(this);
            populateBlocks(macros.blocks, macros.inlines);
            return macros;
        };

        TestEnvironment.prototype.hasHelper = function hasHelper(helperName) {
            return helperName.length === 1 && helperName[0] in this.helpers;
        };

        TestEnvironment.prototype.lookupHelper = function lookupHelper(helperParts) {
            var helperName = helperParts[0];
            var helper = this.helpers[helperName];
            if (!helper) throw new Error("Helper for " + helperParts.join('.') + " not found.");
            return helper;
        };

        TestEnvironment.prototype.hasPartial = function hasPartial(partialName) {
            return partialName in this.partials;
        };

        TestEnvironment.prototype.lookupPartial = function lookupPartial(partialName) {
            var partial = this.partials[partialName];
            return partial;
        };

        TestEnvironment.prototype.hasComponentDefinition = function hasComponentDefinition(name) {
            return !!this.components[name[0]];
        };

        TestEnvironment.prototype.getComponentDefinition = function getComponentDefinition(name, blockMeta) {
            return this.components[name[0]];
        };

        TestEnvironment.prototype.hasModifier = function hasModifier(modifierName) {
            return modifierName.length === 1 && modifierName[0] in this.modifiers;
        };

        TestEnvironment.prototype.lookupModifier = function lookupModifier(modifierName) {
            var name = modifierName[0];

            var modifier = this.modifiers[name];
            if (!modifier) throw new Error("Modifier for " + modifierName.join('.') + " not found.");
            return modifier;
        };

        TestEnvironment.prototype.compile = function compile(template) {
            return _glimmerTestHelpersLibHelpers.compile(template, { env: this });
        };

        TestEnvironment.prototype.compileLayout = function compileLayout(template) {
            return _glimmerTestHelpersLibHelpers.compileLayout(template, { env: this });
        };

        TestEnvironment.prototype.iterableFor = function iterableFor(ref, args) {
            var keyPath = args.named.get("key").value();
            var keyFor = undefined;
            if (!keyPath) {
                throw new Error('Must specify a key for #each');
            }
            switch (keyPath) {
                case '@index':
                    keyFor = function (_, index) {
                        return String(index);
                    };
                    break;
                case '@primitive':
                    keyFor = function (item) {
                        return String(item);
                    };
                    break;
                default:
                    keyFor = function (item) {
                        return item[keyPath];
                    };
                    break;
            }
            return new Iterable(ref, keyFor);
        };

        return TestEnvironment;
    })(_glimmerRuntime.Environment);

    exports.TestEnvironment = TestEnvironment;

    var TestDynamicScope = (function () {
        function TestDynamicScope() {
            var bucket = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

            _classCallCheck(this, TestDynamicScope);

            if (bucket) {
                this.bucket = _glimmerUtil.assign({}, bucket);
            } else {
                this.bucket = {};
            }
        }

        TestDynamicScope.prototype.get = function get(key) {
            return this.bucket[key];
        };

        TestDynamicScope.prototype.set = function set(key, reference) {
            return this.bucket[key] = reference;
        };

        TestDynamicScope.prototype.child = function child() {
            return new TestDynamicScope(this.bucket);
        };

        return TestDynamicScope;
    })();

    exports.TestDynamicScope = TestDynamicScope;

    var DynamicComponentReference = (function () {
        function DynamicComponentReference(nameRef, env, symbolTable) {
            _classCallCheck(this, DynamicComponentReference);

            this.nameRef = nameRef;
            this.env = env;
            this.symbolTable = symbolTable;
            this.tag = nameRef.tag;
        }

        DynamicComponentReference.prototype.value = function value() {
            var env = this.env;
            var nameRef = this.nameRef;

            var nameOrDef = nameRef.value();
            if (typeof nameOrDef === 'string') {
                return env.getComponentDefinition([nameOrDef], this.symbolTable);
            } else if (_glimmerRuntime.isComponentDefinition(nameOrDef)) {
                return nameOrDef;
            }
            return null;
        };

        DynamicComponentReference.prototype.get = function get() {
            return null;
        };

        return DynamicComponentReference;
    })();

    function dynamicComponentFor(vm, symbolTable) {
        var args = vm.getArgs();
        var nameRef = args.positional.at(0);
        var env = vm.env;
        return new DynamicComponentReference(nameRef, env, symbolTable);
    }
    ;

    var GenericComponentDefinition = (function (_ComponentDefinition) {
        _inherits(GenericComponentDefinition, _ComponentDefinition);

        function GenericComponentDefinition(name, manager, ComponentClass, layout) {
            _classCallCheck(this, GenericComponentDefinition);

            _ComponentDefinition.call(this, name, manager, ComponentClass);
            this.layoutString = layout;
        }

        return GenericComponentDefinition;
    })(_glimmerRuntime.ComponentDefinition);

    exports.GenericComponentDefinition = GenericComponentDefinition;

    var BasicComponentDefinition = (function (_GenericComponentDefinition) {
        _inherits(BasicComponentDefinition, _GenericComponentDefinition);

        function BasicComponentDefinition() {
            _classCallCheck(this, BasicComponentDefinition);

            _GenericComponentDefinition.apply(this, arguments);
        }

        return BasicComponentDefinition;
    })(GenericComponentDefinition);

    exports.BasicComponentDefinition = BasicComponentDefinition;

    var StaticTaglessComponentDefinition = (function (_GenericComponentDefinition2) {
        _inherits(StaticTaglessComponentDefinition, _GenericComponentDefinition2);

        function StaticTaglessComponentDefinition() {
            _classCallCheck(this, StaticTaglessComponentDefinition);

            _GenericComponentDefinition2.apply(this, arguments);
        }

        return StaticTaglessComponentDefinition;
    })(GenericComponentDefinition);

    var EmberishCurlyComponentDefinition = (function (_GenericComponentDefinition3) {
        _inherits(EmberishCurlyComponentDefinition, _GenericComponentDefinition3);

        function EmberishCurlyComponentDefinition() {
            _classCallCheck(this, EmberishCurlyComponentDefinition);

            _GenericComponentDefinition3.apply(this, arguments);
        }

        return EmberishCurlyComponentDefinition;
    })(GenericComponentDefinition);

    exports.EmberishCurlyComponentDefinition = EmberishCurlyComponentDefinition;

    var EmberishGlimmerComponentDefinition = (function (_GenericComponentDefinition4) {
        _inherits(EmberishGlimmerComponentDefinition, _GenericComponentDefinition4);

        function EmberishGlimmerComponentDefinition() {
            _classCallCheck(this, EmberishGlimmerComponentDefinition);

            _GenericComponentDefinition4.apply(this, arguments);
        }

        return EmberishGlimmerComponentDefinition;
    })(GenericComponentDefinition);

    exports.EmberishGlimmerComponentDefinition = EmberishGlimmerComponentDefinition;

    var GenericComponentLayoutCompiler = (function () {
        function GenericComponentLayoutCompiler(layoutString) {
            _classCallCheck(this, GenericComponentLayoutCompiler);

            this.layoutString = layoutString;
        }

        GenericComponentLayoutCompiler.prototype.compileLayout = function compileLayout(env) {
            return _glimmerTestHelpersLibHelpers.compileLayout(this.layoutString, { env: env });
        };

        return GenericComponentLayoutCompiler;
    })();

    var BasicComponentLayoutCompiler = (function (_GenericComponentLayoutCompiler) {
        _inherits(BasicComponentLayoutCompiler, _GenericComponentLayoutCompiler);

        function BasicComponentLayoutCompiler() {
            _classCallCheck(this, BasicComponentLayoutCompiler);

            _GenericComponentLayoutCompiler.apply(this, arguments);
        }

        BasicComponentLayoutCompiler.prototype.compile = function compile(builder) {
            builder.fromLayout(this.compileLayout(builder.env));
        };

        return BasicComponentLayoutCompiler;
    })(GenericComponentLayoutCompiler);

    var StaticTaglessComponentLayoutCompiler = (function (_GenericComponentLayoutCompiler2) {
        _inherits(StaticTaglessComponentLayoutCompiler, _GenericComponentLayoutCompiler2);

        function StaticTaglessComponentLayoutCompiler() {
            _classCallCheck(this, StaticTaglessComponentLayoutCompiler);

            _GenericComponentLayoutCompiler2.apply(this, arguments);
        }

        StaticTaglessComponentLayoutCompiler.prototype.compile = function compile(builder) {
            builder.wrapLayout(this.compileLayout(builder.env));
        };

        return StaticTaglessComponentLayoutCompiler;
    })(GenericComponentLayoutCompiler);

    function EmberTagName(vm) {
        var self = vm.getSelf().value();
        var tagName = self['tagName'];
        tagName = tagName === '' ? null : self['tagName'] || 'div';
        return _glimmerRuntime.PrimitiveReference.create(tagName);
    }
    function EmberID(vm) {
        var self = vm.getSelf().value();
        return _glimmerRuntime.PrimitiveReference.create("ember" + self._guid);
    }

    var EmberishCurlyComponentLayoutCompiler = (function (_GenericComponentLayoutCompiler3) {
        _inherits(EmberishCurlyComponentLayoutCompiler, _GenericComponentLayoutCompiler3);

        function EmberishCurlyComponentLayoutCompiler() {
            _classCallCheck(this, EmberishCurlyComponentLayoutCompiler);

            _GenericComponentLayoutCompiler3.apply(this, arguments);
        }

        EmberishCurlyComponentLayoutCompiler.prototype.compile = function compile(builder) {
            builder.wrapLayout(this.compileLayout(builder.env));
            builder.tag.dynamic(EmberTagName);
            builder.attrs.static('class', 'ember-view');
            builder.attrs.dynamic('id', EmberID);
        };

        return EmberishCurlyComponentLayoutCompiler;
    })(GenericComponentLayoutCompiler);

    var EmberishGlimmerComponentLayoutCompiler = (function (_GenericComponentLayoutCompiler4) {
        _inherits(EmberishGlimmerComponentLayoutCompiler, _GenericComponentLayoutCompiler4);

        function EmberishGlimmerComponentLayoutCompiler() {
            _classCallCheck(this, EmberishGlimmerComponentLayoutCompiler);

            _GenericComponentLayoutCompiler4.apply(this, arguments);
        }

        EmberishGlimmerComponentLayoutCompiler.prototype.compile = function compile(builder) {
            builder.fromLayout(this.compileLayout(builder.env));
            builder.attrs.static('class', 'ember-view');
            builder.attrs.dynamic('id', EmberID);
        };

        return EmberishGlimmerComponentLayoutCompiler;
    })(GenericComponentLayoutCompiler);

    function inspectHooks(ComponentClass) {
        return ComponentClass.extend({
            init: function () {
                this._super.apply(this, arguments);
                this.hooks = {
                    didInitAttrs: 0,
                    didUpdateAttrs: 0,
                    didReceiveAttrs: 0,
                    willInsertElement: 0,
                    willUpdate: 0,
                    willRender: 0,
                    didInsertElement: 0,
                    didUpdate: 0,
                    didRender: 0
                };
            },
            didInitAttrs: function () {
                this._super.apply(this, arguments);
                this.hooks['didInitAttrs']++;
            },
            didUpdateAttrs: function () {
                this._super.apply(this, arguments);
                this.hooks['didUpdateAttrs']++;
            },
            didReceiveAttrs: function () {
                this._super.apply(this, arguments);
                this.hooks['didReceiveAttrs']++;
            },
            willInsertElement: function () {
                this._super.apply(this, arguments);
                this.hooks['willInsertElement']++;
            },
            willUpdate: function () {
                this._super.apply(this, arguments);
                this.hooks['willUpdate']++;
            },
            willRender: function () {
                this._super.apply(this, arguments);
                this.hooks['willRender']++;
            },
            didInsertElement: function () {
                this._super.apply(this, arguments);
                this.hooks['didInsertElement']++;
            },
            didUpdate: function () {
                this._super.apply(this, arguments);
                this.hooks['didUpdate']++;
            },
            didRender: function () {
                this._super.apply(this, arguments);
                this.hooks['didRender']++;
            }
        });
    }

    var _BaselineSyntax$NestedBlock = _glimmerRuntime.BaselineSyntax.NestedBlock;
    var defaultBlock = _BaselineSyntax$NestedBlock.defaultBlock;
    var inverseBlock = _BaselineSyntax$NestedBlock.inverseBlock;
    var params = _BaselineSyntax$NestedBlock.params;
    var hash = _BaselineSyntax$NestedBlock.hash;

    function populateBlocks(blocks, inlines) {
        blocks.add('identity', function (sexp, builder) {
            builder.evaluate(sexp[4]);
        });
        blocks.add('render-inverse', function (sexp, builder) {
            builder.evaluate(sexp[5]);
        });
        blocks.add('-with-dynamic-vars', function (sexp, builder) {
            var block = defaultBlock(sexp);
            var args = _glimmerRuntime.compileArgs(params(sexp), hash(sexp), builder);
            builder.unit(function (b) {
                b.putArgs(args);
                b.pushDynamicScope();
                b.bindDynamicScope(args.named.keys);
                b.evaluate(_glimmerUtil.unwrap(block));
                b.popDynamicScope();
            });
        });
        blocks.add('-in-element', function (sexp, builder) {
            var block = defaultBlock(sexp);
            var args = _glimmerRuntime.compileArgs(params(sexp), hash(sexp), builder);
            builder.putArgs(args);
            builder.test('simple');
            builder.labelled(null, function (b) {
                b.jumpUnless('END');
                b.pushRemoteElement();
                b.evaluate(_glimmerUtil.unwrap(block));
                b.popRemoteElement();
            });
        });
        blocks.add('component', function (sexp, builder) {
            var path = sexp[1];
            var params = sexp[2];
            var hash = sexp[3];
            var _default = sexp[4];
            var inverse = sexp[5];

            var definitionArgs = [params.slice(0, 1), null, null, null];
            var args = [params.slice(1), hash, _default, inverse];
            builder.component.dynamic(definitionArgs, dynamicComponentFor, args, builder.symbolTable);
            return true;
        });
        blocks.addMissing(function (sexp, builder) {
            var path = sexp[1];
            var params = sexp[2];
            var hash = sexp[3];
            var _default = sexp[4];
            var inverse = sexp[5];

            var table = builder.symbolTable;
            if (!params) {
                params = [];
            }
            if (path.length > 1) {
                var definitionArgs = [[['get', path]], hash, _default, inverse];
                var args = [params, hash, _default, inverse];
                builder.component.dynamic(definitionArgs, dynamicComponentFor, args, table);
                return true;
            }
            var definition = builder.env.getComponentDefinition(path, builder.symbolTable);
            if (definition) {
                builder.component.static(definition, [params, hash, _default, inverse], table);
                return true;
            }
            return false;
        });
        inlines.add('component', function (path, params, hash, builder) {
            var definitionArgs = [params.slice(0, 1), null, null, null];
            var args = [params.slice(1), hash, null, null];
            builder.component.dynamic(definitionArgs, dynamicComponentFor, args, builder.symbolTable);
            return true;
        });
        inlines.addMissing(function (path, params, hash, builder) {
            var table = builder.symbolTable;
            var definition = builder.env.getComponentDefinition(path, builder.symbolTable);
            if (path.length > 1) {
                var definitionArgs = [[['get', path]], hash, null, null];
                var args = [params, hash, null, null];
                builder.component.dynamic(definitionArgs, dynamicComponentFor, args, table);
                return true;
            }
            if (definition) {
                builder.component.static(definition, [params, hash, null, null], table);
                return true;
            }
            return false;
        });
        return { blocks: blocks, inlines: inlines };
    }

    function equalsElement(element, tagName, attributes, content) {
        QUnit.push(element.tagName === tagName.toUpperCase(), element.tagName.toLowerCase(), tagName, "expect tagName to be " + tagName);
        var expectedAttrs = _glimmerUtil.dict();
        var expectedCount = 0;
        for (var prop in attributes) {
            expectedCount++;
            var expected = attributes[prop];
            var matcher = typeof expected === 'object' && MATCHER in expected ? expected : equalsAttr(expected);
            expectedAttrs[prop] = matcher;
            QUnit.push(expectedAttrs[prop].match(element.getAttribute(prop)), matcher.fail(element.getAttribute(prop)), matcher.fail(element.getAttribute(prop)), "Expected element's " + prop + " attribute " + matcher.expected());
        }
        var actualAttributes = {};
        for (var i = 0, l = element.attributes.length; i < l; i++) {
            actualAttributes[element.attributes[i].name] = element.attributes[i].value;
        }
        if (!(element instanceof HTMLElement)) {
            QUnit.push(element instanceof HTMLElement, null, null, "Element must be an HTML Element, not an SVG Element");
        } else {
            QUnit.push(element.attributes.length === expectedCount, element.attributes.length, expectedCount, "Expected " + expectedCount + " attributes; got " + element.outerHTML);
            if (content !== null) {
                QUnit.push(element.innerHTML === content, element.innerHTML, content, "The element had '" + content + "' as its content");
            }
        }
    }

    var MATCHER = "3d4ef194-13be-4ccf-8dc7-862eea02c93e";
    exports.MATCHER = MATCHER;

    function equalsAttr(expected) {
        return {
            "3d4ef194-13be-4ccf-8dc7-862eea02c93e": true,
            match: function (actual) {
                return expected === actual;
            },
            expected: function () {
                return "to equal " + expected;
            },
            fail: function (actual) {
                return actual + " did not equal " + expected;
            }
        };
    }

    function equals(expected) {
        return {
            "3d4ef194-13be-4ccf-8dc7-862eea02c93e": true,
            match: function (actual) {
                return expected === actual;
            },
            expected: function () {
                return "to equal " + expected;
            },
            fail: function (actual) {
                return actual + " did not equal " + expected;
            }
        };
    }

    function regex(r) {
        return {
            "3d4ef194-13be-4ccf-8dc7-862eea02c93e": true,
            match: function (v) {
                return r.test(v);
            },
            expected: function () {
                return "to match " + r;
            },
            fail: function (actual) {
                return actual + " did not match " + r;
            }
        };
    }

    function classes(expected) {
        return {
            "3d4ef194-13be-4ccf-8dc7-862eea02c93e": true,
            match: function (actual) {
                return actual && expected.split(' ').sort().join(' ') === actual.split(' ').sort().join(' ');
            },
            expected: function () {
                return "to include '" + expected + "'";
            },
            fail: function (actual) {
                return "'" + actual + "'' did not match '" + expected + "'";
            }
        };
    }
});

// Environment

// Partials

// Values

// References

enifed('@glimmer/test-helpers/lib/environment.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/test-helpers/lib');
    QUnit.test('@glimmer/test-helpers/lib/environment.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/test-helpers/lib/environment.ts should pass tslint.');
    });
});

enifed("@glimmer/test-helpers/lib/helpers", ["exports", "simple-html-tokenizer", "@glimmer/runtime", "@glimmer/compiler"], function (exports, _simpleHtmlTokenizer, _glimmerRuntime, _glimmerCompiler) {
    "use strict";

    exports.compile = compile;
    exports.compileLayout = compileLayout;
    exports.equalInnerHTML = equalInnerHTML;
    exports.equalHTML = equalHTML;
    exports.equalTokens = equalTokens;
    exports.generateSnapshot = generateSnapshot;
    exports.equalSnapshots = equalSnapshots;
    exports.normalizeInnerHTML = normalizeInnerHTML;
    exports.getTextContent = getTextContent;
    exports.strip = strip;
    exports.stripTight = stripTight;
    exports.trimLines = trimLines;

    // For Phantom
    function toObject(val) {
        if (val === null || val === undefined) {
            throw new TypeError('Object.assign cannot be called with null or undefined');
        }
        return Object(val);
    }
    if (typeof Object.assign !== 'function') {
        Object.assign = function (target, source) {
            var from = undefined;
            var to = toObject(target);
            var symbols = undefined;
            for (var s = 1; s < arguments.length; s++) {
                from = Object(arguments[s]);
                for (var key in from) {
                    if (Object.prototype.hasOwnProperty.call(from, key)) {
                        to[key] = from[key];
                    }
                }
                if (Object.getOwnPropertySymbols) {
                    symbols = Object.getOwnPropertySymbols(from);
                    for (var i = 0; i < symbols.length; i++) {
                        if (Object.prototype.propertyIsEnumerable.call(from, symbols[i])) {
                            to[symbols[i]] = from[symbols[i]];
                        }
                    }
                }
            }
            return to;
        };
    }
    var assign = Object.assign;
    exports.assign = assign;
    function isMarker(node) {
        var TextNode = window.Text;
        var Comment = window.Comment;
        if (node instanceof Comment && node.textContent === '') {
            return true;
        }
        if (node instanceof TextNode && node.textContent === '') {
            return true;
        }
        return false;
    }

    function compile(string, options) {
        var js = _glimmerCompiler.precompile(string, options);
        var factory = _glimmerRuntime.templateFactory(JSON.parse(js));
        return factory.create(options.env);
    }

    function compileLayout(string, options) {
        return compile(string, options).asLayout();
    }

    function equalInnerHTML(fragment, html, msg) {
        var actualHTML = normalizeInnerHTML(fragment.innerHTML);
        QUnit.push(actualHTML === html, actualHTML, html, msg);
    }

    function equalHTML(node, html) {
        var fragment = undefined;
        if (!node.nodeType && node.length) {
            fragment = document.createDocumentFragment();
            while (node[0]) {
                fragment.appendChild(node[0]);
            }
        } else {
            fragment = node;
        }
        var div = document.createElement("div");
        div.appendChild(fragment.cloneNode(true));
        equalInnerHTML(div, html);
    }

    function generateTokens(divOrHTML) {
        var div = undefined;
        if (typeof divOrHTML === 'string') {
            div = document.createElement("div");
            div.innerHTML = divOrHTML;
        } else {
            div = divOrHTML;
        }
        return { tokens: _simpleHtmlTokenizer.tokenize(div.innerHTML), html: div.innerHTML };
    }

    function equalTokens(fragment, html) {
        var message = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

        if (fragment.fragment) {
            fragment = fragment.fragment;
        }
        if (html.fragment) {
            html = html.fragment;
        }
        var fragTokens = generateTokens(fragment);
        var htmlTokens = generateTokens(html);
        function normalizeTokens(token) {
            if (token.type === 'StartTag') {
                token.attributes = token.attributes.sort(function (a, b) {
                    if (a[0] > b[0]) {
                        return 1;
                    }
                    if (a[0] < b[0]) {
                        return -1;
                    }
                    return 0;
                });
            }
        }
        fragTokens.tokens.forEach(normalizeTokens);
        htmlTokens.tokens.forEach(normalizeTokens);
        // let msg = "Expected: " + htmlTokens.html + "; Actual: " + fragTokens.html;
        // if (message) { msg += " (" + message + ")"; }
        var equiv = QUnit.equiv(fragTokens.tokens, htmlTokens.tokens);
        if (equiv && fragTokens.html !== htmlTokens.html) {
            QUnit.deepEqual(fragTokens.tokens, htmlTokens.tokens, message);
        } else {
            QUnit.push(QUnit.equiv(fragTokens.tokens, htmlTokens.tokens), fragTokens.html, htmlTokens.html, message);
        }
        // deepEqual(fragTokens.tokens, htmlTokens.tokens, msg);
    }

    function generateSnapshot(element) {
        var snapshot = [];
        var node = element.firstChild;
        while (node) {
            if (!isMarker(node)) {
                snapshot.push(node);
            }
            node = node.nextSibling;
        }
        return snapshot;
    }

    function equalSnapshots(a, b) {
        QUnit.strictEqual(a.length, b.length, 'Same number of nodes');
        for (var i = 0; i < b.length; i++) {
            QUnit.strictEqual(a[i], b[i], 'Nodes are the same');
        }
    }

    // detect side-effects of cloning svg elements in IE9-11
    var ieSVGInnerHTML = (function () {
        if (typeof document === 'undefined' || !document.createElementNS) {
            return false;
        }
        var div = document.createElement('div');
        var node = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        div.appendChild(node);
        var clone = div.cloneNode(true);
        return clone.innerHTML === '<svg xmlns="http://www.w3.org/2000/svg" />';
    })();

    function normalizeInnerHTML(actualHTML) {
        if (ieSVGInnerHTML) {
            // Replace `<svg xmlns="http://www.w3.org/2000/svg" height="50%" />` with `<svg height="50%"></svg>`, etc.
            // drop namespace attribute
            actualHTML = actualHTML.replace(/ xmlns="[^"]+"/, '');
            // replace self-closing elements
            actualHTML = actualHTML.replace(/<([^ >]+) [^\/>]*\/>/gi, function (tag, tagName) {
                return tag.slice(0, tag.length - 3) + '></' + tagName + '>';
            });
        }
        return actualHTML;
    }

    var isCheckedInputHTML = undefined;
    if (typeof document === 'undefined') {
        exports.isCheckedInputHTML = isCheckedInputHTML = function (element) {};
    } else {
        (function () {
            // detect weird IE8 checked element string
            var checkedInput = document.createElement('input');
            checkedInput.setAttribute('checked', 'checked');
            var checkedInputString = checkedInput.outerHTML;
            exports.isCheckedInputHTML = isCheckedInputHTML = function (element) {
                QUnit.equal(element.outerHTML, checkedInputString);
            };
        })();
    }
    exports.isCheckedInputHTML = isCheckedInputHTML;

    // check which property has the node's text content
    var textProperty = typeof document === 'object' && document.createElement('div').textContent === undefined ? 'innerText' : 'textContent';

    function getTextContent(el) {
        // textNode
        if (el.nodeType === 3) {
            return el.nodeValue;
        } else {
            return el[textProperty];
        }
    }

    function strip(strings) {
        return strings[0].split('\n').map(function (s) {
            return s.trim();
        }).join(' ');
    }

    function stripTight(strings) {
        return strings[0].split('\n').map(function (s) {
            return s.trim();
        }).join('');
    }

    function trimLines(strings) {
        return strings[0].trim().split('\n').map(function (s) {
            return s.trim();
        }).join('\n');
    }
});

enifed('@glimmer/test-helpers/lib/helpers.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/test-helpers/lib');
    QUnit.test('@glimmer/test-helpers/lib/helpers.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/test-helpers/lib/helpers.ts should pass tslint.');
    });
});

enifed('@glimmer/util/index.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/util');
    QUnit.test('@glimmer/util/index.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/util/index.ts should pass tslint.');
    });
});

enifed('@glimmer/util/lib/array-utils.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/util/lib');
    QUnit.test('@glimmer/util/lib/array-utils.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/util/lib/array-utils.ts should pass tslint.');
    });
});

enifed('@glimmer/util/lib/assert.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/util/lib');
    QUnit.test('@glimmer/util/lib/assert.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/util/lib/assert.ts should pass tslint.');
    });
});

enifed('@glimmer/util/lib/collections.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/util/lib');
    QUnit.test('@glimmer/util/lib/collections.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/util/lib/collections.ts should pass tslint.');
    });
});

enifed('@glimmer/util/lib/guid.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/util/lib');
    QUnit.test('@glimmer/util/lib/guid.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/util/lib/guid.ts should pass tslint.');
    });
});

enifed('@glimmer/util/lib/list-utils.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/util/lib');
    QUnit.test('@glimmer/util/lib/list-utils.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/util/lib/list-utils.ts should pass tslint.');
    });
});

enifed('@glimmer/util/lib/logger.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/util/lib');
    QUnit.test('@glimmer/util/lib/logger.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/util/lib/logger.ts should pass tslint.');
    });
});

enifed('@glimmer/util/lib/namespaces.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/util/lib');
    QUnit.test('@glimmer/util/lib/namespaces.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/util/lib/namespaces.ts should pass tslint.');
    });
});

enifed('@glimmer/util/lib/object-utils.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/util/lib');
    QUnit.test('@glimmer/util/lib/object-utils.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/util/lib/object-utils.ts should pass tslint.');
    });
});

enifed('@glimmer/util/lib/platform-utils.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/util/lib');
    QUnit.test('@glimmer/util/lib/platform-utils.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/util/lib/platform-utils.ts should pass tslint.');
    });
});

enifed('@glimmer/util/lib/weakmap.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/util/lib');
    QUnit.test('@glimmer/util/lib/weakmap.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/util/lib/weakmap.ts should pass tslint.');
    });
});

enifed('@glimmer/util/tests/object-utils-test', ['exports', '@glimmer/util/lib/object-utils'], function (exports, _glimmerUtilLibObjectUtils) {
    'use strict';

    QUnit.module('object-utils tests');
    QUnit.test('assign should ignore null/undefined arguments', function (assert) {
        var result = _glimmerUtilLibObjectUtils.assign({}, { foo: 'bar' }, null, undefined, { derp: "herk" });
        assert.deepEqual(result, { foo: 'bar', derp: 'herk' }, 'has correct result');
    });
});

enifed('@glimmer/util/tests/object-utils-test.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/util/tests');
    QUnit.test('@glimmer/util/tests/object-utils-test.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/util/tests/object-utils-test.ts should pass tslint.');
    });
});

enifed('@glimmer/wire-format/index.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - @glimmer/wire-format');
    QUnit.test('@glimmer/wire-format/index.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, '@glimmer/wire-format/index.ts should pass tslint.');
    });
});

enifed('glimmer-benchmarks/index.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - glimmer-benchmarks');
    QUnit.test('glimmer-benchmarks/index.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, 'glimmer-benchmarks/index.ts should pass tslint.');
    });
});

enifed('glimmer-benchmarks/lib/bench-infra.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - glimmer-benchmarks/lib');
    QUnit.test('glimmer-benchmarks/lib/bench-infra.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, 'glimmer-benchmarks/lib/bench-infra.ts should pass tslint.');
    });
});

enifed('glimmer-benchmarks/lib/bench-init.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - glimmer-benchmarks/lib');
    QUnit.test('glimmer-benchmarks/lib/bench-init.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, 'glimmer-benchmarks/lib/bench-init.ts should pass tslint.');
    });
});

enifed('glimmer-benchmarks/lib/bench-suites.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - glimmer-benchmarks/lib');
    QUnit.test('glimmer-benchmarks/lib/bench-suites.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, 'glimmer-benchmarks/lib/bench-suites.ts should pass tslint.');
    });
});

enifed('glimmer-benchmarks/lib/bench.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - glimmer-benchmarks/lib');
    QUnit.test('glimmer-benchmarks/lib/bench.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, 'glimmer-benchmarks/lib/bench.ts should pass tslint.');
    });
});

enifed('glimmer-benchmarks/lib/benchmarks/baseline.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - glimmer-benchmarks/lib/benchmarks');
    QUnit.test('glimmer-benchmarks/lib/benchmarks/baseline.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, 'glimmer-benchmarks/lib/benchmarks/baseline.ts should pass tslint.');
    });
});

enifed('glimmer-benchmarks/lib/benchmarks/components.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - glimmer-benchmarks/lib/benchmarks');
    QUnit.test('glimmer-benchmarks/lib/benchmarks/components.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, 'glimmer-benchmarks/lib/benchmarks/components.ts should pass tslint.');
    });
});

enifed('glimmer-benchmarks/lib/benchmarks/if.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - glimmer-benchmarks/lib/benchmarks');
    QUnit.test('glimmer-benchmarks/lib/benchmarks/if.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, 'glimmer-benchmarks/lib/benchmarks/if.ts should pass tslint.');
    });
});

enifed('glimmer-benchmarks/lib/benchmarks/partials.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - glimmer-benchmarks/lib/benchmarks');
    QUnit.test('glimmer-benchmarks/lib/benchmarks/partials.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, 'glimmer-benchmarks/lib/benchmarks/partials.ts should pass tslint.');
    });
});

enifed('glimmer-benchmarks/lib/stats.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - glimmer-benchmarks/lib');
    QUnit.test('glimmer-benchmarks/lib/stats.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, 'glimmer-benchmarks/lib/stats.ts should pass tslint.');
    });
});

enifed('glimmer-demos/index.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - glimmer-demos');
    QUnit.test('glimmer-demos/index.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, 'glimmer-demos/index.ts should pass tslint.');
    });
});

enifed('glimmer-demos/lib/conways.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - glimmer-demos/lib');
    QUnit.test('glimmer-demos/lib/conways.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, 'glimmer-demos/lib/conways.ts should pass tslint.');
    });
});

enifed('glimmer-demos/lib/dbmon.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - glimmer-demos/lib');
    QUnit.test('glimmer-demos/lib/dbmon.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, 'glimmer-demos/lib/dbmon.ts should pass tslint.');
    });
});

enifed('glimmer-demos/lib/ema.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - glimmer-demos/lib');
    QUnit.test('glimmer-demos/lib/ema.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, 'glimmer-demos/lib/ema.ts should pass tslint.');
    });
});

enifed('glimmer-demos/lib/ripples.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - glimmer-demos/lib');
    QUnit.test('glimmer-demos/lib/ripples.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, 'glimmer-demos/lib/ripples.ts should pass tslint.');
    });
});

enifed('glimmer-demos/lib/uptime.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - glimmer-demos/lib');
    QUnit.test('glimmer-demos/lib/uptime.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, 'glimmer-demos/lib/uptime.ts should pass tslint.');
    });
});

enifed('glimmer-demos/lib/visualizer.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - glimmer-demos/lib');
    QUnit.test('glimmer-demos/lib/visualizer.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, 'glimmer-demos/lib/visualizer.ts should pass tslint.');
    });
});

enifed('glimmer/index.tslint', ['exports'], function (exports) {
    'use strict';

    QUnit.module('TSLint - glimmer');
    QUnit.test('glimmer/index.ts should pass tslint', function (assert) {
        assert.expect(1);
        assert.ok(true, 'glimmer/index.ts should pass tslint.');
    });
});
//# sourceMappingURL=glimmer-tests.amd.map
