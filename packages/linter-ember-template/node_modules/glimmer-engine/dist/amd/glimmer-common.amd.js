enifed('@glimmer/object-model/index', ['exports', '@glimmer/object-model/lib/object', '@glimmer/object-model/lib/reference', '@glimmer/object-model/lib/blueprint'], function (exports, _glimmerObjectModelLibObject, _glimmerObjectModelLibReference, _glimmerObjectModelLibBlueprint) {
  'use strict';

  function _interopExportWildcard(obj, defaults) { var newObj = defaults({}, obj); delete newObj['default']; return newObj; }

  function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

  exports.default = _glimmerObjectModelLibObject.default;

  _defaults(exports, _interopExportWildcard(_glimmerObjectModelLibObject, _defaults));

  _defaults(exports, _interopExportWildcard(_glimmerObjectModelLibReference, _defaults));

  _defaults(exports, _interopExportWildcard(_glimmerObjectModelLibBlueprint, _defaults));
});

enifed('@glimmer/object-model/lib/blueprint', ['exports', '@glimmer/object-model/lib/reference'], function (exports, _glimmerObjectModelLibReference) {
    'use strict';

    exports.computed = computed;

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var Blueprint = function Blueprint(key) {
        _classCallCheck(this, Blueprint);

        this.key = key;
    };

    exports.Blueprint = Blueprint;

    var VALUE_DESCRIPTOR = {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
    };
    var ACCESSOR_DESCRIPTOR = {
        enumerable: true,
        configurable: true,
        get: undefined,
        set: undefined
    };

    var ValueBlueprint = (function (_Blueprint) {
        _inherits(ValueBlueprint, _Blueprint);

        function ValueBlueprint(key, value) {
            _classCallCheck(this, ValueBlueprint);

            _Blueprint.call(this, key);
            this.value = value;
        }

        ValueBlueprint.prototype.define = function define(home) {
            VALUE_DESCRIPTOR.value = this.value;
            Object.defineProperty(home, this.key, VALUE_DESCRIPTOR);
        };

        return ValueBlueprint;
    })(Blueprint);

    exports.ValueBlueprint = ValueBlueprint;

    var GlimmerDescriptor = function GlimmerDescriptor() {
        _classCallCheck(this, GlimmerDescriptor);
    };

    exports.GlimmerDescriptor = GlimmerDescriptor;

    var Computed = (function (_GlimmerDescriptor) {
        _inherits(Computed, _GlimmerDescriptor);

        function Computed(dependentKeys, accessor) {
            _classCallCheck(this, Computed);

            _GlimmerDescriptor.call(this);
            this.dependentKeys = dependentKeys;
            this.accessor = accessor;
        }

        Computed.prototype.blueprint = function blueprint(key) {
            return new ComputedBlueprint(key, this);
        };

        Computed.prototype.reference = function reference(root, key) {};

        Computed.prototype.define = function define(home, key) {
            _glimmerObjectModelLibReference.classMeta(home).defineComputed(key, this);
            ACCESSOR_DESCRIPTOR.get = this.accessor.get;
            ACCESSOR_DESCRIPTOR.set = this.accessor.set;
            Object.defineProperty(home, key, ACCESSOR_DESCRIPTOR);
        };

        return Computed;
    })(GlimmerDescriptor);

    exports.Computed = Computed;

    function computed() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var depKeys = args.slice(0, -1);
        var accessor = args[args.length - 1];
        return new Computed(depKeys, accessor);
    }

    var ComputedBlueprint = (function (_Blueprint2) {
        _inherits(ComputedBlueprint, _Blueprint2);

        function ComputedBlueprint(key, computed) {
            _classCallCheck(this, ComputedBlueprint);

            _Blueprint2.call(this, key);
            this.computed = computed;
        }

        ComputedBlueprint.prototype.define = function define(home) {
            this.computed.define(home, this.key);
        };

        return ComputedBlueprint;
    })(Blueprint);

    exports.ComputedBlueprint = ComputedBlueprint;

    var DescriptorBlueprint = (function (_Blueprint3) {
        _inherits(DescriptorBlueprint, _Blueprint3);

        function DescriptorBlueprint(key, descriptor) {
            _classCallCheck(this, DescriptorBlueprint);

            _Blueprint3.call(this, key);
            this.descriptor = descriptor;
        }

        DescriptorBlueprint.prototype.define = function define(home) {
            Object.defineProperty(home, this.key, this.descriptor);
        };

        return DescriptorBlueprint;
    })(Blueprint);

    exports.DescriptorBlueprint = DescriptorBlueprint;
});

enifed('@glimmer/object-model/lib/meta', ['exports', '@glimmer/util', '@glimmer/reference'], function (exports, _glimmerUtil, _glimmerReference) {
    'use strict';

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var _default = (function () {
        function _default() {
            _classCallCheck(this, _default);

            this.bookkeeping = _glimmerUtil.dict();
        }

        _default.prototype.tag = function tag(name) {
            var bookkeeping = this.bookkeeping;
            var tag = bookkeeping[name];
            if (tag === undefined) {
                tag = new _glimmerReference.DirtyableTag();
                bookkeeping[name] = tag;
            }
            return tag;
        };

        _default.prototype.dirty = function dirty(name) {
            var tag = this.tag(name);
            tag.dirty();
        };

        return _default;
    })();

    exports.default = _default;

    var ClassMeta = (function () {
        function ClassMeta() {
            _classCallCheck(this, ClassMeta);

            this.computed = _glimmerUtil.dict();
        }

        ClassMeta.prototype.defineComputed = function defineComputed(name, value) {
            this.computed[name] = value;
        };

        ClassMeta.prototype.getComputed = function getComputed(name) {
            return this.computed[name];
        };

        return ClassMeta;
    })();

    exports.ClassMeta = ClassMeta;
});

enifed('@glimmer/object-model/lib/object', ['exports', '@glimmer/object-model/lib/blueprint'], function (exports, _glimmerObjectModelLibBlueprint) {
    'use strict';

    exports.classof = classof;

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var GlimmerObjectBase = function GlimmerObjectBase() {
        _classCallCheck(this, GlimmerObjectBase);
    };

    exports.GlimmerObjectBase = GlimmerObjectBase;

    var GlimmerObject = (function () {
        GlimmerObject.create = function create(properties) {
            return new this(properties);
        };

        GlimmerObject.extend = function extend(extensions) {
            // This method intentionally uses internal typecasts to convince TypeScript
            // that what we're doing is legitimate. The real action of this method is in
            // its signature (and the signature of GlimmerClass).
            var sub = (function (_ref) {
                _inherits(sub, _ref);

                function sub() {
                    _classCallCheck(this, sub);

                    _ref.apply(this, arguments);
                }

                return sub;
            })(this);
            if (extensions !== undefined) {
                var blueprints = Object.keys(extensions).map(function (k) {
                    var extension = extensions[k];
                    if (extension instanceof _glimmerObjectModelLibBlueprint.GlimmerDescriptor) {
                        return extension.blueprint(k);
                    } else {
                        return new _glimmerObjectModelLibBlueprint.ValueBlueprint(k, extensions[k]);
                    }
                });
                blueprints.forEach(function (b) {
                    return b.define(sub.prototype);
                });
            }
            return sub;
        };

        function GlimmerObject(properties) {
            _classCallCheck(this, GlimmerObject);

            if (properties !== undefined) {
                Object.assign(this, properties);
            }
        }

        /**
         * Adapter for TypeScript.
         *
         * A shim library could just declare the variable as the type
         * GlimmerClass<FirstInstance>. The key point is that shimming
         * between the two worlds requires writing a static interface
         * definition, as TypeScript isn't willing to treat the dynamic
         * intersection as a valid constructor return type.
         *
         * This function is a noop and is used like this:
         *
         * ```ts
         * // in one file
         * let Person = GlimmerObject.extend({
         *   named: 'Dan'
         * });
         *
         *
         * // in a TypeScript wrapper file
         * import { Person as OriginalPerson } from 'original-definition';
         *
         * interface PersonInstance {
         *   named: string
         * }
         *
         * export let Person = classof<PersonInstance>(OriginalPerson);
         *
         * // in a subclassing file
         * import { Person } from 'wrapped-definition';
         *
         * class FancyPerson extends Person {
         *   salutation: string;
         *
         *   fullName() {
         *     return `${this.salutation} ${this.named}`;
         *   }
         * }
         *
         * FancyPerson.create({ name: 'Tom Dale', salutation: 'Mr.' }).fullName();
         * // typechecks and returns 'Mr. Tom Dale'
         * ```
        */
        return GlimmerObject;
    })();

    exports.default = GlimmerObject;

    function classof(klass) {
        return klass;
    }
});

enifed('@glimmer/object-model/lib/reference', ['exports', '@glimmer/object-model/lib/meta', '@glimmer/reference', '@glimmer/util'], function (exports, _glimmerObjectModelLibMeta, _glimmerReference, _glimmerUtil) {
    'use strict';

    exports.set = set;
    exports.root = root;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var classMeta = undefined;
    exports.classMeta = classMeta;
    var meta = undefined;
    exports.meta = meta;
    if (_glimmerUtil.HAS_NATIVE_WEAKMAP) {
        (function () {
            var META = new WeakMap();
            var CLASS_META = new WeakMap();
            exports.classMeta = classMeta = function _classMetaNative(object) {
                var m = CLASS_META.get(object);
                if (m === undefined) {
                    m = new _glimmerObjectModelLibMeta.ClassMeta();
                    CLASS_META.set(object, m);
                }
                return m;
            };
            exports.meta = meta = function _metaNative(object) {
                var m = META.get(object);
                if (m === undefined) {
                    m = new _glimmerObjectModelLibMeta.default();
                    META.set(object, m);
                }
                return m;
            };
        })();
    } else {
        (function () {
            var GLIMMER_META = 'META__glimmer__1484170086860394543206811';
            var GLIMMER_CLASS_META = 'CLASS_META__glimmer__14841708559821468834708062';
            exports.classMeta = classMeta = function _classMetaFaux(object) {
                var m = object[GLIMMER_CLASS_META];
                if (m === undefined) {
                    m = new _glimmerObjectModelLibMeta.ClassMeta();
                    object[GLIMMER_CLASS_META] = m;
                }
                return m;
            };
            exports.meta = meta = function _metaFaux(object) {
                var m = object[GLIMMER_META];
                if (m === undefined) {
                    m = new _glimmerObjectModelLibMeta.default();
                    object[GLIMMER_META] = m;
                }
                return m;
            };
        })();
    }

    function set(object, key, value) {
        object[key] = value;
        meta(object).dirty(key);
    }

    function root(object) {
        return new VersionedRootReference(object);
    }

    var VersionedRootReference = (function () {
        function VersionedRootReference(inner) {
            _classCallCheck(this, VersionedRootReference);

            this.inner = inner;
            this.tag = _glimmerReference.CONSTANT_TAG;
        }

        VersionedRootReference.prototype.value = function value() {
            return this.inner;
        };

        VersionedRootReference.prototype.get = function get(key) {
            return new VersionedObjectReference(this, key);
        };

        return VersionedRootReference;
    })();

    exports.VersionedRootReference = VersionedRootReference;

    var VersionedObjectReference = (function () {
        function VersionedObjectReference(parent, key) {
            _classCallCheck(this, VersionedObjectReference);

            this.parent = parent;
            this.key = key;
            this.tag = _glimmerReference.CURRENT_TAG;
        }

        VersionedObjectReference.prototype.value = function value() {
            var _this = this;

            var parent = this.parent;
            var key = this.key;

            var parentObject = this.parent.value();
            var computed = classMeta(Object.getPrototypeOf(parentObject)).getComputed(key);
            var tags = [meta(parentObject).tag(key)];
            if (computed) {
                tags.push.apply(tags, computed.dependentKeys.map(function (key) {
                    return path(_this, key).tag;
                }));
            }
            this.tag = _glimmerReference.combine(tags);
            return parentObject[key];
        };

        VersionedObjectReference.prototype.get = function get(key) {
            return new VersionedObjectReference(this, key);
        };

        return VersionedObjectReference;
    })();

    exports.VersionedObjectReference = VersionedObjectReference;

    function path(parent, key) {
        return key.split('.').reduce(function (ref, part) {
            return ref.get(part);
        }, parent);
    }
});

enifed("@glimmer/object-reference/index", ["exports", "@glimmer/object-reference/lib/references/descriptors", "@glimmer/object-reference/lib/meta", "@glimmer/object-reference/lib/object", "@glimmer/object-reference/lib/types", "@glimmer/object-reference/lib/references/path", "@glimmer/object-reference/lib/references/root", "@glimmer/reference"], function (exports, _glimmerObjectReferenceLibReferencesDescriptors, _glimmerObjectReferenceLibMeta, _glimmerObjectReferenceLibObject, _glimmerObjectReferenceLibTypes, _glimmerObjectReferenceLibReferencesPath, _glimmerObjectReferenceLibReferencesRoot, _glimmerReference) {
  "use strict";

  function _interopExportWildcard(obj, defaults) { var newObj = defaults({}, obj); delete newObj["default"]; return newObj; }

  function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

  exports.ComputedReferenceBlueprint = _glimmerObjectReferenceLibReferencesDescriptors.ComputedReferenceBlueprint;
  exports.InnerReferenceFactory = _glimmerObjectReferenceLibReferencesDescriptors.InnerReferenceFactory;
  exports.PropertyReference = _glimmerObjectReferenceLibReferencesDescriptors.PropertyReference;
  exports.CLASS_META = _glimmerObjectReferenceLibMeta.CLASS_META;
  exports.Meta = _glimmerObjectReferenceLibMeta.default;
  exports.metaFor = _glimmerObjectReferenceLibMeta.metaFor;
  exports.setProperty = _glimmerObjectReferenceLibObject.setProperty;
  exports.notifyProperty = _glimmerObjectReferenceLibObject.notifyProperty;

  _defaults(exports, _interopExportWildcard(_glimmerObjectReferenceLibTypes, _defaults));

  exports.ObjectReference = _glimmerObjectReferenceLibReferencesPath.default;
  exports.UpdatableReference = _glimmerObjectReferenceLibReferencesRoot.default;
  exports.ConstReference = _glimmerReference.ConstReference;
  exports.isConst = _glimmerReference.isConst;
});

enifed('@glimmer/object-reference/lib/meta', ['exports', '@glimmer/object-reference/lib/references/descriptors', '@glimmer/object-reference/lib/references/root', '@glimmer/util', '@glimmer/reference'], function (exports, _glimmerObjectReferenceLibReferencesDescriptors, _glimmerObjectReferenceLibReferencesRoot, _glimmerUtil, _glimmerReference) {
    'use strict';

    exports.metaFor = metaFor;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var NOOP_DESTROY = { destroy: function () {} };

    var ConstPath = (function () {
        function ConstPath(parent, property) {
            _classCallCheck(this, ConstPath);

            this.tag = _glimmerReference.VOLATILE_TAG;
            this.parent = parent;
        }

        ConstPath.prototype.chain = function chain() {
            return NOOP_DESTROY;
        };

        ConstPath.prototype.notify = function notify() {};

        ConstPath.prototype.value = function value() {
            return this.parent[this.property];
        };

        ConstPath.prototype.get = function get(prop) {
            return new ConstPath(this.parent[this.property], prop);
        };

        return ConstPath;
    })();

    var ConstRoot = (function () {
        function ConstRoot(value) {
            _classCallCheck(this, ConstRoot);

            this.tag = _glimmerReference.VOLATILE_TAG;
            this.inner = value;
        }

        ConstRoot.prototype.update = function update(inner) {
            this.inner = inner;
        };

        ConstRoot.prototype.chain = function chain() {
            return NOOP_DESTROY;
        };

        ConstRoot.prototype.notify = function notify() {};

        ConstRoot.prototype.value = function value() {
            return this.inner;
        };

        ConstRoot.prototype.referenceFromParts = function referenceFromParts(parts) {
            throw new Error("Not implemented");
        };

        ConstRoot.prototype.chainFor = function chainFor(prop) {
            throw new Error("Not implemented");
        };

        ConstRoot.prototype.get = function get(prop) {
            return new ConstPath(this.inner, prop);
        };

        return ConstRoot;
    })();

    var ConstMeta /*implements IMeta*/ = (function () {
        function ConstMeta(object) {
            _classCallCheck(this, ConstMeta);

            this.object = object;
        }

        ConstMeta.prototype.root = function root() {
            return new ConstRoot(this.object);
        };

        return ConstMeta;
    })();

    var CLASS_META = "df8be4c8-4e89-44e2-a8f9-550c8dacdca7";
    exports.CLASS_META = CLASS_META;
    var hasOwnProperty = Object.hasOwnProperty;

    var Meta = (function () {
        function Meta(object, _ref) {
            var RootReferenceFactory = _ref.RootReferenceFactory;
            var DefaultPathReferenceFactory = _ref.DefaultPathReferenceFactory;

            _classCallCheck(this, Meta);

            this.references = null;
            this.slots = null;
            this.referenceTypes = null;
            this.propertyMetadata = null;
            this.object = object;
            this.RootReferenceFactory = RootReferenceFactory || _glimmerObjectReferenceLibReferencesRoot.default;
            this.DefaultPathReferenceFactory = DefaultPathReferenceFactory || _glimmerObjectReferenceLibReferencesDescriptors.PropertyReference;
        }

        Meta.for = function _for(obj) {
            if (obj === null || obj === undefined) return new Meta(obj, {});
            if (hasOwnProperty.call(obj, '_meta') && obj._meta) return obj._meta;
            if (!Object.isExtensible(obj)) return new ConstMeta(obj);
            var MetaToUse = Meta;
            if (obj.constructor && obj.constructor[CLASS_META]) {
                var classMeta = obj.constructor[CLASS_META];
                MetaToUse = classMeta.InstanceMetaConstructor;
            } else if (obj[CLASS_META]) {
                MetaToUse = obj[CLASS_META].InstanceMetaConstructor;
            }
            return obj._meta = new MetaToUse(obj, {});
        };

        Meta.exists = function exists(obj) {
            return typeof obj === 'object' && obj._meta;
        };

        Meta.metadataForProperty = function metadataForProperty(key) {
            return null;
        };

        Meta.prototype.addReference = function addReference(property, reference) {
            var refs = this.references = this.references || _glimmerUtil.dict();
            var set = refs[property] = refs[property] || new _glimmerUtil.DictSet();
            set.add(reference);
        };

        Meta.prototype.addReferenceTypeFor = function addReferenceTypeFor(property, type) {
            this.referenceTypes = this.referenceTypes || _glimmerUtil.dict();
            this.referenceTypes[property] = type;
        };

        Meta.prototype.referenceTypeFor = function referenceTypeFor(property) {
            if (!this.referenceTypes) return _glimmerObjectReferenceLibReferencesDescriptors.PropertyReference;
            return this.referenceTypes[property] || _glimmerObjectReferenceLibReferencesDescriptors.PropertyReference;
        };

        Meta.prototype.removeReference = function removeReference(property, reference) {
            if (!this.references) return;
            var set = this.references[property];
            set.delete(reference);
        };

        Meta.prototype.getReferenceTypes = function getReferenceTypes() {
            this.referenceTypes = this.referenceTypes || _glimmerUtil.dict();
            return this.referenceTypes;
        };

        Meta.prototype.referencesFor = function referencesFor(property) {
            if (!this.references) return;
            return this.references[property];
        };

        Meta.prototype.getSlots = function getSlots() {
            return this.slots = this.slots || _glimmerUtil.dict();
        };

        Meta.prototype.root = function root() {
            return this.rootCache = this.rootCache || new this.RootReferenceFactory(this.object);
        };

        return Meta;
    })();

    exports.default = Meta;

    function metaFor(obj) {
        return Meta.for(obj);
    }
});

enifed("@glimmer/object-reference/lib/object", ["exports"], function (exports) {
    // import { metaFor } from './meta';
    // import { intern } from '@glimmer/util';
    // import { metaFor } from './meta';
    "use strict";

    exports.setProperty = setProperty;
    exports.notifyProperty = notifyProperty;

    function setProperty(parent, property, val) {
        // let rootProp = metaFor(parent).root().chainFor(property));
        // let referencesToNotify = metaFor(parent).referencesFor(property));
        parent[property] = val;
        // if (referencesToNotify) {
        //   referencesToNotify.forEach(function(ref) { ref.notify(); });
        // }
        // if (rootProp) rootProp.notify();
    }

    function notifyProperty(parent, property) {
        // let rootProp = metaFor(parent).root().chainFor(property));
        // let referencesToNotify = metaFor(parent).referencesFor(property));
        // if (referencesToNotify) {
        //   referencesToNotify.forEach(function(ref) { ref.notify(); });
        // }
        // if (rootProp) rootProp.notify();
    }
});

enifed('@glimmer/object-reference/lib/references/descriptors', ['exports', '@glimmer/object-reference/lib/meta', '@glimmer/reference'], function (exports, _glimmerObjectReferenceLibMeta, _glimmerReference) {
    'use strict';

    exports.ComputedReferenceBlueprint = ComputedReferenceBlueprint;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var PropertyReference = (function () {
        function PropertyReference(object, property, outer) {
            _classCallCheck(this, PropertyReference);

            this.tag = _glimmerReference.VOLATILE_TAG;
            this.object = object;
            this.property = property;
        }

        PropertyReference.prototype.value = function value() {
            return this.object[this.property];
        };

        PropertyReference.prototype.label = function label() {
            return '[reference Property]';
        };

        return PropertyReference;
    })();

    exports.PropertyReference = PropertyReference;

    function ComputedReferenceBlueprint(property, dependencies) {
        return (function () {
            function ComputedReference(object, property, outer) {
                _classCallCheck(this, ComputedReference);

                this.installed = false;
                this.tag = _glimmerReference.VOLATILE_TAG;
                this.object = object;
                this.property = property;
                this.dependencies = dependencies;
                this.outer = outer;
            }

            ComputedReference.prototype.value = function value() {
                var _this = this;

                if (!this.installed) {
                    (function () {
                        var root = _glimmerObjectReferenceLibMeta.default.for(_this.object).root();
                        _this.dependencies.forEach(function (dep) {
                            var ref = root.referenceFromParts(dep);
                            ref.value();
                        });
                        _this.installed = true;
                    })();
                }
                return this.object[this.property];
            };

            ComputedReference.prototype.label = function label() {
                return '[reference Computed]';
            };

            return ComputedReference;
        })();
    }
});

enifed('@glimmer/object-reference/lib/references/path', ['exports', '@glimmer/object-reference/lib/utils', '@glimmer/util', '@glimmer/object-reference/lib/meta', '@glimmer/object-reference/lib/references/descriptors', '@glimmer/reference'], function (exports, _glimmerObjectReferenceLibUtils, _glimmerUtil, _glimmerObjectReferenceLibMeta, _glimmerObjectReferenceLibReferencesDescriptors, _glimmerReference) {
    'use strict';

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var UnchainFromPath = (function () {
        function UnchainFromPath(set, child) {
            _classCallCheck(this, UnchainFromPath);

            this.set = set;
            this.child = child;
        }

        UnchainFromPath.prototype.destroy = function destroy() {
            this.set.delete(this.child);
        };

        return UnchainFromPath;
    })();

    var PathReference = (function () {
        function PathReference(parent, property) {
            _classCallCheck(this, PathReference);

            this.cache = _glimmerObjectReferenceLibUtils.EMPTY_CACHE;
            this.inner = null;
            this.chains = null;
            this.lastParentValue = _glimmerObjectReferenceLibUtils.EMPTY_CACHE;
            this._guid = null;
            this.tag = _glimmerReference.VOLATILE_TAG;
            this.parent = parent;
            this.property = property;
        }

        PathReference.prototype.value = function value() {
            var lastParentValue = this.lastParentValue;
            var property = this.property;
            var inner = this.inner;

            var parentValue = this._parentValue();
            if (parentValue === null || parentValue === undefined) {
                return this.cache = undefined;
            }
            if (lastParentValue === parentValue) {
                inner = this.inner;
            } else {
                var ReferenceType = typeof parentValue === 'object' ? _glimmerObjectReferenceLibMeta.default.for(parentValue).referenceTypeFor(property) : _glimmerObjectReferenceLibReferencesDescriptors.PropertyReference;
                inner = this.inner = new ReferenceType(parentValue, property, this);
            }
            // if (typeof parentValue === 'object') {
            //   Meta.for(parentValue).addReference(property, this);
            // }
            return this.cache = inner.value();
        };

        PathReference.prototype.get = function get(prop) {
            var chains = this._getChains();
            if (prop in chains) return chains[prop];
            return chains[prop] = new PathReference(this, prop);
        };

        PathReference.prototype.label = function label() {
            return '[reference Direct]';
        };

        PathReference.prototype._getChains = function _getChains() {
            if (this.chains) return this.chains;
            return this.chains = _glimmerUtil.dict();
        };

        PathReference.prototype._parentValue = function _parentValue() {
            var parent = this.parent.value();
            this.lastParentValue = parent;
            return parent;
        };

        return PathReference;
    })();

    exports.default = PathReference;
    exports.PathReference = PathReference;
});

enifed('@glimmer/object-reference/lib/references/root', ['exports', '@glimmer/util', '@glimmer/object-reference/lib/references/path', '@glimmer/reference'], function (exports, _glimmerUtil, _glimmerObjectReferenceLibReferencesPath, _glimmerReference) {
    'use strict';

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var RootReference = (function () {
        function RootReference(object) {
            _classCallCheck(this, RootReference);

            this.chains = _glimmerUtil.dict();
            this.tag = _glimmerReference.VOLATILE_TAG;
            this.object = object;
        }

        RootReference.prototype.value = function value() {
            return this.object;
        };

        RootReference.prototype.update = function update(object) {
            this.object = object;
            // this.notify();
        };

        RootReference.prototype.get = function get(prop) {
            var chains = this.chains;
            if (prop in chains) return chains[prop];
            return chains[prop] = new _glimmerObjectReferenceLibReferencesPath.PathReference(this, prop);
        };

        RootReference.prototype.chainFor = function chainFor(prop) {
            var chains = this.chains;
            if (prop in chains) return chains[prop];
            return null;
        };

        RootReference.prototype.path = function path(string) {
            return string.split('.').reduce(function (ref, part) {
                return ref.get(part);
            }, this);
        };

        RootReference.prototype.referenceFromParts = function referenceFromParts(parts) {
            return parts.reduce(function (ref, part) {
                return ref.get(part);
            }, this);
        };

        RootReference.prototype.label = function label() {
            return '[reference Root]';
        };

        return RootReference;
    })();

    exports.default = RootReference;
});

enifed("@glimmer/object-reference/lib/types", ["exports"], function (exports) {
  "use strict";
});

enifed("@glimmer/object-reference/lib/utils", ["exports"], function (exports) {
  "use strict";

  exports.EMPTY_CACHE = EMPTY_CACHE;

  function EMPTY_CACHE() {}
});

enifed('@glimmer/object/index', ['exports', '@glimmer/object/lib/object', '@glimmer/object/lib/computed', '@glimmer/object/lib/mixin', '@glimmer/object/lib/descriptors'], function (exports, _glimmerObjectLibObject, _glimmerObjectLibComputed, _glimmerObjectLibMixin, _glimmerObjectLibDescriptors) {
  'use strict';

  exports.default = _glimmerObjectLibObject.default;
  exports.ClassMeta = _glimmerObjectLibObject.ClassMeta;
  exports.InstanceMeta = _glimmerObjectLibObject.InstanceMeta;
  exports.GlimmerObjectFactory = _glimmerObjectLibObject.GlimmerObjectFactory;
  exports.computed = _glimmerObjectLibComputed.computed;
  exports.observer = _glimmerObjectLibComputed.observer;
  exports.Mixin = _glimmerObjectLibMixin.Mixin;
  exports.Blueprint = _glimmerObjectLibMixin.Blueprint;
  exports.toMixin = _glimmerObjectLibMixin.toMixin;
  exports.aliasMethod = _glimmerObjectLibDescriptors.aliasMethod;
  exports.alias = _glimmerObjectLibDescriptors.alias;
});

enifed('@glimmer/object/lib/computed', ['exports', '@glimmer/object-reference', '@glimmer/object/lib/object', '@glimmer/object/lib/mixin'], function (exports, _glimmerObjectReference, _glimmerObjectLibObject, _glimmerObjectLibMixin) {
    'use strict';

    exports.computed = computed;
    exports.observer = observer;

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    var ComputedBlueprint = (function (_Blueprint) {
        _inherits(ComputedBlueprint, _Blueprint);

        function ComputedBlueprint(accessor) {
            var deps = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

            _classCallCheck(this, ComputedBlueprint);

            _Blueprint.call(this);
            this.metadata = {};
            this.accessor = accessor;
            this.deps = deps;
        }

        ComputedBlueprint.prototype.descriptor = function descriptor(target, key, classMeta) {
            classMeta.addReferenceTypeFor(key, _glimmerObjectReference.ComputedReferenceBlueprint(key, this.deps));
            classMeta.addPropertyMetadata(key, this.metadata);
            classMeta.addSlotFor(key);
            return new Computed(this.accessor);
        };

        ComputedBlueprint.prototype.property = function property() {
            for (var _len = arguments.length, paths = Array(_len), _key = 0; _key < _len; _key++) {
                paths[_key] = arguments[_key];
            }

            this.deps = paths.map(function (d) {
                return d.split('.');
            });
            return this;
        };

        ComputedBlueprint.prototype.meta = function meta(object) {
            this.metadata = object;
            return this;
        };

        ComputedBlueprint.prototype.volatile = function volatile() {
            return this;
        };

        return ComputedBlueprint;
    })(_glimmerObjectLibMixin.Blueprint);

    exports.ComputedBlueprint = ComputedBlueprint;

    var Computed = (function () {
        function Computed(accessor) {
            _classCallCheck(this, Computed);

            this["5d90f84f-908e-4a42-9749-3d0f523c262c"] = true;
            this.accessor = accessor;
        }

        Computed.prototype.define = function define(prototype, key, home) {
            Object.defineProperty(prototype, key, wrapAccessor(home, key, this.accessor));
        };

        return Computed;
    })();

    function wrapAccessor(home, accessorName, _desc) {
        var superDesc = getPropertyDescriptor(home, accessorName);
        var originalGet = undefined;
        var originalSet = undefined;
        var desc = {
            enumerable: true,
            configurable: true
        };
        if (_desc.get && _desc.get.length > 0) {
            originalGet = function () {
                return _desc.get.call(this, accessorName);
            };
        } else {
            originalGet = _desc.get;
        }
        if (_desc.set && _desc.set.length > 1) {
            originalSet = function (value) {
                return _desc.set.call(this, accessorName, value);
            };
        } else {
            originalSet = _desc.set;
        }
        var cacheGet = function () {
            if (_glimmerObjectReference.Meta.exists(this)) {
                var slot = _glimmerObjectReference.Meta.for(this).getSlots()[accessorName];
                if (slot !== _glimmerObjectLibObject.EMPTY_CACHE) return slot;
            }
            return originalGet.call(this);
        };
        var cacheSet = undefined;
        if (originalSet) {
            cacheSet = function (value) {
                var meta = _glimmerObjectReference.Meta.for(this);
                var slots = meta.getSlots();
                var ret = originalSet.call(this, value);
                if (ret !== undefined) {
                    slots[accessorName] = ret;
                }
            };
        } else {
            cacheSet = function (value) {
                var meta = _glimmerObjectReference.Meta.for(this);
                var slots = meta.getSlots();
                if (value !== undefined) slots[accessorName] = value;
            };
        }
        if (!superDesc || 'value' in superDesc) {
            desc.get = cacheGet;
            desc.set = cacheSet;
            return desc;
        }
        desc.get = function () {
            var lastSuper = this._super;
            this._super = function () {
                return superDesc.get.call(this);
            };
            try {
                return cacheGet.call(this);
            } finally {
                this._super = lastSuper;
            }
        };
        desc.set = function (val) {
            var lastSuper = this._super;
            this._super = function () {
                return superDesc.set.call(this, val);
            };
            try {
                return cacheSet.call(this, val);
            } finally {
                this._super = lastSuper;
            }
        };
        return desc;
    }
    function getPropertyDescriptor(subject, name) {
        var pd = Object.getOwnPropertyDescriptor(subject, name);
        var proto = Object.getPrototypeOf(subject);
        while (typeof pd === 'undefined' && proto !== null) {
            pd = Object.getOwnPropertyDescriptor(proto, name);
            proto = Object.getPrototypeOf(proto);
        }
        return pd;
    }

    function computed() {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
        }

        var last = args.pop();
        var deps = args;
        if (typeof last === 'function') {
            var _ref;

            return (_ref = new ComputedBlueprint({
                get: last
            })).property.apply(_ref, deps);
        } else if (typeof last === 'object') {
            var _ref2;

            return (_ref2 = new ComputedBlueprint(last)).property.apply(_ref2, deps);
        } else {
            throw new TypeError("computed expects a function or an object as last argument");
        }
    }

    function observer() {}
});

enifed('@glimmer/object/lib/descriptors', ['exports', '@glimmer/object/lib/mixin', '@glimmer/object/lib/computed'], function (exports, _glimmerObjectLibMixin, _glimmerObjectLibComputed) {
    'use strict';

    exports.aliasMethod = aliasMethod;
    exports.alias = alias;

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    var AliasMethodDescriptor = (function (_Descriptor) {
        _inherits(AliasMethodDescriptor, _Descriptor);

        function AliasMethodDescriptor(name) {
            _classCallCheck(this, AliasMethodDescriptor);

            _Descriptor.call(this);
            this.name = name;
        }

        AliasMethodDescriptor.prototype.define = function define(target, key, home) {
            var name = this.name;
            Object.defineProperty(target, key, {
                enumerable: true,
                configurable: true,
                get: function () {
                    return this[name];
                }
            });
        };

        return AliasMethodDescriptor;
    })(_glimmerObjectLibMixin.Descriptor);

    var AliasMethodBlueprint = (function (_Blueprint) {
        _inherits(AliasMethodBlueprint, _Blueprint);

        function AliasMethodBlueprint(name) {
            _classCallCheck(this, AliasMethodBlueprint);

            _Blueprint.call(this);
            this.name = name;
        }

        AliasMethodBlueprint.prototype.descriptor = function descriptor(target, key, meta) {
            return new AliasMethodDescriptor(this.name);
        };

        return AliasMethodBlueprint;
    })(_glimmerObjectLibMixin.Blueprint);

    function aliasMethod(name) {
        return new AliasMethodBlueprint(name);
    }

    var AliasBlueprint = (function (_ComputedBlueprint) {
        _inherits(AliasBlueprint, _ComputedBlueprint);

        function AliasBlueprint(name) {
            _classCallCheck(this, AliasBlueprint);

            var parent = name.slice(0, -1);
            var last = name[name.length - 1];
            var get = function () {
                return name.reduce(function (obj, n) {
                    return obj[n];
                }, this);
            };
            var set = function (value) {
                var p = parent.reduce(function (obj, n) {
                    return obj[n];
                }, this);
                p[last] = value;
            };
            _ComputedBlueprint.call(this, { get: get, set: set }, [name]);
            this.name = name;
        }

        AliasBlueprint.prototype.descriptor = function descriptor(target, key, meta) {
            if (this.name[0] === key) throw new Error('Setting alias \'' + key + '\' on self');
            return _ComputedBlueprint.prototype.descriptor.call(this, target, key, meta);
        };

        return AliasBlueprint;
    })(_glimmerObjectLibComputed.ComputedBlueprint);

    function alias(name) {
        return new AliasBlueprint(name.split('.'));
    }
});

enifed('@glimmer/object/lib/mixin', ['exports', '@glimmer/object-reference', '@glimmer/util', '@glimmer/object/lib/object', '@glimmer/object/lib/utils'], function (exports, _glimmerObjectReference, _glimmerUtil, _glimmerObjectLibObject, _glimmerObjectLibUtils) {
    'use strict';

    exports.extend = extend;
    exports.relinkSubclasses = relinkSubclasses;
    exports.toMixin = toMixin;
    exports.wrapMethod = wrapMethod;

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var isArray = Array.isArray;
    var DESCRIPTOR = "5d90f84f-908e-4a42-9749-3d0f523c262c";
    exports.DESCRIPTOR = DESCRIPTOR;
    var BLUEPRINT = "8d97cf5f-db9e-48d8-a6b2-7a75b7170805";
    exports.BLUEPRINT = BLUEPRINT;

    var Descriptor = function Descriptor() {
        _classCallCheck(this, Descriptor);

        this["5d90f84f-908e-4a42-9749-3d0f523c262c"] = true;
    };

    exports.Descriptor = Descriptor;

    var Blueprint = function Blueprint() {
        _classCallCheck(this, Blueprint);

        this["8d97cf5f-db9e-48d8-a6b2-7a75b7170805"] = true;
    };

    exports.Blueprint = Blueprint;

    var Mixin = (function () {
        function Mixin(extensions, mixins) {
            var _dependencies;

            _classCallCheck(this, Mixin);

            this.extensions = null;
            this.concatenatedProperties = [];
            this.mergedProperties = [];
            this.dependencies = [];
            this.reopen(extensions);
            (_dependencies = this.dependencies).push.apply(_dependencies, mixins);
        }

        Mixin.create = function create() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            var extensions = args[args.length - 1];
            if (args.length === 0) {
                return new this({}, []);
            } else if (extensions instanceof Mixin) {
                return new this({}, args);
            } else {
                var deps = args.slice(0, -1).map(toMixin);
                return new this(extensions, deps);
            }
        };

        Mixin.mixins = function mixins(obj) {
            if (typeof obj !== 'object' || obj === null) return [];
            var meta = _glimmerObjectLibObject.ClassMeta.for(obj);
            if (!meta) return [];
            return meta.getAppliedMixins();
        };

        Mixin.prototype.detect = function detect(obj) {
            if (typeof obj !== 'object' || obj === null) return false;
            if (obj instanceof Mixin) {
                return obj.dependencies.indexOf(this) !== -1;
            }
            var meta = _glimmerObjectLibObject.ClassMeta.for(obj);
            return !!meta && meta.hasAppliedMixin(this);
        };

        Mixin.prototype.reopen = function reopen(extensions) {
            if (this.extensions) {
                this.dependencies.push(toMixin(this.extensions));
            }
            if (typeof extensions === 'object' && 'concatenatedProperties' in extensions) {
                var concat = undefined;
                var rawConcat = extensions.concatenatedProperties;
                if (isArray(rawConcat)) {
                    concat = rawConcat.slice();
                } else if (rawConcat === null || rawConcat === undefined) {
                    concat = [];
                } else {
                    concat = [rawConcat];
                }
                delete extensions.concatenatedProperties;
                this.concatenatedProperties = concat;
            }
            if (typeof extensions === 'object' && 'mergedProperties' in extensions) {
                var merged = undefined;
                var rawMerged = extensions.mergedProperties;
                if (isArray(rawMerged)) {
                    merged = rawMerged.slice();
                } else if (rawMerged === null || rawMerged === undefined) {
                    merged = [];
                } else {
                    merged = [rawMerged];
                }
                delete extensions.mergedProperties;
                this.mergedProperties = merged;
            }
            var normalized = Object.keys(extensions).reduce(function (obj, key) {
                var value = extensions[key];
                switch (typeof value) {
                    case 'function':
                        obj[key] = new MethodBlueprint({ value: value });
                        break;
                    case 'object':
                        if (value && BLUEPRINT in value) {
                            obj[key] = value;
                            break;
                        }
                    /* falls through */
                    default:
                        obj[key] = new DataBlueprint({ value: value });
                }
                return obj;
            }, _glimmerUtil.dict());
            this.extensions = _glimmerUtil.dict();
            _glimmerUtil.assign(this.extensions, _glimmerObjectLibObject.turbocharge(normalized));
        };

        Mixin.prototype.apply = function apply(target) {
            var meta = target[_glimmerObjectReference.CLASS_META] = target[_glimmerObjectReference.CLASS_META] || new _glimmerObjectLibObject.ClassMeta();
            this.dependencies.forEach(function (m) {
                return m.apply(target);
            });
            this.mergeProperties(target, target, meta);
            meta.addMixin(this);
            meta.seal();
            meta.reseal(target);
            return target;
        };

        Mixin.prototype.extendPrototype = function extendPrototype(Original) {
            Original.prototype = Object.create(Original.prototype);
            this.dependencies.forEach(function (m) {
                return m.extendPrototype(Original);
            });
            this.extendPrototypeOnto(Original, Original);
        };

        Mixin.prototype.extendPrototypeOnto = function extendPrototypeOnto(Subclass, Parent) {
            this.dependencies.forEach(function (m) {
                return m.extendPrototypeOnto(Subclass, Parent);
            });
            this.mergeProperties(Subclass.prototype, Parent.prototype, Subclass[_glimmerObjectReference.CLASS_META]);
            Subclass[_glimmerObjectReference.CLASS_META].addMixin(this);
        };

        Mixin.prototype.extendStatic = function extendStatic(Target) {
            this.dependencies.forEach(function (m) {
                return m.extendStatic(Target);
            });
            this.mergeProperties(Target, Object.getPrototypeOf(Target), Target[_glimmerObjectReference.CLASS_META][_glimmerObjectReference.CLASS_META]);
            Target[_glimmerObjectReference.CLASS_META].addStaticMixin(this);
        };

        Mixin.prototype.mergeProperties = function mergeProperties(target, parent, meta) {
            var _this = this;

            if (meta.hasAppliedMixin(this)) return;
            meta.addAppliedMixin(this);
            this.mergedProperties.forEach(function (k) {
                return meta.addMergedProperty(k, parent[k]);
            });
            this.concatenatedProperties.forEach(function (k) {
                return meta.addConcatenatedProperty(k, []);
            });
            new ValueDescriptor({ value: meta.getConcatenatedProperties() }).define(target, 'concatenatedProperties', null);
            new ValueDescriptor({ value: meta.getMergedProperties() }).define(target, 'mergedProperties', null);
            Object.keys(this.extensions).forEach(function (key) {
                var extension = _this.extensions[key];
                var desc = extension.descriptor(target, key, meta);
                desc.define(target, key, parent);
            });
            new ValueDescriptor({ value: _glimmerObjectLibUtils.ROOT }).define(target, '_super', null);
        };

        return Mixin;
    })();

    exports.Mixin = Mixin;

    function extend(Parent) {
        for (var _len2 = arguments.length, extensions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            extensions[_key2 - 1] = arguments[_key2];
        }

        var Super = Parent;
        var Subclass = (function (_Super) {
            _inherits(Subclass, _Super);

            function Subclass() {
                _classCallCheck(this, Subclass);

                _Super.apply(this, arguments);
            }

            return Subclass;
        })(Super);
        Subclass[_glimmerObjectReference.CLASS_META] = _glimmerObjectLibObject.InstanceMeta.fromParent(Parent[_glimmerObjectReference.CLASS_META]);
        var mixins = extensions.map(toMixin);
        Parent[_glimmerObjectReference.CLASS_META].addSubclass(Subclass);
        mixins.forEach(function (m) {
            return Subclass[_glimmerObjectReference.CLASS_META].addMixin(m);
        });
        _glimmerObjectLibObject.ClassMeta.applyAllMixins(Subclass, Parent);
        return Subclass;
    }

    function relinkSubclasses(Parent) {
        Parent[_glimmerObjectReference.CLASS_META].getSubclasses().forEach(function (Subclass) {
            Subclass[_glimmerObjectReference.CLASS_META].reset(Parent[_glimmerObjectReference.CLASS_META]);
            Subclass.prototype = Object.create(Parent.prototype);
            _glimmerObjectLibObject.ClassMeta.applyAllMixins(Subclass, Parent);
            // recurse into sub-subclasses
            relinkSubclasses(Subclass);
        });
    }

    function toMixin(extension) {
        if (extension instanceof Mixin) return extension;else return new Mixin(extension, []);
    }

    var ValueDescriptor = (function (_Descriptor) {
        _inherits(ValueDescriptor, _Descriptor);

        function ValueDescriptor(_ref) {
            var _ref$enumerable = _ref.enumerable;
            var enumerable = _ref$enumerable === undefined ? true : _ref$enumerable;
            var _ref$configurable = _ref.configurable;
            var configurable = _ref$configurable === undefined ? true : _ref$configurable;
            var _ref$writable = _ref.writable;
            var writable = _ref$writable === undefined ? true : _ref$writable;
            var value = _ref.value;

            _classCallCheck(this, ValueDescriptor);

            _Descriptor.call(this);
            this.enumerable = enumerable;
            this.configurable = configurable;
            this.writable = writable;
            this.value = value;
        }

        ValueDescriptor.prototype.define = function define(target, key, home) {
            Object.defineProperty(target, key, {
                enumerable: this.enumerable,
                configurable: this.configurable,
                writable: this.writable,
                value: this.value
            });
        };

        return ValueDescriptor;
    })(Descriptor);

    var AccessorDescriptor = (function (_Descriptor2) {
        _inherits(AccessorDescriptor, _Descriptor2);

        function AccessorDescriptor(_ref2) {
            var enumerable = _ref2.enumerable;
            var configurable = _ref2.configurable;
            var get = _ref2.get;
            var set = _ref2.set;

            _classCallCheck(this, AccessorDescriptor);

            _Descriptor2.call(this);
            this.enumerable = enumerable;
            this.configurable = configurable;
            this.get = get;
            this.set = set;
        }

        AccessorDescriptor.prototype.define = function define(target, key) {
            Object.defineProperty(target, key, {
                enumerable: this.enumerable,
                configurable: this.configurable,
                get: this.get,
                set: this.set
            });
        };

        return AccessorDescriptor;
    })(Descriptor);

    var DataBlueprint = (function (_Blueprint) {
        _inherits(DataBlueprint, _Blueprint);

        function DataBlueprint(_ref3) {
            var _ref3$enumerable = _ref3.enumerable;
            var enumerable = _ref3$enumerable === undefined ? true : _ref3$enumerable;
            var _ref3$configurable = _ref3.configurable;
            var configurable = _ref3$configurable === undefined ? true : _ref3$configurable;
            var _ref3$writable = _ref3.writable;
            var writable = _ref3$writable === undefined ? true : _ref3$writable;
            var value = _ref3.value;

            _classCallCheck(this, DataBlueprint);

            _Blueprint.call(this);
            this.enumerable = enumerable;
            this.configurable = configurable;
            this.value = value;
            this.writable = writable;
        }

        DataBlueprint.prototype.descriptor = function descriptor(target, key, classMeta) {
            var enumerable = this.enumerable;
            var configurable = this.configurable;
            var writable = this.writable;
            var value = this.value;

            if (classMeta.hasConcatenatedProperty(key)) {
                classMeta.addConcatenatedProperty(key, value);
                value = classMeta.getConcatenatedProperty(key);
            } else if (classMeta.hasMergedProperty(key)) {
                classMeta.addMergedProperty(key, value);
                value = classMeta.getMergedProperty(key);
            }
            return new ValueDescriptor({ enumerable: enumerable, configurable: configurable, writable: writable, value: value });
        };

        return DataBlueprint;
    })(Blueprint);

    exports.DataBlueprint = DataBlueprint;

    var AccessorBlueprint = (function (_Blueprint2) {
        _inherits(AccessorBlueprint, _Blueprint2);

        function AccessorBlueprint(_ref4) {
            var _ref4$enumerable = _ref4.enumerable;
            var enumerable = _ref4$enumerable === undefined ? true : _ref4$enumerable;
            var _ref4$configurable = _ref4.configurable;
            var configurable = _ref4$configurable === undefined ? true : _ref4$configurable;
            var get = _ref4.get;
            var set = _ref4.set;

            _classCallCheck(this, AccessorBlueprint);

            _Blueprint2.call(this);
            this.enumerable = enumerable;
            this.configurable = configurable;
            this.get = get;
            this.set = set;
        }

        AccessorBlueprint.prototype.descriptor = function descriptor(target, key, classMeta) {
            return new ValueDescriptor({
                enumerable: this.enumerable,
                configurable: this.configurable,
                get: this.get,
                set: this.set
            });
        };

        return AccessorBlueprint;
    })(Blueprint);

    exports.AccessorBlueprint = AccessorBlueprint;

    var MethodDescriptor = (function (_ValueDescriptor) {
        _inherits(MethodDescriptor, _ValueDescriptor);

        function MethodDescriptor() {
            _classCallCheck(this, MethodDescriptor);

            _ValueDescriptor.apply(this, arguments);
        }

        MethodDescriptor.prototype.define = function define(target, key, home) {
            this.value = wrapMethod(home, key, this.value);
            _ValueDescriptor.prototype.define.call(this, target, key, home);
        };

        return MethodDescriptor;
    })(ValueDescriptor);

    var MethodBlueprint = (function (_DataBlueprint) {
        _inherits(MethodBlueprint, _DataBlueprint);

        function MethodBlueprint() {
            _classCallCheck(this, MethodBlueprint);

            _DataBlueprint.apply(this, arguments);
        }

        MethodBlueprint.prototype.descriptor = function descriptor(target, key, classMeta) {
            var desc = _DataBlueprint.prototype.descriptor.call(this, target, key, classMeta);
            return new MethodDescriptor(desc);
        };

        return MethodBlueprint;
    })(DataBlueprint);

    function wrapMethod(home, methodName, original) {
        if (!(methodName in home)) return maybeWrap(original);
        var superMethod = home[methodName];
        var func = function () {
            for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                args[_key3] = arguments[_key3];
            }

            if (!this) return original.apply(this, args);
            var lastSuper = this._super;
            this._super = superMethod;
            try {
                return original.apply(this, args);
            } finally {
                this._super = lastSuper;
            }
        };
        func.__wrapped = true;
        return func;
    }

    function maybeWrap(original) {
        if ('__wrapped' in original) return original;
        return function () {
            for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                args[_key4] = arguments[_key4];
            }

            if (!this) return original.apply(this, args);
            var lastSuper = this._super;
            this._super = _glimmerObjectLibUtils.ROOT;
            try {
                return original.apply(this, args);
            } finally {
                this._super = lastSuper;
            }
        };
    }
});

enifed('@glimmer/object/lib/object', ['exports', '@glimmer/object-reference', '@glimmer/util', '@glimmer/object/lib/mixin', '@glimmer/object/lib/utils'], function (exports, _glimmerObjectReference, _glimmerUtil, _glimmerObjectLibMixin, _glimmerObjectLibUtils) {
    'use strict';

    exports.turbocharge = turbocharge;

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    var isArray = Array.isArray;
    var EMPTY_CACHE = function EMPTY_CACHE() {};
    exports.EMPTY_CACHE = EMPTY_CACHE;
    var CLASS_META = "df8be4c8-4e89-44e2-a8f9-550c8dacdca7";

    function turbocharge(obj) {
        // function Dummy() {}
        // Dummy.prototype = obj;
        return obj;
    }

    var SealedMeta = (function (_Meta) {
        _inherits(SealedMeta, _Meta);

        function SealedMeta() {
            _classCallCheck(this, SealedMeta);

            _Meta.apply(this, arguments);
        }

        SealedMeta.prototype.addReferenceTypeFor = function addReferenceTypeFor() {
            throw new Error("Cannot modify reference types on a sealed meta");
        };

        return SealedMeta;
    })(_glimmerObjectReference.Meta);

    var ClassMeta = (function () {
        function ClassMeta() {
            _classCallCheck(this, ClassMeta);

            this.referenceTypes = _glimmerUtil.dict();
            this.propertyMetadata = _glimmerUtil.dict();
            this.concatenatedProperties = _glimmerUtil.dict();
            this.hasConcatenatedProperties = false;
            this.mergedProperties = _glimmerUtil.dict();
            this.hasMergedProperties = false;
            this.mixins = [];
            this.appliedMixins = [];
            this.staticMixins = [];
            this.subclasses = [];
            this.slots = [];
            this.InstanceMetaConstructor = null;
        }

        ClassMeta.fromParent = function fromParent(parent) {
            var meta = new this();
            meta.reset(parent);
            return meta;
        };

        ClassMeta.for = function _for(object) {
            if (CLASS_META in object) return object[CLASS_META];else if (object.constructor) return object.constructor[CLASS_META] || null;else return null;
        };

        ClassMeta.prototype.init = function init(object, attrs) {
            if (typeof attrs !== 'object' || attrs === null) return;
            if (this.hasConcatenatedProperties) {
                var concatProps = this.concatenatedProperties;
                for (var prop in concatProps) {
                    if (prop in attrs) {
                        var concat = concatProps[prop].slice();
                        object[prop] = concat.concat(attrs[prop]);
                    }
                }
            }
            if (this.hasMergedProperties) {
                var mergedProps = this.mergedProperties;
                for (var prop in mergedProps) {
                    if (prop in attrs) {
                        var merged = _glimmerUtil.assign({}, mergedProps[prop]);
                        object[prop] = _glimmerUtil.assign(merged, attrs[prop]);
                    }
                }
            }
        };

        ClassMeta.prototype.addStaticMixin = function addStaticMixin(mixin) {
            this.staticMixins.push(mixin);
        };

        ClassMeta.prototype.addMixin = function addMixin(mixin) {
            this.mixins.push(mixin);
        };

        ClassMeta.prototype.getStaticMixins = function getStaticMixins() {
            return this.staticMixins;
        };

        ClassMeta.prototype.getMixins = function getMixins() {
            return this.mixins;
        };

        ClassMeta.prototype.addAppliedMixin = function addAppliedMixin(mixin) {
            this.appliedMixins.push(mixin);
        };

        ClassMeta.prototype.hasAppliedMixin = function hasAppliedMixin(mixin) {
            return this.appliedMixins.indexOf(mixin) !== -1;
        };

        ClassMeta.prototype.getAppliedMixins = function getAppliedMixins() {
            return this.appliedMixins;
        };

        ClassMeta.prototype.hasStaticMixin = function hasStaticMixin(mixin) {
            return this.staticMixins.indexOf(mixin) !== -1;
        };

        ClassMeta.applyAllMixins = function applyAllMixins(Subclass, Parent) {
            Subclass[CLASS_META].getMixins().forEach(function (m) {
                return m.extendPrototypeOnto(Subclass, Parent);
            });
            Subclass[CLASS_META].getStaticMixins().forEach(function (m) {
                return m.extendStatic(Subclass);
            });
            Subclass[CLASS_META].seal();
        };

        ClassMeta.prototype.addSubclass = function addSubclass(constructor) {
            this.subclasses.push(constructor);
        };

        ClassMeta.prototype.getSubclasses = function getSubclasses() {
            return this.subclasses;
        };

        ClassMeta.prototype.addPropertyMetadata = function addPropertyMetadata(property, value) {
            this.propertyMetadata[property] = value;
        };

        ClassMeta.prototype.metadataForProperty = function metadataForProperty(property) {
            return this.propertyMetadata[property];
        };

        ClassMeta.prototype.addReferenceTypeFor = function addReferenceTypeFor(property, type) {
            this.referenceTypes[property] = type;
        };

        ClassMeta.prototype.addSlotFor = function addSlotFor(property) {
            this.slots.push(property);
        };

        ClassMeta.prototype.hasConcatenatedProperty = function hasConcatenatedProperty(property) {
            if (!this.hasConcatenatedProperties) return false;
            return property in this.concatenatedProperties;
        };

        ClassMeta.prototype.getConcatenatedProperty = function getConcatenatedProperty(property) {
            return this.concatenatedProperties[property];
        };

        ClassMeta.prototype.getConcatenatedProperties = function getConcatenatedProperties() {
            return Object.keys(this.concatenatedProperties);
        };

        ClassMeta.prototype.addConcatenatedProperty = function addConcatenatedProperty(property, value) {
            this.hasConcatenatedProperties = true;
            if (property in this.concatenatedProperties) {
                var val = this.concatenatedProperties[property].concat(value);
                this.concatenatedProperties[property] = val;
            } else {
                this.concatenatedProperties[property] = value;
            }
        };

        ClassMeta.prototype.hasMergedProperty = function hasMergedProperty(property) {
            if (!this.hasMergedProperties) return false;
            return property in this.mergedProperties;
        };

        ClassMeta.prototype.getMergedProperty = function getMergedProperty(property) {
            return this.mergedProperties[property];
        };

        ClassMeta.prototype.getMergedProperties = function getMergedProperties() {
            return Object.keys(this.mergedProperties);
        };

        ClassMeta.prototype.addMergedProperty = function addMergedProperty(property, value) {
            this.hasMergedProperties = true;
            if (isArray(value)) {
                throw new Error('You passed in `' + JSON.stringify(value) + '` as the value for `foo` but `foo` cannot be an Array');
            }
            if (property in this.mergedProperties && this.mergedProperties[property] && value) {
                this.mergedProperties[property] = mergeMergedProperties(value, this.mergedProperties[property]);
            } else {
                value = value === null ? value : value || {};
                this.mergedProperties[property] = value;
            }
        };

        ClassMeta.prototype.getReferenceTypes = function getReferenceTypes() {
            return this.referenceTypes;
        };

        ClassMeta.prototype.getPropertyMetadata = function getPropertyMetadata() {
            return this.propertyMetadata;
        };

        ClassMeta.prototype.reset = function reset(parent) {
            this.referenceTypes = _glimmerUtil.dict();
            this.propertyMetadata = _glimmerUtil.dict();
            this.concatenatedProperties = _glimmerUtil.dict();
            this.mergedProperties = _glimmerUtil.dict();
            if (parent) {
                this.hasConcatenatedProperties = parent.hasConcatenatedProperties;
                for (var prop in parent.concatenatedProperties) {
                    this.concatenatedProperties[prop] = parent.concatenatedProperties[prop].slice();
                }
                this.hasMergedProperties = parent.hasMergedProperties;
                for (var prop in parent.mergedProperties) {
                    this.mergedProperties[prop] = _glimmerUtil.assign({}, parent.mergedProperties[prop]);
                }
                _glimmerUtil.assign(this.referenceTypes, parent.referenceTypes);
                _glimmerUtil.assign(this.propertyMetadata, parent.propertyMetadata);
            }
        };

        ClassMeta.prototype.reseal = function reseal(obj) {
            var meta = _glimmerObjectReference.Meta.for(obj);
            var fresh = new this.InstanceMetaConstructor(obj, {});
            var referenceTypes = meta.getReferenceTypes();
            var slots = meta.getSlots();
            turbocharge(_glimmerUtil.assign(referenceTypes, this.referenceTypes));
            turbocharge(_glimmerUtil.assign(slots, fresh.getSlots()));
        };

        ClassMeta.prototype.seal = function seal() {
            var referenceTypes = turbocharge(_glimmerUtil.assign({}, this.referenceTypes));
            turbocharge(this.concatenatedProperties);
            turbocharge(this.mergedProperties);
            if (!this.hasMergedProperties && !this.hasConcatenatedProperties) {
                this.init = function () {};
            }
            var slots = this.slots;

            var Slots = function Slots() {
                var _this = this;

                _classCallCheck(this, Slots);

                slots.forEach(function (name) {
                    _this[name] = EMPTY_CACHE;
                });
            };

            this.InstanceMetaConstructor = (function (_SealedMeta) {
                _inherits(_class, _SealedMeta);

                function _class() {
                    _classCallCheck(this, _class);

                    _SealedMeta.apply(this, arguments);
                    this.slots = new Slots();
                    this.referenceTypes = referenceTypes;
                }

                _class.prototype.getReferenceTypes = function getReferenceTypes() {
                    return this.referenceTypes;
                };

                _class.prototype.referenceTypeFor = function referenceTypeFor(property) {
                    return this.referenceTypes[property] || _glimmerObjectReference.PropertyReference;
                };

                _class.prototype.getSlots = function getSlots() {
                    return this.slots;
                };

                return _class;
            })(SealedMeta);
            turbocharge(this);
        };

        return ClassMeta;
    })();

    exports.ClassMeta = ClassMeta;

    function mergeMergedProperties(attrs, parent) {
        var merged = _glimmerUtil.assign({}, parent);
        for (var prop in attrs) {
            if (prop in parent && typeof parent[prop] === 'function' && typeof attrs[prop] === 'function') {
                var wrapped = _glimmerObjectLibMixin.wrapMethod(parent, prop, attrs[prop]);
                merged[prop] = wrapped;
            } else {
                merged[prop] = attrs[prop];
            }
        }
        return merged;
    }

    var InstanceMeta = (function (_ClassMeta) {
        _inherits(InstanceMeta, _ClassMeta);

        function InstanceMeta() {
            _classCallCheck(this, InstanceMeta);

            _ClassMeta.apply(this, arguments);
            this["df8be4c8-4e89-44e2-a8f9-550c8dacdca7"] = ClassMeta.fromParent(null);
        }

        InstanceMeta.fromParent = function fromParent(parent) {
            return _ClassMeta.fromParent.call(this, parent);
        };

        InstanceMeta.prototype.reset = function reset(parent) {
            _ClassMeta.prototype.reset.call(this, parent);
            if (parent) this[CLASS_META].reset(parent[CLASS_META]);
        };

        InstanceMeta.prototype.seal = function seal() {
            _ClassMeta.prototype.seal.call(this);
            this[CLASS_META].seal();
        };

        return InstanceMeta;
    })(ClassMeta);

    exports.InstanceMeta = InstanceMeta;

    var GlimmerObject = (function () {
        function GlimmerObject(attrs) {
            _classCallCheck(this, GlimmerObject);

            this._super = _glimmerObjectLibUtils.ROOT;
            this._meta = null;
            if (attrs) _glimmerUtil.assign(this, attrs);
            this.constructor[CLASS_META].init(this, attrs);
            this._super = _glimmerObjectLibUtils.ROOT;
            _glimmerUtil.initializeGuid(this);
            this.init();
        }

        GlimmerObject.extend = function extend() {
            for (var _len = arguments.length, extensions = Array(_len), _key = 0; _key < _len; _key++) {
                extensions[_key] = arguments[_key];
            }

            return _glimmerObjectLibMixin.extend.apply(undefined, [this].concat(extensions));
        };

        GlimmerObject.create = function create(attrs) {
            return new this(attrs);
        };

        GlimmerObject.reopen = function reopen(extensions) {
            _glimmerObjectLibMixin.toMixin(extensions).extendPrototype(this);
            this[CLASS_META].seal();
            _glimmerObjectLibMixin.relinkSubclasses(this);
        };

        GlimmerObject.reopenClass = function reopenClass(extensions) {
            _glimmerObjectLibMixin.toMixin(extensions).extendStatic(this);
            this[CLASS_META].seal();
        };

        GlimmerObject.metaForProperty = function metaForProperty(property) {
            var value = this[CLASS_META].metadataForProperty(property);
            if (!value) throw new Error('metaForProperty() could not find a computed property with key \'' + property + '\'.');
            return value;
        };

        GlimmerObject.eachComputedProperty = function eachComputedProperty(callback) {
            var metadata = this[CLASS_META].getPropertyMetadata();
            if (!metadata) return;
            for (var prop in metadata) {
                callback(prop, metadata[prop]);
            }
        };

        GlimmerObject.prototype.init = function init() {};

        GlimmerObject.prototype.get = function get(key) {
            return this[key];
        };

        GlimmerObject.prototype.set = function set(key, value) {
            this[key] = value;
        };

        GlimmerObject.prototype.setProperties = function setProperties(attrs) {
            _glimmerUtil.assign(this, attrs);
        };

        GlimmerObject.prototype.destroy = function destroy() {};

        return GlimmerObject;
    })();

    exports.default = GlimmerObject;

    GlimmerObject["df8be4c8-4e89-44e2-a8f9-550c8dacdca7"] = InstanceMeta.fromParent(null);
    GlimmerObject.isClass = true;
});

enifed('@glimmer/object/lib/utils', ['exports'], function (exports) {
    'use strict';

    exports.ROOT = ROOT;
    exports.hasSuper = hasSuper;
    var HAS_SUPER_PATTERN = /\.(_super|call\(this|apply\(this)/;
    var checkHasSuper = (function () {
        var sourceAvailable = (function () {
            return this;
        }).toString().indexOf('return this') > -1;
        if (sourceAvailable) {
            return function checkHasSuper(func) {
                return HAS_SUPER_PATTERN.test(func.toString());
            };
        }
        return function checkHasSuper() {
            return true;
        };
    })();
    exports.checkHasSuper = checkHasSuper;

    function ROOT() {}

    ROOT.__hasSuper = false;

    function hasSuper(func) {
        if (func.__hasSuper === undefined) {
            func.__hasSuper = checkHasSuper(func);
        }
        return func.__hasSuper;
    }
});

enifed('@glimmer/reference/index', ['exports', '@glimmer/reference/lib/reference', '@glimmer/reference/lib/const', '@glimmer/reference/lib/iterable', '@glimmer/reference/lib/validators', '@glimmer/reference/lib/utils'], function (exports, _glimmerReferenceLibReference, _glimmerReferenceLibConst, _glimmerReferenceLibIterable, _glimmerReferenceLibValidators, _glimmerReferenceLibUtils) {
  'use strict';

  function _interopExportWildcard(obj, defaults) { var newObj = defaults({}, obj); delete newObj['default']; return newObj; }

  function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

  exports.BasicReference = _glimmerReferenceLibReference.Reference;
  exports.BasicPathReference = _glimmerReferenceLibReference.PathReference;
  exports.ConstReference = _glimmerReferenceLibConst.ConstReference;
  exports.isConst = _glimmerReferenceLibConst.isConst;
  exports.ListItem = _glimmerReferenceLibIterable.ListItem;

  _defaults(exports, _interopExportWildcard(_glimmerReferenceLibValidators, _defaults));

  exports.Reference = _glimmerReferenceLibValidators.VersionedReference;
  exports.PathReference = _glimmerReferenceLibValidators.VersionedPathReference;
  exports.referenceFromParts = _glimmerReferenceLibUtils.referenceFromParts;
  exports.IterationItem = _glimmerReferenceLibIterable.IterationItem;
  exports.Iterator = _glimmerReferenceLibIterable.Iterator;
  exports.Iterable = _glimmerReferenceLibIterable.Iterable;
  exports.OpaqueIterator = _glimmerReferenceLibIterable.OpaqueIterator;
  exports.OpaqueIterable = _glimmerReferenceLibIterable.OpaqueIterable;
  exports.AbstractIterator = _glimmerReferenceLibIterable.AbstractIterator;
  exports.AbstractIterable = _glimmerReferenceLibIterable.AbstractIterable;
  exports.IterationArtifacts = _glimmerReferenceLibIterable.IterationArtifacts;
  exports.ReferenceIterator = _glimmerReferenceLibIterable.ReferenceIterator;
  exports.IteratorSynchronizer = _glimmerReferenceLibIterable.IteratorSynchronizer;
  exports.IteratorSynchronizerDelegate = _glimmerReferenceLibIterable.IteratorSynchronizerDelegate;
});

enifed('@glimmer/reference/lib/const', ['exports', '@glimmer/reference/lib/validators'], function (exports, _glimmerReferenceLibValidators) {
    'use strict';

    exports.isConst = isConst;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var ConstReference = (function () {
        function ConstReference(inner) {
            _classCallCheck(this, ConstReference);

            this.inner = inner;
            this.tag = _glimmerReferenceLibValidators.CONSTANT_TAG;
        }

        ConstReference.prototype.value = function value() {
            return this.inner;
        };

        return ConstReference;
    })();

    exports.ConstReference = ConstReference;

    function isConst(reference) {
        return reference.tag === _glimmerReferenceLibValidators.CONSTANT_TAG;
    }
});

enifed("@glimmer/reference/lib/iterable", ["exports", "@glimmer/util"], function (exports, _glimmerUtil) {
    "use strict";

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    var ListItem = (function (_ListNode) {
        _inherits(ListItem, _ListNode);

        function ListItem(iterable, result) {
            _classCallCheck(this, ListItem);

            _ListNode.call(this, iterable.valueReferenceFor(result));
            this.retained = false;
            this.seen = false;
            this.key = result.key;
            this.iterable = iterable;
            this.memo = iterable.memoReferenceFor(result);
        }

        ListItem.prototype.update = function update(item) {
            this.retained = true;
            this.iterable.updateValueReference(this.value, item);
            this.iterable.updateMemoReference(this.memo, item);
        };

        ListItem.prototype.shouldRemove = function shouldRemove() {
            return !this.retained;
        };

        ListItem.prototype.reset = function reset() {
            this.retained = false;
            this.seen = false;
        };

        return ListItem;
    })(_glimmerUtil.ListNode);

    exports.ListItem = ListItem;

    var IterationArtifacts = (function () {
        function IterationArtifacts(iterable) {
            _classCallCheck(this, IterationArtifacts);

            this.map = _glimmerUtil.dict();
            this.list = new _glimmerUtil.LinkedList();
            this.tag = iterable.tag;
            this.iterable = iterable;
        }

        IterationArtifacts.prototype.isEmpty = function isEmpty() {
            var iterator = this.iterator = this.iterable.iterate();
            return iterator.isEmpty();
        };

        IterationArtifacts.prototype.iterate = function iterate() {
            var iterator = this.iterator || this.iterable.iterate();
            this.iterator = null;
            return iterator;
        };

        IterationArtifacts.prototype.has = function has(key) {
            return !!this.map[key];
        };

        IterationArtifacts.prototype.get = function get(key) {
            return this.map[key];
        };

        IterationArtifacts.prototype.wasSeen = function wasSeen(key) {
            var node = this.map[key];
            return node && node.seen;
        };

        IterationArtifacts.prototype.append = function append(item) {
            var map = this.map;
            var list = this.list;
            var iterable = this.iterable;

            var node = map[item.key] = new ListItem(iterable, item);
            list.append(node);
            return node;
        };

        IterationArtifacts.prototype.insertBefore = function insertBefore(item, reference) {
            var map = this.map;
            var list = this.list;
            var iterable = this.iterable;

            var node = map[item.key] = new ListItem(iterable, item);
            node.retained = true;
            list.insertBefore(node, reference);
            return node;
        };

        IterationArtifacts.prototype.move = function move(item, reference) {
            var list = this.list;

            item.retained = true;
            list.remove(item);
            list.insertBefore(item, reference);
        };

        IterationArtifacts.prototype.remove = function remove(item) {
            var list = this.list;

            list.remove(item);
            delete this.map[item.key];
        };

        IterationArtifacts.prototype.nextNode = function nextNode(item) {
            return this.list.nextNode(item);
        };

        IterationArtifacts.prototype.head = function head() {
            return this.list.head();
        };

        return IterationArtifacts;
    })();

    exports.IterationArtifacts = IterationArtifacts;

    var ReferenceIterator = (function () {
        // if anyone needs to construct this object with something other than
        // an iterable, let @wycats know.

        function ReferenceIterator(iterable) {
            _classCallCheck(this, ReferenceIterator);

            this.iterator = null;
            var artifacts = new IterationArtifacts(iterable);
            this.artifacts = artifacts;
        }

        ReferenceIterator.prototype.next = function next() {
            var artifacts = this.artifacts;

            var iterator = this.iterator = this.iterator || artifacts.iterate();
            var item = iterator.next();
            if (!item) return null;
            return artifacts.append(item);
        };

        return ReferenceIterator;
    })();

    exports.ReferenceIterator = ReferenceIterator;

    var Phase;
    (function (Phase) {
        Phase[Phase["Append"] = 0] = "Append";
        Phase[Phase["Prune"] = 1] = "Prune";
        Phase[Phase["Done"] = 2] = "Done";
    })(Phase || (Phase = {}));

    var IteratorSynchronizer = (function () {
        function IteratorSynchronizer(_ref) {
            var target = _ref.target;
            var artifacts = _ref.artifacts;

            _classCallCheck(this, IteratorSynchronizer);

            this.target = target;
            this.artifacts = artifacts;
            this.iterator = artifacts.iterate();
            this.current = artifacts.head();
        }

        IteratorSynchronizer.prototype.sync = function sync() {
            var phase = Phase.Append;
            while (true) {
                switch (phase) {
                    case Phase.Append:
                        phase = this.nextAppend();
                        break;
                    case Phase.Prune:
                        phase = this.nextPrune();
                        break;
                    case Phase.Done:
                        this.nextDone();
                        return;
                }
            }
        };

        IteratorSynchronizer.prototype.advanceToKey = function advanceToKey(key) {
            var current = this.current;
            var artifacts = this.artifacts;

            var seek = current;
            while (seek && seek.key !== key) {
                seek.seen = true;
                seek = artifacts.nextNode(seek);
            }
            this.current = seek && artifacts.nextNode(seek);
        };

        IteratorSynchronizer.prototype.nextAppend = function nextAppend() {
            var iterator = this.iterator;
            var current = this.current;
            var artifacts = this.artifacts;

            var item = iterator.next();
            if (item === null) {
                return this.startPrune();
            }
            var key = item.key;

            if (current && current.key === key) {
                this.nextRetain(item);
            } else if (artifacts.has(key)) {
                this.nextMove(item);
            } else {
                this.nextInsert(item);
            }
            return Phase.Append;
        };

        IteratorSynchronizer.prototype.nextRetain = function nextRetain(item) {
            var artifacts = this.artifacts;
            var current = this.current;

            current = _glimmerUtil.expect(current, 'BUG: current is empty');
            current.update(item);
            this.current = artifacts.nextNode(current);
            this.target.retain(item.key, current.value, current.memo);
        };

        IteratorSynchronizer.prototype.nextMove = function nextMove(item) {
            var current = this.current;
            var artifacts = this.artifacts;
            var target = this.target;
            var key = item.key;

            var found = artifacts.get(item.key);
            found.update(item);
            if (artifacts.wasSeen(item.key)) {
                artifacts.move(found, current);
                target.move(found.key, found.value, found.memo, current ? current.key : null);
            } else {
                this.advanceToKey(key);
            }
        };

        IteratorSynchronizer.prototype.nextInsert = function nextInsert(item) {
            var artifacts = this.artifacts;
            var target = this.target;
            var current = this.current;

            var node = artifacts.insertBefore(item, current);
            target.insert(node.key, node.value, node.memo, current ? current.key : null);
        };

        IteratorSynchronizer.prototype.startPrune = function startPrune() {
            this.current = this.artifacts.head();
            return Phase.Prune;
        };

        IteratorSynchronizer.prototype.nextPrune = function nextPrune() {
            var artifacts = this.artifacts;
            var target = this.target;
            var current = this.current;

            if (current === null) {
                return Phase.Done;
            }
            var node = current;
            this.current = artifacts.nextNode(node);
            if (node.shouldRemove()) {
                artifacts.remove(node);
                target.delete(node.key);
            } else {
                node.reset();
            }
            return Phase.Prune;
        };

        IteratorSynchronizer.prototype.nextDone = function nextDone() {
            this.target.done();
        };

        return IteratorSynchronizer;
    })();

    exports.IteratorSynchronizer = IteratorSynchronizer;
});

enifed("@glimmer/reference/lib/reference", ["exports"], function (exports) {
  "use strict";
});

enifed("@glimmer/reference/lib/utils", ["exports"], function (exports) {
    "use strict";

    exports.referenceFromParts = referenceFromParts;

    function referenceFromParts(root, parts) {
        var reference = root;
        for (var i = 0; i < parts.length; i++) {
            reference = reference.get(parts[i]);
        }
        return reference;
    }
});

enifed("@glimmer/reference/lib/validators", ["exports"], function (exports) {
    "use strict";

    exports.combineTagged = combineTagged;
    exports.combineSlice = combineSlice;
    exports.combine = combine;
    exports.map = map;
    exports.isModified = isModified;

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var CONSTANT = 0;
    exports.CONSTANT = CONSTANT;
    var INITIAL = 1;
    exports.INITIAL = INITIAL;
    var VOLATILE = NaN;
    exports.VOLATILE = VOLATILE;

    var RevisionTag = (function () {
        function RevisionTag() {
            _classCallCheck(this, RevisionTag);
        }

        RevisionTag.prototype.validate = function validate(snapshot) {
            return this.value() === snapshot;
        };

        return RevisionTag;
    })();

    exports.RevisionTag = RevisionTag;

    var $REVISION = INITIAL;

    var DirtyableTag = (function (_RevisionTag) {
        _inherits(DirtyableTag, _RevisionTag);

        function DirtyableTag() {
            var revision = arguments.length <= 0 || arguments[0] === undefined ? $REVISION : arguments[0];

            _classCallCheck(this, DirtyableTag);

            _RevisionTag.call(this);
            this.revision = revision;
        }

        DirtyableTag.prototype.value = function value() {
            return this.revision;
        };

        DirtyableTag.prototype.dirty = function dirty() {
            this.revision = ++$REVISION;
        };

        return DirtyableTag;
    })(RevisionTag);

    exports.DirtyableTag = DirtyableTag;

    function combineTagged(tagged) {
        var optimized = [];
        for (var i = 0, l = tagged.length; i < l; i++) {
            var tag = tagged[i].tag;
            if (tag === VOLATILE_TAG) return VOLATILE_TAG;
            if (tag === CONSTANT_TAG) continue;
            optimized.push(tag);
        }
        return _combine(optimized);
    }

    function combineSlice(slice) {
        var optimized = [];
        var node = slice.head();
        while (node !== null) {
            var tag = node.tag;
            if (tag === VOLATILE_TAG) return VOLATILE_TAG;
            if (tag !== CONSTANT_TAG) optimized.push(tag);
            node = slice.nextNode(node);
        }
        return _combine(optimized);
    }

    function combine(tags) {
        var optimized = [];
        for (var i = 0, l = tags.length; i < l; i++) {
            var tag = tags[i];
            if (tag === VOLATILE_TAG) return VOLATILE_TAG;
            if (tag === CONSTANT_TAG) continue;
            optimized.push(tag);
        }
        return _combine(optimized);
    }

    function _combine(tags) {
        switch (tags.length) {
            case 0:
                return CONSTANT_TAG;
            case 1:
                return tags[0];
            case 2:
                return new TagsPair(tags[0], tags[1]);
            default:
                return new TagsCombinator(tags);
        }
        ;
    }

    var CachedTag = (function (_RevisionTag2) {
        _inherits(CachedTag, _RevisionTag2);

        function CachedTag() {
            _classCallCheck(this, CachedTag);

            _RevisionTag2.apply(this, arguments);
            this.lastChecked = null;
            this.lastValue = null;
        }

        CachedTag.prototype.value = function value() {
            var lastChecked = this.lastChecked;
            var lastValue = this.lastValue;

            if (lastChecked !== $REVISION) {
                this.lastChecked = $REVISION;
                this.lastValue = lastValue = this.compute();
            }
            return this.lastValue;
        };

        CachedTag.prototype.invalidate = function invalidate() {
            this.lastChecked = null;
        };

        return CachedTag;
    })(RevisionTag);

    exports.CachedTag = CachedTag;

    var TagsPair = (function (_CachedTag) {
        _inherits(TagsPair, _CachedTag);

        function TagsPair(first, second) {
            _classCallCheck(this, TagsPair);

            _CachedTag.call(this);
            this.first = first;
            this.second = second;
        }

        TagsPair.prototype.compute = function compute() {
            return Math.max(this.first.value(), this.second.value());
        };

        return TagsPair;
    })(CachedTag);

    var TagsCombinator = (function (_CachedTag2) {
        _inherits(TagsCombinator, _CachedTag2);

        function TagsCombinator(tags) {
            _classCallCheck(this, TagsCombinator);

            _CachedTag2.call(this);
            this.tags = tags;
        }

        TagsCombinator.prototype.compute = function compute() {
            var tags = this.tags;

            var max = -1;
            for (var i = 0; i < tags.length; i++) {
                var value = tags[i].value();
                max = Math.max(value, max);
            }
            return max;
        };

        return TagsCombinator;
    })(CachedTag);

    var UpdatableTag = (function (_CachedTag3) {
        _inherits(UpdatableTag, _CachedTag3);

        function UpdatableTag(tag) {
            _classCallCheck(this, UpdatableTag);

            _CachedTag3.call(this);
            this.tag = tag;
            this.lastUpdated = INITIAL;
        }

        //////////

        UpdatableTag.prototype.compute = function compute() {
            return Math.max(this.lastUpdated, this.tag.value());
        };

        UpdatableTag.prototype.update = function update(tag) {
            if (tag !== this.tag) {
                this.tag = tag;
                this.lastUpdated = $REVISION;
                this.invalidate();
            }
        };

        return UpdatableTag;
    })(CachedTag);

    exports.UpdatableTag = UpdatableTag;
    var CONSTANT_TAG = new ((function (_RevisionTag3) {
        _inherits(ConstantTag, _RevisionTag3);

        function ConstantTag() {
            _classCallCheck(this, ConstantTag);

            _RevisionTag3.apply(this, arguments);
        }

        ConstantTag.prototype.value = function value() {
            return CONSTANT;
        };

        return ConstantTag;
    })(RevisionTag))();
    exports.CONSTANT_TAG = CONSTANT_TAG;
    var VOLATILE_TAG = new ((function (_RevisionTag4) {
        _inherits(VolatileTag, _RevisionTag4);

        function VolatileTag() {
            _classCallCheck(this, VolatileTag);

            _RevisionTag4.apply(this, arguments);
        }

        VolatileTag.prototype.value = function value() {
            return VOLATILE;
        };

        return VolatileTag;
    })(RevisionTag))();
    exports.VOLATILE_TAG = VOLATILE_TAG;
    var CURRENT_TAG = new ((function (_DirtyableTag) {
        _inherits(CurrentTag, _DirtyableTag);

        function CurrentTag() {
            _classCallCheck(this, CurrentTag);

            _DirtyableTag.apply(this, arguments);
        }

        CurrentTag.prototype.value = function value() {
            return $REVISION;
        };

        return CurrentTag;
    })(DirtyableTag))();
    exports.CURRENT_TAG = CURRENT_TAG;

    var CachedReference = (function () {
        function CachedReference() {
            _classCallCheck(this, CachedReference);

            this.lastRevision = null;
            this.lastValue = null;
        }

        CachedReference.prototype.value = function value() {
            var tag = this.tag;
            var lastRevision = this.lastRevision;
            var lastValue = this.lastValue;

            if (!lastRevision || !tag.validate(lastRevision)) {
                lastValue = this.lastValue = this.compute();
                this.lastRevision = tag.value();
            }
            return lastValue;
        };

        CachedReference.prototype.invalidate = function invalidate() {
            this.lastRevision = null;
        };

        return CachedReference;
    })();

    exports.CachedReference = CachedReference;

    var MapperReference = (function (_CachedReference) {
        _inherits(MapperReference, _CachedReference);

        function MapperReference(reference, mapper) {
            _classCallCheck(this, MapperReference);

            _CachedReference.call(this);
            this.tag = reference.tag;
            this.reference = reference;
            this.mapper = mapper;
        }

        MapperReference.prototype.compute = function compute() {
            var reference = this.reference;
            var mapper = this.mapper;

            return mapper(reference.value());
        };

        return MapperReference;
    })(CachedReference);

    function map(reference, mapper) {
        return new MapperReference(reference, mapper);
    }

    //////////

    var ReferenceCache = (function () {
        function ReferenceCache(reference) {
            _classCallCheck(this, ReferenceCache);

            this.lastValue = null;
            this.lastRevision = null;
            this.initialized = false;
            this.tag = reference.tag;
            this.reference = reference;
        }

        ReferenceCache.prototype.peek = function peek() {
            if (!this.initialized) {
                return this.initialize();
            }
            return this.lastValue;
        };

        ReferenceCache.prototype.revalidate = function revalidate() {
            if (!this.initialized) {
                return this.initialize();
            }
            var reference = this.reference;
            var lastRevision = this.lastRevision;

            var tag = reference.tag;
            if (tag.validate(lastRevision)) return NOT_MODIFIED;
            this.lastRevision = tag.value();
            var lastValue = this.lastValue;

            var value = reference.value();
            if (value === lastValue) return NOT_MODIFIED;
            this.lastValue = value;
            return value;
        };

        ReferenceCache.prototype.initialize = function initialize() {
            var reference = this.reference;

            var value = this.lastValue = reference.value();
            this.lastRevision = reference.tag.value();
            this.initialized = true;
            return value;
        };

        return ReferenceCache;
    })();

    exports.ReferenceCache = ReferenceCache;

    var NOT_MODIFIED = "adb3b78e-3d22-4e4b-877a-6317c2c5c145";

    function isModified(value) {
        return value !== NOT_MODIFIED;
    }
});

enifed('@glimmer/util/index', ['exports', '@glimmer/util/lib/namespaces', '@glimmer/util/lib/platform-utils', '@glimmer/util/lib/assert', '@glimmer/util/lib/logger', '@glimmer/util/lib/object-utils', '@glimmer/util/lib/guid', '@glimmer/util/lib/collections', '@glimmer/util/lib/list-utils', '@glimmer/util/lib/array-utils', '@glimmer/util/lib/weakmap'], function (exports, _glimmerUtilLibNamespaces, _glimmerUtilLibPlatformUtils, _glimmerUtilLibAssert, _glimmerUtilLibLogger, _glimmerUtilLibObjectUtils, _glimmerUtilLibGuid, _glimmerUtilLibCollections, _glimmerUtilLibListUtils, _glimmerUtilLibArrayUtils, _glimmerUtilLibWeakmap) {
  'use strict';

  function _interopExportWildcard(obj, defaults) { var newObj = defaults({}, obj); delete newObj['default']; return newObj; }

  function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

  exports.getAttrNamespace = _glimmerUtilLibNamespaces.getAttrNamespace;

  _defaults(exports, _interopExportWildcard(_glimmerUtilLibPlatformUtils, _defaults));

  exports.assert = _glimmerUtilLibAssert.default;
  exports.LOGGER = _glimmerUtilLibLogger.default;
  exports.Logger = _glimmerUtilLibLogger.Logger;
  exports.LogLevel = _glimmerUtilLibLogger.LogLevel;
  exports.assign = _glimmerUtilLibObjectUtils.assign;
  exports.fillNulls = _glimmerUtilLibObjectUtils.fillNulls;
  exports.ensureGuid = _glimmerUtilLibGuid.ensureGuid;
  exports.initializeGuid = _glimmerUtilLibGuid.initializeGuid;
  exports.HasGuid = _glimmerUtilLibGuid.HasGuid;
  exports.Stack = _glimmerUtilLibCollections.Stack;
  exports.Dict = _glimmerUtilLibCollections.Dict;
  exports.Set = _glimmerUtilLibCollections.Set;
  exports.DictSet = _glimmerUtilLibCollections.DictSet;
  exports.dict = _glimmerUtilLibCollections.dict;
  exports.EMPTY_SLICE = _glimmerUtilLibListUtils.EMPTY_SLICE;
  exports.LinkedList = _glimmerUtilLibListUtils.LinkedList;
  exports.LinkedListNode = _glimmerUtilLibListUtils.LinkedListNode;
  exports.ListNode = _glimmerUtilLibListUtils.ListNode;
  exports.CloneableListNode = _glimmerUtilLibListUtils.CloneableListNode;
  exports.ListSlice = _glimmerUtilLibListUtils.ListSlice;
  exports.Slice = _glimmerUtilLibListUtils.Slice;
  exports.A = _glimmerUtilLibArrayUtils.default;
  exports.HAS_NATIVE_WEAKMAP = _glimmerUtilLibWeakmap.HAS_NATIVE_WEAKMAP;
});

enifed('@glimmer/util/lib/array-utils', ['exports'], function (exports) {
    'use strict';

    var HAS_TYPED_ARRAYS = typeof Uint32Array !== 'undefined';
    var A = undefined;
    if (HAS_TYPED_ARRAYS) {
        A = Uint32Array;
    } else {
        A = Array;
    }
    exports.default = A;
});

enifed("@glimmer/util/lib/assert", ["exports"], function (exports) {
    // import Logger from './logger';
    // let alreadyWarned = false;
    // import Logger from './logger';
    "use strict";

    exports.debugAssert = debugAssert;
    exports.prodAssert = prodAssert;

    function debugAssert(test, msg) {
        // if (!alreadyWarned) {
        //   alreadyWarned = true;
        //   Logger.warn("Don't leave debug assertions on in public builds");
        // }
        if (!test) {
            throw new Error(msg || "assertion failure");
        }
    }

    function prodAssert() {}

    exports.default = debugAssert;
});

enifed('@glimmer/util/lib/collections', ['exports', '@glimmer/util/lib/guid'], function (exports, _glimmerUtilLibGuid) {
    'use strict';

    exports.dict = dict;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var proto = Object.create(null, {
        // without this, we will always still end up with (new
        // EmptyObject()).constructor === Object
        constructor: {
            value: undefined,
            enumerable: false,
            writable: true
        }
    });
    function EmptyObject() {}
    EmptyObject.prototype = proto;

    function dict() {
        // let d = Object.create(null);
        // d.x = 1;
        // delete d.x;
        // return d;
        return new EmptyObject();
    }

    var DictSet = (function () {
        function DictSet() {
            _classCallCheck(this, DictSet);

            this.dict = dict();
        }

        DictSet.prototype.add = function add(obj) {
            if (typeof obj === 'string') this.dict[obj] = obj;else this.dict[_glimmerUtilLibGuid.ensureGuid(obj)] = obj;
            return this;
        };

        DictSet.prototype.delete = function _delete(obj) {
            if (typeof obj === 'string') delete this.dict[obj];else if (obj._guid) delete this.dict[obj._guid];
        };

        DictSet.prototype.forEach = function forEach(callback) {
            var dict = this.dict;

            Object.keys(dict).forEach(function (key) {
                return callback(dict[key]);
            });
        };

        DictSet.prototype.toArray = function toArray() {
            return Object.keys(this.dict);
        };

        return DictSet;
    })();

    exports.DictSet = DictSet;

    var Stack = (function () {
        function Stack() {
            _classCallCheck(this, Stack);

            this.stack = [];
            this.current = null;
        }

        Stack.prototype.toArray = function toArray() {
            return this.stack;
        };

        Stack.prototype.push = function push(item) {
            this.current = item;
            this.stack.push(item);
        };

        Stack.prototype.pop = function pop() {
            var item = this.stack.pop();
            var len = this.stack.length;
            this.current = len === 0 ? null : this.stack[len - 1];
            return item === undefined ? null : item;
        };

        Stack.prototype.isEmpty = function isEmpty() {
            return this.stack.length === 0;
        };

        return Stack;
    })();

    exports.Stack = Stack;
});

enifed("@glimmer/util/lib/guid", ["exports"], function (exports) {
    "use strict";

    exports.initializeGuid = initializeGuid;
    exports.ensureGuid = ensureGuid;
    var GUID = 0;

    function initializeGuid(object) {
        return object._guid = ++GUID;
    }

    function ensureGuid(object) {
        return object._guid || initializeGuid(object);
    }
});

enifed("@glimmer/util/lib/list-utils", ["exports"], function (exports) {
    "use strict";

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var ListNode = function ListNode(value) {
        _classCallCheck(this, ListNode);

        this.next = null;
        this.prev = null;
        this.value = value;
    };

    exports.ListNode = ListNode;

    var LinkedList = (function () {
        function LinkedList() {
            _classCallCheck(this, LinkedList);

            this.clear();
        }

        LinkedList.fromSlice = function fromSlice(slice) {
            var list = new LinkedList();
            slice.forEachNode(function (n) {
                return list.append(n.clone());
            });
            return list;
        };

        LinkedList.prototype.head = function head() {
            return this._head;
        };

        LinkedList.prototype.tail = function tail() {
            return this._tail;
        };

        LinkedList.prototype.clear = function clear() {
            this._head = this._tail = null;
        };

        LinkedList.prototype.isEmpty = function isEmpty() {
            return this._head === null;
        };

        LinkedList.prototype.toArray = function toArray() {
            var out = [];
            this.forEachNode(function (n) {
                return out.push(n);
            });
            return out;
        };

        LinkedList.prototype.splice = function splice(start, end, reference) {
            var before = undefined;
            if (reference === null) {
                before = this._tail;
                this._tail = end;
            } else {
                before = reference.prev;
                end.next = reference;
                reference.prev = end;
            }
            if (before) {
                before.next = start;
                start.prev = before;
            }
        };

        LinkedList.prototype.nextNode = function nextNode(node) {
            return node.next;
        };

        LinkedList.prototype.prevNode = function prevNode(node) {
            return node.prev;
        };

        LinkedList.prototype.forEachNode = function forEachNode(callback) {
            var node = this._head;
            while (node !== null) {
                callback(node);
                node = node.next;
            }
        };

        LinkedList.prototype.contains = function contains(needle) {
            var node = this._head;
            while (node !== null) {
                if (node === needle) return true;
                node = node.next;
            }
            return false;
        };

        LinkedList.prototype.insertBefore = function insertBefore(node) {
            var reference = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

            if (reference === null) return this.append(node);
            if (reference.prev) reference.prev.next = node;else this._head = node;
            node.prev = reference.prev;
            node.next = reference;
            reference.prev = node;
            return node;
        };

        LinkedList.prototype.append = function append(node) {
            var tail = this._tail;
            if (tail) {
                tail.next = node;
                node.prev = tail;
                node.next = null;
            } else {
                this._head = node;
            }
            return this._tail = node;
        };

        LinkedList.prototype.pop = function pop() {
            if (this._tail) return this.remove(this._tail);
            return null;
        };

        LinkedList.prototype.prepend = function prepend(node) {
            if (this._head) return this.insertBefore(node, this._head);
            return this._head = this._tail = node;
        };

        LinkedList.prototype.remove = function remove(node) {
            if (node.prev) node.prev.next = node.next;else this._head = node.next;
            if (node.next) node.next.prev = node.prev;else this._tail = node.prev;
            return node;
        };

        return LinkedList;
    })();

    exports.LinkedList = LinkedList;

    var ListSlice = (function () {
        function ListSlice(head, tail) {
            _classCallCheck(this, ListSlice);

            this._head = head;
            this._tail = tail;
        }

        ListSlice.toList = function toList(slice) {
            var list = new LinkedList();
            slice.forEachNode(function (n) {
                return list.append(n.clone());
            });
            return list;
        };

        ListSlice.prototype.forEachNode = function forEachNode(callback) {
            var node = this._head;
            while (node !== null) {
                callback(node);
                node = this.nextNode(node);
            }
        };

        ListSlice.prototype.contains = function contains(needle) {
            var node = this._head;
            while (node !== null) {
                if (node === needle) return true;
                node = node.next;
            }
            return false;
        };

        ListSlice.prototype.head = function head() {
            return this._head;
        };

        ListSlice.prototype.tail = function tail() {
            return this._tail;
        };

        ListSlice.prototype.toArray = function toArray() {
            var out = [];
            this.forEachNode(function (n) {
                return out.push(n);
            });
            return out;
        };

        ListSlice.prototype.nextNode = function nextNode(node) {
            if (node === this._tail) return null;
            return node.next;
        };

        ListSlice.prototype.prevNode = function prevNode(node) {
            if (node === this._head) return null;
            return node.prev;
        };

        ListSlice.prototype.isEmpty = function isEmpty() {
            return false;
        };

        return ListSlice;
    })();

    exports.ListSlice = ListSlice;
    var EMPTY_SLICE = new ListSlice(null, null);
    exports.EMPTY_SLICE = EMPTY_SLICE;
});

enifed("@glimmer/util/lib/logger", ["exports"], function (exports) {
    "use strict";

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var LogLevel;
    exports.LogLevel = LogLevel;
    (function (LogLevel) {
        LogLevel[LogLevel["Trace"] = 0] = "Trace";
        LogLevel[LogLevel["Debug"] = 1] = "Debug";
        LogLevel[LogLevel["Warn"] = 2] = "Warn";
        LogLevel[LogLevel["Error"] = 3] = "Error";
    })(LogLevel || (exports.LogLevel = LogLevel = {}));

    var NullConsole = (function () {
        function NullConsole() {
            _classCallCheck(this, NullConsole);
        }

        NullConsole.prototype.log = function log(_message) {};

        NullConsole.prototype.warn = function warn(_message) {};

        NullConsole.prototype.error = function error(_message) {};

        NullConsole.prototype.trace = function trace() {};

        return NullConsole;
    })();

    var ALWAYS = undefined;

    var Logger = (function () {
        function Logger(_ref) {
            var console = _ref.console;
            var level = _ref.level;

            _classCallCheck(this, Logger);

            this.f = ALWAYS;
            this.force = ALWAYS;
            this.console = console;
            this.level = level;
        }

        Logger.prototype.skipped = function skipped(level) {
            return level < this.level;
        };

        Logger.prototype.trace = function trace(message) {
            var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            var _ref2$stackTrace = _ref2.stackTrace;
            var stackTrace = _ref2$stackTrace === undefined ? false : _ref2$stackTrace;

            if (this.skipped(LogLevel.Trace)) return;
            this.console.log(message);
            if (stackTrace) this.console.trace();
        };

        Logger.prototype.debug = function debug(message) {
            var _ref3 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            var _ref3$stackTrace = _ref3.stackTrace;
            var stackTrace = _ref3$stackTrace === undefined ? false : _ref3$stackTrace;

            if (this.skipped(LogLevel.Debug)) return;
            this.console.log(message);
            if (stackTrace) this.console.trace();
        };

        Logger.prototype.warn = function warn(message) {
            var _ref4 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            var _ref4$stackTrace = _ref4.stackTrace;
            var stackTrace = _ref4$stackTrace === undefined ? false : _ref4$stackTrace;

            if (this.skipped(LogLevel.Warn)) return;
            this.console.warn(message);
            if (stackTrace) this.console.trace();
        };

        Logger.prototype.error = function error(message) {
            if (this.skipped(LogLevel.Error)) return;
            this.console.error(message);
        };

        return Logger;
    })();

    exports.Logger = Logger;

    var _console = typeof console === 'undefined' ? new NullConsole() : console;
    ALWAYS = new Logger({ console: _console, level: LogLevel.Trace });
    var LOG_LEVEL = LogLevel.Warn;
    exports.default = new Logger({ console: _console, level: LOG_LEVEL });
});

enifed('@glimmer/util/lib/namespaces', ['exports'], function (exports) {
    // There is a small whitelist of namespaced attributes specially
    // enumerated in
    // https://www.w3.org/TR/html/syntax.html#attributes-0
    //
    // > When a foreign element has one of the namespaced attributes given by
    // > the local name and namespace of the first and second cells of a row
    // > from the following table, it must be written using the name given by
    // > the third cell from the same row.
    //
    // In all other cases, colons are interpreted as a regular character
    // with no special meaning:
    //
    // > No other namespaced attribute can be expressed in the HTML syntax.
    'use strict';

    exports.getAttrNamespace = getAttrNamespace;
    var XLINK = 'http://www.w3.org/1999/xlink';
    var XML = 'http://www.w3.org/XML/1998/namespace';
    var XMLNS = 'http://www.w3.org/2000/xmlns/';
    var WHITELIST = {
        'xlink:actuate': XLINK,
        'xlink:arcrole': XLINK,
        'xlink:href': XLINK,
        'xlink:role': XLINK,
        'xlink:show': XLINK,
        'xlink:title': XLINK,
        'xlink:type': XLINK,
        'xml:base': XML,
        'xml:lang': XML,
        'xml:space': XML,
        'xmlns': XMLNS,
        'xmlns:xlink': XMLNS
    };

    function getAttrNamespace(attrName) {
        return WHITELIST[attrName] || null;
    }
});

enifed('@glimmer/util/lib/object-utils', ['exports'], function (exports) {
    'use strict';

    exports.assign = assign;
    exports.fillNulls = fillNulls;
    var objKeys = Object.keys;

    function assign(obj) {
        for (var i = 1; i < arguments.length; i++) {
            var assignment = arguments[i];
            if (assignment === null || typeof assignment !== 'object') continue;
            var keys = objKeys(assignment);
            for (var j = 0; j < keys.length; j++) {
                var key = keys[j];
                obj[key] = assignment[key];
            }
        }
        return obj;
    }

    function fillNulls(count) {
        var arr = new Array(count);
        for (var i = 0; i < count; i++) {
            arr[i] = null;
        }
        return arr;
    }
});

enifed('@glimmer/util/lib/platform-utils', ['exports'], function (exports) {
    // tslint:disable-line
    'use strict';

    exports.unwrap = unwrap;
    exports.expect = expect;
    exports.unreachable = unreachable;

    function unwrap(val) {
        if (val === null || val === undefined) throw new Error('Expected value to be present');
        return val;
    }

    function expect(val, message) {
        if (val === null || val === undefined) throw new Error(message);
        return val;
    }

    function unreachable() {
        return new Error('unreachable');
    }
});

enifed('@glimmer/util/lib/weakmap', ['exports'], function (exports) {
    'use strict';

    var HAS_NATIVE_WEAKMAP = (function () {
        // detect if `WeakMap` is even present
        var hasWeakMap = typeof WeakMap === 'function';
        if (!hasWeakMap) {
            return false;
        }
        var instance = new WeakMap();
        // use `Object`'s `.toString` directly to prevent us from detecting
        // polyfills as native weakmaps
        return Object.prototype.toString.call(instance) === '[object WeakMap]';
    })();
    exports.HAS_NATIVE_WEAKMAP = HAS_NATIVE_WEAKMAP;
});

enifed('@glimmer/wire-format/index', ['exports'], function (exports) {
    'use strict';

    exports.is = is;

    function is(variant) {
        return function (value) {
            return value[0] === variant;
        };
    }

    var Expressions;
    exports.Expressions = Expressions;
    (function (Expressions) {
        Expressions.isUnknown = is('unknown');
        Expressions.isArg = is('arg');
        Expressions.isGet = is('get');
        Expressions.isConcat = is('concat');
        Expressions.isHelper = is('helper');
        Expressions.isHasBlock = is('has-block');
        Expressions.isHasBlockParams = is('has-block-params');
        Expressions.isUndefined = is('undefined');
        function isPrimitiveValue(value) {
            if (value === null) {
                return true;
            }
            return typeof value !== 'object';
        }
        Expressions.isPrimitiveValue = isPrimitiveValue;
    })(Expressions || (exports.Expressions = Expressions = {}));
    var Statements;
    exports.Statements = Statements;
    (function (Statements) {
        Statements.isText = is('text');
        Statements.isAppend = is('append');
        Statements.isComment = is('comment');
        Statements.isModifier = is('modifier');
        Statements.isBlock = is('block');
        Statements.isComponent = is('component');
        Statements.isOpenElement = is('open-element');
        Statements.isFlushElement = is('flush-element');
        Statements.isCloseElement = is('close-element');
        Statements.isStaticAttr = is('static-attr');
        Statements.isDynamicAttr = is('dynamic-attr');
        Statements.isYield = is('yield');
        Statements.isPartial = is('partial');
        Statements.isDynamicArg = is('dynamic-arg');
        Statements.isStaticArg = is('static-arg');
        Statements.isTrustingAttr = is('trusting-attr');
        Statements.isDebugger = is('debugger');
        function isAttribute(val) {
            return val[0] === 'static-attr' || val[0] === 'dynamic-attr';
        }
        Statements.isAttribute = isAttribute;
        function isArgument(val) {
            return val[0] === 'static-arg' || val[0] === 'dynamic-arg';
        }
        Statements.isArgument = isArgument;
        function isParameter(val) {
            return isAttribute(val) || isArgument(val);
        }
        Statements.isParameter = isParameter;
        function getParameterName(s) {
            return s[1];
        }
        Statements.getParameterName = getParameterName;
    })(Statements || (exports.Statements = Statements = {}));
});

enifed('glimmer/index', ['exports', '@glimmer/compiler'], function (exports, _glimmerCompiler) {
  /*
   * @overview  Glimmer
   * @copyright Copyright 2011-2015 Tilde Inc. and contributors
   * @license   Licensed under MIT license
   *            See https://raw.githubusercontent.com/tildeio/glimmer/master/LICENSE
   * @version   VERSION_STRING_PLACEHOLDER
   */
  'use strict';

  exports.precompile = _glimmerCompiler.precompile;
});
//# sourceMappingURL=glimmer-common.amd.map
