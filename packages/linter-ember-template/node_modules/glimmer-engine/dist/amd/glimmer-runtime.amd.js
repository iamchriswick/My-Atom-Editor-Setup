enifed("@glimmer/public-runtime/index", ["exports"], function (exports) {
  "use strict";
});

enifed('@glimmer/runtime/index', ['exports', '@glimmer/runtime/lib/bootstrap', '@glimmer/runtime/lib/dom/interfaces', '@glimmer/runtime/lib/template', '@glimmer/runtime/lib/references', '@glimmer/runtime/lib/compiled/opcodes/builder', '@glimmer/runtime/lib/compiler', '@glimmer/runtime/lib/opcode-builder', '@glimmer/runtime/lib/compiled/blocks', '@glimmer/runtime/lib/dom/attribute-managers', '@glimmer/runtime/lib/compiled/opcodes/content', '@glimmer/runtime/lib/compiled/expressions', '@glimmer/runtime/lib/compiled/expressions/args', '@glimmer/runtime/lib/compiled/expressions/function', '@glimmer/runtime/lib/helpers/get-dynamic-var', '@glimmer/runtime/lib/syntax/functions', '@glimmer/runtime/lib/scanner', '@glimmer/runtime/lib/vm', '@glimmer/runtime/lib/upsert', '@glimmer/runtime/lib/environment', '@glimmer/runtime/lib/partial', '@glimmer/runtime/lib/component/interfaces', '@glimmer/runtime/lib/modifier/interfaces', '@glimmer/runtime/lib/dom/helper', '@glimmer/runtime/lib/builder', '@glimmer/runtime/lib/bounds'], function (exports, _glimmerRuntimeLibBootstrap, _glimmerRuntimeLibDomInterfaces, _glimmerRuntimeLibTemplate, _glimmerRuntimeLibReferences, _glimmerRuntimeLibCompiledOpcodesBuilder, _glimmerRuntimeLibCompiler, _glimmerRuntimeLibOpcodeBuilder, _glimmerRuntimeLibCompiledBlocks, _glimmerRuntimeLibDomAttributeManagers, _glimmerRuntimeLibCompiledOpcodesContent, _glimmerRuntimeLibCompiledExpressions, _glimmerRuntimeLibCompiledExpressionsArgs, _glimmerRuntimeLibCompiledExpressionsFunction, _glimmerRuntimeLibHelpersGetDynamicVar, _glimmerRuntimeLibSyntaxFunctions, _glimmerRuntimeLibScanner, _glimmerRuntimeLibVm, _glimmerRuntimeLibUpsert, _glimmerRuntimeLibEnvironment, _glimmerRuntimeLibPartial, _glimmerRuntimeLibComponentInterfaces, _glimmerRuntimeLibModifierInterfaces, _glimmerRuntimeLibDomHelper, _glimmerRuntimeLibBuilder, _glimmerRuntimeLibBounds) {
  'use strict';

  exports.templateFactory = _glimmerRuntimeLibTemplate.default;
  exports.TemplateFactory = _glimmerRuntimeLibTemplate.TemplateFactory;
  exports.Template = _glimmerRuntimeLibTemplate.Template;
  exports.NULL_REFERENCE = _glimmerRuntimeLibReferences.NULL_REFERENCE;
  exports.UNDEFINED_REFERENCE = _glimmerRuntimeLibReferences.UNDEFINED_REFERENCE;
  exports.PrimitiveReference = _glimmerRuntimeLibReferences.PrimitiveReference;
  exports.ConditionalReference = _glimmerRuntimeLibReferences.ConditionalReference;
  exports.OpcodeBuilderDSL = _glimmerRuntimeLibCompiledOpcodesBuilder.default;
  exports.CompilableLayout = _glimmerRuntimeLibCompiler.CompilableLayout;
  exports.compileLayout = _glimmerRuntimeLibCompiler.compileLayout;
  exports.ComponentBuilder = _glimmerRuntimeLibOpcodeBuilder.ComponentBuilder;
  exports.StaticDefinition = _glimmerRuntimeLibOpcodeBuilder.StaticDefinition;
  exports.DynamicDefinition = _glimmerRuntimeLibOpcodeBuilder.DynamicDefinition;
  exports.CompiledBlock = _glimmerRuntimeLibCompiledBlocks.CompiledBlock;
  exports.CompiledProgram = _glimmerRuntimeLibCompiledBlocks.CompiledProgram;
  exports.IAttributeManager = _glimmerRuntimeLibDomAttributeManagers.AttributeManager;
  exports.AttributeManager = _glimmerRuntimeLibDomAttributeManagers.AttributeManager;
  exports.PropertyManager = _glimmerRuntimeLibDomAttributeManagers.PropertyManager;
  exports.INPUT_VALUE_PROPERTY_MANAGER = _glimmerRuntimeLibDomAttributeManagers.INPUT_VALUE_PROPERTY_MANAGER;
  exports.defaultManagers = _glimmerRuntimeLibDomAttributeManagers.defaultManagers;
  exports.defaultAttributeManagers = _glimmerRuntimeLibDomAttributeManagers.defaultAttributeManagers;
  exports.defaultPropertyManagers = _glimmerRuntimeLibDomAttributeManagers.defaultPropertyManagers;
  exports.readDOMAttr = _glimmerRuntimeLibDomAttributeManagers.readDOMAttr;
  exports.normalizeTextValue = _glimmerRuntimeLibCompiledOpcodesContent.normalizeTextValue;
  exports.CompiledExpression = _glimmerRuntimeLibCompiledExpressions.CompiledExpression;
  exports.CompiledArgs = _glimmerRuntimeLibCompiledExpressionsArgs.CompiledArgs;
  exports.CompiledNamedArgs = _glimmerRuntimeLibCompiledExpressionsArgs.CompiledNamedArgs;
  exports.CompiledPositionalArgs = _glimmerRuntimeLibCompiledExpressionsArgs.CompiledPositionalArgs;
  exports.EvaluatedArgs = _glimmerRuntimeLibCompiledExpressionsArgs.EvaluatedArgs;
  exports.EvaluatedNamedArgs = _glimmerRuntimeLibCompiledExpressionsArgs.EvaluatedNamedArgs;
  exports.EvaluatedPositionalArgs = _glimmerRuntimeLibCompiledExpressionsArgs.EvaluatedPositionalArgs;
  exports.FunctionExpression = _glimmerRuntimeLibCompiledExpressionsFunction.FunctionExpression;
  exports.getDynamicVar = _glimmerRuntimeLibHelpersGetDynamicVar.default;
  exports.BlockMacros = _glimmerRuntimeLibSyntaxFunctions.Blocks;
  exports.InlineMacros = _glimmerRuntimeLibSyntaxFunctions.Inlines;
  exports.NestedBlockSyntax = _glimmerRuntimeLibSyntaxFunctions.NestedBlockSyntax;
  exports.CompileBlockMacro = _glimmerRuntimeLibSyntaxFunctions.CompileBlockMacro;
  exports.compileArgs = _glimmerRuntimeLibSyntaxFunctions.compileArgs;
  exports.setDebuggerCallback = _glimmerRuntimeLibSyntaxFunctions.setDebuggerCallback;
  exports.resetDebuggerCallback = _glimmerRuntimeLibSyntaxFunctions.resetDebuggerCallback;
  exports.debugCallback = _glimmerRuntimeLibSyntaxFunctions.debugCallback;
  exports.BaselineSyntax = _glimmerRuntimeLibScanner.BaselineSyntax;
  exports.Layout = _glimmerRuntimeLibScanner.Layout;
  exports.VM = _glimmerRuntimeLibVm.PublicVM;
  exports.UpdatingVM = _glimmerRuntimeLibVm.UpdatingVM;
  exports.RenderResult = _glimmerRuntimeLibVm.RenderResult;
  exports.SafeString = _glimmerRuntimeLibUpsert.SafeString;
  exports.isSafeString = _glimmerRuntimeLibUpsert.isSafeString;
  exports.Scope = _glimmerRuntimeLibEnvironment.Scope;
  exports.Environment = _glimmerRuntimeLibEnvironment.default;
  exports.Helper = _glimmerRuntimeLibEnvironment.Helper;
  exports.DynamicScope = _glimmerRuntimeLibEnvironment.DynamicScope;
  exports.PartialDefinition = _glimmerRuntimeLibPartial.PartialDefinition;
  exports.Component = _glimmerRuntimeLibComponentInterfaces.Component;
  exports.ComponentClass = _glimmerRuntimeLibComponentInterfaces.ComponentClass;
  exports.ComponentManager = _glimmerRuntimeLibComponentInterfaces.ComponentManager;
  exports.ComponentDefinition = _glimmerRuntimeLibComponentInterfaces.ComponentDefinition;
  exports.ComponentLayoutBuilder = _glimmerRuntimeLibComponentInterfaces.ComponentLayoutBuilder;
  exports.ComponentAttrsBuilder = _glimmerRuntimeLibComponentInterfaces.ComponentAttrsBuilder;
  exports.isComponentDefinition = _glimmerRuntimeLibComponentInterfaces.isComponentDefinition;
  exports.ModifierManager = _glimmerRuntimeLibModifierInterfaces.ModifierManager;
  exports.DOMChanges = _glimmerRuntimeLibDomHelper.default;
  exports.IDOMChanges = _glimmerRuntimeLibDomHelper.DOMChanges;
  exports.DOMTreeConstruction = _glimmerRuntimeLibDomHelper.DOMTreeConstruction;
  exports.isWhitespace = _glimmerRuntimeLibDomHelper.isWhitespace;
  exports.insertHTMLBefore = _glimmerRuntimeLibDomHelper.insertHTMLBefore;
  exports.Simple = _glimmerRuntimeLibDomInterfaces;
  exports.ElementStack = _glimmerRuntimeLibBuilder.ElementStack;
  exports.ElementOperations = _glimmerRuntimeLibBuilder.ElementOperations;
  exports.Bounds = _glimmerRuntimeLibBounds.default;
  exports.ConcreteBounds = _glimmerRuntimeLibBounds.ConcreteBounds;
});

enifed('@glimmer/runtime/lib/bootstrap', ['exports', '@glimmer/runtime/lib/opcodes', '@glimmer/runtime/lib/compiled/opcodes/blocks', '@glimmer/runtime/lib/compiled/opcodes/component', '@glimmer/runtime/lib/compiled/opcodes/content', '@glimmer/runtime/lib/compiled/opcodes/dom', '@glimmer/runtime/lib/compiled/opcodes/partial', '@glimmer/runtime/lib/compiled/opcodes/vm', '@glimmer/runtime/lib/compiled/opcodes/lists'], function (exports, _glimmerRuntimeLibOpcodes, _glimmerRuntimeLibCompiledOpcodesBlocks, _glimmerRuntimeLibCompiledOpcodesComponent, _glimmerRuntimeLibCompiledOpcodesContent, _glimmerRuntimeLibCompiledOpcodesDom, _glimmerRuntimeLibCompiledOpcodesPartial, _glimmerRuntimeLibCompiledOpcodesVm, _glimmerRuntimeLibCompiledOpcodesLists) {
  'use strict';
});

enifed("@glimmer/runtime/lib/bounds", ["exports"], function (exports) {
    "use strict";

    exports.bounds = bounds;
    exports.single = single;
    exports.move = move;
    exports.clear = clear;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var Cursor = function Cursor(element, nextSibling) {
        _classCallCheck(this, Cursor);

        this.element = element;
        this.nextSibling = nextSibling;
    };

    exports.Cursor = Cursor;

    var RealDOMBounds = (function () {
        function RealDOMBounds(bounds) {
            _classCallCheck(this, RealDOMBounds);

            this.bounds = bounds;
        }

        RealDOMBounds.prototype.parentElement = function parentElement() {
            return this.bounds.parentElement();
        };

        RealDOMBounds.prototype.firstNode = function firstNode() {
            return this.bounds.firstNode();
        };

        RealDOMBounds.prototype.lastNode = function lastNode() {
            return this.bounds.lastNode();
        };

        return RealDOMBounds;
    })();

    exports.RealDOMBounds = RealDOMBounds;

    var ConcreteBounds = (function () {
        function ConcreteBounds(parentNode, first, last) {
            _classCallCheck(this, ConcreteBounds);

            this.parentNode = parentNode;
            this.first = first;
            this.last = last;
        }

        ConcreteBounds.prototype.parentElement = function parentElement() {
            return this.parentNode;
        };

        ConcreteBounds.prototype.firstNode = function firstNode() {
            return this.first;
        };

        ConcreteBounds.prototype.lastNode = function lastNode() {
            return this.last;
        };

        return ConcreteBounds;
    })();

    exports.ConcreteBounds = ConcreteBounds;

    var SingleNodeBounds = (function () {
        function SingleNodeBounds(parentNode, node) {
            _classCallCheck(this, SingleNodeBounds);

            this.parentNode = parentNode;
            this.node = node;
        }

        SingleNodeBounds.prototype.parentElement = function parentElement() {
            return this.parentNode;
        };

        SingleNodeBounds.prototype.firstNode = function firstNode() {
            return this.node;
        };

        SingleNodeBounds.prototype.lastNode = function lastNode() {
            return this.node;
        };

        return SingleNodeBounds;
    })();

    exports.SingleNodeBounds = SingleNodeBounds;

    function bounds(parent, first, last) {
        return new ConcreteBounds(parent, first, last);
    }

    function single(parent, node) {
        return new SingleNodeBounds(parent, node);
    }

    function move(bounds, reference) {
        var parent = bounds.parentElement();
        var first = bounds.firstNode();
        var last = bounds.lastNode();
        var node = first;
        while (node) {
            var next = node.nextSibling;
            parent.insertBefore(node, reference);
            if (node === last) return next;
            node = next;
        }
        return null;
    }

    function clear(bounds) {
        var parent = bounds.parentElement();
        var first = bounds.firstNode();
        var last = bounds.lastNode();
        var node = first;
        while (node) {
            var next = node.nextSibling;
            parent.removeChild(node);
            if (node === last) return next;
            node = next;
        }
        return null;
    }
});

enifed('@glimmer/runtime/lib/builder', ['exports', '@glimmer/runtime/lib/bounds', '@glimmer/util', '@glimmer/runtime/lib/compiled/opcodes/dom'], function (exports, _glimmerRuntimeLibBounds, _glimmerUtil, _glimmerRuntimeLibCompiledOpcodesDom) {
    'use strict';

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var First = (function () {
        function First(node) {
            _classCallCheck(this, First);

            this.node = node;
        }

        First.prototype.firstNode = function firstNode() {
            return this.node;
        };

        return First;
    })();

    var Last = (function () {
        function Last(node) {
            _classCallCheck(this, Last);

            this.node = node;
        }

        Last.prototype.lastNode = function lastNode() {
            return this.node;
        };

        return Last;
    })();

    var Fragment = (function () {
        function Fragment(bounds) {
            _classCallCheck(this, Fragment);

            this.bounds = bounds;
        }

        Fragment.prototype.parentElement = function parentElement() {
            return this.bounds.parentElement();
        };

        Fragment.prototype.firstNode = function firstNode() {
            return this.bounds.firstNode();
        };

        Fragment.prototype.lastNode = function lastNode() {
            return this.bounds.lastNode();
        };

        Fragment.prototype.update = function update(bounds) {
            this.bounds = bounds;
        };

        return Fragment;
    })();

    exports.Fragment = Fragment;

    var ElementStack = (function () {
        function ElementStack(env, parentNode, nextSibling) {
            _classCallCheck(this, ElementStack);

            this.constructing = null;
            this.operations = null;
            this.elementStack = new _glimmerUtil.Stack();
            this.nextSiblingStack = new _glimmerUtil.Stack();
            this.blockStack = new _glimmerUtil.Stack();
            this.env = env;
            this.dom = env.getAppendOperations();
            this.updateOperations = env.getDOM();
            this.element = parentNode;
            this.nextSibling = nextSibling;
            this.defaultOperations = new _glimmerRuntimeLibCompiledOpcodesDom.SimpleElementOperations(env);
            this.elementStack.push(this.element);
            this.nextSiblingStack.push(this.nextSibling);
        }

        ElementStack.forInitialRender = function forInitialRender(env, parentNode, nextSibling) {
            return new ElementStack(env, parentNode, nextSibling);
        };

        ElementStack.resume = function resume(env, tracker, nextSibling) {
            var parentNode = tracker.parentElement();
            var stack = new ElementStack(env, parentNode, nextSibling);
            stack.pushBlockTracker(tracker);
            return stack;
        };

        ElementStack.prototype.expectConstructing = function expectConstructing(method) {
            return _glimmerUtil.expect(this.constructing, method + ' should only be called while constructing an element');
        };

        ElementStack.prototype.expectOperations = function expectOperations(method) {
            return _glimmerUtil.expect(this.operations, method + ' should only be called while constructing an element');
        };

        ElementStack.prototype.block = function block() {
            return _glimmerUtil.expect(this.blockStack.current, "Expected a current block tracker");
        };

        ElementStack.prototype.popElement = function popElement() {
            var elementStack = this.elementStack;
            var nextSiblingStack = this.nextSiblingStack;

            var topElement = elementStack.pop();
            nextSiblingStack.pop();
            _glimmerUtil.LOGGER.debug('-> element stack ' + this.elementStack.toArray().map(function (e) {
                return e.tagName;
            }).join(', '));
            this.element = _glimmerUtil.expect(elementStack.current, "can't pop past the last element");
            this.nextSibling = nextSiblingStack.current;
            return topElement;
        };

        ElementStack.prototype.pushSimpleBlock = function pushSimpleBlock() {
            var tracker = new SimpleBlockTracker(this.element);
            this.pushBlockTracker(tracker);
            return tracker;
        };

        ElementStack.prototype.pushUpdatableBlock = function pushUpdatableBlock() {
            var tracker = new UpdatableBlockTracker(this.element);
            this.pushBlockTracker(tracker);
            return tracker;
        };

        ElementStack.prototype.pushBlockTracker = function pushBlockTracker(tracker) {
            var isRemote = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

            var current = this.blockStack.current;
            if (current !== null) {
                current.newDestroyable(tracker);
                if (!isRemote) {
                    current.newBounds(tracker);
                }
            }
            this.blockStack.push(tracker);
            return tracker;
        };

        ElementStack.prototype.pushBlockList = function pushBlockList(list) {
            var tracker = new BlockListTracker(this.element, list);
            var current = this.blockStack.current;
            if (current !== null) {
                current.newDestroyable(tracker);
                current.newBounds(tracker);
            }
            this.blockStack.push(tracker);
            return tracker;
        };

        ElementStack.prototype.popBlock = function popBlock() {
            this.block().finalize(this);
            return _glimmerUtil.expect(this.blockStack.pop(), "Expected popBlock to return a block");
        };

        ElementStack.prototype.openElement = function openElement(tag) {
            var operations = arguments.length <= 1 || arguments[1] === undefined ? this.defaultOperations : arguments[1];

            var element = this.dom.createElement(tag, this.element);
            this.constructing = element;
            this.operations = operations;
            return element;
        };

        ElementStack.prototype.flushElement = function flushElement() {
            var parent = this.element;
            var element = _glimmerUtil.expect(this.constructing, 'flushElement should only be called when constructing an element');
            this.dom.insertBefore(parent, element, this.nextSibling);
            this.constructing = null;
            this.operations = null;
            this.pushElement(element);
            this.block().openElement(element);
        };

        ElementStack.prototype.pushRemoteElement = function pushRemoteElement(element) {
            this.pushElement(element);
            var tracker = new RemoteBlockTracker(element);
            this.pushBlockTracker(tracker, true);
        };

        ElementStack.prototype.popRemoteElement = function popRemoteElement() {
            this.popBlock();
            this.popElement();
        };

        ElementStack.prototype.pushElement = function pushElement(element) {
            this.element = element;
            this.elementStack.push(element);
            _glimmerUtil.LOGGER.debug('-> element stack ' + this.elementStack.toArray().map(function (e) {
                return e.tagName;
            }).join(', '));
            this.nextSibling = null;
            this.nextSiblingStack.push(null);
        };

        ElementStack.prototype.newDestroyable = function newDestroyable(d) {
            this.block().newDestroyable(d);
        };

        ElementStack.prototype.newBounds = function newBounds(bounds) {
            this.block().newBounds(bounds);
        };

        ElementStack.prototype.appendText = function appendText(string) {
            var dom = this.dom;

            var text = dom.createTextNode(string);
            dom.insertBefore(this.element, text, this.nextSibling);
            this.block().newNode(text);
            return text;
        };

        ElementStack.prototype.appendComment = function appendComment(string) {
            var dom = this.dom;

            var comment = dom.createComment(string);
            dom.insertBefore(this.element, comment, this.nextSibling);
            this.block().newNode(comment);
            return comment;
        };

        ElementStack.prototype.setStaticAttribute = function setStaticAttribute(name, value) {
            this.expectOperations('setStaticAttribute').addStaticAttribute(this.expectConstructing('setStaticAttribute'), name, value);
        };

        ElementStack.prototype.setStaticAttributeNS = function setStaticAttributeNS(namespace, name, value) {
            this.expectOperations('setStaticAttributeNS').addStaticAttributeNS(this.expectConstructing('setStaticAttributeNS'), namespace, name, value);
        };

        ElementStack.prototype.setDynamicAttribute = function setDynamicAttribute(name, reference, isTrusting) {
            this.expectOperations('setDynamicAttribute').addDynamicAttribute(this.expectConstructing('setDynamicAttribute'), name, reference, isTrusting);
        };

        ElementStack.prototype.setDynamicAttributeNS = function setDynamicAttributeNS(namespace, name, reference, isTrusting) {
            this.expectOperations('setDynamicAttributeNS').addDynamicAttributeNS(this.expectConstructing('setDynamicAttributeNS'), namespace, name, reference, isTrusting);
        };

        ElementStack.prototype.closeElement = function closeElement() {
            this.block().closeElement();
            this.popElement();
        };

        return ElementStack;
    })();

    exports.ElementStack = ElementStack;

    var SimpleBlockTracker = (function () {
        function SimpleBlockTracker(parent) {
            _classCallCheck(this, SimpleBlockTracker);

            this.parent = parent;
            this.first = null;
            this.last = null;
            this.destroyables = null;
            this.nesting = 0;
        }

        SimpleBlockTracker.prototype.destroy = function destroy() {
            var destroyables = this.destroyables;

            if (destroyables && destroyables.length) {
                for (var i = 0; i < destroyables.length; i++) {
                    destroyables[i].destroy();
                }
            }
        };

        SimpleBlockTracker.prototype.parentElement = function parentElement() {
            return this.parent;
        };

        SimpleBlockTracker.prototype.firstNode = function firstNode() {
            return this.first && this.first.firstNode();
        };

        SimpleBlockTracker.prototype.lastNode = function lastNode() {
            return this.last && this.last.lastNode();
        };

        SimpleBlockTracker.prototype.openElement = function openElement(element) {
            this.newNode(element);
            this.nesting++;
        };

        SimpleBlockTracker.prototype.closeElement = function closeElement() {
            this.nesting--;
        };

        SimpleBlockTracker.prototype.newNode = function newNode(node) {
            if (this.nesting !== 0) return;
            if (!this.first) {
                this.first = new First(node);
            }
            this.last = new Last(node);
        };

        SimpleBlockTracker.prototype.newBounds = function newBounds(bounds) {
            if (this.nesting !== 0) return;
            if (!this.first) {
                this.first = bounds;
            }
            this.last = bounds;
        };

        SimpleBlockTracker.prototype.newDestroyable = function newDestroyable(d) {
            this.destroyables = this.destroyables || [];
            this.destroyables.push(d);
        };

        SimpleBlockTracker.prototype.finalize = function finalize(stack) {
            if (!this.first) {
                stack.appendComment('');
            }
        };

        return SimpleBlockTracker;
    })();

    exports.SimpleBlockTracker = SimpleBlockTracker;

    var RemoteBlockTracker = (function (_SimpleBlockTracker) {
        _inherits(RemoteBlockTracker, _SimpleBlockTracker);

        function RemoteBlockTracker() {
            _classCallCheck(this, RemoteBlockTracker);

            _SimpleBlockTracker.apply(this, arguments);
        }

        RemoteBlockTracker.prototype.destroy = function destroy() {
            _SimpleBlockTracker.prototype.destroy.call(this);
            _glimmerRuntimeLibBounds.clear(this);
        };

        return RemoteBlockTracker;
    })(SimpleBlockTracker);

    var UpdatableBlockTracker = (function (_SimpleBlockTracker2) {
        _inherits(UpdatableBlockTracker, _SimpleBlockTracker2);

        function UpdatableBlockTracker() {
            _classCallCheck(this, UpdatableBlockTracker);

            _SimpleBlockTracker2.apply(this, arguments);
        }

        UpdatableBlockTracker.prototype.reset = function reset(env) {
            var destroyables = this.destroyables;

            if (destroyables && destroyables.length) {
                for (var i = 0; i < destroyables.length; i++) {
                    env.didDestroy(destroyables[i]);
                }
            }
            var nextSibling = _glimmerRuntimeLibBounds.clear(this);
            this.destroyables = null;
            this.first = null;
            this.last = null;
            return nextSibling;
        };

        return UpdatableBlockTracker;
    })(SimpleBlockTracker);

    exports.UpdatableBlockTracker = UpdatableBlockTracker;

    var BlockListTracker = (function () {
        function BlockListTracker(parent, boundList) {
            _classCallCheck(this, BlockListTracker);

            this.parent = parent;
            this.boundList = boundList;
            this.parent = parent;
            this.boundList = boundList;
        }

        BlockListTracker.prototype.destroy = function destroy() {
            this.boundList.forEachNode(function (node) {
                return node.destroy();
            });
        };

        BlockListTracker.prototype.parentElement = function parentElement() {
            return this.parent;
        };

        BlockListTracker.prototype.firstNode = function firstNode() {
            var head = this.boundList.head();
            return head && head.firstNode();
        };

        BlockListTracker.prototype.lastNode = function lastNode() {
            var tail = this.boundList.tail();
            return tail && tail.lastNode();
        };

        BlockListTracker.prototype.openElement = function openElement(_element) {
            _glimmerUtil.assert(false, 'Cannot openElement directly inside a block list');
        };

        BlockListTracker.prototype.closeElement = function closeElement() {
            _glimmerUtil.assert(false, 'Cannot closeElement directly inside a block list');
        };

        BlockListTracker.prototype.newNode = function newNode(_node) {
            _glimmerUtil.assert(false, 'Cannot create a new node directly inside a block list');
        };

        BlockListTracker.prototype.newBounds = function newBounds(_bounds) {};

        BlockListTracker.prototype.newDestroyable = function newDestroyable(_d) {};

        BlockListTracker.prototype.finalize = function finalize(_stack) {};

        return BlockListTracker;
    })();
});

enifed('@glimmer/runtime/lib/compat/inner-html-fix', ['exports', '@glimmer/runtime/lib/bounds', '@glimmer/runtime/lib/dom/helper'], function (exports, _glimmerRuntimeLibBounds, _glimmerRuntimeLibDomHelper) {
    'use strict';

    exports.domChanges = domChanges;
    exports.treeConstruction = treeConstruction;

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    var innerHTMLWrapper = {
        colgroup: { depth: 2, before: '<table><colgroup>', after: '</colgroup></table>' },
        table: { depth: 1, before: '<table>', after: '</table>' },
        tbody: { depth: 2, before: '<table><tbody>', after: '</tbody></table>' },
        tfoot: { depth: 2, before: '<table><tfoot>', after: '</tfoot></table>' },
        thead: { depth: 2, before: '<table><thead>', after: '</thead></table>' },
        tr: { depth: 3, before: '<table><tbody><tr>', after: '</tr></tbody></table>' }
    };
    // Patch:    innerHTML Fix
    // Browsers: IE9
    // Reason:   IE9 don't allow us to set innerHTML on col, colgroup, frameset,
    //           html, style, table, tbody, tfoot, thead, title, tr.
    // Fix:      Wrap the innerHTML we are about to set in its parents, apply the
    //           wrapped innerHTML on a div, then move the unwrapped nodes into the
    //           target position.

    function domChanges(document, DOMChangesClass) {
        if (!document) return DOMChangesClass;
        if (!shouldApplyFix(document)) {
            return DOMChangesClass;
        }
        var div = document.createElement('div');
        return (function (_DOMChangesClass) {
            _inherits(DOMChangesWithInnerHTMLFix, _DOMChangesClass);

            function DOMChangesWithInnerHTMLFix() {
                _classCallCheck(this, DOMChangesWithInnerHTMLFix);

                _DOMChangesClass.apply(this, arguments);
            }

            DOMChangesWithInnerHTMLFix.prototype.insertHTMLBefore = function insertHTMLBefore(parent, nextSibling, html) {
                if (html === null || html === '') {
                    return _DOMChangesClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
                }
                var parentTag = parent.tagName.toLowerCase();
                var wrapper = innerHTMLWrapper[parentTag];
                if (wrapper === undefined) {
                    return _DOMChangesClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
                }
                return fixInnerHTML(parent, wrapper, div, html, nextSibling);
            };

            return DOMChangesWithInnerHTMLFix;
        })(DOMChangesClass);
    }

    function treeConstruction(document, DOMTreeConstructionClass) {
        if (!document) return DOMTreeConstructionClass;
        if (!shouldApplyFix(document)) {
            return DOMTreeConstructionClass;
        }
        var div = document.createElement('div');
        return (function (_DOMTreeConstructionClass) {
            _inherits(DOMTreeConstructionWithInnerHTMLFix, _DOMTreeConstructionClass);

            function DOMTreeConstructionWithInnerHTMLFix() {
                _classCallCheck(this, DOMTreeConstructionWithInnerHTMLFix);

                _DOMTreeConstructionClass.apply(this, arguments);
            }

            DOMTreeConstructionWithInnerHTMLFix.prototype.insertHTMLBefore = function insertHTMLBefore(parent, html, reference) {
                if (html === null || html === '') {
                    return _DOMTreeConstructionClass.prototype.insertHTMLBefore.call(this, parent, html, reference);
                }
                var parentTag = parent.tagName.toLowerCase();
                var wrapper = innerHTMLWrapper[parentTag];
                if (wrapper === undefined) {
                    return _DOMTreeConstructionClass.prototype.insertHTMLBefore.call(this, parent, html, reference);
                }
                return fixInnerHTML(parent, wrapper, div, html, reference);
            };

            return DOMTreeConstructionWithInnerHTMLFix;
        })(DOMTreeConstructionClass);
    }

    function fixInnerHTML(parent, wrapper, div, html, reference) {
        var wrappedHtml = wrapper.before + html + wrapper.after;
        div.innerHTML = wrappedHtml;
        var parentNode = div;
        for (var i = 0; i < wrapper.depth; i++) {
            parentNode = parentNode.childNodes[0];
        }

        var _moveNodesBefore = _glimmerRuntimeLibDomHelper.moveNodesBefore(parentNode, parent, reference);

        var first = _moveNodesBefore[0];
        var last = _moveNodesBefore[1];

        return new _glimmerRuntimeLibBounds.ConcreteBounds(parent, first, last);
    }
    function shouldApplyFix(document) {
        var table = document.createElement('table');
        try {
            table.innerHTML = '<tbody></tbody>';
        } catch (e) {} finally {
            if (table.childNodes.length !== 0) {
                // It worked as expected, no fix required
                return false;
            }
        }
        return true;
    }
});

enifed('@glimmer/runtime/lib/compat/svg-inner-html-fix', ['exports', '@glimmer/runtime/lib/bounds', '@glimmer/runtime/lib/dom/helper', '@glimmer/util'], function (exports, _glimmerRuntimeLibBounds, _glimmerRuntimeLibDomHelper, _glimmerUtil) {
    'use strict';

    exports.domChanges = domChanges;
    exports.treeConstruction = treeConstruction;

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    exports.SVG_NAMESPACE = SVG_NAMESPACE;
    // Patch:    insertAdjacentHTML on SVG Fix
    // Browsers: Safari, IE, Edge, Firefox ~33-34
    // Reason:   insertAdjacentHTML does not exist on SVG elements in Safari. It is
    //           present but throws an exception on IE and Edge. Old versions of
    //           Firefox create nodes in the incorrect namespace.
    // Fix:      Since IE and Edge silently fail to create SVG nodes using
    //           innerHTML, and because Firefox may create nodes in the incorrect
    //           namespace using innerHTML on SVG elements, an HTML-string wrapping
    //           approach is used. A pre/post SVG tag is added to the string, then
    //           that whole string is added to a div. The created nodes are plucked
    //           out and applied to the target location on DOM.

    function domChanges(document, DOMChangesClass, svgNamespace) {
        if (!document) return DOMChangesClass;
        if (!shouldApplyFix(document, svgNamespace)) {
            return DOMChangesClass;
        }
        var div = document.createElement('div');
        return (function (_DOMChangesClass) {
            _inherits(DOMChangesWithSVGInnerHTMLFix, _DOMChangesClass);

            function DOMChangesWithSVGInnerHTMLFix() {
                _classCallCheck(this, DOMChangesWithSVGInnerHTMLFix);

                _DOMChangesClass.apply(this, arguments);
            }

            DOMChangesWithSVGInnerHTMLFix.prototype.insertHTMLBefore = function insertHTMLBefore(parent, nextSibling, html) {
                if (html === null || html === '') {
                    return _DOMChangesClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
                }
                if (parent.namespaceURI !== svgNamespace) {
                    return _DOMChangesClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
                }
                return fixSVG(parent, div, html, nextSibling);
            };

            return DOMChangesWithSVGInnerHTMLFix;
        })(DOMChangesClass);
    }

    function treeConstruction(document, TreeConstructionClass, svgNamespace) {
        if (!document) return TreeConstructionClass;
        if (!shouldApplyFix(document, svgNamespace)) {
            return TreeConstructionClass;
        }
        var div = document.createElement('div');
        return (function (_TreeConstructionClass) {
            _inherits(TreeConstructionWithSVGInnerHTMLFix, _TreeConstructionClass);

            function TreeConstructionWithSVGInnerHTMLFix() {
                _classCallCheck(this, TreeConstructionWithSVGInnerHTMLFix);

                _TreeConstructionClass.apply(this, arguments);
            }

            TreeConstructionWithSVGInnerHTMLFix.prototype.insertHTMLBefore = function insertHTMLBefore(parent, html, reference) {
                if (html === null || html === '') {
                    return _TreeConstructionClass.prototype.insertHTMLBefore.call(this, parent, html, reference);
                }
                if (parent.namespaceURI !== svgNamespace) {
                    return _TreeConstructionClass.prototype.insertHTMLBefore.call(this, parent, html, reference);
                }
                return fixSVG(parent, div, html, reference);
            };

            return TreeConstructionWithSVGInnerHTMLFix;
        })(TreeConstructionClass);
    }

    function fixSVG(parent, div, html, reference) {
        // IE, Edge: also do not correctly support using `innerHTML` on SVG
        // namespaced elements. So here a wrapper is used.
        var wrappedHtml = '<svg>' + html + '</svg>';
        div.innerHTML = wrappedHtml;

        var _moveNodesBefore = _glimmerRuntimeLibDomHelper.moveNodesBefore(div.firstChild, parent, reference);

        var first = _moveNodesBefore[0];
        var last = _moveNodesBefore[1];

        return new _glimmerRuntimeLibBounds.ConcreteBounds(parent, first, last);
    }
    function shouldApplyFix(document, svgNamespace) {
        var svg = document.createElementNS(svgNamespace, 'svg');
        try {
            svg['insertAdjacentHTML']('beforeEnd', '<circle></circle>');
        } catch (e) {} finally {
            // FF: Old versions will create a node in the wrong namespace
            if (svg.childNodes.length === 1 && _glimmerUtil.unwrap(svg.firstChild).namespaceURI === SVG_NAMESPACE) {
                // The test worked as expected, no fix required
                return false;
            }
            return true;
        }
    }
});

enifed('@glimmer/runtime/lib/compat/text-node-merging-fix', ['exports'], function (exports) {
    // Patch:    Adjacent text node merging fix
    // Browsers: IE, Edge, Firefox w/o inspector open
    // Reason:   These browsers will merge adjacent text nodes. For exmaple given
    //           <div>Hello</div> with div.insertAdjacentHTML(' world') browsers
    //           with proper behavior will populate div.childNodes with two items.
    //           These browsers will populate it with one merged node instead.
    // Fix:      Add these nodes to a wrapper element, then iterate the childNodes
    //           of that wrapper and move the nodes to their target location. Note
    //           that potential SVG bugs will have been handled before this fix.
    //           Note that this fix must only apply to the previous text node, as
    //           the base implementation of `insertHTMLBefore` already handles
    //           following text nodes correctly.
    'use strict';

    exports.domChanges = domChanges;
    exports.treeConstruction = treeConstruction;

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function domChanges(document, DOMChangesClass) {
        if (!document) return DOMChangesClass;
        if (!shouldApplyFix(document)) {
            return DOMChangesClass;
        }
        return (function (_DOMChangesClass) {
            _inherits(DOMChangesWithTextNodeMergingFix, _DOMChangesClass);

            function DOMChangesWithTextNodeMergingFix(document) {
                _classCallCheck(this, DOMChangesWithTextNodeMergingFix);

                _DOMChangesClass.call(this, document);
                this.uselessComment = document.createComment('');
            }

            DOMChangesWithTextNodeMergingFix.prototype.insertHTMLBefore = function insertHTMLBefore(parent, nextSibling, html) {
                if (html === null) {
                    return _DOMChangesClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
                }
                var didSetUselessComment = false;
                var nextPrevious = nextSibling ? nextSibling.previousSibling : parent.lastChild;
                if (nextPrevious && nextPrevious instanceof Text) {
                    didSetUselessComment = true;
                    parent.insertBefore(this.uselessComment, nextSibling);
                }
                var bounds = _DOMChangesClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
                if (didSetUselessComment) {
                    parent.removeChild(this.uselessComment);
                }
                return bounds;
            };

            return DOMChangesWithTextNodeMergingFix;
        })(DOMChangesClass);
    }

    function treeConstruction(document, TreeConstructionClass) {
        if (!document) return TreeConstructionClass;
        if (!shouldApplyFix(document)) {
            return TreeConstructionClass;
        }
        return (function (_TreeConstructionClass) {
            _inherits(TreeConstructionWithTextNodeMergingFix, _TreeConstructionClass);

            function TreeConstructionWithTextNodeMergingFix(document) {
                _classCallCheck(this, TreeConstructionWithTextNodeMergingFix);

                _TreeConstructionClass.call(this, document);
                this.uselessComment = this.createComment('');
            }

            TreeConstructionWithTextNodeMergingFix.prototype.insertHTMLBefore = function insertHTMLBefore(parent, html, reference) {
                if (html === null) {
                    return _TreeConstructionClass.prototype.insertHTMLBefore.call(this, parent, html, reference);
                }
                var didSetUselessComment = false;
                var nextPrevious = reference ? reference.previousSibling : parent.lastChild;
                if (nextPrevious && nextPrevious instanceof Text) {
                    didSetUselessComment = true;
                    parent.insertBefore(this.uselessComment, reference);
                }
                var bounds = _TreeConstructionClass.prototype.insertHTMLBefore.call(this, parent, html, reference);
                if (didSetUselessComment) {
                    parent.removeChild(this.uselessComment);
                }
                return bounds;
            };

            return TreeConstructionWithTextNodeMergingFix;
        })(TreeConstructionClass);
    }

    function shouldApplyFix(document) {
        var mergingTextDiv = document.createElement('div');
        mergingTextDiv.innerHTML = 'first';
        mergingTextDiv.insertAdjacentHTML('beforeEnd', 'second');
        if (mergingTextDiv.childNodes.length === 2) {
            // It worked as expected, no fix required
            return false;
        }
        return true;
    }
});

enifed("@glimmer/runtime/lib/compiled/blocks", ["exports"], function (exports) {
    "use strict";

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var CompiledBlock = function CompiledBlock(slice) {
        _classCallCheck(this, CompiledBlock);

        this.start = slice[0];
        this.end = slice[1];
        this.slice = slice;
    };

    exports.CompiledBlock = CompiledBlock;

    var CompiledProgram = (function (_CompiledBlock) {
        _inherits(CompiledProgram, _CompiledBlock);

        function CompiledProgram(slice, symbols) {
            _classCallCheck(this, CompiledProgram);

            _CompiledBlock.call(this, slice);
            this.symbols = symbols;
        }

        return CompiledProgram;
    })(CompiledBlock);

    exports.CompiledProgram = CompiledProgram;
});

enifed('@glimmer/runtime/lib/compiled/expressions', ['exports', '@glimmer/runtime/lib/compiled/expressions/args'], function (exports, _glimmerRuntimeLibCompiledExpressionsArgs) {
    'use strict';

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    exports.CompiledArgs = _glimmerRuntimeLibCompiledExpressionsArgs.CompiledArgs;

    var CompiledExpression = (function () {
        function CompiledExpression() {
            _classCallCheck(this, CompiledExpression);
        }

        CompiledExpression.prototype.toJSON = function toJSON() {
            return 'UNIMPL: ' + this.type.toUpperCase();
        };

        return CompiledExpression;
    })();

    exports.CompiledExpression = CompiledExpression;
});

enifed('@glimmer/runtime/lib/compiled/expressions/args', ['exports', '@glimmer/runtime/lib/compiled/expressions/positional-args', '@glimmer/runtime/lib/compiled/expressions/named-args', '@glimmer/reference'], function (exports, _glimmerRuntimeLibCompiledExpressionsPositionalArgs, _glimmerRuntimeLibCompiledExpressionsNamedArgs, _glimmerReference) {
    'use strict';

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    exports.COMPILED_EMPTY_POSITIONAL_ARGS = _glimmerRuntimeLibCompiledExpressionsPositionalArgs.COMPILED_EMPTY_POSITIONAL_ARGS;
    exports.COMPILED_EMPTY_NAMED_ARGS = _glimmerRuntimeLibCompiledExpressionsNamedArgs.COMPILED_EMPTY_NAMED_ARGS;
    var EMPTY_BLOCKS = {
        default: null,
        inverse: null
    };
    exports.EMPTY_BLOCKS = EMPTY_BLOCKS;

    var CompiledArgs = (function () {
        function CompiledArgs(positional, named, blocks) {
            _classCallCheck(this, CompiledArgs);

            this.positional = positional;
            this.named = named;
            this.blocks = blocks;
            this.type = "compiled-args";
        }

        CompiledArgs.create = function create(positional, named, blocks) {
            if (positional === _glimmerRuntimeLibCompiledExpressionsPositionalArgs.COMPILED_EMPTY_POSITIONAL_ARGS && named === _glimmerRuntimeLibCompiledExpressionsNamedArgs.COMPILED_EMPTY_NAMED_ARGS && blocks === EMPTY_BLOCKS) {
                return this.empty();
            } else {
                return new this(positional, named, blocks);
            }
        };

        CompiledArgs.empty = function empty() {
            return COMPILED_EMPTY_ARGS;
        };

        CompiledArgs.prototype.evaluate = function evaluate(vm) {
            var positional = this.positional;
            var named = this.named;
            var blocks = this.blocks;

            return EvaluatedArgs.create(positional.evaluate(vm), named.evaluate(vm), blocks);
        };

        return CompiledArgs;
    })();

    exports.CompiledArgs = CompiledArgs;
    var COMPILED_EMPTY_ARGS = new ((function (_CompiledArgs) {
        _inherits(_class, _CompiledArgs);

        function _class() {
            _classCallCheck(this, _class);

            _CompiledArgs.call(this, _glimmerRuntimeLibCompiledExpressionsPositionalArgs.COMPILED_EMPTY_POSITIONAL_ARGS, _glimmerRuntimeLibCompiledExpressionsNamedArgs.COMPILED_EMPTY_NAMED_ARGS, EMPTY_BLOCKS);
        }

        _class.prototype.evaluate = function evaluate(_vm) {
            return EMPTY_EVALUATED_ARGS;
        };

        return _class;
    })(CompiledArgs))();
    exports.COMPILED_EMPTY_ARGS = COMPILED_EMPTY_ARGS;

    var EvaluatedArgs = (function () {
        function EvaluatedArgs(positional, named, blocks) {
            _classCallCheck(this, EvaluatedArgs);

            this.positional = positional;
            this.named = named;
            this.blocks = blocks;
            this.tag = _glimmerReference.combineTagged([positional, named]);
        }

        EvaluatedArgs.empty = function empty() {
            return EMPTY_EVALUATED_ARGS;
        };

        EvaluatedArgs.create = function create(positional, named, blocks) {
            return new this(positional, named, blocks);
        };

        EvaluatedArgs.positional = function positional(values) {
            var blocks = arguments.length <= 1 || arguments[1] === undefined ? EMPTY_BLOCKS : arguments[1];

            return new this(_glimmerRuntimeLibCompiledExpressionsPositionalArgs.EvaluatedPositionalArgs.create(values), _glimmerRuntimeLibCompiledExpressionsNamedArgs.EVALUATED_EMPTY_NAMED_ARGS, blocks);
        };

        EvaluatedArgs.named = function named(map) {
            var blocks = arguments.length <= 1 || arguments[1] === undefined ? EMPTY_BLOCKS : arguments[1];

            return new this(_glimmerRuntimeLibCompiledExpressionsPositionalArgs.EVALUATED_EMPTY_POSITIONAL_ARGS, _glimmerRuntimeLibCompiledExpressionsNamedArgs.EvaluatedNamedArgs.create(map), blocks);
        };

        return EvaluatedArgs;
    })();

    exports.EvaluatedArgs = EvaluatedArgs;

    var EMPTY_EVALUATED_ARGS = new EvaluatedArgs(_glimmerRuntimeLibCompiledExpressionsPositionalArgs.EVALUATED_EMPTY_POSITIONAL_ARGS, _glimmerRuntimeLibCompiledExpressionsNamedArgs.EVALUATED_EMPTY_NAMED_ARGS, EMPTY_BLOCKS);
    exports.CompiledPositionalArgs = _glimmerRuntimeLibCompiledExpressionsPositionalArgs.CompiledPositionalArgs;
    exports.EvaluatedPositionalArgs = _glimmerRuntimeLibCompiledExpressionsPositionalArgs.EvaluatedPositionalArgs;
    exports.CompiledNamedArgs = _glimmerRuntimeLibCompiledExpressionsNamedArgs.CompiledNamedArgs;
    exports.EvaluatedNamedArgs = _glimmerRuntimeLibCompiledExpressionsNamedArgs.EvaluatedNamedArgs;
});

enifed("@glimmer/runtime/lib/compiled/expressions/concat", ["exports", "@glimmer/reference"], function (exports, _glimmerReference) {
    "use strict";

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var CompiledConcat = (function () {
        function CompiledConcat(parts) {
            _classCallCheck(this, CompiledConcat);

            this.parts = parts;
            this.type = "concat";
        }

        CompiledConcat.prototype.evaluate = function evaluate(vm) {
            var parts = new Array(this.parts.length);
            for (var i = 0; i < this.parts.length; i++) {
                parts[i] = this.parts[i].evaluate(vm);
            }
            return new ConcatReference(parts);
        };

        CompiledConcat.prototype.toJSON = function toJSON() {
            return "concat(" + this.parts.map(function (expr) {
                return expr.toJSON();
            }).join(", ") + ")";
        };

        return CompiledConcat;
    })();

    exports.default = CompiledConcat;

    var ConcatReference = (function (_CachedReference) {
        _inherits(ConcatReference, _CachedReference);

        function ConcatReference(parts) {
            _classCallCheck(this, ConcatReference);

            _CachedReference.call(this);
            this.parts = parts;
            this.tag = _glimmerReference.combineTagged(parts);
        }

        ConcatReference.prototype.compute = function compute() {
            var parts = new Array();
            for (var i = 0; i < this.parts.length; i++) {
                var value = this.parts[i].value();
                if (value !== null && value !== undefined) {
                    parts[i] = castToString(value);
                }
            }
            if (parts.length > 0) {
                return parts.join('');
            }
            return null;
        };

        return ConcatReference;
    })(_glimmerReference.CachedReference);

    exports.ConcatReference = ConcatReference;

    function castToString(value) {
        if (typeof value['toString'] !== 'function') {
            return '';
        }
        return String(value);
    }
});

enifed("@glimmer/runtime/lib/compiled/expressions/function", ["exports", "@glimmer/runtime/lib/compiled/expressions"], function (exports, _glimmerRuntimeLibCompiledExpressions) {
    "use strict";

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    var CompiledFunctionExpression = (function (_CompiledExpression) {
        _inherits(CompiledFunctionExpression, _CompiledExpression);

        function CompiledFunctionExpression(func, symbolTable) {
            _classCallCheck(this, CompiledFunctionExpression);

            _CompiledExpression.call(this);
            this.func = func;
            this.symbolTable = symbolTable;
            this.type = "function";
            this.func = func;
        }

        CompiledFunctionExpression.prototype.evaluate = function evaluate(vm) {
            var func = this.func;
            var symbolTable = this.symbolTable;

            return func(vm, symbolTable);
        };

        CompiledFunctionExpression.prototype.toJSON = function toJSON() {
            var func = this.func;

            if (func.name) {
                return "`" + func.name + "(...)`";
            } else {
                return "`func(...)`";
            }
        };

        return CompiledFunctionExpression;
    })(_glimmerRuntimeLibCompiledExpressions.CompiledExpression);

    exports.CompiledFunctionExpression = CompiledFunctionExpression;
});

enifed('@glimmer/runtime/lib/compiled/expressions/has-block', ['exports', '@glimmer/runtime/lib/compiled/expressions', '@glimmer/runtime/lib/references'], function (exports, _glimmerRuntimeLibCompiledExpressions, _glimmerRuntimeLibReferences) {
    'use strict';

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    var CompiledHasBlock = (function (_CompiledExpression) {
        _inherits(CompiledHasBlock, _CompiledExpression);

        function CompiledHasBlock(inner) {
            _classCallCheck(this, CompiledHasBlock);

            _CompiledExpression.call(this);
            this.inner = inner;
            this.type = "has-block";
        }

        CompiledHasBlock.prototype.evaluate = function evaluate(vm) {
            var block = this.inner.evaluate(vm);
            return _glimmerRuntimeLibReferences.PrimitiveReference.create(!!block);
        };

        CompiledHasBlock.prototype.toJSON = function toJSON() {
            return 'has-block(' + this.inner.toJSON() + ')';
        };

        return CompiledHasBlock;
    })(_glimmerRuntimeLibCompiledExpressions.CompiledExpression);

    exports.default = CompiledHasBlock;

    var CompiledHasBlockParams = (function (_CompiledExpression2) {
        _inherits(CompiledHasBlockParams, _CompiledExpression2);

        function CompiledHasBlockParams(inner) {
            _classCallCheck(this, CompiledHasBlockParams);

            _CompiledExpression2.call(this);
            this.inner = inner;
            this.type = "has-block-params";
        }

        CompiledHasBlockParams.prototype.evaluate = function evaluate(vm) {
            var block = this.inner.evaluate(vm);
            var hasLocals = block && block.symbolTable.getSymbols().locals;
            return _glimmerRuntimeLibReferences.PrimitiveReference.create(!!hasLocals);
        };

        CompiledHasBlockParams.prototype.toJSON = function toJSON() {
            return 'has-block-params(' + this.inner.toJSON() + ')';
        };

        return CompiledHasBlockParams;
    })(_glimmerRuntimeLibCompiledExpressions.CompiledExpression);

    exports.CompiledHasBlockParams = CompiledHasBlockParams;

    var CompiledGetBlockBySymbol = (function () {
        function CompiledGetBlockBySymbol(symbol, debug) {
            _classCallCheck(this, CompiledGetBlockBySymbol);

            this.symbol = symbol;
            this.debug = debug;
        }

        CompiledGetBlockBySymbol.prototype.evaluate = function evaluate(vm) {
            return vm.scope().getBlock(this.symbol);
        };

        CompiledGetBlockBySymbol.prototype.toJSON = function toJSON() {
            return 'get-block($' + this.symbol + '(' + this.debug + '))';
        };

        return CompiledGetBlockBySymbol;
    })();

    exports.CompiledGetBlockBySymbol = CompiledGetBlockBySymbol;

    var CompiledInPartialGetBlock = (function () {
        function CompiledInPartialGetBlock(symbol, name) {
            _classCallCheck(this, CompiledInPartialGetBlock);

            this.symbol = symbol;
            this.name = name;
        }

        CompiledInPartialGetBlock.prototype.evaluate = function evaluate(vm) {
            var symbol = this.symbol;
            var name = this.name;

            var args = vm.scope().getPartialArgs(symbol);
            return args.blocks[name];
        };

        CompiledInPartialGetBlock.prototype.toJSON = function toJSON() {
            return 'get-block($' + this.symbol + '($ARGS).' + this.name + '))';
        };

        return CompiledInPartialGetBlock;
    })();

    exports.CompiledInPartialGetBlock = CompiledInPartialGetBlock;
});

enifed('@glimmer/runtime/lib/compiled/expressions/helper', ['exports', '@glimmer/runtime/lib/compiled/expressions'], function (exports, _glimmerRuntimeLibCompiledExpressions) {
    'use strict';

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    var CompiledHelper = (function (_CompiledExpression) {
        _inherits(CompiledHelper, _CompiledExpression);

        function CompiledHelper(name, helper, args, symbolTable) {
            _classCallCheck(this, CompiledHelper);

            _CompiledExpression.call(this);
            this.name = name;
            this.helper = helper;
            this.args = args;
            this.symbolTable = symbolTable;
            this.type = "helper";
        }

        CompiledHelper.prototype.evaluate = function evaluate(vm) {
            var helper = this.helper;

            return helper(vm, this.args.evaluate(vm), this.symbolTable);
        };

        CompiledHelper.prototype.toJSON = function toJSON() {
            return '`' + this.name.join('.') + '($ARGS)`';
        };

        return CompiledHelper;
    })(_glimmerRuntimeLibCompiledExpressions.CompiledExpression);

    exports.default = CompiledHelper;
});

enifed('@glimmer/runtime/lib/compiled/expressions/lookups', ['exports', '@glimmer/runtime/lib/compiled/expressions', '@glimmer/reference'], function (exports, _glimmerRuntimeLibCompiledExpressions, _glimmerReference) {
    'use strict';

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    var CompiledLookup = (function (_CompiledExpression) {
        _inherits(CompiledLookup, _CompiledExpression);

        function CompiledLookup(base, path) {
            _classCallCheck(this, CompiledLookup);

            _CompiledExpression.call(this);
            this.base = base;
            this.path = path;
            this.type = "lookup";
        }

        CompiledLookup.create = function create(base, path) {
            if (path.length === 0) {
                return base;
            } else {
                return new this(base, path);
            }
        };

        CompiledLookup.prototype.evaluate = function evaluate(vm) {
            var base = this.base;
            var path = this.path;

            return _glimmerReference.referenceFromParts(base.evaluate(vm), path);
        };

        CompiledLookup.prototype.toJSON = function toJSON() {
            return this.base.toJSON() + '.' + this.path.join('.');
        };

        return CompiledLookup;
    })(_glimmerRuntimeLibCompiledExpressions.CompiledExpression);

    exports.default = CompiledLookup;

    var CompiledSelf = (function (_CompiledExpression2) {
        _inherits(CompiledSelf, _CompiledExpression2);

        function CompiledSelf() {
            _classCallCheck(this, CompiledSelf);

            _CompiledExpression2.apply(this, arguments);
        }

        CompiledSelf.prototype.evaluate = function evaluate(vm) {
            return vm.getSelf();
        };

        CompiledSelf.prototype.toJSON = function toJSON() {
            return 'self';
        };

        return CompiledSelf;
    })(_glimmerRuntimeLibCompiledExpressions.CompiledExpression);

    exports.CompiledSelf = CompiledSelf;

    var CompiledSymbol = (function (_CompiledExpression3) {
        _inherits(CompiledSymbol, _CompiledExpression3);

        function CompiledSymbol(symbol, debug) {
            _classCallCheck(this, CompiledSymbol);

            _CompiledExpression3.call(this);
            this.symbol = symbol;
            this.debug = debug;
        }

        CompiledSymbol.prototype.evaluate = function evaluate(vm) {
            return vm.referenceForSymbol(this.symbol);
        };

        CompiledSymbol.prototype.toJSON = function toJSON() {
            return '$' + this.symbol + '(' + this.debug + ')';
        };

        return CompiledSymbol;
    })(_glimmerRuntimeLibCompiledExpressions.CompiledExpression);

    exports.CompiledSymbol = CompiledSymbol;

    var CompiledInPartialName = (function (_CompiledExpression4) {
        _inherits(CompiledInPartialName, _CompiledExpression4);

        function CompiledInPartialName(symbol, name) {
            _classCallCheck(this, CompiledInPartialName);

            _CompiledExpression4.call(this);
            this.symbol = symbol;
            this.name = name;
        }

        CompiledInPartialName.prototype.evaluate = function evaluate(vm) {
            var symbol = this.symbol;
            var name = this.name;

            var args = vm.scope().getPartialArgs(symbol);
            return args.named.get(name);
        };

        CompiledInPartialName.prototype.toJSON = function toJSON() {
            return '$' + this.symbol + '($ARGS).' + this.name;
        };

        return CompiledInPartialName;
    })(_glimmerRuntimeLibCompiledExpressions.CompiledExpression);

    exports.CompiledInPartialName = CompiledInPartialName;
});

enifed('@glimmer/runtime/lib/compiled/expressions/named-args', ['exports', '@glimmer/runtime/lib/references', '@glimmer/runtime/lib/utils', '@glimmer/reference', '@glimmer/util'], function (exports, _glimmerRuntimeLibReferences, _glimmerRuntimeLibUtils, _glimmerReference, _glimmerUtil) {
    'use strict';

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var CompiledNamedArgs = (function () {
        function CompiledNamedArgs(keys, values) {
            _classCallCheck(this, CompiledNamedArgs);

            this.keys = keys;
            this.values = values;
            this.length = keys.length;
            _glimmerUtil.assert(keys.length === values.length, 'Keys and values do not have the same length');
        }

        CompiledNamedArgs.empty = function empty() {
            return COMPILED_EMPTY_NAMED_ARGS;
        };

        CompiledNamedArgs.create = function create(map) {
            var keys = Object.keys(map);
            var length = keys.length;
            if (length > 0) {
                var values = [];
                for (var i = 0; i < length; i++) {
                    values[i] = map[keys[i]];
                }
                return new this(keys, values);
            } else {
                return COMPILED_EMPTY_NAMED_ARGS;
            }
        };

        CompiledNamedArgs.prototype.evaluate = function evaluate(vm) {
            var keys = this.keys;
            var values = this.values;
            var length = this.length;

            var evaluated = new Array(length);
            for (var i = 0; i < length; i++) {
                evaluated[i] = values[i].evaluate(vm);
            }
            return new EvaluatedNamedArgs(keys, evaluated);
        };

        CompiledNamedArgs.prototype.toJSON = function toJSON() {
            var keys = this.keys;
            var values = this.values;

            var inner = keys.map(function (key, i) {
                return key + ': ' + values[i].toJSON();
            }).join(", ");
            return '{' + inner + '}';
        };

        return CompiledNamedArgs;
    })();

    exports.CompiledNamedArgs = CompiledNamedArgs;
    var COMPILED_EMPTY_NAMED_ARGS = new ((function (_CompiledNamedArgs) {
        _inherits(_class, _CompiledNamedArgs);

        function _class() {
            _classCallCheck(this, _class);

            _CompiledNamedArgs.call(this, _glimmerRuntimeLibUtils.EMPTY_ARRAY, _glimmerRuntimeLibUtils.EMPTY_ARRAY);
        }

        _class.prototype.evaluate = function evaluate(_vm) {
            return EVALUATED_EMPTY_NAMED_ARGS;
        };

        _class.prototype.toJSON = function toJSON() {
            return '<EMPTY>';
        };

        return _class;
    })(CompiledNamedArgs))();
    exports.COMPILED_EMPTY_NAMED_ARGS = COMPILED_EMPTY_NAMED_ARGS;

    var EvaluatedNamedArgs = (function () {
        function EvaluatedNamedArgs(keys, values) {
            var _map = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

            _classCallCheck(this, EvaluatedNamedArgs);

            this.keys = keys;
            this.values = values;
            this._map = _map;
            this.tag = _glimmerReference.combineTagged(values);
            this.length = keys.length;
            _glimmerUtil.assert(keys.length === values.length, 'Keys and values do not have the same length');
        }

        EvaluatedNamedArgs.create = function create(map) {
            var keys = Object.keys(map);
            var length = keys.length;
            if (length > 0) {
                var values = new Array(length);
                for (var i = 0; i < length; i++) {
                    values[i] = map[keys[i]];
                }
                return new this(keys, values, map);
            } else {
                return EVALUATED_EMPTY_NAMED_ARGS;
            }
        };

        EvaluatedNamedArgs.empty = function empty() {
            return EVALUATED_EMPTY_NAMED_ARGS;
        };

        EvaluatedNamedArgs.prototype.get = function get(key) {
            var keys = this.keys;
            var values = this.values;

            var index = keys.indexOf(key);
            return index === -1 ? _glimmerRuntimeLibReferences.UNDEFINED_REFERENCE : values[index];
        };

        EvaluatedNamedArgs.prototype.has = function has(key) {
            return this.keys.indexOf(key) !== -1;
        };

        EvaluatedNamedArgs.prototype.value = function value() {
            var keys = this.keys;
            var values = this.values;

            var out = _glimmerUtil.dict();
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var ref = values[i];
                out[key] = ref.value();
            }
            return out;
        };

        _createClass(EvaluatedNamedArgs, [{
            key: 'map',
            get: function () {
                var map = this._map;

                if (map) {
                    return map;
                }
                map = this._map = _glimmerUtil.dict();
                var keys = this.keys;
                var values = this.values;
                var length = this.length;

                for (var i = 0; i < length; i++) {
                    map[keys[i]] = values[i];
                }
                return map;
            }
        }]);

        return EvaluatedNamedArgs;
    })();

    exports.EvaluatedNamedArgs = EvaluatedNamedArgs;
    var EVALUATED_EMPTY_NAMED_ARGS = new ((function (_EvaluatedNamedArgs) {
        _inherits(_class2, _EvaluatedNamedArgs);

        function _class2() {
            _classCallCheck(this, _class2);

            _EvaluatedNamedArgs.call(this, _glimmerRuntimeLibUtils.EMPTY_ARRAY, _glimmerRuntimeLibUtils.EMPTY_ARRAY, _glimmerRuntimeLibUtils.EMPTY_DICT);
        }

        _class2.prototype.get = function get() {
            return _glimmerRuntimeLibReferences.UNDEFINED_REFERENCE;
        };

        _class2.prototype.has = function has(_key) {
            return false;
        };

        _class2.prototype.value = function value() {
            return _glimmerRuntimeLibUtils.EMPTY_DICT;
        };

        return _class2;
    })(EvaluatedNamedArgs))();
    exports.EVALUATED_EMPTY_NAMED_ARGS = EVALUATED_EMPTY_NAMED_ARGS;
});

enifed('@glimmer/runtime/lib/compiled/expressions/positional-args', ['exports', '@glimmer/runtime/lib/references', '@glimmer/runtime/lib/utils', '@glimmer/reference'], function (exports, _glimmerRuntimeLibReferences, _glimmerRuntimeLibUtils, _glimmerReference) {
    'use strict';

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var CompiledPositionalArgs = (function () {
        function CompiledPositionalArgs(values) {
            _classCallCheck(this, CompiledPositionalArgs);

            this.values = values;
            this.length = values.length;
        }

        CompiledPositionalArgs.create = function create(values) {
            if (values.length) {
                return new this(values);
            } else {
                return COMPILED_EMPTY_POSITIONAL_ARGS;
            }
        };

        CompiledPositionalArgs.empty = function empty() {
            return COMPILED_EMPTY_POSITIONAL_ARGS;
        };

        CompiledPositionalArgs.prototype.evaluate = function evaluate(vm) {
            var values = this.values;
            var length = this.length;

            var references = new Array(length);
            for (var i = 0; i < length; i++) {
                references[i] = values[i].evaluate(vm);
            }
            return EvaluatedPositionalArgs.create(references);
        };

        CompiledPositionalArgs.prototype.toJSON = function toJSON() {
            return '[' + this.values.map(function (value) {
                return value.toJSON();
            }).join(", ") + ']';
        };

        return CompiledPositionalArgs;
    })();

    exports.CompiledPositionalArgs = CompiledPositionalArgs;
    var COMPILED_EMPTY_POSITIONAL_ARGS = new ((function (_CompiledPositionalArgs) {
        _inherits(_class, _CompiledPositionalArgs);

        function _class() {
            _classCallCheck(this, _class);

            _CompiledPositionalArgs.call(this, _glimmerRuntimeLibUtils.EMPTY_ARRAY);
        }

        _class.prototype.evaluate = function evaluate(_vm) {
            return EVALUATED_EMPTY_POSITIONAL_ARGS;
        };

        _class.prototype.toJSON = function toJSON() {
            return '<EMPTY>';
        };

        return _class;
    })(CompiledPositionalArgs))();
    exports.COMPILED_EMPTY_POSITIONAL_ARGS = COMPILED_EMPTY_POSITIONAL_ARGS;

    var EvaluatedPositionalArgs = (function () {
        function EvaluatedPositionalArgs(values) {
            _classCallCheck(this, EvaluatedPositionalArgs);

            this.values = values;
            this.tag = _glimmerReference.combineTagged(values);
            this.length = values.length;
        }

        EvaluatedPositionalArgs.create = function create(values) {
            return new this(values);
        };

        EvaluatedPositionalArgs.empty = function empty() {
            return EVALUATED_EMPTY_POSITIONAL_ARGS;
        };

        EvaluatedPositionalArgs.prototype.at = function at(index) {
            var values = this.values;
            var length = this.length;

            return index < length ? values[index] : _glimmerRuntimeLibReferences.UNDEFINED_REFERENCE;
        };

        EvaluatedPositionalArgs.prototype.value = function value() {
            var values = this.values;
            var length = this.length;

            var ret = new Array(length);
            for (var i = 0; i < length; i++) {
                ret[i] = values[i].value();
            }
            return ret;
        };

        return EvaluatedPositionalArgs;
    })();

    exports.EvaluatedPositionalArgs = EvaluatedPositionalArgs;
    var EVALUATED_EMPTY_POSITIONAL_ARGS = new ((function (_EvaluatedPositionalArgs) {
        _inherits(_class2, _EvaluatedPositionalArgs);

        function _class2() {
            _classCallCheck(this, _class2);

            _EvaluatedPositionalArgs.call(this, _glimmerRuntimeLibUtils.EMPTY_ARRAY);
        }

        _class2.prototype.at = function at() {
            return _glimmerRuntimeLibReferences.UNDEFINED_REFERENCE;
        };

        _class2.prototype.value = function value() {
            return this.values;
        };

        return _class2;
    })(EvaluatedPositionalArgs))();
    exports.EVALUATED_EMPTY_POSITIONAL_ARGS = EVALUATED_EMPTY_POSITIONAL_ARGS;
});

enifed('@glimmer/runtime/lib/compiled/expressions/value', ['exports', '@glimmer/runtime/lib/compiled/expressions', '@glimmer/runtime/lib/references'], function (exports, _glimmerRuntimeLibCompiledExpressions, _glimmerRuntimeLibReferences) {
    'use strict';

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    var CompiledValue = (function (_CompiledExpression) {
        _inherits(CompiledValue, _CompiledExpression);

        function CompiledValue(value) {
            _classCallCheck(this, CompiledValue);

            _CompiledExpression.call(this);
            this.type = "value";
            this.reference = _glimmerRuntimeLibReferences.PrimitiveReference.create(value);
        }

        CompiledValue.prototype.evaluate = function evaluate(_vm) {
            return this.reference;
        };

        CompiledValue.prototype.toJSON = function toJSON() {
            return JSON.stringify(this.reference.value());
        };

        return CompiledValue;
    })(_glimmerRuntimeLibCompiledExpressions.CompiledExpression);

    exports.default = CompiledValue;
});

enifed('@glimmer/runtime/lib/compiled/opcodes/blocks', ['exports', '@glimmer/runtime/lib/opcodes'], function (exports, _glimmerRuntimeLibOpcodes) {
    'use strict';

    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.OpenBlock, function (vm, _ref) {
        var _getBlock = _ref.op1;
        var _args = _ref.op2;

        var inner = vm.constants.getOther(_getBlock);
        var rawArgs = vm.constants.getExpression(_args);
        var args = null;
        var block = inner.evaluate(vm);
        if (block) {
            args = rawArgs.evaluate(vm);
        }
        // FIXME: can we avoid doing this when we don't have a block?
        vm.pushCallerScope();
        if (block) {
            vm.invokeBlock(block, args || null);
        }
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.CloseBlock, function (vm) {
        return vm.popScope();
    });
});

enifed('@glimmer/runtime/lib/compiled/opcodes/builder', ['exports', '@glimmer/runtime/lib/compiled/opcodes/content', '@glimmer/runtime/lib/compiled/opcodes/vm', '@glimmer/runtime/lib/compiled/expressions/has-block', '@glimmer/util', '@glimmer/runtime/lib/syntax/functions', '@glimmer/runtime/lib/compiled/expressions', '@glimmer/runtime/lib/compiler', '@glimmer/runtime/lib/opcodes'], function (exports, _glimmerRuntimeLibCompiledOpcodesContent, _glimmerRuntimeLibCompiledOpcodesVm, _glimmerRuntimeLibCompiledExpressionsHasBlock, _glimmerUtil, _glimmerRuntimeLibSyntaxFunctions, _glimmerRuntimeLibCompiledExpressions, _glimmerRuntimeLibCompiler, _glimmerRuntimeLibOpcodes) {
    'use strict';

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function appendOpcode(name, op1, op2, op3) {
        return _glimmerRuntimeLibOpcodes.APPEND_OPCODES.construct(name, null, op1, op2, op3);
    }

    var Labels = (function () {
        function Labels() {
            _classCallCheck(this, Labels);

            this.labels = _glimmerUtil.dict();
            this.jumps = [];
            this.ranges = [];
        }

        Labels.prototype.label = function label(name, index) {
            this.labels[name] = index;
        };

        Labels.prototype.jump = function jump(at, Target, target) {
            this.jumps.push({ at: at, target: target, Target: Target });
        };

        Labels.prototype.range = function range(at, Range, start, end) {
            this.ranges.push({ at: at, start: start, end: end, Range: Range });
        };

        Labels.prototype.patch = function patch(constants, opcodes) {
            for (var i = 0; i < this.jumps.length; i++) {
                var _jumps$i = this.jumps[i];
                var at = _jumps$i.at;
                var target = _jumps$i.target;
                var Target = _jumps$i.Target;

                opcodes.set(at, _glimmerRuntimeLibOpcodes.APPEND_OPCODES.construct(Target, null, this.labels[target]));
            }
            for (var i = 0; i < this.ranges.length; i++) {
                var _ranges$i = this.ranges[i];
                var at = _ranges$i.at;
                var start = _ranges$i.start;
                var end = _ranges$i.end;
                var _Range = _ranges$i.Range;

                var slice = constants.slice([this.labels[start], this.labels[end] - 1]);
                opcodes.set(at, _glimmerRuntimeLibOpcodes.APPEND_OPCODES.construct(_Range, null, slice));
            }
        };

        return Labels;
    })();

    var BasicOpcodeBuilder = (function () {
        function BasicOpcodeBuilder(symbolTable, env, program) {
            _classCallCheck(this, BasicOpcodeBuilder);

            this.symbolTable = symbolTable;
            this.env = env;
            this.program = program;
            this.labelsStack = new _glimmerUtil.Stack();
            this.constants = env.constants;
            this.start = program.next;
        }

        BasicOpcodeBuilder.prototype.opcode = function opcode(name, op1, op2, op3) {
            this.push(appendOpcode(name, op1, op2, op3));
        };

        BasicOpcodeBuilder.prototype.push = function push(op) {
            // console.log(`pushing ${op && op.type}`);
            if (op === null) {
                this.program.push([0, 0, 0, 0]);
            } else {
                this.program.push(op);
            }
        };

        BasicOpcodeBuilder.prototype.toSlice = function toSlice() {
            return [this.start, this.program.current];
        };

        // helpers

        BasicOpcodeBuilder.prototype.startLabels = function startLabels() {
            this.labelsStack.push(new Labels());
        };

        BasicOpcodeBuilder.prototype.stopLabels = function stopLabels() {
            var label = _glimmerUtil.expect(this.labelsStack.pop(), 'unbalanced push and pop labels');
            label.patch(this.constants, this.program);
        };

        // partials

        BasicOpcodeBuilder.prototype.putPartialDefinition = function putPartialDefinition(_definition) {
            var definition = this.constants.other(_definition);
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.PutPartial, definition);
        };

        BasicOpcodeBuilder.prototype.putDynamicPartialDefinition = function putDynamicPartialDefinition() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.PutDynamicPartial, this.constants.other(this.symbolTable));
        };

        BasicOpcodeBuilder.prototype.evaluatePartial = function evaluatePartial() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.EvaluatePartial, this.constants.other(this.symbolTable), this.constants.other(_glimmerUtil.dict()));
        };

        // components

        BasicOpcodeBuilder.prototype.putComponentDefinition = function putComponentDefinition(definition) {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.PutComponent, this.other(definition));
        };

        BasicOpcodeBuilder.prototype.putDynamicComponentDefinition = function putDynamicComponentDefinition() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.PutDynamicComponent);
        };

        BasicOpcodeBuilder.prototype.openComponent = function openComponent(args, shadow) {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.OpenComponent, this.args(args), shadow ? this.block(shadow) : 0);
        };

        BasicOpcodeBuilder.prototype.didCreateElement = function didCreateElement() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.DidCreateElement);
        };

        BasicOpcodeBuilder.prototype.shadowAttributes = function shadowAttributes() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.ShadowAttributes);
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.CloseBlock);
        };

        BasicOpcodeBuilder.prototype.didRenderLayout = function didRenderLayout() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.DidRenderLayout);
        };

        BasicOpcodeBuilder.prototype.closeComponent = function closeComponent() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.CloseComponent);
        };

        // content

        BasicOpcodeBuilder.prototype.dynamicContent = function dynamicContent(Opcode) {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.DynamicContent, this.other(Opcode));
        };

        BasicOpcodeBuilder.prototype.cautiousAppend = function cautiousAppend() {
            this.dynamicContent(new _glimmerRuntimeLibCompiledOpcodesContent.OptimizedCautiousAppendOpcode());
        };

        BasicOpcodeBuilder.prototype.trustingAppend = function trustingAppend() {
            this.dynamicContent(new _glimmerRuntimeLibCompiledOpcodesContent.OptimizedTrustingAppendOpcode());
        };

        BasicOpcodeBuilder.prototype.guardedCautiousAppend = function guardedCautiousAppend(expression) {
            this.dynamicContent(new _glimmerRuntimeLibCompiledOpcodesContent.GuardedCautiousAppendOpcode(this.compileExpression(expression), this.symbolTable));
        };

        BasicOpcodeBuilder.prototype.guardedTrustingAppend = function guardedTrustingAppend(expression) {
            this.dynamicContent(new _glimmerRuntimeLibCompiledOpcodesContent.GuardedTrustingAppendOpcode(this.compileExpression(expression), this.symbolTable));
        };

        // dom

        BasicOpcodeBuilder.prototype.text = function text(_text) {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.Text, this.constants.string(_text));
        };

        BasicOpcodeBuilder.prototype.openPrimitiveElement = function openPrimitiveElement(tag) {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.OpenElement, this.constants.string(tag));
        };

        BasicOpcodeBuilder.prototype.openComponentElement = function openComponentElement(tag) {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.OpenComponentElement, this.constants.string(tag));
        };

        BasicOpcodeBuilder.prototype.openDynamicPrimitiveElement = function openDynamicPrimitiveElement() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.OpenDynamicElement);
        };

        BasicOpcodeBuilder.prototype.flushElement = function flushElement() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.FlushElement);
        };

        BasicOpcodeBuilder.prototype.closeElement = function closeElement() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.CloseElement);
        };

        BasicOpcodeBuilder.prototype.staticAttr = function staticAttr(_name, _namespace, _value) {
            var name = this.constants.string(_name);
            var namespace = _namespace ? this.constants.string(_namespace) : 0;
            var value = this.constants.string(_value);
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.StaticAttr, name, value, namespace);
        };

        BasicOpcodeBuilder.prototype.dynamicAttrNS = function dynamicAttrNS(_name, _namespace, trusting) {
            var name = this.constants.string(_name);
            var namespace = this.constants.string(_namespace);
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.DynamicAttrNS, name, namespace, trusting | 0);
        };

        BasicOpcodeBuilder.prototype.dynamicAttr = function dynamicAttr(_name, trusting) {
            var name = this.constants.string(_name);
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.DynamicAttr, name, trusting | 0);
        };

        BasicOpcodeBuilder.prototype.comment = function comment(_comment) {
            var comment = this.constants.string(_comment);
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.Comment, comment);
        };

        BasicOpcodeBuilder.prototype.modifier = function modifier(_name, _args) {
            var args = this.constants.expression(this.compile(_args));
            var _modifierManager = this.env.lookupModifier([_name], this.symbolTable);
            var modifierManager = this.constants.other(_modifierManager);
            var name = this.constants.string(_name);
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.Modifier, name, modifierManager, args);
        };

        // lists

        BasicOpcodeBuilder.prototype.putIterator = function putIterator() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.PutIterator);
        };

        BasicOpcodeBuilder.prototype.enterList = function enterList(start, end) {
            this.push(null);
            this.labels.range(this.pos, _glimmerRuntimeLibOpcodes.OpcodeName.EnterList, start, end);
        };

        BasicOpcodeBuilder.prototype.exitList = function exitList() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.ExitList);
        };

        BasicOpcodeBuilder.prototype.enterWithKey = function enterWithKey(start, end) {
            this.push(null);
            this.labels.range(this.pos, _glimmerRuntimeLibOpcodes.OpcodeName.EnterWithKey, start, end);
        };

        BasicOpcodeBuilder.prototype.nextIter = function nextIter(end) {
            this.push(null);
            this.labels.jump(this.pos, _glimmerRuntimeLibOpcodes.OpcodeName.NextIter, end);
        };

        // vm

        BasicOpcodeBuilder.prototype.openBlock = function openBlock(_args, _inner) {
            var args = this.constants.expression(this.compile(_args));
            var inner = this.constants.other(_inner);
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.OpenBlock, inner, args);
        };

        BasicOpcodeBuilder.prototype.closeBlock = function closeBlock() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.CloseBlock);
        };

        BasicOpcodeBuilder.prototype.pushRemoteElement = function pushRemoteElement() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.PushRemoteElement);
        };

        BasicOpcodeBuilder.prototype.popRemoteElement = function popRemoteElement() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.PopRemoteElement);
        };

        BasicOpcodeBuilder.prototype.popElement = function popElement() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.PopElement);
        };

        BasicOpcodeBuilder.prototype.label = function label(name) {
            this.labels.label(name, this.nextPos);
        };

        BasicOpcodeBuilder.prototype.pushChildScope = function pushChildScope() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.PushChildScope);
        };

        BasicOpcodeBuilder.prototype.popScope = function popScope() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.PopScope);
        };

        BasicOpcodeBuilder.prototype.pushDynamicScope = function pushDynamicScope() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.PushDynamicScope);
        };

        BasicOpcodeBuilder.prototype.popDynamicScope = function popDynamicScope() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.PopDynamicScope);
        };

        BasicOpcodeBuilder.prototype.putNull = function putNull() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.Put, this.constants.NULL_REFERENCE);
        };

        BasicOpcodeBuilder.prototype.putValue = function putValue(_expression) {
            var expr = this.constants.expression(this.compileExpression(_expression));
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.EvaluatePut, expr);
        };

        BasicOpcodeBuilder.prototype.putArgs = function putArgs(_args) {
            var args = this.constants.expression(this.compile(_args));
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.PutArgs, args);
        };

        BasicOpcodeBuilder.prototype.bindDynamicScope = function bindDynamicScope(_names) {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.BindDynamicScope, this.names(_names));
        };

        BasicOpcodeBuilder.prototype.bindPositionalArgs = function bindPositionalArgs(_names, _symbols) {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.BindPositionalArgs, this.names(_names), this.symbols(_symbols));
        };

        BasicOpcodeBuilder.prototype.bindNamedArgs = function bindNamedArgs(_names, _symbols) {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.BindNamedArgs, this.names(_names), this.symbols(_symbols));
        };

        BasicOpcodeBuilder.prototype.bindBlocks = function bindBlocks(_names, _symbols) {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.BindBlocks, this.names(_names), this.symbols(_symbols));
        };

        BasicOpcodeBuilder.prototype.enter = function enter(_enter, exit) {
            this.push(null);
            this.labels.range(this.pos, _glimmerRuntimeLibOpcodes.OpcodeName.Enter, _enter, exit);
        };

        BasicOpcodeBuilder.prototype.exit = function exit() {
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.Exit);
        };

        BasicOpcodeBuilder.prototype.evaluate = function evaluate(_block) {
            var block = this.constants.block(_block);
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.Evaluate, block);
        };

        BasicOpcodeBuilder.prototype.test = function test(testFunc) {
            var _func = undefined;
            if (testFunc === 'const') {
                _func = _glimmerRuntimeLibCompiledOpcodesVm.ConstTest;
            } else if (testFunc === 'simple') {
                _func = _glimmerRuntimeLibCompiledOpcodesVm.SimpleTest;
            } else if (testFunc === 'environment') {
                _func = _glimmerRuntimeLibCompiledOpcodesVm.EnvironmentTest;
            } else if (typeof testFunc === 'function') {
                _func = testFunc;
            } else {
                throw new Error('unreachable');
            }
            var func = this.constants.function(_func);
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.Test, func);
        };

        BasicOpcodeBuilder.prototype.jump = function jump(target) {
            this.push(null);
            this.labels.jump(this.pos, _glimmerRuntimeLibOpcodes.OpcodeName.Jump, target);
        };

        BasicOpcodeBuilder.prototype.jumpIf = function jumpIf(target) {
            this.push(null);
            this.labels.jump(this.pos, _glimmerRuntimeLibOpcodes.OpcodeName.JumpIf, target);
        };

        BasicOpcodeBuilder.prototype.jumpUnless = function jumpUnless(target) {
            this.push(null);
            this.labels.jump(this.pos, _glimmerRuntimeLibOpcodes.OpcodeName.JumpUnless, target);
        };

        BasicOpcodeBuilder.prototype.names = function names(_names) {
            var _this = this;

            var names = _names.map(function (n) {
                return _this.constants.string(n);
            });
            return this.constants.array(names);
        };

        BasicOpcodeBuilder.prototype.symbols = function symbols(_symbols2) {
            return this.constants.array(_symbols2);
        };

        BasicOpcodeBuilder.prototype.other = function other(value) {
            return this.constants.other(value);
        };

        BasicOpcodeBuilder.prototype.args = function args(_args2) {
            return this.constants.expression(this.compile(_args2));
        };

        BasicOpcodeBuilder.prototype.block = function block(_block2) {
            return this.constants.block(_block2);
        };

        _createClass(BasicOpcodeBuilder, [{
            key: 'pos',
            get: function () {
                return this.program.current;
            }
        }, {
            key: 'nextPos',
            get: function () {
                return this.program.next;
            }
        }, {
            key: 'labels',
            get: function () {
                return _glimmerUtil.expect(this.labelsStack.current, 'bug: not in a label stack');
            }
        }]);

        return BasicOpcodeBuilder;
    })();

    exports.BasicOpcodeBuilder = BasicOpcodeBuilder;

    function isCompilableExpression(expr) {
        return expr && typeof expr['compile'] === 'function';
    }

    var OpcodeBuilder = (function (_BasicOpcodeBuilder) {
        _inherits(OpcodeBuilder, _BasicOpcodeBuilder);

        function OpcodeBuilder(symbolTable, env) {
            var program = arguments.length <= 2 || arguments[2] === undefined ? env.program : arguments[2];
            return (function () {
                _classCallCheck(this, OpcodeBuilder);

                _BasicOpcodeBuilder.call(this, symbolTable, env, program);
                this.component = new _glimmerRuntimeLibCompiler.ComponentBuilder(this);
            }).apply(this, arguments);
        }

        OpcodeBuilder.prototype.compile = function compile(expr) {
            if (isCompilableExpression(expr)) {
                return expr.compile(this);
            } else {
                return expr;
            }
        };

        OpcodeBuilder.prototype.compileExpression = function compileExpression(expression) {
            if (expression instanceof _glimmerRuntimeLibCompiledExpressions.CompiledExpression) {
                return expression;
            } else {
                return _glimmerRuntimeLibSyntaxFunctions.expr(expression, this);
            }
        };

        OpcodeBuilder.prototype.bindPositionalArgsForLocals = function bindPositionalArgsForLocals(locals) {
            var symbols = Object.keys(locals).map(function (name) {
                return locals[name];
            });
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.BindPositionalArgs, this.symbols(symbols));
        };

        OpcodeBuilder.prototype.preludeForLayout = function preludeForLayout(layout) {
            var _this2 = this;

            var symbols = layout.symbolTable.getSymbols();
            if (symbols.named) {
                (function () {
                    var named = symbols.named;
                    var namedNames = Object.keys(named);
                    var namedSymbols = namedNames.map(function (n) {
                        return named[n];
                    });
                    _this2.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.BindNamedArgs, _this2.names(namedNames), _this2.symbols(namedSymbols));
                })();
            }
            this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.BindCallerScope);
            if (symbols.yields) {
                (function () {
                    var yields = symbols.yields;
                    var yieldNames = Object.keys(yields);
                    var yieldSymbols = yieldNames.map(function (n) {
                        return yields[n];
                    });
                    _this2.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.BindBlocks, _this2.names(yieldNames), _this2.symbols(yieldSymbols));
                })();
            }
            if (symbols.partialArgs) {
                this.opcode(_glimmerRuntimeLibOpcodes.OpcodeName.BindPartialArgs, symbols.partialArgs);
            }
        };

        OpcodeBuilder.prototype.yield = function _yield(args, to) {
            var yields = undefined,
                partial = undefined;
            var inner = undefined;
            if (yields = this.symbolTable.getSymbol('yields', to)) {
                inner = new _glimmerRuntimeLibCompiledExpressionsHasBlock.CompiledGetBlockBySymbol(yields, to);
            } else if (partial = this.symbolTable.getPartialArgs()) {
                inner = new _glimmerRuntimeLibCompiledExpressionsHasBlock.CompiledInPartialGetBlock(partial, to);
            } else {
                throw new Error('[BUG] ${to} is not a valid block name.');
            }
            this.openBlock(args, inner);
            this.closeBlock();
        };

        // TODO
        // come back to this

        OpcodeBuilder.prototype.labelled = function labelled(args, callback) {
            if (args) this.putArgs(args);
            this.startLabels();
            this.enter('BEGIN', 'END');
            this.label('BEGIN');
            callback(this, 'BEGIN', 'END');
            this.label('END');
            this.exit();
            this.stopLabels();
        };

        // TODO
        // come back to this

        OpcodeBuilder.prototype.iter = function iter(callback) {
            this.startLabels();
            this.enterList('BEGIN', 'END');
            this.label('ITER');
            this.nextIter('BREAK');
            this.enterWithKey('BEGIN', 'END');
            this.label('BEGIN');
            callback(this, 'BEGIN', 'END');
            this.label('END');
            this.exit();
            this.jump('ITER');
            this.label('BREAK');
            this.exitList();
            this.stopLabels();
        };

        // TODO
        // come back to this

        OpcodeBuilder.prototype.unit = function unit(callback) {
            this.startLabels();
            callback(this);
            this.stopLabels();
        };

        return OpcodeBuilder;
    })(BasicOpcodeBuilder);

    exports.default = OpcodeBuilder;
});

enifed('@glimmer/runtime/lib/compiled/opcodes/component', ['exports', '@glimmer/runtime/lib/opcodes', '@glimmer/runtime/lib/compiled/opcodes/vm', '@glimmer/runtime/lib/compiled/expressions/args', '@glimmer/reference'], function (exports, _glimmerRuntimeLibOpcodes, _glimmerRuntimeLibCompiledOpcodesVm, _glimmerRuntimeLibCompiledExpressionsArgs, _glimmerReference) {
    'use strict';

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.PutDynamicComponent, function (vm) {
        var reference = vm.frame.getOperand();
        var cache = _glimmerReference.isConst(reference) ? undefined : new _glimmerReference.ReferenceCache(reference);
        var definition = cache ? cache.peek() : reference.value();
        vm.frame.setImmediate(definition);
        if (cache) {
            vm.updateWith(new _glimmerRuntimeLibCompiledOpcodesVm.Assert(cache));
        }
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.PutComponent, function (vm, _ref) {
        var _component = _ref.op1;

        var definition = vm.constants.getOther(_component);
        vm.frame.setImmediate(definition);
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.OpenComponent, function (vm, _ref2) {
        var _args = _ref2.op1;
        var _shadow = _ref2.op2;

        var rawArgs = vm.constants.getExpression(_args);
        var shadow = vm.constants.getBlock(_shadow);
        var definition = vm.frame.getImmediate();
        var dynamicScope = vm.pushDynamicScope();
        var callerScope = vm.scope();
        var manager = definition.manager;
        var args = manager.prepareArgs(definition, rawArgs.evaluate(vm), dynamicScope);
        var hasDefaultBlock = !!args.blocks.default; // TODO Cleanup?
        var component = manager.create(vm.env, definition, args, dynamicScope, vm.getSelf(), hasDefaultBlock);
        var destructor = manager.getDestructor(component);
        if (destructor) vm.newDestroyable(destructor);
        var layout = manager.layoutFor(definition, component, vm.env);
        var selfRef = manager.getSelf(component);
        vm.beginCacheGroup();
        vm.stack().pushSimpleBlock();
        vm.pushRootScope(selfRef, layout.symbols);
        vm.invokeLayout(args, layout, callerScope, component, manager, shadow);
        vm.updateWith(new UpdateComponentOpcode(definition.name, component, manager, args, dynamicScope));
    });
    // export class DidCreateElementOpcode extends Opcode {
    //   public type = "did-create-element";
    //   evaluate(vm: VM) {
    //     let manager = vm.frame.getManager();
    //     let component = vm.frame.getComponent();
    //     let action = 'DidCreateElementOpcode#evaluate';
    //     manager.didCreateElement(component, vm.stack().expectConstructing(action), vm.stack().expectOperations(action));
    //   }
    //   toJSON(): OpcodeJSON {
    //     return {
    //       guid: this._guid,
    //       type: this.type,
    //       args: ["$ARGS"]
    //     };
    //   }
    // }
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.DidCreateElement, function (vm) {
        var manager = vm.frame.getManager();
        var component = vm.frame.getComponent();
        var action = 'DidCreateElementOpcode#evaluate';
        manager.didCreateElement(component, vm.stack().expectConstructing(action), vm.stack().expectOperations(action));
    });
    // export class ShadowAttributesOpcode extends Opcode {
    //   public type = "shadow-attributes";
    //   evaluate(vm: VM) {
    //     let shadow = vm.frame.getShadow();
    //     vm.pushCallerScope();
    //     if (!shadow) return;
    //     vm.invokeBlock(shadow, EvaluatedArgs.empty());
    //   }
    //   toJSON(): OpcodeJSON {
    //     return {
    //       guid: this._guid,
    //       type: this.type,
    //       args: ["$ARGS"]
    //     };
    //   }
    // }
    // Slow path for non-specialized component invocations. Uses an internal
    // named lookup on the args.
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.ShadowAttributes, function (vm) {
        var shadow = vm.frame.getShadow();
        vm.pushCallerScope();
        if (!shadow) return;
        vm.invokeBlock(shadow, _glimmerRuntimeLibCompiledExpressionsArgs.EvaluatedArgs.empty());
    });
    // export class DidRenderLayoutOpcode extends Opcode {
    //   public type = "did-render-layout";
    //   evaluate(vm: VM) {
    //     let manager = vm.frame.getManager();
    //     let component = vm.frame.getComponent();
    //     let bounds = vm.stack().popBlock();
    //     manager.didRenderLayout(component, bounds);
    //     vm.env.didCreate(component, manager);
    //     vm.updateWith(new DidUpdateLayoutOpcode(manager, component, bounds));
    //   }
    // }
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.DidRenderLayout, function (vm) {
        var manager = vm.frame.getManager();
        var component = vm.frame.getComponent();
        var bounds = vm.stack().popBlock();
        manager.didRenderLayout(component, bounds);
        vm.env.didCreate(component, manager);
        vm.updateWith(new DidUpdateLayoutOpcode(manager, component, bounds));
    });
    // export class CloseComponentOpcode extends Opcode {
    //   public type = "close-component";
    //   evaluate(vm: VM) {
    //     vm.popScope();
    //     vm.popDynamicScope();
    //     vm.commitCacheGroup();
    //   }
    // }
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.CloseComponent, function (vm) {
        vm.popScope();
        vm.popDynamicScope();
        vm.commitCacheGroup();
    });

    var UpdateComponentOpcode = (function (_UpdatingOpcode) {
        _inherits(UpdateComponentOpcode, _UpdatingOpcode);

        function UpdateComponentOpcode(name, component, manager, args, dynamicScope) {
            _classCallCheck(this, UpdateComponentOpcode);

            _UpdatingOpcode.call(this);
            this.name = name;
            this.component = component;
            this.manager = manager;
            this.args = args;
            this.dynamicScope = dynamicScope;
            this.type = "update-component";
            var componentTag = manager.getTag(component);
            if (componentTag) {
                this.tag = _glimmerReference.combine([args.tag, componentTag]);
            } else {
                this.tag = args.tag;
            }
        }

        UpdateComponentOpcode.prototype.evaluate = function evaluate(_vm) {
            var component = this.component;
            var manager = this.manager;
            var args = this.args;
            var dynamicScope = this.dynamicScope;

            manager.update(component, args, dynamicScope);
        };

        UpdateComponentOpcode.prototype.toJSON = function toJSON() {
            return {
                guid: this._guid,
                type: this.type,
                args: [JSON.stringify(this.name)]
            };
        };

        return UpdateComponentOpcode;
    })(_glimmerRuntimeLibOpcodes.UpdatingOpcode);

    exports.UpdateComponentOpcode = UpdateComponentOpcode;

    var DidUpdateLayoutOpcode = (function (_UpdatingOpcode2) {
        _inherits(DidUpdateLayoutOpcode, _UpdatingOpcode2);

        function DidUpdateLayoutOpcode(manager, component, bounds) {
            _classCallCheck(this, DidUpdateLayoutOpcode);

            _UpdatingOpcode2.call(this);
            this.manager = manager;
            this.component = component;
            this.bounds = bounds;
            this.type = "did-update-layout";
            this.tag = _glimmerReference.CONSTANT_TAG;
        }

        DidUpdateLayoutOpcode.prototype.evaluate = function evaluate(vm) {
            var manager = this.manager;
            var component = this.component;
            var bounds = this.bounds;

            manager.didUpdateLayout(component, bounds);
            vm.env.didUpdate(component, manager);
        };

        return DidUpdateLayoutOpcode;
    })(_glimmerRuntimeLibOpcodes.UpdatingOpcode);

    exports.DidUpdateLayoutOpcode = DidUpdateLayoutOpcode;
});

enifed('@glimmer/runtime/lib/compiled/opcodes/content', ['exports', '@glimmer/runtime/lib/upsert', '@glimmer/runtime/lib/component/interfaces', '@glimmer/runtime/lib/opcodes', '@glimmer/runtime/lib/compiled/expressions', '@glimmer/runtime/lib/vm/update', '@glimmer/reference', '@glimmer/util', '@glimmer/runtime/lib/bounds', '@glimmer/runtime/lib/builder', '@glimmer/runtime/lib/compiled/opcodes/builder', '@glimmer/runtime/lib/references'], function (exports, _glimmerRuntimeLibUpsert, _glimmerRuntimeLibComponentInterfaces, _glimmerRuntimeLibOpcodes, _glimmerRuntimeLibCompiledExpressions, _glimmerRuntimeLibVmUpdate, _glimmerReference, _glimmerUtil, _glimmerRuntimeLibBounds, _glimmerRuntimeLibBuilder, _glimmerRuntimeLibCompiledOpcodesBuilder, _glimmerRuntimeLibReferences) {
    'use strict';

    exports.normalizeTextValue = normalizeTextValue;

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.DynamicContent, function (vm, _ref) {
        var append = _ref.op1;

        var opcode = vm.constants.getOther(append);
        opcode.evaluate(vm);
    });
    function isEmpty(value) {
        return value === null || value === undefined || typeof value['toString'] !== 'function';
    }

    function normalizeTextValue(value) {
        if (isEmpty(value)) {
            return '';
        }
        return String(value);
    }

    function normalizeTrustedValue(value) {
        if (isEmpty(value)) {
            return '';
        }
        if (_glimmerRuntimeLibUpsert.isString(value)) {
            return value;
        }
        if (_glimmerRuntimeLibUpsert.isSafeString(value)) {
            return value.toHTML();
        }
        if (_glimmerRuntimeLibUpsert.isNode(value)) {
            return value;
        }
        return String(value);
    }
    function normalizeValue(value) {
        if (isEmpty(value)) {
            return '';
        }
        if (_glimmerRuntimeLibUpsert.isString(value)) {
            return value;
        }
        if (_glimmerRuntimeLibUpsert.isSafeString(value) || _glimmerRuntimeLibUpsert.isNode(value)) {
            return value;
        }
        return String(value);
    }

    var AppendDynamicOpcode = (function () {
        function AppendDynamicOpcode() {
            _classCallCheck(this, AppendDynamicOpcode);
        }

        AppendDynamicOpcode.prototype.evaluate = function evaluate(vm) {
            var reference = vm.frame.getOperand();
            var normalized = this.normalize(reference);
            var value = undefined,
                cache = undefined;
            if (_glimmerReference.isConst(reference)) {
                value = normalized.value();
            } else {
                cache = new _glimmerReference.ReferenceCache(normalized);
                value = cache.peek();
            }
            var stack = vm.stack();
            var upsert = this.insert(vm.env.getAppendOperations(), stack, value);
            var bounds = new _glimmerRuntimeLibBuilder.Fragment(upsert.bounds);
            stack.newBounds(bounds);
            if (cache /* i.e. !isConst(reference) */) {
                    vm.updateWith(this.updateWith(vm, reference, cache, bounds, upsert));
                }
        };

        return AppendDynamicOpcode;
    })();

    exports.AppendDynamicOpcode = AppendDynamicOpcode;

    var GuardedAppendOpcode = (function (_AppendDynamicOpcode) {
        _inherits(GuardedAppendOpcode, _AppendDynamicOpcode);

        function GuardedAppendOpcode(expression, symbolTable) {
            _classCallCheck(this, GuardedAppendOpcode);

            _AppendDynamicOpcode.call(this);
            this.expression = expression;
            this.symbolTable = symbolTable;
            this.deopted = null;
        }

        GuardedAppendOpcode.prototype.evaluate = function evaluate(vm) {
            if (this.deopted) {
                vm.pushEvalFrame(this.deopted);
            } else {
                vm.evaluateOperand(this.expression);
                var value = vm.frame.getOperand().value();
                if (_glimmerRuntimeLibComponentInterfaces.isComponentDefinition(value)) {
                    vm.pushEvalFrame(this.deopt(vm.env));
                } else {
                    _AppendDynamicOpcode.prototype.evaluate.call(this, vm);
                }
            }
        };

        GuardedAppendOpcode.prototype.deopt = function deopt(env) {
            var _this = this;

            // At compile time, we determined that this append callsite might refer
            // to a local variable/property lookup that resolves to a component
            // definition at runtime.
            //
            // We could have eagerly compiled this callsite into something like this:
            //
            //   {{#if (is-component-definition foo)}}
            //     {{component foo}}
            //   {{else}}
            //     {{foo}}
            //   {{/if}}
            //
            // However, in practice, there might be a large amout of these callsites
            // and most of them would resolve to a simple value lookup. Therefore, we
            // tried to be optimistic and assumed that the callsite will resolve to
            // appending a simple value.
            //
            // However, we have reached here because at runtime, the guard conditional
            // have detected that this callsite is indeed referring to a component
            // definition object. Since this is likely going to be true for other
            // instances of the same callsite, it is now appropiate to deopt into the
            // expanded version that handles both cases. The compilation would look
            // like this:
            //
            //               PutValue(expression)
            //               Test(is-component-definition)
            //               Enter(BEGIN, END)
            //   BEGIN:      Noop
            //               JumpUnless(VALUE)
            //               PutDynamicComponentDefinitionOpcode
            //               OpenComponent
            //               CloseComponent
            //               Jump(END)
            //   VALUE:      Noop
            //               OptimizedAppend
            //   END:        Noop
            //               Exit
            //
            // Keep in mind that even if we *don't* reach here at initial render time,
            // it is still possible (although quite rare) that the simple value we
            // encounter during initial render could later change into a component
            // definition object at update time. That is handled by the "lazy deopt"
            // code on the update side (scroll down for the next big block of comment).
            var dsl = new _glimmerRuntimeLibCompiledOpcodesBuilder.default(this.symbolTable, env);
            dsl.putValue(this.expression);
            dsl.test(IsComponentDefinitionReference.create);
            dsl.labelled(null, function (dsl, _BEGIN, END) {
                dsl.jumpUnless('VALUE');
                dsl.putDynamicComponentDefinition();
                dsl.openComponent(_glimmerRuntimeLibCompiledExpressions.CompiledArgs.empty());
                dsl.closeComponent();
                dsl.jump(END);
                dsl.label('VALUE');
                dsl.dynamicContent(new _this.AppendOpcode());
            });
            var deopted = this.deopted = dsl.toSlice();
            // From this point on, we have essentially replaced ourselves with a new set
            // of opcodes. Since we will always be executing the new/deopted code, it's
            // a good idea (as a pattern) to null out any unneeded fields here to avoid
            // holding on to unneeded/stale objects:
            // QUESTION: Shouldn't this whole object be GCed? If not, why not?
            this.expression = null;
            return deopted;
        };

        return GuardedAppendOpcode;
    })(AppendDynamicOpcode);

    exports.GuardedAppendOpcode = GuardedAppendOpcode;

    var IsComponentDefinitionReference = (function (_ConditionalReference) {
        _inherits(IsComponentDefinitionReference, _ConditionalReference);

        function IsComponentDefinitionReference() {
            _classCallCheck(this, IsComponentDefinitionReference);

            _ConditionalReference.apply(this, arguments);
        }

        IsComponentDefinitionReference.create = function create(inner) {
            return new IsComponentDefinitionReference(inner);
        };

        IsComponentDefinitionReference.prototype.toBool = function toBool(value) {
            return _glimmerRuntimeLibComponentInterfaces.isComponentDefinition(value);
        };

        return IsComponentDefinitionReference;
    })(_glimmerRuntimeLibReferences.ConditionalReference);

    var UpdateOpcode = (function (_UpdatingOpcode) {
        _inherits(UpdateOpcode, _UpdatingOpcode);

        function UpdateOpcode(cache, bounds, upsert) {
            _classCallCheck(this, UpdateOpcode);

            _UpdatingOpcode.call(this);
            this.cache = cache;
            this.bounds = bounds;
            this.upsert = upsert;
            this.tag = cache.tag;
        }

        UpdateOpcode.prototype.evaluate = function evaluate(vm) {
            var value = this.cache.revalidate();
            if (_glimmerReference.isModified(value)) {
                var bounds = this.bounds;
                var upsert = this.upsert;
                var dom = vm.dom;

                if (!this.upsert.update(dom, value)) {
                    var cursor = new _glimmerRuntimeLibBounds.Cursor(bounds.parentElement(), _glimmerRuntimeLibBounds.clear(bounds));
                    upsert = this.upsert = this.insert(vm.env.getAppendOperations(), cursor, value);
                }
                bounds.update(upsert.bounds);
            }
        };

        UpdateOpcode.prototype.toJSON = function toJSON() {
            var guid = this._guid;
            var type = this.type;
            var cache = this.cache;

            return {
                guid: guid,
                type: type,
                details: { lastValue: JSON.stringify(cache.peek()) }
            };
        };

        return UpdateOpcode;
    })(_glimmerRuntimeLibOpcodes.UpdatingOpcode);

    var GuardedUpdateOpcode = (function (_UpdateOpcode) {
        _inherits(GuardedUpdateOpcode, _UpdateOpcode);

        function GuardedUpdateOpcode(reference, cache, bounds, upsert, appendOpcode, state) {
            _classCallCheck(this, GuardedUpdateOpcode);

            _UpdateOpcode.call(this, cache, bounds, upsert);
            this.reference = reference;
            this.appendOpcode = appendOpcode;
            this.state = state;
            this.deopted = null;
            this.tag = this._tag = new _glimmerReference.UpdatableTag(this.tag);
        }

        GuardedUpdateOpcode.prototype.evaluate = function evaluate(vm) {
            if (this.deopted) {
                vm.evaluateOpcode(this.deopted);
            } else {
                if (_glimmerRuntimeLibComponentInterfaces.isComponentDefinition(this.reference.value())) {
                    this.lazyDeopt(vm);
                } else {
                    _UpdateOpcode.prototype.evaluate.call(this, vm);
                }
            }
        };

        GuardedUpdateOpcode.prototype.lazyDeopt = function lazyDeopt(vm) {
            // Durign initial render, we know that the reference does not contain a
            // component definition, so we optimistically assumed that this append
            // is just a normal append. However, at update time, we discovered that
            // the reference has switched into containing a component definition, so
            // we need to do a "lazy deopt", simulating what would have happened if
            // we had decided to perform the deopt in the first place during initial
            // render.
            //
            // More concretely, we would have expanded the curly into a if/else, and
            // based on whether the value is a component definition or not, we would
            // have entered either the dynamic component branch or the simple value
            // branch.
            //
            // Since we rendered a simple value during initial render (and all the
            // updates up until this point), we need to pretend that the result is
            // produced by the "VALUE" branch of the deopted append opcode:
            //
            //   Try(BEGIN, END)
            //     Assert(IsComponentDefinition, expected=false)
            //     OptimizedUpdate
            //
            // In this case, because the reference has switched from being a simple
            // value into a component definition, what would have happened is that
            // the assert would throw, causing the Try opcode to teardown the bounds
            // and rerun the original append opcode.
            //
            // Since the Try opcode would have nuked the updating opcodes anyway, we
            // wouldn't have to worry about simulating those. All we have to do is to
            // execute the Try opcode and immediately throw.
            var bounds = this.bounds;
            var appendOpcode = this.appendOpcode;
            var state = this.state;

            var env = vm.env;
            var slice = appendOpcode.deopt(env);
            var enter = _glimmerUtil.expect(env.program.opcode(slice[0] + 8), 'hardcoded deopt location');
            var ops = vm.constants.getSlice(enter.op1);
            var tracker = new _glimmerRuntimeLibBuilder.UpdatableBlockTracker(bounds.parentElement());
            tracker.newBounds(this.bounds);
            var children = new _glimmerUtil.LinkedList();
            state.frame['condition'] = IsComponentDefinitionReference.create(_glimmerUtil.expect(state.frame['operand'], 'operand should be populated'));
            var deopted = this.deopted = new _glimmerRuntimeLibVmUpdate.TryOpcode(ops, state, tracker, children);
            this._tag.update(deopted.tag);
            vm.evaluateOpcode(deopted);
            vm.throw();
            // From this point on, we have essentially replaced ourselve with a new
            // opcode. Since we will always be executing the new/deopted code, it's a
            // good idea (as a pattern) to null out any unneeded fields here to avoid
            // holding on to unneeded/stale objects:
            // QUESTION: Shouldn't this whole object be GCed? If not, why not?
            this._tag = null;
            this.reference = null;
            this.cache = null;
            this.bounds = null;
            this.upsert = null;
            this.appendOpcode = null;
            this.state = null;
        };

        GuardedUpdateOpcode.prototype.toJSON = function toJSON() {
            var guid = this._guid;
            var type = this.type;
            var deopted = this.deopted;

            if (deopted) {
                return {
                    guid: guid,
                    type: type,
                    deopted: true,
                    children: [deopted.toJSON()]
                };
            } else {
                return _UpdateOpcode.prototype.toJSON.call(this);
            }
        };

        return GuardedUpdateOpcode;
    })(UpdateOpcode);

    var OptimizedCautiousAppendOpcode = (function (_AppendDynamicOpcode2) {
        _inherits(OptimizedCautiousAppendOpcode, _AppendDynamicOpcode2);

        function OptimizedCautiousAppendOpcode() {
            _classCallCheck(this, OptimizedCautiousAppendOpcode);

            _AppendDynamicOpcode2.apply(this, arguments);
            this.type = 'optimized-cautious-append';
        }

        OptimizedCautiousAppendOpcode.prototype.normalize = function normalize(reference) {
            return _glimmerReference.map(reference, normalizeValue);
        };

        OptimizedCautiousAppendOpcode.prototype.insert = function insert(dom, cursor, value) {
            return _glimmerRuntimeLibUpsert.cautiousInsert(dom, cursor, value);
        };

        OptimizedCautiousAppendOpcode.prototype.updateWith = function updateWith(_vm, _reference, cache, bounds, upsert) {
            return new OptimizedCautiousUpdateOpcode(cache, bounds, upsert);
        };

        return OptimizedCautiousAppendOpcode;
    })(AppendDynamicOpcode);

    exports.OptimizedCautiousAppendOpcode = OptimizedCautiousAppendOpcode;

    var OptimizedCautiousUpdateOpcode = (function (_UpdateOpcode2) {
        _inherits(OptimizedCautiousUpdateOpcode, _UpdateOpcode2);

        function OptimizedCautiousUpdateOpcode() {
            _classCallCheck(this, OptimizedCautiousUpdateOpcode);

            _UpdateOpcode2.apply(this, arguments);
            this.type = 'optimized-cautious-update';
        }

        OptimizedCautiousUpdateOpcode.prototype.insert = function insert(dom, cursor, value) {
            return _glimmerRuntimeLibUpsert.cautiousInsert(dom, cursor, value);
        };

        return OptimizedCautiousUpdateOpcode;
    })(UpdateOpcode);

    var GuardedCautiousAppendOpcode = (function (_GuardedAppendOpcode) {
        _inherits(GuardedCautiousAppendOpcode, _GuardedAppendOpcode);

        function GuardedCautiousAppendOpcode() {
            _classCallCheck(this, GuardedCautiousAppendOpcode);

            _GuardedAppendOpcode.apply(this, arguments);
            this.type = 'guarded-cautious-append';
            this.AppendOpcode = OptimizedCautiousAppendOpcode;
        }

        GuardedCautiousAppendOpcode.prototype.normalize = function normalize(reference) {
            return _glimmerReference.map(reference, normalizeValue);
        };

        GuardedCautiousAppendOpcode.prototype.insert = function insert(dom, cursor, value) {
            return _glimmerRuntimeLibUpsert.cautiousInsert(dom, cursor, value);
        };

        GuardedCautiousAppendOpcode.prototype.updateWith = function updateWith(vm, reference, cache, bounds, upsert) {
            return new GuardedCautiousUpdateOpcode(reference, cache, bounds, upsert, this, vm.capture());
        };

        return GuardedCautiousAppendOpcode;
    })(GuardedAppendOpcode);

    exports.GuardedCautiousAppendOpcode = GuardedCautiousAppendOpcode;

    var GuardedCautiousUpdateOpcode = (function (_GuardedUpdateOpcode) {
        _inherits(GuardedCautiousUpdateOpcode, _GuardedUpdateOpcode);

        function GuardedCautiousUpdateOpcode() {
            _classCallCheck(this, GuardedCautiousUpdateOpcode);

            _GuardedUpdateOpcode.apply(this, arguments);
            this.type = 'guarded-cautious-update';
        }

        GuardedCautiousUpdateOpcode.prototype.insert = function insert(dom, cursor, value) {
            return _glimmerRuntimeLibUpsert.cautiousInsert(dom, cursor, value);
        };

        return GuardedCautiousUpdateOpcode;
    })(GuardedUpdateOpcode);

    var OptimizedTrustingAppendOpcode = (function (_AppendDynamicOpcode3) {
        _inherits(OptimizedTrustingAppendOpcode, _AppendDynamicOpcode3);

        function OptimizedTrustingAppendOpcode() {
            _classCallCheck(this, OptimizedTrustingAppendOpcode);

            _AppendDynamicOpcode3.apply(this, arguments);
            this.type = 'optimized-trusting-append';
        }

        OptimizedTrustingAppendOpcode.prototype.normalize = function normalize(reference) {
            return _glimmerReference.map(reference, normalizeTrustedValue);
        };

        OptimizedTrustingAppendOpcode.prototype.insert = function insert(dom, cursor, value) {
            return _glimmerRuntimeLibUpsert.trustingInsert(dom, cursor, value);
        };

        OptimizedTrustingAppendOpcode.prototype.updateWith = function updateWith(_vm, _reference, cache, bounds, upsert) {
            return new OptimizedTrustingUpdateOpcode(cache, bounds, upsert);
        };

        return OptimizedTrustingAppendOpcode;
    })(AppendDynamicOpcode);

    exports.OptimizedTrustingAppendOpcode = OptimizedTrustingAppendOpcode;

    var OptimizedTrustingUpdateOpcode = (function (_UpdateOpcode3) {
        _inherits(OptimizedTrustingUpdateOpcode, _UpdateOpcode3);

        function OptimizedTrustingUpdateOpcode() {
            _classCallCheck(this, OptimizedTrustingUpdateOpcode);

            _UpdateOpcode3.apply(this, arguments);
            this.type = 'optimized-trusting-update';
        }

        OptimizedTrustingUpdateOpcode.prototype.insert = function insert(dom, cursor, value) {
            return _glimmerRuntimeLibUpsert.trustingInsert(dom, cursor, value);
        };

        return OptimizedTrustingUpdateOpcode;
    })(UpdateOpcode);

    var GuardedTrustingAppendOpcode = (function (_GuardedAppendOpcode2) {
        _inherits(GuardedTrustingAppendOpcode, _GuardedAppendOpcode2);

        function GuardedTrustingAppendOpcode() {
            _classCallCheck(this, GuardedTrustingAppendOpcode);

            _GuardedAppendOpcode2.apply(this, arguments);
            this.type = 'guarded-trusting-append';
            this.AppendOpcode = OptimizedTrustingAppendOpcode;
        }

        GuardedTrustingAppendOpcode.prototype.normalize = function normalize(reference) {
            return _glimmerReference.map(reference, normalizeTrustedValue);
        };

        GuardedTrustingAppendOpcode.prototype.insert = function insert(dom, cursor, value) {
            return _glimmerRuntimeLibUpsert.trustingInsert(dom, cursor, value);
        };

        GuardedTrustingAppendOpcode.prototype.updateWith = function updateWith(vm, reference, cache, bounds, upsert) {
            return new GuardedTrustingUpdateOpcode(reference, cache, bounds, upsert, this, vm.capture());
        };

        return GuardedTrustingAppendOpcode;
    })(GuardedAppendOpcode);

    exports.GuardedTrustingAppendOpcode = GuardedTrustingAppendOpcode;

    var GuardedTrustingUpdateOpcode = (function (_GuardedUpdateOpcode2) {
        _inherits(GuardedTrustingUpdateOpcode, _GuardedUpdateOpcode2);

        function GuardedTrustingUpdateOpcode() {
            _classCallCheck(this, GuardedTrustingUpdateOpcode);

            _GuardedUpdateOpcode2.apply(this, arguments);
            this.type = 'trusting-update';
        }

        GuardedTrustingUpdateOpcode.prototype.insert = function insert(dom, cursor, value) {
            return _glimmerRuntimeLibUpsert.trustingInsert(dom, cursor, value);
        };

        return GuardedTrustingUpdateOpcode;
    })(GuardedUpdateOpcode);
});

enifed('@glimmer/runtime/lib/compiled/opcodes/dom', ['exports', '@glimmer/runtime/lib/opcodes', '@glimmer/util', '@glimmer/reference', '@glimmer/runtime/lib/references', '@glimmer/runtime/lib/compiled/opcodes/vm'], function (exports, _glimmerRuntimeLibOpcodes, _glimmerUtil, _glimmerReference, _glimmerRuntimeLibReferences, _glimmerRuntimeLibCompiledOpcodesVm) {
    'use strict';

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.Text, function (vm, _ref) {
        var text = _ref.op1;

        vm.stack().appendText(vm.constants.getString(text));
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.Comment, function (vm, _ref2) {
        var text = _ref2.op1;

        vm.stack().appendComment(vm.constants.getString(text));
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.OpenElement, function (vm, _ref3) {
        var tag = _ref3.op1;

        vm.stack().openElement(vm.constants.getString(tag));
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.PushRemoteElement, function (vm) {
        var reference = vm.frame.getOperand();
        var cache = _glimmerReference.isConst(reference) ? undefined : new _glimmerReference.ReferenceCache(reference);
        var element = cache ? cache.peek() : reference.value();
        vm.stack().pushRemoteElement(element);
        if (cache) {
            vm.updateWith(new _glimmerRuntimeLibCompiledOpcodesVm.Assert(cache));
        }
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.PopRemoteElement, function (vm) {
        return vm.stack().popRemoteElement();
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.OpenComponentElement, function (vm, _ref4) {
        var _tag = _ref4.op1;

        var tag = vm.constants.getString(_tag);
        vm.stack().openElement(tag, new ComponentElementOperations(vm.env));
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.OpenDynamicElement, function (vm) {
        var tagName = vm.frame.getOperand().value();
        vm.stack().openElement(tagName);
    });

    var ClassList = (function () {
        function ClassList() {
            _classCallCheck(this, ClassList);

            this.list = null;
            this.isConst = true;
        }

        ClassList.prototype.append = function append(reference) {
            var list = this.list;
            var isConst = this.isConst;

            if (list === null) list = this.list = [];
            list.push(reference);
            this.isConst = isConst && _glimmerReference.isConst(reference);
        };

        ClassList.prototype.toReference = function toReference() {
            var list = this.list;
            var isConst = this.isConst;

            if (!list) return _glimmerRuntimeLibReferences.NULL_REFERENCE;
            if (isConst) return _glimmerRuntimeLibReferences.PrimitiveReference.create(toClassName(list));
            return new ClassListReference(list);
        };

        return ClassList;
    })();

    var ClassListReference = (function (_CachedReference) {
        _inherits(ClassListReference, _CachedReference);

        function ClassListReference(list) {
            _classCallCheck(this, ClassListReference);

            _CachedReference.call(this);
            this.list = [];
            this.tag = _glimmerReference.combineTagged(list);
            this.list = list;
        }

        ClassListReference.prototype.compute = function compute() {
            return toClassName(this.list);
        };

        return ClassListReference;
    })(_glimmerReference.CachedReference);

    function toClassName(list) {
        var ret = [];
        for (var i = 0; i < list.length; i++) {
            var value = list[i].value();
            if (value !== false && value !== null && value !== undefined) ret.push(value);
        }
        return ret.length === 0 ? null : ret.join(' ');
    }

    var SimpleElementOperations = (function () {
        function SimpleElementOperations(env) {
            _classCallCheck(this, SimpleElementOperations);

            this.env = env;
            this.opcodes = null;
            this.classList = null;
        }

        SimpleElementOperations.prototype.addStaticAttribute = function addStaticAttribute(element, name, value) {
            if (name === 'class') {
                this.addClass(_glimmerRuntimeLibReferences.PrimitiveReference.create(value));
            } else {
                this.env.getAppendOperations().setAttribute(element, name, value);
            }
        };

        SimpleElementOperations.prototype.addStaticAttributeNS = function addStaticAttributeNS(element, namespace, name, value) {
            this.env.getAppendOperations().setAttribute(element, name, value, namespace);
        };

        SimpleElementOperations.prototype.addDynamicAttribute = function addDynamicAttribute(element, name, reference, isTrusting) {
            if (name === 'class') {
                this.addClass(reference);
            } else {
                var attributeManager = this.env.attributeFor(element, name, isTrusting);
                var attribute = new DynamicAttribute(element, attributeManager, name, reference);
                this.addAttribute(attribute);
            }
        };

        SimpleElementOperations.prototype.addDynamicAttributeNS = function addDynamicAttributeNS(element, namespace, name, reference, isTrusting) {
            var attributeManager = this.env.attributeFor(element, name, isTrusting, namespace);
            var nsAttribute = new DynamicAttribute(element, attributeManager, name, reference, namespace);
            this.addAttribute(nsAttribute);
        };

        SimpleElementOperations.prototype.flush = function flush(element, vm) {
            var env = vm.env;
            var opcodes = this.opcodes;
            var classList = this.classList;

            for (var i = 0; opcodes && i < opcodes.length; i++) {
                vm.updateWith(opcodes[i]);
            }
            if (classList) {
                var attributeManager = env.attributeFor(element, 'class', false);
                var attribute = new DynamicAttribute(element, attributeManager, 'class', classList.toReference());
                var opcode = attribute.flush(env);
                if (opcode) {
                    vm.updateWith(opcode);
                }
            }
            this.opcodes = null;
            this.classList = null;
        };

        SimpleElementOperations.prototype.addClass = function addClass(reference) {
            var classList = this.classList;

            if (!classList) {
                classList = this.classList = new ClassList();
            }
            classList.append(reference);
        };

        SimpleElementOperations.prototype.addAttribute = function addAttribute(attribute) {
            var opcode = attribute.flush(this.env);
            if (opcode) {
                var opcodes = this.opcodes;

                if (!opcodes) {
                    opcodes = this.opcodes = [];
                }
                opcodes.push(opcode);
            }
        };

        return SimpleElementOperations;
    })();

    exports.SimpleElementOperations = SimpleElementOperations;

    var ComponentElementOperations = (function () {
        function ComponentElementOperations(env) {
            _classCallCheck(this, ComponentElementOperations);

            this.env = env;
            this.attributeNames = null;
            this.attributes = null;
            this.classList = null;
        }

        ComponentElementOperations.prototype.addStaticAttribute = function addStaticAttribute(element, name, value) {
            if (name === 'class') {
                this.addClass(_glimmerRuntimeLibReferences.PrimitiveReference.create(value));
            } else if (this.shouldAddAttribute(name)) {
                this.addAttribute(name, new StaticAttribute(element, name, value));
            }
        };

        ComponentElementOperations.prototype.addStaticAttributeNS = function addStaticAttributeNS(element, namespace, name, value) {
            if (this.shouldAddAttribute(name)) {
                this.addAttribute(name, new StaticAttribute(element, name, value, namespace));
            }
        };

        ComponentElementOperations.prototype.addDynamicAttribute = function addDynamicAttribute(element, name, reference, isTrusting) {
            if (name === 'class') {
                this.addClass(reference);
            } else if (this.shouldAddAttribute(name)) {
                var attributeManager = this.env.attributeFor(element, name, isTrusting);
                var attribute = new DynamicAttribute(element, attributeManager, name, reference);
                this.addAttribute(name, attribute);
            }
        };

        ComponentElementOperations.prototype.addDynamicAttributeNS = function addDynamicAttributeNS(element, namespace, name, reference, isTrusting) {
            if (this.shouldAddAttribute(name)) {
                var attributeManager = this.env.attributeFor(element, name, isTrusting, namespace);
                var nsAttribute = new DynamicAttribute(element, attributeManager, name, reference, namespace);
                this.addAttribute(name, nsAttribute);
            }
        };

        ComponentElementOperations.prototype.flush = function flush(element, vm) {
            var env = this.env;
            var attributes = this.attributes;
            var classList = this.classList;

            for (var i = 0; attributes && i < attributes.length; i++) {
                var opcode = attributes[i].flush(env);
                if (opcode) {
                    vm.updateWith(opcode);
                }
            }
            if (classList) {
                var attributeManager = env.attributeFor(element, 'class', false);
                var attribute = new DynamicAttribute(element, attributeManager, 'class', classList.toReference());
                var opcode = attribute.flush(env);
                if (opcode) {
                    vm.updateWith(opcode);
                }
            }
        };

        ComponentElementOperations.prototype.shouldAddAttribute = function shouldAddAttribute(name) {
            return !this.attributeNames || this.attributeNames.indexOf(name) === -1;
        };

        ComponentElementOperations.prototype.addClass = function addClass(reference) {
            var classList = this.classList;

            if (!classList) {
                classList = this.classList = new ClassList();
            }
            classList.append(reference);
        };

        ComponentElementOperations.prototype.addAttribute = function addAttribute(name, attribute) {
            var attributeNames = this.attributeNames;
            var attributes = this.attributes;

            if (!attributeNames) {
                attributeNames = this.attributeNames = [];
                attributes = this.attributes = [];
            }
            attributeNames.push(name);
            _glimmerUtil.unwrap(attributes).push(attribute);
        };

        return ComponentElementOperations;
    })();

    exports.ComponentElementOperations = ComponentElementOperations;

    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.FlushElement, function (vm) {
        var stack = vm.stack();
        var action = 'FlushElementOpcode#evaluate';
        stack.expectOperations(action).flush(stack.expectConstructing(action), vm);
        stack.flushElement();
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.CloseElement, function (vm) {
        return vm.stack().closeElement();
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.PopElement, function (vm) {
        return vm.stack().popElement();
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.StaticAttr, function (vm, _ref5) {
        var _name = _ref5.op1;
        var _value = _ref5.op2;
        var _namespace = _ref5.op3;

        var name = vm.constants.getString(_name);
        var value = vm.constants.getString(_value);
        if (_namespace) {
            var namespace = vm.constants.getString(_namespace);
            vm.stack().setStaticAttributeNS(namespace, name, value);
        } else {
            vm.stack().setStaticAttribute(name, value);
        }
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.Modifier, function (vm, _ref6) {
        var _name = _ref6.op1;
        var _manager = _ref6.op2;
        var _args = _ref6.op3;

        var manager = vm.constants.getOther(_manager);
        var rawArgs = vm.constants.getExpression(_args);
        var stack = vm.stack();
        var element = stack.constructing;
        var updateOperations = stack.updateOperations;

        var args = rawArgs.evaluate(vm);
        var dynamicScope = vm.dynamicScope();
        var modifier = manager.create(element, args, dynamicScope, updateOperations);
        vm.env.scheduleInstallModifier(modifier, manager);
        var destructor = manager.getDestructor(modifier);
        if (destructor) {
            vm.newDestroyable(destructor);
        }
        vm.updateWith(new UpdateModifierOpcode(manager, modifier, args));
    });

    var UpdateModifierOpcode = (function (_UpdatingOpcode) {
        _inherits(UpdateModifierOpcode, _UpdatingOpcode);

        function UpdateModifierOpcode(manager, modifier, args) {
            _classCallCheck(this, UpdateModifierOpcode);

            _UpdatingOpcode.call(this);
            this.manager = manager;
            this.modifier = modifier;
            this.args = args;
            this.type = "update-modifier";
            this.tag = args.tag;
            this.lastUpdated = args.tag.value();
        }

        UpdateModifierOpcode.prototype.evaluate = function evaluate(vm) {
            var manager = this.manager;
            var modifier = this.modifier;
            var tag = this.tag;
            var lastUpdated = this.lastUpdated;

            if (!tag.validate(lastUpdated)) {
                vm.env.scheduleUpdateModifier(modifier, manager);
                this.lastUpdated = tag.value();
            }
        };

        UpdateModifierOpcode.prototype.toJSON = function toJSON() {
            return {
                guid: this._guid,
                type: this.type,
                args: [JSON.stringify(this.args)]
            };
        };

        return UpdateModifierOpcode;
    })(_glimmerRuntimeLibOpcodes.UpdatingOpcode);

    exports.UpdateModifierOpcode = UpdateModifierOpcode;

    var StaticAttribute = (function () {
        function StaticAttribute(element, name, value, namespace) {
            _classCallCheck(this, StaticAttribute);

            this.element = element;
            this.name = name;
            this.value = value;
            this.namespace = namespace;
        }

        StaticAttribute.prototype.flush = function flush(env) {
            env.getAppendOperations().setAttribute(this.element, this.name, this.value, this.namespace);
            return null;
        };

        return StaticAttribute;
    })();

    exports.StaticAttribute = StaticAttribute;

    var DynamicAttribute = (function () {
        function DynamicAttribute(element, attributeManager, name, reference, namespace) {
            _classCallCheck(this, DynamicAttribute);

            this.element = element;
            this.attributeManager = attributeManager;
            this.name = name;
            this.reference = reference;
            this.namespace = namespace;
            this.cache = null;
            this.tag = reference.tag;
        }

        DynamicAttribute.prototype.patch = function patch(env) {
            var element = this.element;
            var cache = this.cache;

            var value = _glimmerUtil.expect(cache, 'must patch after flush').revalidate();
            if (_glimmerReference.isModified(value)) {
                this.attributeManager.updateAttribute(env, element, value, this.namespace);
            }
        };

        DynamicAttribute.prototype.flush = function flush(env) {
            var reference = this.reference;
            var element = this.element;

            if (_glimmerReference.isConst(reference)) {
                var value = reference.value();
                this.attributeManager.setAttribute(env, element, value, this.namespace);
                return null;
            } else {
                var cache = this.cache = new _glimmerReference.ReferenceCache(reference);
                var value = cache.peek();
                this.attributeManager.setAttribute(env, element, value, this.namespace);
                return new PatchElementOpcode(this);
            }
        };

        DynamicAttribute.prototype.toJSON = function toJSON() {
            var element = this.element;
            var namespace = this.namespace;
            var name = this.name;
            var cache = this.cache;

            var formattedElement = formatElement(element);
            var lastValue = _glimmerUtil.expect(cache, 'must serialize after flush').peek();
            if (namespace) {
                return {
                    element: formattedElement,
                    type: 'attribute',
                    namespace: namespace,
                    name: name,
                    lastValue: lastValue
                };
            }
            return {
                element: formattedElement,
                type: 'attribute',
                namespace: namespace === undefined ? null : namespace,
                name: name,
                lastValue: lastValue
            };
        };

        return DynamicAttribute;
    })();

    exports.DynamicAttribute = DynamicAttribute;

    function formatElement(element) {
        return JSON.stringify('<' + element.tagName.toLowerCase() + ' />');
    }
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.DynamicAttrNS, function (vm, _ref7) {
        var _name = _ref7.op1;
        var _namespace = _ref7.op2;
        var trusting = _ref7.op3;

        var name = vm.constants.getString(_name);
        var namespace = vm.constants.getString(_namespace);
        var reference = vm.frame.getOperand();
        vm.stack().setDynamicAttributeNS(namespace, name, reference, !!trusting);
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.DynamicAttr, function (vm, _ref8) {
        var _name = _ref8.op1;
        var trusting = _ref8.op2;

        var name = vm.constants.getString(_name);
        var reference = vm.frame.getOperand();
        vm.stack().setDynamicAttribute(name, reference, !!trusting);
    });

    var PatchElementOpcode = (function (_UpdatingOpcode2) {
        _inherits(PatchElementOpcode, _UpdatingOpcode2);

        function PatchElementOpcode(operation) {
            _classCallCheck(this, PatchElementOpcode);

            _UpdatingOpcode2.call(this);
            this.type = "patch-element";
            this.tag = operation.tag;
            this.operation = operation;
        }

        PatchElementOpcode.prototype.evaluate = function evaluate(vm) {
            this.operation.patch(vm.env);
        };

        PatchElementOpcode.prototype.toJSON = function toJSON() {
            var _guid = this._guid;
            var type = this.type;
            var operation = this.operation;

            return {
                guid: _guid,
                type: type,
                details: operation.toJSON()
            };
        };

        return PatchElementOpcode;
    })(_glimmerRuntimeLibOpcodes.UpdatingOpcode);

    exports.PatchElementOpcode = PatchElementOpcode;
});

enifed('@glimmer/runtime/lib/compiled/opcodes/lists', ['exports', '@glimmer/runtime/lib/compiled/expressions/args', '@glimmer/util', '@glimmer/reference', '@glimmer/runtime/lib/opcodes'], function (exports, _glimmerRuntimeLibCompiledExpressionsArgs, _glimmerUtil, _glimmerReference, _glimmerRuntimeLibOpcodes) {
    'use strict';

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var IterablePresenceReference = (function () {
        function IterablePresenceReference(artifacts) {
            _classCallCheck(this, IterablePresenceReference);

            this.tag = artifacts.tag;
            this.artifacts = artifacts;
        }

        IterablePresenceReference.prototype.value = function value() {
            return !this.artifacts.isEmpty();
        };

        return IterablePresenceReference;
    })();

    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.PutIterator, function (vm) {
        var listRef = vm.frame.getOperand();
        var args = _glimmerUtil.expect(vm.frame.getArgs(), 'PutIteratorOpcode expects a populated args register');
        var iterable = vm.env.iterableFor(listRef, args);
        var iterator = new _glimmerReference.ReferenceIterator(iterable);
        vm.frame.setIterator(iterator);
        vm.frame.setCondition(new IterablePresenceReference(iterator.artifacts));
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.EnterList, function (vm, _ref) {
        var _slice = _ref.op1;

        vm.enterList(vm.constants.getSlice(_slice));
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.ExitList, function (vm) {
        return vm.exitList();
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.EnterWithKey, function (vm, _ref2) {
        var _slice = _ref2.op2;

        var key = _glimmerUtil.expect(vm.frame.getKey(), 'EnterWithKeyOpcode expects a populated key register');
        var slice = vm.constants.getSlice(_slice);
        vm.enterWithKey(key, slice);
    });
    var TRUE_REF = new _glimmerReference.ConstReference(true);
    var FALSE_REF = new _glimmerReference.ConstReference(false);
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.NextIter, function (vm, _ref3) {
        var end = _ref3.op1;

        var item = vm.frame.getIterator().next();
        if (item) {
            vm.frame.setCondition(TRUE_REF);
            vm.frame.setKey(item.key);
            vm.frame.setOperand(item.value);
            vm.frame.setArgs(_glimmerRuntimeLibCompiledExpressionsArgs.EvaluatedArgs.positional([item.value, item.memo]));
        } else {
            vm.frame.setCondition(FALSE_REF);
            vm.goto(end);
        }
    });
});

enifed('@glimmer/runtime/lib/compiled/opcodes/partial', ['exports', '@glimmer/reference', '@glimmer/runtime/lib/compiled/opcodes/vm', '@glimmer/runtime/lib/opcodes'], function (exports, _glimmerReference, _glimmerRuntimeLibCompiledOpcodesVm, _glimmerRuntimeLibOpcodes) {
    'use strict';

    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.PutDynamicPartial, function (vm, _ref) {
        var _symbolTable = _ref.op1;

        var env = vm.env;
        var symbolTable = vm.constants.getOther(_symbolTable);
        function lookupPartial(name) {
            var normalized = String(name);
            if (!env.hasPartial(normalized, symbolTable)) {
                throw new Error('Could not find a partial named "' + normalized + '"');
            }
            return env.lookupPartial(normalized, symbolTable);
        }
        var reference = _glimmerReference.map(vm.frame.getOperand(), lookupPartial);
        var cache = _glimmerReference.isConst(reference) ? undefined : new _glimmerReference.ReferenceCache(reference);
        var definition = cache ? cache.peek() : reference.value();
        vm.frame.setImmediate(definition);
        if (cache) {
            vm.updateWith(new _glimmerRuntimeLibCompiledOpcodesVm.Assert(cache));
        }
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.PutPartial, function (vm, _ref2) {
        var _definition = _ref2.op1;

        var definition = vm.constants.getOther(_definition);
        vm.frame.setImmediate(definition);
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.EvaluatePartial, function (vm, _ref3) {
        var _symbolTable = _ref3.op1;
        var _cache = _ref3.op2;

        var symbolTable = vm.constants.getOther(_symbolTable);
        var cache = vm.constants.getOther(_cache);

        var _vm$frame$getImmediate = vm.frame.getImmediate();

        var template = _vm$frame$getImmediate.template;

        var block = cache[template.id];
        if (!block) {
            block = template.asPartial(symbolTable);
        }
        vm.invokePartial(block);
    });
});

enifed('@glimmer/runtime/lib/compiled/opcodes/vm', ['exports', '@glimmer/runtime/lib/opcodes', '@glimmer/reference', '@glimmer/util'], function (exports, _glimmerRuntimeLibOpcodes, _glimmerReference, _glimmerUtil) {
    'use strict';

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.PushChildScope, function (vm) {
        return vm.pushChildScope();
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.PopScope, function (vm) {
        return vm.popScope();
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.PushDynamicScope, function (vm) {
        return vm.pushDynamicScope();
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.PopDynamicScope, function (vm) {
        return vm.popDynamicScope();
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.Put, function (vm, _ref) {
        var reference = _ref.op1;

        vm.frame.setOperand(vm.constants.getReference(reference));
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.EvaluatePut, function (vm, _ref2) {
        var expression = _ref2.op1;

        var expr = vm.constants.getExpression(expression);
        vm.evaluateOperand(expr);
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.PutArgs, function (vm, _ref3) {
        var args = _ref3.op1;

        vm.evaluateArgs(vm.constants.getExpression(args));
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.BindPositionalArgs, function (vm, _ref4) {
        var _symbols = _ref4.op1;

        var symbols = vm.constants.getArray(_symbols);
        vm.bindPositionalArgs(symbols);
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.BindNamedArgs, function (vm, _ref5) {
        var _names = _ref5.op1;
        var _symbols = _ref5.op2;

        var names = vm.constants.getArray(_names);
        var symbols = vm.constants.getArray(_symbols);
        vm.bindNamedArgs(names, symbols);
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.BindBlocks, function (vm, _ref6) {
        var _names = _ref6.op1;
        var _symbols = _ref6.op2;

        var names = vm.constants.getArray(_names);
        var symbols = vm.constants.getArray(_symbols);
        vm.bindBlocks(names, symbols);
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.BindPartialArgs, function (vm, _ref7) {
        var symbol = _ref7.op1;

        vm.bindPartialArgs(symbol);
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.BindCallerScope, function (vm) {
        return vm.bindCallerScope();
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.BindDynamicScope, function (vm, _ref8) {
        var _names = _ref8.op1;

        var names = vm.constants.getArray(_names);
        vm.bindDynamicScope(names);
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.Enter, function (vm, _ref9) {
        var slice = _ref9.op1;
        return vm.enter(slice);
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.Exit, function (vm) {
        return vm.exit();
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.Evaluate, function (vm, _ref10) {
        var _block = _ref10.op1;

        var block = vm.constants.getBlock(_block);
        var args = vm.frame.getArgs();
        vm.invokeBlock(block, args);
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.Jump, function (vm, _ref11) {
        var target = _ref11.op1;
        return vm.goto(target);
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.JumpIf, function (vm, _ref12) {
        var target = _ref12.op1;

        var reference = vm.frame.getCondition();
        if (_glimmerReference.isConst(reference)) {
            if (reference.value()) {
                vm.goto(target);
            }
        } else {
            var cache = new _glimmerReference.ReferenceCache(reference);
            if (cache.peek()) {
                vm.goto(target);
            }
            vm.updateWith(new Assert(cache));
        }
    });
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.JumpUnless, function (vm, _ref13) {
        var target = _ref13.op1;

        var reference = vm.frame.getCondition();
        if (_glimmerReference.isConst(reference)) {
            if (!reference.value()) {
                vm.goto(target);
            }
        } else {
            var cache = new _glimmerReference.ReferenceCache(reference);
            if (!cache.peek()) {
                vm.goto(target);
            }
            vm.updateWith(new Assert(cache));
        }
    });
    var ConstTest = function (ref, _env) {
        return new _glimmerReference.ConstReference(!!ref.value());
    };
    exports.ConstTest = ConstTest;
    var SimpleTest = function (ref, _env) {
        return ref;
    };
    exports.SimpleTest = SimpleTest;
    var EnvironmentTest = function (ref, env) {
        return env.toConditionalReference(ref);
    };
    exports.EnvironmentTest = EnvironmentTest;
    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.add(_glimmerRuntimeLibOpcodes.OpcodeName.Test, function (vm, _ref14) {
        var _func = _ref14.op1;

        var operand = vm.frame.getOperand();
        var func = vm.constants.getFunction(_func);
        vm.frame.setCondition(func(operand, vm.env));
    });

    var Assert = (function (_UpdatingOpcode) {
        _inherits(Assert, _UpdatingOpcode);

        function Assert(cache) {
            _classCallCheck(this, Assert);

            _UpdatingOpcode.call(this);
            this.type = "assert";
            this.tag = cache.tag;
            this.cache = cache;
        }

        Assert.prototype.evaluate = function evaluate(vm) {
            var cache = this.cache;

            if (_glimmerReference.isModified(cache.revalidate())) {
                vm.throw();
            }
        };

        Assert.prototype.toJSON = function toJSON() {
            var type = this.type;
            var _guid = this._guid;
            var cache = this.cache;

            var expected = undefined;
            try {
                expected = JSON.stringify(cache.peek());
            } catch (e) {
                expected = String(cache.peek());
            }
            return {
                guid: _guid,
                type: type,
                args: [],
                details: { expected: expected }
            };
        };

        return Assert;
    })(_glimmerRuntimeLibOpcodes.UpdatingOpcode);

    exports.Assert = Assert;

    var JumpIfNotModifiedOpcode = (function (_UpdatingOpcode2) {
        _inherits(JumpIfNotModifiedOpcode, _UpdatingOpcode2);

        function JumpIfNotModifiedOpcode(tag, target) {
            _classCallCheck(this, JumpIfNotModifiedOpcode);

            _UpdatingOpcode2.call(this);
            this.target = target;
            this.type = "jump-if-not-modified";
            this.tag = tag;
            this.lastRevision = tag.value();
        }

        JumpIfNotModifiedOpcode.prototype.evaluate = function evaluate(vm) {
            var tag = this.tag;
            var target = this.target;
            var lastRevision = this.lastRevision;

            if (!vm.alwaysRevalidate && tag.validate(lastRevision)) {
                vm.goto(target);
            }
        };

        JumpIfNotModifiedOpcode.prototype.didModify = function didModify() {
            this.lastRevision = this.tag.value();
        };

        JumpIfNotModifiedOpcode.prototype.toJSON = function toJSON() {
            return {
                guid: this._guid,
                type: this.type,
                args: [JSON.stringify(this.target.inspect())]
            };
        };

        return JumpIfNotModifiedOpcode;
    })(_glimmerRuntimeLibOpcodes.UpdatingOpcode);

    exports.JumpIfNotModifiedOpcode = JumpIfNotModifiedOpcode;

    var DidModifyOpcode = (function (_UpdatingOpcode3) {
        _inherits(DidModifyOpcode, _UpdatingOpcode3);

        function DidModifyOpcode(target) {
            _classCallCheck(this, DidModifyOpcode);

            _UpdatingOpcode3.call(this);
            this.target = target;
            this.type = "did-modify";
            this.tag = _glimmerReference.CONSTANT_TAG;
        }

        DidModifyOpcode.prototype.evaluate = function evaluate() {
            this.target.didModify();
        };

        return DidModifyOpcode;
    })(_glimmerRuntimeLibOpcodes.UpdatingOpcode);

    exports.DidModifyOpcode = DidModifyOpcode;

    var LabelOpcode = (function () {
        function LabelOpcode(label) {
            _classCallCheck(this, LabelOpcode);

            this.tag = _glimmerReference.CONSTANT_TAG;
            this.type = "label";
            this.label = null;
            this.prev = null;
            this.next = null;
            _glimmerUtil.initializeGuid(this);
            if (label) this.label = label;
        }

        LabelOpcode.prototype.evaluate = function evaluate() {};

        LabelOpcode.prototype.inspect = function inspect() {
            return this.label + ' [' + this._guid + ']';
        };

        LabelOpcode.prototype.toJSON = function toJSON() {
            return {
                guid: this._guid,
                type: this.type,
                args: [JSON.stringify(this.inspect())]
            };
        };

        return LabelOpcode;
    })();

    exports.LabelOpcode = LabelOpcode;
});

enifed('@glimmer/runtime/lib/compiler', ['exports', '@glimmer/runtime/lib/compiled/blocks', '@glimmer/runtime/lib/scanner', '@glimmer/runtime/lib/syntax/functions', '@glimmer/runtime/lib/compiled/opcodes/builder'], function (exports, _glimmerRuntimeLibCompiledBlocks, _glimmerRuntimeLibScanner, _glimmerRuntimeLibSyntaxFunctions, _glimmerRuntimeLibCompiledOpcodesBuilder) {
    'use strict';

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    exports.compileLayout = compileLayout;
    exports.builder = builder;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function compileLayout(compilable, env) {
        var builder = new ComponentLayoutBuilder(env);
        compilable.compile(builder);
        return builder.compile();
    }

    var ComponentLayoutBuilder = (function () {
        function ComponentLayoutBuilder(env) {
            _classCallCheck(this, ComponentLayoutBuilder);

            this.env = env;
        }

        ComponentLayoutBuilder.prototype.wrapLayout = function wrapLayout(layout) {
            this.inner = new WrappedBuilder(this.env, layout);
        };

        ComponentLayoutBuilder.prototype.fromLayout = function fromLayout(layout) {
            this.inner = new UnwrappedBuilder(this.env, layout);
        };

        ComponentLayoutBuilder.prototype.compile = function compile() {
            return this.inner.compile();
        };

        _createClass(ComponentLayoutBuilder, [{
            key: 'tag',
            get: function () {
                return this.inner.tag;
            }
        }, {
            key: 'attrs',
            get: function () {
                return this.inner.attrs;
            }
        }]);

        return ComponentLayoutBuilder;
    })();

    var WrappedBuilder = (function () {
        function WrappedBuilder(env, layout) {
            _classCallCheck(this, WrappedBuilder);

            this.env = env;
            this.layout = layout;
            this.tag = new ComponentTagBuilder();
            this.attrs = new ComponentAttrsBuilder();
        }

        WrappedBuilder.prototype.compile = function compile() {
            //========DYNAMIC
            //        PutValue(TagExpr)
            //        Test
            //        JumpUnless(BODY)
            //        OpenDynamicPrimitiveElement
            //        DidCreateElement
            //        ...attr statements...
            //        FlushElement
            // BODY:  Noop
            //        ...body statements...
            //        PutValue(TagExpr)
            //        Test
            //        JumpUnless(END)
            //        CloseElement
            // END:   Noop
            //        DidRenderLayout
            //        Exit
            //
            //========STATIC
            //        OpenPrimitiveElementOpcode
            //        DidCreateElement
            //        ...attr statements...
            //        FlushElement
            //        ...body statements...
            //        CloseElement
            //        DidRenderLayout
            //        Exit
            var env = this.env;
            var layout = this.layout;

            var symbolTable = layout.symbolTable;
            var b = builder(env, layout.symbolTable);
            b.startLabels();
            var dynamicTag = this.tag.getDynamic();
            var staticTag = undefined;
            if (dynamicTag) {
                b.putValue(dynamicTag);
                b.test('simple');
                b.jumpUnless('BODY');
                b.openDynamicPrimitiveElement();
                b.didCreateElement();
                this.attrs['buffer'].forEach(function (statement) {
                    return _glimmerRuntimeLibScanner.compileStatement(statement, b);
                });
                b.flushElement();
                b.label('BODY');
            } else if (staticTag = this.tag.getStatic()) {
                b.openPrimitiveElement(staticTag);
                b.didCreateElement();
                this.attrs['buffer'].forEach(function (statement) {
                    return _glimmerRuntimeLibScanner.compileStatement(statement, b);
                });
                b.flushElement();
            }
            b.preludeForLayout(layout);
            layout.statements.forEach(function (statement) {
                return _glimmerRuntimeLibScanner.compileStatement(statement, b);
            });
            if (dynamicTag) {
                b.putValue(dynamicTag);
                b.test('simple');
                b.jumpUnless('END');
                b.closeElement();
                b.label('END');
            } else if (staticTag) {
                b.closeElement();
            }
            b.didRenderLayout();
            b.stopLabels();
            return new _glimmerRuntimeLibCompiledBlocks.CompiledProgram(b.toSlice(), symbolTable.size);
        };

        return WrappedBuilder;
    })();

    function isOpenElement(value) {
        var type = value[0];
        return type === 'open-element' || type === 'open-primitive-element';
    }

    var UnwrappedBuilder = (function () {
        function UnwrappedBuilder(env, layout) {
            _classCallCheck(this, UnwrappedBuilder);

            this.env = env;
            this.layout = layout;
            this.attrs = new ComponentAttrsBuilder();
        }

        UnwrappedBuilder.prototype.compile = function compile() {
            var env = this.env;
            var layout = this.layout;

            var b = builder(env, layout.symbolTable);
            b.startLabels();
            b.preludeForLayout(layout);
            var attrs = this.attrs['buffer'];
            var attrsInserted = false;
            for (var i = 0; i < layout.statements.length; i++) {
                var statement = layout.statements[i];
                if (!attrsInserted && isOpenElement(statement)) {
                    b.openComponentElement(statement[1]);
                    b.didCreateElement();
                    b.shadowAttributes();
                    attrs.forEach(function (statement) {
                        return _glimmerRuntimeLibScanner.compileStatement(statement, b);
                    });
                    attrsInserted = true;
                } else {
                    _glimmerRuntimeLibScanner.compileStatement(statement, b);
                }
            }
            b.didRenderLayout();
            b.stopLabels();
            return new _glimmerRuntimeLibCompiledBlocks.CompiledProgram(b.toSlice(), layout.symbolTable.size);
        };

        _createClass(UnwrappedBuilder, [{
            key: 'tag',
            get: function () {
                throw new Error('BUG: Cannot call `tag` on an UnwrappedBuilder');
            }
        }]);

        return UnwrappedBuilder;
    })();

    var ComponentTagBuilder = (function () {
        function ComponentTagBuilder() {
            _classCallCheck(this, ComponentTagBuilder);

            this.isDynamic = null;
            this.isStatic = null;
            this.staticTagName = null;
            this.dynamicTagName = null;
        }

        ComponentTagBuilder.prototype.getDynamic = function getDynamic() {
            if (this.isDynamic) {
                return this.dynamicTagName;
            }
        };

        ComponentTagBuilder.prototype.getStatic = function getStatic() {
            if (this.isStatic) {
                return this.staticTagName;
            }
        };

        ComponentTagBuilder.prototype.static = function _static(tagName) {
            this.isStatic = true;
            this.staticTagName = tagName;
        };

        ComponentTagBuilder.prototype.dynamic = function dynamic(tagName) {
            this.isDynamic = true;
            this.dynamicTagName = ['function', tagName];
        };

        return ComponentTagBuilder;
    })();

    var ComponentAttrsBuilder = (function () {
        function ComponentAttrsBuilder() {
            _classCallCheck(this, ComponentAttrsBuilder);

            this.buffer = [];
        }

        ComponentAttrsBuilder.prototype.static = function _static(name, value) {
            this.buffer.push(['static-attr', name, value, null]);
        };

        ComponentAttrsBuilder.prototype.dynamic = function dynamic(name, value) {
            this.buffer.push(['dynamic-attr', name, ['function', value], null]);
        };

        return ComponentAttrsBuilder;
    })();

    var ComponentBuilder = (function () {
        function ComponentBuilder(builder) {
            _classCallCheck(this, ComponentBuilder);

            this.builder = builder;
            this.env = builder.env;
        }

        ComponentBuilder.prototype.static = function _static(definition, args, _symbolTable, shadow) {
            this.builder.unit(function (b) {
                b.putComponentDefinition(definition);
                b.openComponent(_glimmerRuntimeLibSyntaxFunctions.compileBaselineArgs(args, b), shadow);
                b.closeComponent();
            });
        };

        ComponentBuilder.prototype.dynamic = function dynamic(definitionArgs, definition, args, _symbolTable, shadow) {
            this.builder.unit(function (b) {
                b.putArgs(_glimmerRuntimeLibSyntaxFunctions.compileArgs(definitionArgs[0], definitionArgs[1], b));
                b.putValue(['function', definition]);
                b.test('simple');
                b.enter('BEGIN', 'END');
                b.label('BEGIN');
                b.jumpUnless('END');
                b.putDynamicComponentDefinition();
                b.openComponent(_glimmerRuntimeLibSyntaxFunctions.compileBaselineArgs(args, b), shadow);
                b.closeComponent();
                b.label('END');
                b.exit();
            });
        };

        return ComponentBuilder;
    })();

    exports.ComponentBuilder = ComponentBuilder;

    function builder(env, symbolTable) {
        return new _glimmerRuntimeLibCompiledOpcodesBuilder.default(symbolTable, env);
    }
});

enifed('@glimmer/runtime/lib/component/interfaces', ['exports'], function (exports) {
    'use strict';

    exports.isComponentDefinition = isComponentDefinition;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var COMPONENT_DEFINITION_BRAND = 'COMPONENT DEFINITION [id=e59c754e-61eb-4392-8c4a-2c0ac72bfcd4]';

    function isComponentDefinition(obj) {
        return typeof obj === 'object' && obj && obj[COMPONENT_DEFINITION_BRAND];
    }

    var ComponentDefinition = function ComponentDefinition(name, manager, ComponentClass) {
        _classCallCheck(this, ComponentDefinition);

        this[COMPONENT_DEFINITION_BRAND] = true;
        this.name = name;
        this.manager = manager;
        this.ComponentClass = ComponentClass;
    };

    exports.ComponentDefinition = ComponentDefinition;
});

enifed('@glimmer/runtime/lib/dom/attribute-managers', ['exports', '@glimmer/runtime/lib/dom/sanitized-values', '@glimmer/runtime/lib/dom/props', '@glimmer/runtime/lib/dom/helper', '@glimmer/runtime/lib/compiled/opcodes/content'], function (exports, _glimmerRuntimeLibDomSanitizedValues, _glimmerRuntimeLibDomProps, _glimmerRuntimeLibDomHelper, _glimmerRuntimeLibCompiledOpcodesContent) {
    'use strict';

    exports.defaultManagers = defaultManagers;
    exports.defaultPropertyManagers = defaultPropertyManagers;
    exports.defaultAttributeManagers = defaultAttributeManagers;
    exports.readDOMAttr = readDOMAttr;

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function defaultManagers(element, attr, _isTrusting, _namespace) {
        var tagName = element.tagName;
        var isSVG = element.namespaceURI === _glimmerRuntimeLibDomHelper.SVG_NAMESPACE;
        if (isSVG) {
            return defaultAttributeManagers(tagName, attr);
        }

        var _normalizeProperty = _glimmerRuntimeLibDomProps.normalizeProperty(element, attr);

        var type = _normalizeProperty.type;
        var normalized = _normalizeProperty.normalized;

        if (type === 'attr') {
            return defaultAttributeManagers(tagName, normalized);
        } else {
            return defaultPropertyManagers(tagName, normalized);
        }
    }

    function defaultPropertyManagers(tagName, attr) {
        if (_glimmerRuntimeLibDomSanitizedValues.requiresSanitization(tagName, attr)) {
            return new SafePropertyManager(attr);
        }
        if (isUserInputValue(tagName, attr)) {
            return INPUT_VALUE_PROPERTY_MANAGER;
        }
        if (isOptionSelected(tagName, attr)) {
            return OPTION_SELECTED_MANAGER;
        }
        return new PropertyManager(attr);
    }

    function defaultAttributeManagers(tagName, attr) {
        if (_glimmerRuntimeLibDomSanitizedValues.requiresSanitization(tagName, attr)) {
            return new SafeAttributeManager(attr);
        }
        return new AttributeManager(attr);
    }

    function readDOMAttr(element, attr) {
        var isSVG = element.namespaceURI === _glimmerRuntimeLibDomHelper.SVG_NAMESPACE;

        var _normalizeProperty2 = _glimmerRuntimeLibDomProps.normalizeProperty(element, attr);

        var type = _normalizeProperty2.type;
        var normalized = _normalizeProperty2.normalized;

        if (isSVG) {
            return element.getAttribute(normalized);
        }
        if (type === 'attr') {
            return element.getAttribute(normalized);
        }
        {
            return element[normalized];
        }
    }

    ;

    var AttributeManager = (function () {
        function AttributeManager(attr) {
            _classCallCheck(this, AttributeManager);

            this.attr = attr;
        }

        AttributeManager.prototype.setAttribute = function setAttribute(env, element, value, namespace) {
            var dom = env.getAppendOperations();
            var normalizedValue = normalizeAttributeValue(value);
            if (!isAttrRemovalValue(normalizedValue)) {
                dom.setAttribute(element, this.attr, normalizedValue, namespace);
            }
        };

        AttributeManager.prototype.updateAttribute = function updateAttribute(env, element, value, namespace) {
            if (value === null || value === undefined || value === false) {
                if (namespace) {
                    env.getDOM().removeAttributeNS(element, namespace, this.attr);
                } else {
                    env.getDOM().removeAttribute(element, this.attr);
                }
            } else {
                this.setAttribute(env, element, value);
            }
        };

        return AttributeManager;
    })();

    exports.AttributeManager = AttributeManager;

    ;

    var PropertyManager = (function (_AttributeManager) {
        _inherits(PropertyManager, _AttributeManager);

        function PropertyManager() {
            _classCallCheck(this, PropertyManager);

            _AttributeManager.apply(this, arguments);
        }

        PropertyManager.prototype.setAttribute = function setAttribute(_env, element, value, _namespace) {
            if (!isAttrRemovalValue(value)) {
                element[this.attr] = value;
            }
        };

        PropertyManager.prototype.removeAttribute = function removeAttribute(env, element, namespace) {
            // TODO this sucks but to preserve properties first and to meet current
            // semantics we must do this.
            var attr = this.attr;

            if (namespace) {
                env.getDOM().removeAttributeNS(element, namespace, attr);
            } else {
                env.getDOM().removeAttribute(element, attr);
            }
        };

        PropertyManager.prototype.updateAttribute = function updateAttribute(env, element, value, namespace) {
            // ensure the property is always updated
            element[this.attr] = value;
            if (isAttrRemovalValue(value)) {
                this.removeAttribute(env, element, namespace);
            }
        };

        return PropertyManager;
    })(AttributeManager);

    exports.PropertyManager = PropertyManager;

    ;
    function normalizeAttributeValue(value) {
        if (value === false || value === undefined || value === null) {
            return null;
        }
        if (value === true) {
            return '';
        }
        // onclick function etc in SSR
        if (typeof value === 'function') {
            return null;
        }
        return String(value);
    }
    function isAttrRemovalValue(value) {
        return value === null || value === undefined;
    }

    var SafePropertyManager = (function (_PropertyManager) {
        _inherits(SafePropertyManager, _PropertyManager);

        function SafePropertyManager() {
            _classCallCheck(this, SafePropertyManager);

            _PropertyManager.apply(this, arguments);
        }

        SafePropertyManager.prototype.setAttribute = function setAttribute(env, element, value) {
            _PropertyManager.prototype.setAttribute.call(this, env, element, _glimmerRuntimeLibDomSanitizedValues.sanitizeAttributeValue(env, element, this.attr, value));
        };

        SafePropertyManager.prototype.updateAttribute = function updateAttribute(env, element, value) {
            _PropertyManager.prototype.updateAttribute.call(this, env, element, _glimmerRuntimeLibDomSanitizedValues.sanitizeAttributeValue(env, element, this.attr, value));
        };

        return SafePropertyManager;
    })(PropertyManager);

    function isUserInputValue(tagName, attribute) {
        return (tagName === 'INPUT' || tagName === 'TEXTAREA') && attribute === 'value';
    }

    var InputValuePropertyManager = (function (_AttributeManager2) {
        _inherits(InputValuePropertyManager, _AttributeManager2);

        function InputValuePropertyManager() {
            _classCallCheck(this, InputValuePropertyManager);

            _AttributeManager2.apply(this, arguments);
        }

        InputValuePropertyManager.prototype.setAttribute = function setAttribute(_env, element, value) {
            var input = element;
            input.value = _glimmerRuntimeLibCompiledOpcodesContent.normalizeTextValue(value);
        };

        InputValuePropertyManager.prototype.updateAttribute = function updateAttribute(_env, element, value) {
            var input = element;
            var currentValue = input.value;
            var normalizedValue = _glimmerRuntimeLibCompiledOpcodesContent.normalizeTextValue(value);
            if (currentValue !== normalizedValue) {
                input.value = normalizedValue;
            }
        };

        return InputValuePropertyManager;
    })(AttributeManager);

    var INPUT_VALUE_PROPERTY_MANAGER = new InputValuePropertyManager('value');
    exports.INPUT_VALUE_PROPERTY_MANAGER = INPUT_VALUE_PROPERTY_MANAGER;
    function isOptionSelected(tagName, attribute) {
        return tagName === 'OPTION' && attribute === 'selected';
    }

    var OptionSelectedManager = (function (_PropertyManager2) {
        _inherits(OptionSelectedManager, _PropertyManager2);

        function OptionSelectedManager() {
            _classCallCheck(this, OptionSelectedManager);

            _PropertyManager2.apply(this, arguments);
        }

        OptionSelectedManager.prototype.setAttribute = function setAttribute(_env, element, value) {
            if (value !== null && value !== undefined && value !== false) {
                var option = element;
                option.selected = true;
            }
        };

        OptionSelectedManager.prototype.updateAttribute = function updateAttribute(_env, element, value) {
            var option = element;
            if (value) {
                option.selected = true;
            } else {
                option.selected = false;
            }
        };

        return OptionSelectedManager;
    })(PropertyManager);

    var OPTION_SELECTED_MANAGER = new OptionSelectedManager('selected');
    exports.OPTION_SELECTED_MANAGER = OPTION_SELECTED_MANAGER;

    var SafeAttributeManager = (function (_AttributeManager3) {
        _inherits(SafeAttributeManager, _AttributeManager3);

        function SafeAttributeManager() {
            _classCallCheck(this, SafeAttributeManager);

            _AttributeManager3.apply(this, arguments);
        }

        SafeAttributeManager.prototype.setAttribute = function setAttribute(env, element, value) {
            _AttributeManager3.prototype.setAttribute.call(this, env, element, _glimmerRuntimeLibDomSanitizedValues.sanitizeAttributeValue(env, element, this.attr, value));
        };

        SafeAttributeManager.prototype.updateAttribute = function updateAttribute(env, element, value, _namespace) {
            _AttributeManager3.prototype.updateAttribute.call(this, env, element, _glimmerRuntimeLibDomSanitizedValues.sanitizeAttributeValue(env, element, this.attr, value));
        };

        return SafeAttributeManager;
    })(AttributeManager);
});

enifed('@glimmer/runtime/lib/dom/helper', ['exports', '@glimmer/runtime/lib/bounds', '@glimmer/runtime/lib/compat/inner-html-fix', '@glimmer/runtime/lib/compat/svg-inner-html-fix', '@glimmer/runtime/lib/compat/text-node-merging-fix', '@glimmer/runtime/lib/dom/interfaces'], function (exports, _glimmerRuntimeLibBounds, _glimmerRuntimeLibCompatInnerHtmlFix, _glimmerRuntimeLibCompatSvgInnerHtmlFix, _glimmerRuntimeLibCompatTextNodeMergingFix, _glimmerRuntimeLibDomInterfaces) {
    'use strict';

    exports.isWhitespace = isWhitespace;
    exports.moveNodesBefore = moveNodesBefore;
    exports.insertHTMLBefore = _insertHTMLBefore;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    exports.SVG_NAMESPACE = SVG_NAMESPACE;
    // http://www.w3.org/TR/html/syntax.html#html-integration-point
    var SVG_INTEGRATION_POINTS = { foreignObject: 1, desc: 1, title: 1 };
    // http://www.w3.org/TR/html/syntax.html#adjust-svg-attributes
    // TODO: Adjust SVG attributes
    // http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign
    // TODO: Adjust SVG elements
    // http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign
    var BLACKLIST_TABLE = Object.create(null);
    exports.BLACKLIST_TABLE = BLACKLIST_TABLE;
    ["b", "big", "blockquote", "body", "br", "center", "code", "dd", "div", "dl", "dt", "em", "embed", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "i", "img", "li", "listing", "main", "meta", "nobr", "ol", "p", "pre", "ruby", "s", "small", "span", "strong", "strike", "sub", "sup", "table", "tt", "u", "ul", "var"].forEach(function (tag) {
        return BLACKLIST_TABLE[tag] = 1;
    });
    var WHITESPACE = /[\t-\r \xA0\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]/;
    var doc = typeof document === 'undefined' ? null : document;

    function isWhitespace(string) {
        return WHITESPACE.test(string);
    }

    function moveNodesBefore(source, target, nextSibling) {
        var first = source.firstChild;
        var last = null;
        var current = first;
        while (current) {
            last = current;
            current = current.nextSibling;
            target.insertBefore(last, nextSibling);
        }
        return [first, last];
    }

    var DOM;
    exports.DOM = DOM;
    (function (DOM) {
        var TreeConstruction = (function () {
            function TreeConstruction(document) {
                _classCallCheck(this, TreeConstruction);

                this.document = document;
                this.setupUselessElement();
            }

            TreeConstruction.prototype.setupUselessElement = function setupUselessElement() {
                this.uselessElement = this.document.createElement('div');
            };

            TreeConstruction.prototype.createElement = function createElement(tag, context) {
                var isElementInSVGNamespace = undefined,
                    isHTMLIntegrationPoint = undefined;
                if (context) {
                    isElementInSVGNamespace = context.namespaceURI === SVG_NAMESPACE || tag === 'svg';
                    isHTMLIntegrationPoint = SVG_INTEGRATION_POINTS[context.tagName];
                } else {
                    isElementInSVGNamespace = tag === 'svg';
                    isHTMLIntegrationPoint = false;
                }
                if (isElementInSVGNamespace && !isHTMLIntegrationPoint) {
                    // FIXME: This does not properly handle <font> with color, face, or
                    // size attributes, which is also disallowed by the spec. We should fix
                    // this.
                    if (BLACKLIST_TABLE[tag]) {
                        throw new Error('Cannot create a ' + tag + ' inside an SVG context');
                    }
                    return this.document.createElementNS(SVG_NAMESPACE, tag);
                } else {
                    return this.document.createElement(tag);
                }
            };

            TreeConstruction.prototype.createElementNS = function createElementNS(namespace, tag) {
                return this.document.createElementNS(namespace, tag);
            };

            TreeConstruction.prototype.setAttribute = function setAttribute(element, name, value, namespace) {
                if (namespace) {
                    element.setAttributeNS(namespace, name, value);
                } else {
                    element.setAttribute(name, value);
                }
            };

            TreeConstruction.prototype.createTextNode = function createTextNode(text) {
                return this.document.createTextNode(text);
            };

            TreeConstruction.prototype.createComment = function createComment(data) {
                return this.document.createComment(data);
            };

            TreeConstruction.prototype.insertBefore = function insertBefore(parent, node, reference) {
                parent.insertBefore(node, reference);
            };

            TreeConstruction.prototype.insertHTMLBefore = function insertHTMLBefore(parent, html, reference) {
                return _insertHTMLBefore(this.uselessElement, parent, reference, html);
            };

            return TreeConstruction;
        })();

        DOM.TreeConstruction = TreeConstruction;
        var appliedTreeContruction = TreeConstruction;
        appliedTreeContruction = _glimmerRuntimeLibCompatTextNodeMergingFix.treeConstruction(doc, appliedTreeContruction);
        appliedTreeContruction = _glimmerRuntimeLibCompatInnerHtmlFix.treeConstruction(doc, appliedTreeContruction);
        appliedTreeContruction = _glimmerRuntimeLibCompatSvgInnerHtmlFix.treeConstruction(doc, appliedTreeContruction, SVG_NAMESPACE);
        DOM.DOMTreeConstruction = appliedTreeContruction;
    })(DOM || (exports.DOM = DOM = {}));

    var DOMChanges = (function () {
        function DOMChanges(document) {
            _classCallCheck(this, DOMChanges);

            this.document = document;
            this.namespace = null;
            this.uselessElement = this.document.createElement('div');
        }

        DOMChanges.prototype.setAttribute = function setAttribute(element, name, value) {
            element.setAttribute(name, value);
        };

        DOMChanges.prototype.setAttributeNS = function setAttributeNS(element, namespace, name, value) {
            element.setAttributeNS(namespace, name, value);
        };

        DOMChanges.prototype.removeAttribute = function removeAttribute(element, name) {
            element.removeAttribute(name);
        };

        DOMChanges.prototype.removeAttributeNS = function removeAttributeNS(element, namespace, name) {
            element.removeAttributeNS(namespace, name);
        };

        DOMChanges.prototype.createTextNode = function createTextNode(text) {
            return this.document.createTextNode(text);
        };

        DOMChanges.prototype.createComment = function createComment(data) {
            return this.document.createComment(data);
        };

        DOMChanges.prototype.createElement = function createElement(tag, context) {
            var isElementInSVGNamespace = undefined,
                isHTMLIntegrationPoint = undefined;
            if (context) {
                isElementInSVGNamespace = context.namespaceURI === SVG_NAMESPACE || tag === 'svg';
                isHTMLIntegrationPoint = SVG_INTEGRATION_POINTS[context.tagName];
            } else {
                isElementInSVGNamespace = tag === 'svg';
                isHTMLIntegrationPoint = false;
            }
            if (isElementInSVGNamespace && !isHTMLIntegrationPoint) {
                // FIXME: This does not properly handle <font> with color, face, or
                // size attributes, which is also disallowed by the spec. We should fix
                // this.
                if (BLACKLIST_TABLE[tag]) {
                    throw new Error('Cannot create a ' + tag + ' inside an SVG context');
                }
                return this.document.createElementNS(SVG_NAMESPACE, tag);
            } else {
                return this.document.createElement(tag);
            }
        };

        DOMChanges.prototype.insertHTMLBefore = function insertHTMLBefore(_parent, nextSibling, html) {
            return _insertHTMLBefore(this.uselessElement, _parent, nextSibling, html);
        };

        DOMChanges.prototype.insertNodeBefore = function insertNodeBefore(parent, node, reference) {
            if (isDocumentFragment(node)) {
                var firstChild = node.firstChild;
                var lastChild = node.lastChild;

                this.insertBefore(parent, node, reference);
                return new _glimmerRuntimeLibBounds.ConcreteBounds(parent, firstChild, lastChild);
            } else {
                this.insertBefore(parent, node, reference);
                return new _glimmerRuntimeLibBounds.SingleNodeBounds(parent, node);
            }
        };

        DOMChanges.prototype.insertTextBefore = function insertTextBefore(parent, nextSibling, text) {
            var textNode = this.createTextNode(text);
            this.insertBefore(parent, textNode, nextSibling);
            return textNode;
        };

        DOMChanges.prototype.insertBefore = function insertBefore(element, node, reference) {
            element.insertBefore(node, reference);
        };

        DOMChanges.prototype.insertAfter = function insertAfter(element, node, reference) {
            this.insertBefore(element, node, reference.nextSibling);
        };

        return DOMChanges;
    })();

    exports.DOMChanges = DOMChanges;

    function _insertHTMLBefore(_useless, _parent, _nextSibling, html) {
        // TypeScript vendored an old version of the DOM spec where `insertAdjacentHTML`
        // only exists on `HTMLElement` but not on `Element`. We actually work with the
        // newer version of the DOM API here (and monkey-patch this method in `./compat`
        // when we detect older browsers). This is a hack to work around this limitation.
        var parent = _parent;
        var useless = _useless;
        var nextSibling = _nextSibling;
        var prev = nextSibling ? nextSibling.previousSibling : parent.lastChild;
        var last = undefined;
        if (html === null || html === '') {
            return new _glimmerRuntimeLibBounds.ConcreteBounds(parent, null, null);
        }
        if (nextSibling === null) {
            parent.insertAdjacentHTML('beforeEnd', html);
            last = parent.lastChild;
        } else if (nextSibling instanceof HTMLElement) {
            nextSibling.insertAdjacentHTML('beforeBegin', html);
            last = nextSibling.previousSibling;
        } else {
            // Non-element nodes do not support insertAdjacentHTML, so add an
            // element and call it on that element. Then remove the element.
            //
            // This also protects Edge, IE and Firefox w/o the inspector open
            // from merging adjacent text nodes. See ./compat/text-node-merging-fix.ts
            parent.insertBefore(useless, nextSibling);
            useless.insertAdjacentHTML('beforeBegin', html);
            last = useless.previousSibling;
            parent.removeChild(useless);
        }
        var first = prev ? prev.nextSibling : parent.firstChild;
        return new _glimmerRuntimeLibBounds.ConcreteBounds(parent, first, last);
    }

    function isDocumentFragment(node) {
        return node.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
    }
    var helper = DOMChanges;
    helper = _glimmerRuntimeLibCompatTextNodeMergingFix.domChanges(doc, helper);
    helper = _glimmerRuntimeLibCompatInnerHtmlFix.domChanges(doc, helper);
    helper = _glimmerRuntimeLibCompatSvgInnerHtmlFix.domChanges(doc, helper, SVG_NAMESPACE);
    exports.default = helper;
    var DOMTreeConstruction = DOM.DOMTreeConstruction;
    exports.DOMTreeConstruction = DOMTreeConstruction;
    exports.DOMNamespace = _glimmerRuntimeLibDomInterfaces.Namespace;
});

enifed("@glimmer/runtime/lib/dom/interfaces", ["exports"], function (exports) {
    "use strict";

    var NodeType;
    exports.NodeType = NodeType;
    (function (NodeType) {
        NodeType[NodeType["Element"] = 0] = "Element";
        NodeType[NodeType["Attribute"] = 1] = "Attribute";
        NodeType[NodeType["Text"] = 2] = "Text";
        NodeType[NodeType["CdataSection"] = 3] = "CdataSection";
        NodeType[NodeType["EntityReference"] = 4] = "EntityReference";
        NodeType[NodeType["Entity"] = 5] = "Entity";
        NodeType[NodeType["ProcessingInstruction"] = 6] = "ProcessingInstruction";
        NodeType[NodeType["Comment"] = 7] = "Comment";
        NodeType[NodeType["Document"] = 8] = "Document";
        NodeType[NodeType["DocumentType"] = 9] = "DocumentType";
        NodeType[NodeType["DocumentFragment"] = 10] = "DocumentFragment";
        NodeType[NodeType["Notation"] = 11] = "Notation";
    })(NodeType || (exports.NodeType = NodeType = {}));
});

enifed('@glimmer/runtime/lib/dom/props', ['exports'], function (exports) {
    /*
     * @method normalizeProperty
     * @param element {HTMLElement}
     * @param slotName {String}
     * @returns {Object} { name, type }
     */
    'use strict';

    exports.normalizeProperty = normalizeProperty;
    exports.normalizePropertyValue = normalizePropertyValue;

    function normalizeProperty(element, slotName) {
        var type = undefined,
            normalized = undefined;
        if (slotName in element) {
            normalized = slotName;
            type = 'prop';
        } else {
            var lower = slotName.toLowerCase();
            if (lower in element) {
                type = 'prop';
                normalized = lower;
            } else {
                type = 'attr';
                normalized = slotName;
            }
        }
        if (type === 'prop' && (normalized.toLowerCase() === 'style' || preferAttr(element.tagName, normalized))) {
            type = 'attr';
        }
        return { normalized: normalized, type: type };
    }

    function normalizePropertyValue(value) {
        if (value === '') {
            return true;
        }
        return value;
    }

    // properties that MUST be set as attributes, due to:
    // * browser bug
    // * strange spec outlier
    var ATTR_OVERRIDES = {
        // phantomjs < 2.0 lets you set it as a prop but won't reflect it
        // back to the attribute. button.getAttribute('type') === null
        BUTTON: { type: true, form: true },
        INPUT: {
            // Some version of IE (like IE9) actually throw an exception
            // if you set input.type = 'something-unknown'
            type: true,
            form: true,
            // Chrome 46.0.2464.0: 'autocorrect' in document.createElement('input') === false
            // Safari 8.0.7: 'autocorrect' in document.createElement('input') === false
            // Mobile Safari (iOS 8.4 simulator): 'autocorrect' in document.createElement('input') === true
            autocorrect: true,
            // Chrome 54.0.2840.98: 'list' in document.createElement('input') === true
            // Safari 9.1.3: 'list' in document.createElement('input') === false
            list: true
        },
        // element.form is actually a legitimate readOnly property, that is to be
        // mutated, but must be mutated by setAttribute...
        SELECT: { form: true },
        OPTION: { form: true },
        TEXTAREA: { form: true },
        LABEL: { form: true },
        FIELDSET: { form: true },
        LEGEND: { form: true },
        OBJECT: { form: true }
    };
    function preferAttr(tagName, propName) {
        var tag = ATTR_OVERRIDES[tagName.toUpperCase()];
        return tag && tag[propName.toLowerCase()] || false;
    }
});

enifed('@glimmer/runtime/lib/dom/sanitized-values', ['exports', '@glimmer/runtime/lib/compiled/opcodes/content', '@glimmer/runtime/lib/upsert'], function (exports, _glimmerRuntimeLibCompiledOpcodesContent, _glimmerRuntimeLibUpsert) {
    'use strict';

    exports.requiresSanitization = requiresSanitization;
    exports.sanitizeAttributeValue = sanitizeAttributeValue;

    var badProtocols = ['javascript:', 'vbscript:'];
    var badTags = ['A', 'BODY', 'LINK', 'IMG', 'IFRAME', 'BASE', 'FORM'];
    var badTagsForDataURI = ['EMBED'];
    var badAttributes = ['href', 'src', 'background', 'action'];
    var badAttributesForDataURI = ['src'];
    function has(array, item) {
        return array.indexOf(item) !== -1;
    }
    function checkURI(tagName, attribute) {
        return (tagName === null || has(badTags, tagName)) && has(badAttributes, attribute);
    }
    function checkDataURI(tagName, attribute) {
        if (tagName === null) return false;
        return has(badTagsForDataURI, tagName) && has(badAttributesForDataURI, attribute);
    }

    function requiresSanitization(tagName, attribute) {
        return checkURI(tagName, attribute) || checkDataURI(tagName, attribute);
    }

    function sanitizeAttributeValue(env, element, attribute, value) {
        var tagName = null;
        if (value === null || value === undefined) {
            return value;
        }
        if (_glimmerRuntimeLibUpsert.isSafeString(value)) {
            return value.toHTML();
        }
        if (!element) {
            tagName = null;
        } else {
            tagName = element.tagName.toUpperCase();
        }
        var str = _glimmerRuntimeLibCompiledOpcodesContent.normalizeTextValue(value);
        if (checkURI(tagName, attribute)) {
            var protocol = env.protocolForURL(str);
            if (has(badProtocols, protocol)) {
                return 'unsafe:' + str;
            }
        }
        if (checkDataURI(tagName, attribute)) {
            return 'unsafe:' + str;
        }
        return str;
    }
});

enifed('@glimmer/runtime/lib/environment', ['exports', '@glimmer/util', '@glimmer/runtime/lib/syntax/functions', '@glimmer/runtime/lib/opcodes', '@glimmer/runtime/lib/references', '@glimmer/runtime/lib/dom/attribute-managers'], function (exports, _glimmerUtil, _glimmerRuntimeLibSyntaxFunctions, _glimmerRuntimeLibOpcodes, _glimmerRuntimeLibReferences, _glimmerRuntimeLibDomAttributeManagers) {
    'use strict';

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var Scope = (function () {
        function Scope(references) {
            var callerScope = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

            _classCallCheck(this, Scope);

            this.callerScope = null;
            this.slots = references;
            this.callerScope = callerScope;
        }

        Scope.root = function root(self) {
            var size = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

            var refs = new Array(size + 1);
            for (var i = 0; i <= size; i++) {
                refs[i] = _glimmerRuntimeLibReferences.UNDEFINED_REFERENCE;
            }
            return new Scope(refs).init({ self: self });
        };

        Scope.prototype.init = function init(_ref) {
            var self = _ref.self;

            this.slots[0] = self;
            return this;
        };

        Scope.prototype.getSelf = function getSelf() {
            return this.slots[0];
        };

        Scope.prototype.getSymbol = function getSymbol(symbol) {
            return this.slots[symbol];
        };

        Scope.prototype.getBlock = function getBlock(symbol) {
            return this.slots[symbol];
        };

        Scope.prototype.getPartialArgs = function getPartialArgs(symbol) {
            return this.slots[symbol];
        };

        Scope.prototype.bindSymbol = function bindSymbol(symbol, value) {
            this.slots[symbol] = value;
        };

        Scope.prototype.bindBlock = function bindBlock(symbol, value) {
            this.slots[symbol] = value;
        };

        Scope.prototype.bindPartialArgs = function bindPartialArgs(symbol, value) {
            this.slots[symbol] = value;
        };

        Scope.prototype.bindCallerScope = function bindCallerScope(scope) {
            this.callerScope = scope;
        };

        Scope.prototype.getCallerScope = function getCallerScope() {
            return this.callerScope;
        };

        Scope.prototype.child = function child() {
            return new Scope(this.slots.slice(), this.callerScope);
        };

        return Scope;
    })();

    exports.Scope = Scope;

    var Transaction = (function () {
        function Transaction() {
            _classCallCheck(this, Transaction);

            this.scheduledInstallManagers = [];
            this.scheduledInstallModifiers = [];
            this.scheduledUpdateModifierManagers = [];
            this.scheduledUpdateModifiers = [];
            this.createdComponents = [];
            this.createdManagers = [];
            this.updatedComponents = [];
            this.updatedManagers = [];
            this.destructors = [];
        }

        Transaction.prototype.didCreate = function didCreate(component, manager) {
            this.createdComponents.push(component);
            this.createdManagers.push(manager);
        };

        Transaction.prototype.didUpdate = function didUpdate(component, manager) {
            this.updatedComponents.push(component);
            this.updatedManagers.push(manager);
        };

        Transaction.prototype.scheduleInstallModifier = function scheduleInstallModifier(modifier, manager) {
            this.scheduledInstallManagers.push(manager);
            this.scheduledInstallModifiers.push(modifier);
        };

        Transaction.prototype.scheduleUpdateModifier = function scheduleUpdateModifier(modifier, manager) {
            this.scheduledUpdateModifierManagers.push(manager);
            this.scheduledUpdateModifiers.push(modifier);
        };

        Transaction.prototype.didDestroy = function didDestroy(d) {
            this.destructors.push(d);
        };

        Transaction.prototype.commit = function commit() {
            var createdComponents = this.createdComponents;
            var createdManagers = this.createdManagers;

            for (var i = 0; i < createdComponents.length; i++) {
                var component = createdComponents[i];
                var manager = createdManagers[i];
                manager.didCreate(component);
            }
            var updatedComponents = this.updatedComponents;
            var updatedManagers = this.updatedManagers;

            for (var i = 0; i < updatedComponents.length; i++) {
                var component = updatedComponents[i];
                var manager = updatedManagers[i];
                manager.didUpdate(component);
            }
            var destructors = this.destructors;

            for (var i = 0; i < destructors.length; i++) {
                destructors[i].destroy();
            }
            var scheduledInstallManagers = this.scheduledInstallManagers;
            var scheduledInstallModifiers = this.scheduledInstallModifiers;

            for (var i = 0; i < scheduledInstallManagers.length; i++) {
                var manager = scheduledInstallManagers[i];
                var modifier = scheduledInstallModifiers[i];
                manager.install(modifier);
            }
            var scheduledUpdateModifierManagers = this.scheduledUpdateModifierManagers;
            var scheduledUpdateModifiers = this.scheduledUpdateModifiers;

            for (var i = 0; i < scheduledUpdateModifierManagers.length; i++) {
                var manager = scheduledUpdateModifierManagers[i];
                var modifier = scheduledUpdateModifiers[i];
                manager.update(modifier);
            }
        };

        return Transaction;
    })();

    var Opcode = (function () {
        function Opcode(array) {
            _classCallCheck(this, Opcode);

            this.array = array;
            this.offset = 0;
        }

        _createClass(Opcode, [{
            key: 'type',
            get: function () {
                return this.array[this.offset];
            }
        }, {
            key: 'op1',
            get: function () {
                return this.array[this.offset + 1];
            }
        }, {
            key: 'op2',
            get: function () {
                return this.array[this.offset + 2];
            }
        }, {
            key: 'op3',
            get: function () {
                return this.array[this.offset + 3];
            }
        }]);

        return Opcode;
    })();

    exports.Opcode = Opcode;

    var Program = (function () {
        function Program() {
            _classCallCheck(this, Program);

            this.opcodes = new _glimmerUtil.A(0x100000);
            this._offset = 0;
            this._opcode = new Opcode(this.opcodes);
        }

        Program.prototype.opcode = function opcode(offset) {
            this._opcode.offset = offset;
            return this._opcode;
        };

        Program.prototype.set = function set(pos, opcode) {
            var type = opcode[0];
            var op1 = opcode[1];
            var op2 = opcode[2];
            var op3 = opcode[3];

            this.opcodes[pos] = type;
            this.opcodes[pos + 1] = op1;
            this.opcodes[pos + 2] = op2;
            this.opcodes[pos + 3] = op3;
        };

        Program.prototype.push = function push(opcode) {
            var offset = this._offset;
            var type = opcode[0];
            var op1 = opcode[1];
            var op2 = opcode[2];
            var op3 = opcode[3];

            this.opcodes[this._offset++] = type;
            this.opcodes[this._offset++] = op1;
            this.opcodes[this._offset++] = op2;
            this.opcodes[this._offset++] = op3;
            return offset;
        };

        _createClass(Program, [{
            key: 'next',
            get: function () {
                return this._offset;
            }
        }, {
            key: 'current',
            get: function () {
                return this._offset - 4;
            }
        }]);

        return Program;
    })();

    exports.Program = Program;

    var Environment = (function () {
        function Environment(_ref2) {
            var appendOperations = _ref2.appendOperations;
            var updateOperations = _ref2.updateOperations;

            _classCallCheck(this, Environment);

            this._macros = null;
            this._transaction = null;
            this.constants = new _glimmerRuntimeLibOpcodes.Constants();
            this.program = new Program();
            this.appendOperations = appendOperations;
            this.updateOperations = updateOperations;
        }

        Environment.prototype.toConditionalReference = function toConditionalReference(reference) {
            return new _glimmerRuntimeLibReferences.ConditionalReference(reference);
        };

        Environment.prototype.getAppendOperations = function getAppendOperations() {
            return this.appendOperations;
        };

        Environment.prototype.getDOM = function getDOM() {
            return this.updateOperations;
        };

        Environment.prototype.getIdentity = function getIdentity(object) {
            return _glimmerUtil.ensureGuid(object) + '';
        };

        Environment.prototype.begin = function begin() {
            _glimmerUtil.assert(!this._transaction, 'Cannot start a nested transaction');
            this._transaction = new Transaction();
        };

        Environment.prototype.didCreate = function didCreate(component, manager) {
            this.transaction.didCreate(component, manager);
        };

        Environment.prototype.didUpdate = function didUpdate(component, manager) {
            this.transaction.didUpdate(component, manager);
        };

        Environment.prototype.scheduleInstallModifier = function scheduleInstallModifier(modifier, manager) {
            this.transaction.scheduleInstallModifier(modifier, manager);
        };

        Environment.prototype.scheduleUpdateModifier = function scheduleUpdateModifier(modifier, manager) {
            this.transaction.scheduleUpdateModifier(modifier, manager);
        };

        Environment.prototype.didDestroy = function didDestroy(d) {
            this.transaction.didDestroy(d);
        };

        Environment.prototype.commit = function commit() {
            this.transaction.commit();
            this._transaction = null;
        };

        Environment.prototype.attributeFor = function attributeFor(element, attr, isTrusting, namespace) {
            return _glimmerRuntimeLibDomAttributeManagers.defaultManagers(element, attr, isTrusting, namespace === undefined ? null : namespace);
        };

        Environment.prototype.macros = function macros() {
            var macros = this._macros;
            if (!macros) {
                this._macros = macros = _glimmerRuntimeLibSyntaxFunctions.populateBuiltins();
            }
            return macros;
        };

        _createClass(Environment, [{
            key: 'transaction',
            get: function () {
                return _glimmerUtil.expect(this._transaction, 'must be in a transaction');
            }
        }]);

        return Environment;
    })();

    exports.Environment = Environment;
    exports.default = Environment;
});

enifed('@glimmer/runtime/lib/helpers/get-dynamic-var', ['exports', '@glimmer/reference'], function (exports, _glimmerReference) {
    'use strict';

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var DynamicVarReference = (function () {
        function DynamicVarReference(scope, nameRef) {
            _classCallCheck(this, DynamicVarReference);

            this.scope = scope;
            this.nameRef = nameRef;
            var varTag = this.varTag = new _glimmerReference.UpdatableTag(_glimmerReference.CONSTANT_TAG);
            this.tag = _glimmerReference.combine([nameRef.tag, varTag]);
        }

        DynamicVarReference.prototype.value = function value() {
            return this.getVar().value();
        };

        DynamicVarReference.prototype.get = function get(key) {
            return this.getVar().get(key);
        };

        DynamicVarReference.prototype.getVar = function getVar() {
            var name = String(this.nameRef.value());
            var ref = this.scope.get(name);
            this.varTag.update(ref.tag);
            return ref;
        };

        return DynamicVarReference;
    })();

    function getDynamicVar(vm, args, _symbolTable) {
        var scope = vm.dynamicScope();
        var nameRef = args.positional.at(0);
        return new DynamicVarReference(scope, nameRef);
    }
    exports.default = getDynamicVar;
});

enifed("@glimmer/runtime/lib/modifier/interfaces", ["exports"], function (exports) {
  "use strict";
});

enifed("@glimmer/runtime/lib/opcode-builder", ["exports"], function (exports) {
  "use strict";
});

enifed('@glimmer/runtime/lib/opcodes', ['exports', '@glimmer/util', '@glimmer/runtime/lib/references'], function (exports, _glimmerUtil, _glimmerRuntimeLibReferences) {
    'use strict';

    exports.pretty = pretty;
    exports.defaultToJSON = defaultToJSON;
    exports.inspect = inspect;

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function pretty(json) {
        return json.type + '(' + (json.args ? json.args.join(', ') : '') + ')';
    }

    function defaultToJSON(opcode) {
        return { type: opcode[0] };
    }

    var OpcodeName;
    exports.OpcodeName = OpcodeName;
    (function (OpcodeName) {
        OpcodeName[OpcodeName["PushChildScope"] = 0] = "PushChildScope";
        OpcodeName[OpcodeName["PopScope"] = 1] = "PopScope";
        OpcodeName[OpcodeName["PushDynamicScope"] = 2] = "PushDynamicScope";
        OpcodeName[OpcodeName["PopDynamicScope"] = 3] = "PopDynamicScope";
        OpcodeName[OpcodeName["Put"] = 4] = "Put";
        OpcodeName[OpcodeName["EvaluatePut"] = 5] = "EvaluatePut";
        OpcodeName[OpcodeName["PutArgs"] = 6] = "PutArgs";
        OpcodeName[OpcodeName["BindPositionalArgs"] = 7] = "BindPositionalArgs";
        OpcodeName[OpcodeName["BindNamedArgs"] = 8] = "BindNamedArgs";
        OpcodeName[OpcodeName["BindBlocks"] = 9] = "BindBlocks";
        OpcodeName[OpcodeName["BindPartialArgs"] = 10] = "BindPartialArgs";
        OpcodeName[OpcodeName["BindCallerScope"] = 11] = "BindCallerScope";
        OpcodeName[OpcodeName["BindDynamicScope"] = 12] = "BindDynamicScope";
        OpcodeName[OpcodeName["Enter"] = 13] = "Enter";
        OpcodeName[OpcodeName["Exit"] = 14] = "Exit";
        OpcodeName[OpcodeName["Evaluate"] = 15] = "Evaluate";
        OpcodeName[OpcodeName["Jump"] = 16] = "Jump";
        OpcodeName[OpcodeName["JumpIf"] = 17] = "JumpIf";
        OpcodeName[OpcodeName["JumpUnless"] = 18] = "JumpUnless";
        OpcodeName[OpcodeName["Test"] = 19] = "Test";
        OpcodeName[OpcodeName["OpenBlock"] = 20] = "OpenBlock";
        OpcodeName[OpcodeName["CloseBlock"] = 21] = "CloseBlock";
        OpcodeName[OpcodeName["PutDynamicComponent"] = 22] = "PutDynamicComponent";
        OpcodeName[OpcodeName["PutComponent"] = 23] = "PutComponent";
        OpcodeName[OpcodeName["OpenComponent"] = 24] = "OpenComponent";
        OpcodeName[OpcodeName["DidCreateElement"] = 25] = "DidCreateElement";
        OpcodeName[OpcodeName["ShadowAttributes"] = 26] = "ShadowAttributes";
        OpcodeName[OpcodeName["DidRenderLayout"] = 27] = "DidRenderLayout";
        OpcodeName[OpcodeName["CloseComponent"] = 28] = "CloseComponent";
        OpcodeName[OpcodeName["Text"] = 29] = "Text";
        OpcodeName[OpcodeName["Comment"] = 30] = "Comment";
        OpcodeName[OpcodeName["DynamicContent"] = 31] = "DynamicContent";
        OpcodeName[OpcodeName["OpenElement"] = 32] = "OpenElement";
        OpcodeName[OpcodeName["PushRemoteElement"] = 33] = "PushRemoteElement";
        OpcodeName[OpcodeName["PopRemoteElement"] = 34] = "PopRemoteElement";
        OpcodeName[OpcodeName["OpenComponentElement"] = 35] = "OpenComponentElement";
        OpcodeName[OpcodeName["OpenDynamicElement"] = 36] = "OpenDynamicElement";
        OpcodeName[OpcodeName["FlushElement"] = 37] = "FlushElement";
        OpcodeName[OpcodeName["CloseElement"] = 38] = "CloseElement";
        OpcodeName[OpcodeName["PopElement"] = 39] = "PopElement";
        OpcodeName[OpcodeName["StaticAttr"] = 40] = "StaticAttr";
        OpcodeName[OpcodeName["Modifier"] = 41] = "Modifier";
        OpcodeName[OpcodeName["DynamicAttrNS"] = 42] = "DynamicAttrNS";
        OpcodeName[OpcodeName["DynamicAttr"] = 43] = "DynamicAttr";
        OpcodeName[OpcodeName["PutIterator"] = 44] = "PutIterator";
        OpcodeName[OpcodeName["EnterList"] = 45] = "EnterList";
        OpcodeName[OpcodeName["ExitList"] = 46] = "ExitList";
        OpcodeName[OpcodeName["EnterWithKey"] = 47] = "EnterWithKey";
        OpcodeName[OpcodeName["NextIter"] = 48] = "NextIter";
        OpcodeName[OpcodeName["PutDynamicPartial"] = 49] = "PutDynamicPartial";
        OpcodeName[OpcodeName["PutPartial"] = 50] = "PutPartial";
        OpcodeName[OpcodeName["EvaluatePartial"] = 51] = "EvaluatePartial"; // (Other<SymbolTable>, Other<Dict<PartialBlock>>)
    })(OpcodeName || (exports.OpcodeName = OpcodeName = {}));

    var Constants = (function () {
        function Constants() {
            _classCallCheck(this, Constants);

            // `0` means NULL
            this.references = [];
            this.strings = [];
            this.expressions = [];
            this.arrays = [];
            this.slices = [];
            this.blocks = [];
            this.functions = [];
            this.others = [];
            this.NULL_REFERENCE = this.reference(_glimmerRuntimeLibReferences.NULL_REFERENCE);
            this.UNDEFINED_REFERENCE = this.reference(_glimmerRuntimeLibReferences.UNDEFINED_REFERENCE);
        }

        Constants.prototype.getReference = function getReference(value) {
            return this.references[value - 1];
        };

        Constants.prototype.reference = function reference(value) {
            var index = this.references.length;
            this.references.push(value);
            return index + 1;
        };

        Constants.prototype.getString = function getString(value) {
            return this.strings[value - 1];
        };

        Constants.prototype.string = function string(value) {
            var index = this.strings.length;
            this.strings.push(value);
            return index + 1;
        };

        Constants.prototype.getExpression = function getExpression(value) {
            return this.expressions[value - 1];
        };

        Constants.prototype.expression = function expression(value) {
            var index = this.expressions.length;
            this.expressions.push(value);
            return index + 1;
        };

        Constants.prototype.getArray = function getArray(value) {
            return this.arrays[value - 1];
        };

        Constants.prototype.array = function array(values) {
            var index = this.arrays.length;
            this.arrays.push(values);
            return index + 1;
        };

        Constants.prototype.getSlice = function getSlice(value) {
            return this.slices[value - 1];
        };

        Constants.prototype.slice = function slice(_slice) {
            // TODO: Put the entire program in one big array
            var index = this.slices.length;
            this.slices.push(_slice);
            return index + 1;
        };

        Constants.prototype.getBlock = function getBlock(value) {
            return this.blocks[value - 1];
        };

        Constants.prototype.block = function block(_block) {
            var index = this.blocks.length;
            this.blocks.push(_block);
            return index + 1;
        };

        Constants.prototype.getFunction = function getFunction(value) {
            return this.functions[value - 1];
        };

        Constants.prototype.function = function _function(f) {
            var index = this.functions.length;
            this.functions.push(f);
            return index + 1;
        };

        Constants.prototype.getOther = function getOther(value) {
            return this.others[value - 1];
        };

        Constants.prototype.other = function other(_other) {
            var index = this.others.length;
            this.others.push(_other);
            return index + 1;
        };

        return Constants;
    })();

    exports.Constants = Constants;

    var AppendOpcodes = (function () {
        function AppendOpcodes() {
            _classCallCheck(this, AppendOpcodes);

            this.evaluateOpcode = _glimmerUtil.fillNulls(OpcodeName.EvaluatePartial + 1);
        }

        AppendOpcodes.prototype.add = function add(name, evaluate) {
            this.evaluateOpcode[name] = evaluate;
        };

        AppendOpcodes.prototype.construct = function construct(name, _debug, op1, op2, op3) {
            return [name | 0, (op1 || 0) | 0, (op2 || 0) | 0, (op3 || 0) | 0];
        };

        AppendOpcodes.prototype.evaluate = function evaluate(vm, opcode) {
            _glimmerUtil.LOGGER.debug('[VM] OPCODE: ' + opcode.type);
            var func = this.evaluateOpcode[opcode.type];
            func(vm, opcode);
        };

        return AppendOpcodes;
    })();

    exports.AppendOpcodes = AppendOpcodes;
    var APPEND_OPCODES = new AppendOpcodes();
    exports.APPEND_OPCODES = APPEND_OPCODES;

    var AbstractOpcode = (function () {
        function AbstractOpcode() {
            _classCallCheck(this, AbstractOpcode);

            _glimmerUtil.initializeGuid(this);
        }

        AbstractOpcode.prototype.toJSON = function toJSON() {
            return { guid: this._guid, type: this.type };
        };

        return AbstractOpcode;
    })();

    exports.AbstractOpcode = AbstractOpcode;

    var UpdatingOpcode = (function (_AbstractOpcode) {
        _inherits(UpdatingOpcode, _AbstractOpcode);

        function UpdatingOpcode() {
            _classCallCheck(this, UpdatingOpcode);

            _AbstractOpcode.apply(this, arguments);
            this.next = null;
            this.prev = null;
        }

        return UpdatingOpcode;
    })(AbstractOpcode);

    exports.UpdatingOpcode = UpdatingOpcode;

    function inspect(opcodes) {
        var buffer = [];
        opcodes.forEach(function (opcode, i) {
            _inspect(opcode.toJSON(), buffer, 0, i);
        });
        return buffer.join('');
    }

    function _inspect(opcode, buffer, level, index) {
        var indentation = [];
        for (var i = 0; i < level; i++) {
            indentation.push('  ');
        }
        buffer.push.apply(buffer, indentation);
        buffer.push(index + '. ' + opcode.type);
        if (opcode.args || opcode.details) {
            buffer.push('(');
            if (opcode.args) {
                buffer.push(opcode.args.join(', '));
            }
            if (opcode.details) {
                var _keys = Object.keys(opcode.details);
                if (_keys.length) {
                    if (opcode.args && opcode.args.length) {
                        buffer.push(', ');
                    }
                    buffer.push(_keys.map(function (key) {
                        return key + '=' + (opcode.details && opcode.details[key]);
                    }).join(', '));
                }
            }
            buffer.push(')');
        }
        buffer.push('\n');
        if (opcode.children && opcode.children.length) {
            for (var i = 0; i < opcode.children.length; i++) {
                _inspect(opcode.children[i], buffer, level + 1, i);
            }
        }
    }
});

enifed("@glimmer/runtime/lib/partial", ["exports"], function (exports) {
    "use strict";

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var PartialDefinition = function PartialDefinition(name, template) {
        _classCallCheck(this, PartialDefinition);

        this.name = name;
        this.template = template;
    };

    exports.PartialDefinition = PartialDefinition;
});

enifed('@glimmer/runtime/lib/references', ['exports', '@glimmer/reference'], function (exports, _glimmerReference) {
    'use strict';

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    var PrimitiveReference = (function (_ConstReference) {
        _inherits(PrimitiveReference, _ConstReference);

        function PrimitiveReference(value) {
            _classCallCheck(this, PrimitiveReference);

            _ConstReference.call(this, value);
        }

        PrimitiveReference.create = function create(value) {
            if (value === undefined) {
                return UNDEFINED_REFERENCE;
            } else if (value === null) {
                return NULL_REFERENCE;
            } else if (value === true) {
                return TRUE_REFERENCE;
            } else if (value === false) {
                return FALSE_REFERENCE;
            } else if (typeof value === 'number') {
                return new ValueReference(value);
            } else {
                return new StringReference(value);
            }
        };

        PrimitiveReference.prototype.get = function get(_key) {
            return UNDEFINED_REFERENCE;
        };

        return PrimitiveReference;
    })(_glimmerReference.ConstReference);

    exports.PrimitiveReference = PrimitiveReference;

    var StringReference = (function (_PrimitiveReference) {
        _inherits(StringReference, _PrimitiveReference);

        function StringReference() {
            _classCallCheck(this, StringReference);

            _PrimitiveReference.apply(this, arguments);
            this.lengthReference = null;
        }

        StringReference.prototype.get = function get(key) {
            if (key === 'length') {
                var lengthReference = this.lengthReference;

                if (lengthReference === null) {
                    lengthReference = this.lengthReference = new ValueReference(this.inner.length);
                }
                return lengthReference;
            } else {
                return _PrimitiveReference.prototype.get.call(this, key);
            }
        };

        return StringReference;
    })(PrimitiveReference);

    var ValueReference = (function (_PrimitiveReference2) {
        _inherits(ValueReference, _PrimitiveReference2);

        function ValueReference(value) {
            _classCallCheck(this, ValueReference);

            _PrimitiveReference2.call(this, value);
        }

        return ValueReference;
    })(PrimitiveReference);

    var UNDEFINED_REFERENCE = new ValueReference(undefined);
    exports.UNDEFINED_REFERENCE = UNDEFINED_REFERENCE;
    var NULL_REFERENCE = new ValueReference(null);
    exports.NULL_REFERENCE = NULL_REFERENCE;
    var TRUE_REFERENCE = new ValueReference(true);
    var FALSE_REFERENCE = new ValueReference(false);

    var ConditionalReference = (function () {
        function ConditionalReference(inner) {
            _classCallCheck(this, ConditionalReference);

            this.inner = inner;
            this.tag = inner.tag;
        }

        ConditionalReference.prototype.value = function value() {
            return this.toBool(this.inner.value());
        };

        ConditionalReference.prototype.toBool = function toBool(value) {
            return !!value;
        };

        return ConditionalReference;
    })();

    exports.ConditionalReference = ConditionalReference;
});

enifed('@glimmer/runtime/lib/scanner', ['exports', '@glimmer/runtime/lib/compiled/blocks', '@glimmer/runtime/lib/compiler', '@glimmer/wire-format', '@glimmer/runtime/lib/symbol-table', '@glimmer/runtime/lib/syntax/functions', '@glimmer/runtime/lib/syntax/specialize'], function (exports, _glimmerRuntimeLibCompiledBlocks, _glimmerRuntimeLibCompiler, _glimmerWireFormat, _glimmerRuntimeLibSymbolTable, _glimmerRuntimeLibSyntaxFunctions, _glimmerRuntimeLibSyntaxSpecialize) {
    'use strict';

    exports.compileStatement = compileStatement;
    exports.scanBlock = scanBlock;

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function compileStatement(statement, builder) {
        var refined = _glimmerRuntimeLibSyntaxSpecialize.SPECIALIZE.specialize(statement, builder.symbolTable);
        _glimmerRuntimeLibSyntaxFunctions.STATEMENTS.compile(refined, builder);
    }

    var Template = function Template(statements, symbolTable) {
        _classCallCheck(this, Template);

        this.statements = statements;
        this.symbolTable = symbolTable;
    };

    exports.Template = Template;

    var Layout = (function (_Template) {
        _inherits(Layout, _Template);

        function Layout() {
            _classCallCheck(this, Layout);

            _Template.apply(this, arguments);
        }

        return Layout;
    })(Template);

    exports.Layout = Layout;

    var EntryPoint = (function (_Template2) {
        _inherits(EntryPoint, _Template2);

        function EntryPoint() {
            _classCallCheck(this, EntryPoint);

            _Template2.apply(this, arguments);
        }

        EntryPoint.prototype.compile = function compile(env) {
            var table = this.symbolTable;
            var b = _glimmerRuntimeLibCompiler.builder(env, table);
            for (var i = 0; i < this.statements.length; i++) {
                var statement = this.statements[i];
                var refined = _glimmerRuntimeLibSyntaxSpecialize.SPECIALIZE.specialize(statement, table);
                _glimmerRuntimeLibSyntaxFunctions.STATEMENTS.compile(refined, b);
            }
            return new _glimmerRuntimeLibCompiledBlocks.CompiledProgram(b.toSlice(), this.symbolTable.size);
        };

        return EntryPoint;
    })(Template);

    exports.EntryPoint = EntryPoint;

    var InlineBlock = (function (_Template3) {
        _inherits(InlineBlock, _Template3);

        function InlineBlock() {
            _classCallCheck(this, InlineBlock);

            _Template3.apply(this, arguments);
        }

        InlineBlock.prototype.splat = function splat(builder) {
            var table = builder.symbolTable;
            var locals = table.getSymbols().locals;
            if (locals) {
                builder.pushChildScope();
                builder.bindPositionalArgsForLocals(locals);
            }
            for (var i = 0; i < this.statements.length; i++) {
                var statement = this.statements[i];
                var refined = _glimmerRuntimeLibSyntaxSpecialize.SPECIALIZE.specialize(statement, table);
                _glimmerRuntimeLibSyntaxFunctions.STATEMENTS.compile(refined, builder);
            }
            if (locals) {
                builder.popScope();
            }
        };

        InlineBlock.prototype.compile = function compile(env) {
            var table = this.symbolTable;
            var b = _glimmerRuntimeLibCompiler.builder(env, table);
            this.splat(b);
            return new _glimmerRuntimeLibCompiledBlocks.CompiledBlock(b.toSlice());
        };

        return InlineBlock;
    })(Template);

    exports.InlineBlock = InlineBlock;

    var PartialBlock = (function (_Template4) {
        _inherits(PartialBlock, _Template4);

        function PartialBlock() {
            _classCallCheck(this, PartialBlock);

            _Template4.apply(this, arguments);
        }

        PartialBlock.prototype.compile = function compile(env) {
            var table = this.symbolTable;
            var b = _glimmerRuntimeLibCompiler.builder(env, table);
            for (var i = 0; i < this.statements.length; i++) {
                var statement = this.statements[i];
                var refined = _glimmerRuntimeLibSyntaxSpecialize.SPECIALIZE.specialize(statement, table);
                _glimmerRuntimeLibSyntaxFunctions.STATEMENTS.compile(refined, b);
            }
            return new _glimmerRuntimeLibCompiledBlocks.CompiledProgram(b.toSlice(), table.size);
        };

        return PartialBlock;
    })(Template);

    exports.PartialBlock = PartialBlock;

    var Scanner = (function () {
        function Scanner(block, meta, env) {
            _classCallCheck(this, Scanner);

            this.block = block;
            this.meta = meta;
            this.env = env;
        }

        Scanner.prototype.scanEntryPoint = function scanEntryPoint() {
            var block = this.block;
            var meta = this.meta;

            var symbolTable = _glimmerRuntimeLibSymbolTable.entryPoint(meta);
            var child = scanBlock(block, symbolTable, this.env);
            return new EntryPoint(child.statements, symbolTable);
        };

        Scanner.prototype.scanLayout = function scanLayout() {
            var block = this.block;
            var meta = this.meta;
            var named = block.named;
            var yields = block.yields;
            var hasPartials = block.hasPartials;

            var symbolTable = _glimmerRuntimeLibSymbolTable.layout(meta, named, yields, hasPartials);
            var child = scanBlock(block, symbolTable, this.env);
            return new Layout(child.statements, symbolTable);
        };

        Scanner.prototype.scanPartial = function scanPartial(symbolTable) {
            var block = this.block;

            var child = scanBlock(block, symbolTable, this.env);
            return new PartialBlock(child.statements, symbolTable);
        };

        return Scanner;
    })();

    exports.default = Scanner;

    function scanBlock(_ref, symbolTable, env) {
        var statements = _ref.statements;

        return new RawInlineBlock(env, symbolTable, statements).scan();
    }

    var BaselineSyntax;
    exports.BaselineSyntax = BaselineSyntax;
    (function (BaselineSyntax) {
        BaselineSyntax.isScannedComponent = _glimmerWireFormat.is('scanned-component');
        BaselineSyntax.isPrimitiveElement = _glimmerWireFormat.is('open-primitive-element');
        BaselineSyntax.isOptimizedAppend = _glimmerWireFormat.is('optimized-append');
        BaselineSyntax.isUnoptimizedAppend = _glimmerWireFormat.is('unoptimized-append');
        BaselineSyntax.isAnyAttr = _glimmerWireFormat.is('any-dynamic-attr');
        BaselineSyntax.isStaticPartial = _glimmerWireFormat.is('static-partial');
        BaselineSyntax.isDynamicPartial = _glimmerWireFormat.is('dynamic-partial');
        BaselineSyntax.isFunctionExpression = _glimmerWireFormat.is('function');
        BaselineSyntax.isNestedBlock = _glimmerWireFormat.is('nested-block');
        BaselineSyntax.isScannedBlock = _glimmerWireFormat.is('scanned-block');
        BaselineSyntax.isDebugger = _glimmerWireFormat.is('debugger');
        var NestedBlock;
        (function (NestedBlock) {
            function defaultBlock(sexp) {
                return sexp[4];
            }
            NestedBlock.defaultBlock = defaultBlock;
            function inverseBlock(sexp) {
                return sexp[5];
            }
            NestedBlock.inverseBlock = inverseBlock;
            function params(sexp) {
                return sexp[2];
            }
            NestedBlock.params = params;
            function hash(sexp) {
                return sexp[3];
            }
            NestedBlock.hash = hash;
        })(NestedBlock = BaselineSyntax.NestedBlock || (BaselineSyntax.NestedBlock = {}));
    })(BaselineSyntax || (exports.BaselineSyntax = BaselineSyntax = {}));

    var RawInlineBlock = (function () {
        function RawInlineBlock(env, table, statements) {
            _classCallCheck(this, RawInlineBlock);

            this.env = env;
            this.table = table;
            this.statements = statements;
        }

        RawInlineBlock.prototype.scan = function scan() {
            var buffer = [];
            for (var i = 0; i < this.statements.length; i++) {
                var statement = this.statements[i];
                if (_glimmerWireFormat.Statements.isBlock(statement)) {
                    buffer.push(this.specializeBlock(statement));
                } else if (_glimmerWireFormat.Statements.isComponent(statement)) {
                    buffer.push.apply(buffer, this.specializeComponent(statement));
                } else {
                    buffer.push(statement);
                }
            }
            return new InlineBlock(buffer, this.table);
        };

        RawInlineBlock.prototype.specializeBlock = function specializeBlock(block) {
            var path = block[1];
            var params = block[2];
            var hash = block[3];
            var template = block[4];
            var inverse = block[5];

            return ['scanned-block', path, params, hash, this.child(template), this.child(inverse)];
        };

        RawInlineBlock.prototype.specializeComponent = function specializeComponent(sexp) {
            var tag = sexp[1];
            var component = sexp[2];

            if (this.env.hasComponentDefinition([tag], this.table)) {
                var child = this.child(component);
                var attrs = new RawInlineBlock(this.env, this.table, component.attrs);
                return [['scanned-component', tag, attrs, component.args, child]];
            } else {
                var buf = [];
                buf.push(['open-element', tag, []]);
                buf.push.apply(buf, component.attrs);
                buf.push(['flush-element']);
                buf.push.apply(buf, component.statements);
                buf.push(['close-element']);
                return buf;
            }
        };

        RawInlineBlock.prototype.child = function child(block) {
            if (!block) return null;
            var table = _glimmerRuntimeLibSymbolTable.block(this.table, block.locals);
            return new RawInlineBlock(this.env, table, block.statements);
        };

        return RawInlineBlock;
    })();

    exports.RawInlineBlock = RawInlineBlock;
});

enifed('@glimmer/runtime/lib/symbol-table', ['exports', '@glimmer/util'], function (exports, _glimmerUtil) {
    'use strict';

    exports.entryPoint = entryPoint;
    exports.layout = layout;
    exports.block = block;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function entryPoint(meta) {
        return new ProgramSymbolTable(meta);
    }

    function layout(meta, wireNamed, wireYields, hasPartials) {
        var _symbols = symbols(wireNamed, wireYields, hasPartials);

        var named = _symbols.named;
        var yields = _symbols.yields;
        var partialSymbol = _symbols.partialSymbol;
        var size = _symbols.size;

        return new ProgramSymbolTable(meta, named, yields, partialSymbol, size);
    }

    function block(parent, locals) {
        var localsMap = null;
        var program = parent['program'];
        if (locals.length !== 0) {
            (function () {
                var map = localsMap = _glimmerUtil.dict();
                locals.forEach(function (l) {
                    return map[l] = program.size++;
                });
            })();
        }
        return new BlockSymbolTable(parent, program, localsMap);
    }

    function symbols(named, yields, hasPartials) {
        var yieldsMap = null;
        var namedMap = null;
        var size = 1;
        if (yields.length !== 0) {
            (function () {
                var map = yieldsMap = _glimmerUtil.dict();
                yields.forEach(function (y) {
                    return map[y] = size++;
                });
            })();
        }
        if (named.length !== 0) {
            (function () {
                var map = namedMap = _glimmerUtil.dict();
                named.forEach(function (y) {
                    return map[y] = size++;
                });
            })();
        }
        var partialSymbol = hasPartials ? size++ : null;
        return { named: namedMap, yields: yieldsMap, partialSymbol: partialSymbol, size: size };
    }

    var ProgramSymbolTable = (function () {
        function ProgramSymbolTable(meta) {
            var named = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
            var yields = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
            var partialArgs = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
            var size = arguments.length <= 4 || arguments[4] === undefined ? 1 : arguments[4];

            _classCallCheck(this, ProgramSymbolTable);

            this.meta = meta;
            this.named = named;
            this.yields = yields;
            this.partialArgs = partialArgs;
            this.size = size;
            this.program = this;
        }

        ProgramSymbolTable.prototype.getMeta = function getMeta() {
            return this.meta;
        };

        ProgramSymbolTable.prototype.getSymbols = function getSymbols() {
            return {
                named: this.named,
                yields: this.yields,
                locals: null,
                partialArgs: this.partialArgs
            };
        };

        ProgramSymbolTable.prototype.getSymbol = function getSymbol(kind, name) {
            if (kind === 'local') return null;
            return this[kind] && this[kind][name];
        };

        ProgramSymbolTable.prototype.getPartialArgs = function getPartialArgs() {
            return this.partialArgs || 0;
        };

        return ProgramSymbolTable;
    })();

    exports.ProgramSymbolTable = ProgramSymbolTable;

    var BlockSymbolTable = (function () {
        function BlockSymbolTable(parent, program, locals) {
            _classCallCheck(this, BlockSymbolTable);

            this.parent = parent;
            this.program = program;
            this.locals = locals;
        }

        BlockSymbolTable.prototype.getMeta = function getMeta() {
            return this.program.getMeta();
        };

        BlockSymbolTable.prototype.getSymbols = function getSymbols() {
            return {
                named: null,
                yields: null,
                locals: this.locals,
                partialArgs: null
            };
        };

        BlockSymbolTable.prototype.getSymbol = function getSymbol(kind, name) {
            if (kind === 'local') {
                return this.getLocal(name);
            } else {
                return this.program.getSymbol(kind, name);
            }
        };

        BlockSymbolTable.prototype.getLocal = function getLocal(name) {
            var locals = this.locals;
            var parent = this.parent;

            var symbol = locals && locals[name];
            if (!symbol && parent) {
                symbol = parent.getSymbol('local', name);
            }
            return symbol;
        };

        BlockSymbolTable.prototype.getPartialArgs = function getPartialArgs() {
            return this.program.getPartialArgs();
        };

        return BlockSymbolTable;
    })();

    exports.BlockSymbolTable = BlockSymbolTable;
    var EMPTY_SYMBOL_TABLE = {
        getMeta: function () {
            return null;
        },
        getSymbols: function () {
            return {
                named: null,
                yields: null,
                locals: null,
                partialArgs: null
            };
        },
        getSymbol: function (_kind, _name) {
            throw new Error("BUG: Calling getSymbol on EMPTY_SYMBOL_TABLE");
        },
        getPartialArgs: function () {
            return null;
        }
    };
    exports.EMPTY_SYMBOL_TABLE = EMPTY_SYMBOL_TABLE;
});

enifed('@glimmer/runtime/lib/syntax/functions', ['exports', '@glimmer/runtime/lib/compiled/expressions/value', '@glimmer/runtime/lib/compiled/expressions/has-block', '@glimmer/util', '@glimmer/runtime/lib/compiled/expressions/lookups', '@glimmer/runtime/lib/compiled/expressions/helper', '@glimmer/runtime/lib/compiled/expressions/concat', '@glimmer/runtime/lib/compiled/expressions/args', '@glimmer/runtime/lib/compiled/expressions/function'], function (exports, _glimmerRuntimeLibCompiledExpressionsValue, _glimmerRuntimeLibCompiledExpressionsHasBlock, _glimmerUtil, _glimmerRuntimeLibCompiledExpressionsLookups, _glimmerRuntimeLibCompiledExpressionsHelper, _glimmerRuntimeLibCompiledExpressionsConcat, _glimmerRuntimeLibCompiledExpressionsArgs, _glimmerRuntimeLibCompiledExpressionsFunction) {
    'use strict';

    exports.setDebuggerCallback = setDebuggerCallback;
    exports.resetDebuggerCallback = resetDebuggerCallback;
    exports.expr = expr;
    exports.compileArgs = compileArgs;
    exports.compileBlockArgs = compileBlockArgs;
    exports.compileBaselineArgs = compileBaselineArgs;
    exports.populateBuiltins = populateBuiltins;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function debugCallback(context, get) {
        console.info('Use `context`, and `get(<path>)` to debug this template.');
        /* tslint:disable */
        debugger;
        /* tslint:enable */
        return { context: context, get: get };
    }
    function getter(vm, builder) {
        return function (path) {
            var parts = path.split('.');
            if (parts[0] === 'this') {
                parts[0] = null;
            }
            return compileRef(parts, builder).evaluate(vm);
        };
    }
    var callback = debugCallback;
    // For testing purposes

    function setDebuggerCallback(cb) {
        callback = cb;
    }

    function resetDebuggerCallback() {
        callback = debugCallback;
    }

    var Compilers = (function () {
        function Compilers() {
            _classCallCheck(this, Compilers);

            this.names = _glimmerUtil.dict();
            this.funcs = [];
        }

        Compilers.prototype.add = function add(name, func) {
            this.funcs.push(func);
            this.names[name] = this.funcs.length - 1;
        };

        Compilers.prototype.compile = function compile(sexp, builder) {
            var name = sexp[0];
            var index = this.names[name];
            var func = this.funcs[index];
            _glimmerUtil.assert(!!func, 'expected an implementation for ' + sexp[0]);
            return func(sexp, builder);
        };

        return Compilers;
    })();

    exports.Compilers = Compilers;
    var STATEMENTS = new Compilers();
    exports.STATEMENTS = STATEMENTS;
    STATEMENTS.add('text', function (sexp, builder) {
        builder.text(sexp[1]);
    });
    STATEMENTS.add('comment', function (sexp, builder) {
        builder.comment(sexp[1]);
    });
    STATEMENTS.add('close-element', function (_sexp, builder) {
        _glimmerUtil.LOGGER.trace('close-element statement');
        builder.closeElement();
    });
    STATEMENTS.add('flush-element', function (_sexp, builder) {
        builder.flushElement();
    });
    STATEMENTS.add('modifier', function (sexp, builder) {
        var path = sexp[1];
        var params = sexp[2];
        var hash = sexp[3];

        var args = compileArgs(params, hash, builder);
        if (builder.env.hasModifier(path, builder.symbolTable)) {
            builder.modifier(path[0], args);
        } else {
            throw new Error('Compile Error ' + path.join('.') + ' is not a modifier: Helpers may not be used in the element form.');
        }
    });
    STATEMENTS.add('static-attr', function (sexp, builder) {
        var name = sexp[1];
        var value = sexp[2];
        var namespace = sexp[3];

        builder.staticAttr(name, namespace, value);
    });
    STATEMENTS.add('any-dynamic-attr', function (sexp, builder) {
        var name = sexp[1];
        var value = sexp[2];
        var namespace = sexp[3];
        var trusting = sexp[4];

        builder.putValue(value);
        if (namespace) {
            builder.dynamicAttrNS(name, namespace, trusting);
        } else {
            builder.dynamicAttr(name, trusting);
        }
    });
    STATEMENTS.add('open-element', function (sexp, builder) {
        _glimmerUtil.LOGGER.trace('open-element statement');
        builder.openPrimitiveElement(sexp[1]);
    });
    STATEMENTS.add('optimized-append', function (sexp, builder) {
        var value = sexp[1];
        var trustingMorph = sexp[2];

        var _builder$env$macros = builder.env.macros();

        var inlines = _builder$env$macros.inlines;

        var returned = inlines.compile(sexp, builder) || value;
        if (returned === true) return;
        builder.putValue(returned[1]);
        if (trustingMorph) {
            builder.trustingAppend();
        } else {
            builder.cautiousAppend();
        }
    });
    STATEMENTS.add('unoptimized-append', function (sexp, builder) {
        var value = sexp[1];
        var trustingMorph = sexp[2];

        var _builder$env$macros2 = builder.env.macros();

        var inlines = _builder$env$macros2.inlines;

        var returned = inlines.compile(sexp, builder) || value;
        if (returned === true) return;
        if (trustingMorph) {
            builder.guardedTrustingAppend(returned[1]);
        } else {
            builder.guardedCautiousAppend(returned[1]);
        }
    });
    STATEMENTS.add('nested-block', function (sexp, builder) {
        var _builder$env$macros3 = builder.env.macros();

        var blocks = _builder$env$macros3.blocks;

        blocks.compile(sexp, builder);
    });
    STATEMENTS.add('scanned-block', function (sexp, builder) {
        var path = sexp[1];
        var params = sexp[2];
        var hash = sexp[3];
        var template = sexp[4];
        var inverse = sexp[5];

        var templateBlock = template && template.scan();
        var inverseBlock = inverse && inverse.scan();

        var _builder$env$macros4 = builder.env.macros();

        var blocks = _builder$env$macros4.blocks;

        blocks.compile(['nested-block', path, params, hash, templateBlock, inverseBlock], builder);
    });
    STATEMENTS.add('scanned-component', function (sexp, builder) {
        var tag = sexp[1];
        var attrs = sexp[2];
        var rawArgs = sexp[3];
        var rawBlock = sexp[4];

        var block = rawBlock && rawBlock.scan();
        var args = compileBlockArgs(null, rawArgs, { default: block, inverse: null }, builder);
        var definition = builder.env.getComponentDefinition([tag], builder.symbolTable);
        builder.putComponentDefinition(definition);
        builder.openComponent(args, attrs.scan());
        builder.closeComponent();
    });
    STATEMENTS.add('static-partial', function (sexp, builder) {
        var name = sexp[1];

        if (!builder.env.hasPartial(name, builder.symbolTable)) {
            throw new Error('Compile Error: Could not find a partial named "' + name + '"');
        }
        var definition = builder.env.lookupPartial(name, builder.symbolTable);
        builder.putPartialDefinition(definition);
        builder.evaluatePartial();
    });
    STATEMENTS.add('dynamic-partial', function (sexp, builder) {
        var name = sexp[1];

        builder.startLabels();
        builder.putValue(name);
        builder.test('simple');
        builder.enter('BEGIN', 'END');
        builder.label('BEGIN');
        builder.jumpUnless('END');
        builder.putDynamicPartialDefinition();
        builder.evaluatePartial();
        builder.label('END');
        builder.exit();
        builder.stopLabels();
    });
    STATEMENTS.add('yield', function (sexp, builder) {
        var to = sexp[1];
        var params = sexp[2];

        var args = compileArgs(params, null, builder);
        builder.yield(args, to);
    });
    STATEMENTS.add('debugger', function (sexp, builder) {
        builder.putValue(['function', function (vm) {
            var context = vm.getSelf().value();
            var get = function (path) {
                return getter(vm, builder)(path).value();
            };
            callback(context, get);
        }]);
        return sexp;
    });
    var EXPRESSIONS = new Compilers();

    function expr(expression, builder) {
        if (Array.isArray(expression)) {
            return EXPRESSIONS.compile(expression, builder);
        } else {
            return new _glimmerRuntimeLibCompiledExpressionsValue.default(expression);
        }
    }

    EXPRESSIONS.add('unknown', function (sexp, builder) {
        var path = sexp[1];
        if (builder.env.hasHelper(path, builder.symbolTable)) {
            return new _glimmerRuntimeLibCompiledExpressionsHelper.default(path, builder.env.lookupHelper(path, builder.symbolTable), _glimmerRuntimeLibCompiledExpressionsArgs.CompiledArgs.empty(), builder.symbolTable);
        } else {
            return compileRef(path, builder);
        }
    });
    EXPRESSIONS.add('concat', function (sexp, builder) {
        var params = sexp[1].map(function (p) {
            return expr(p, builder);
        });
        return new _glimmerRuntimeLibCompiledExpressionsConcat.default(params);
    });
    EXPRESSIONS.add('function', function (sexp, builder) {
        return new _glimmerRuntimeLibCompiledExpressionsFunction.CompiledFunctionExpression(sexp[1], builder.symbolTable);
    });
    EXPRESSIONS.add('helper', function (sexp, builder) {
        var env = builder.env;
        var symbolTable = builder.symbolTable;
        var path = sexp[1];
        var params = sexp[2];
        var hash = sexp[3];

        if (env.hasHelper(path, symbolTable)) {
            var args = compileArgs(params, hash, builder);
            return new _glimmerRuntimeLibCompiledExpressionsHelper.default(path, env.lookupHelper(path, symbolTable), args, symbolTable);
        } else {
            throw new Error('Compile Error: ' + path.join('.') + ' is not a helper');
        }
    });
    EXPRESSIONS.add('get', function (sexp, builder) {
        return compileRef(sexp[1], builder);
    });
    EXPRESSIONS.add('undefined', function (_sexp, _builder) {
        return new _glimmerRuntimeLibCompiledExpressionsValue.default(undefined);
    });
    EXPRESSIONS.add('arg', function (sexp, builder) {
        var parts = sexp[1];

        var head = parts[0];
        var named = undefined,
            partial = undefined;
        if (named = builder.symbolTable.getSymbol('named', head)) {
            var path = parts.slice(1);
            var inner = new _glimmerRuntimeLibCompiledExpressionsLookups.CompiledSymbol(named, head);
            return _glimmerRuntimeLibCompiledExpressionsLookups.default.create(inner, path);
        } else if (partial = builder.symbolTable.getPartialArgs()) {
            var path = parts.slice(1);
            var inner = new _glimmerRuntimeLibCompiledExpressionsLookups.CompiledInPartialName(partial, head);
            return _glimmerRuntimeLibCompiledExpressionsLookups.default.create(inner, path);
        } else {
            throw new Error('[BUG] @' + parts.join('.') + ' is not a valid lookup path.');
        }
    });
    EXPRESSIONS.add('has-block', function (sexp, builder) {
        var blockName = sexp[1];
        var yields = undefined,
            partial = undefined;
        if (yields = builder.symbolTable.getSymbol('yields', blockName)) {
            var inner = new _glimmerRuntimeLibCompiledExpressionsHasBlock.CompiledGetBlockBySymbol(yields, blockName);
            return new _glimmerRuntimeLibCompiledExpressionsHasBlock.default(inner);
        } else if (partial = builder.symbolTable.getPartialArgs()) {
            var inner = new _glimmerRuntimeLibCompiledExpressionsHasBlock.CompiledInPartialGetBlock(partial, blockName);
            return new _glimmerRuntimeLibCompiledExpressionsHasBlock.default(inner);
        } else {
            throw new Error('[BUG] ${blockName} is not a valid block name.');
        }
    });
    EXPRESSIONS.add('has-block-params', function (sexp, builder) {
        var blockName = sexp[1];
        var yields = undefined,
            partial = undefined;
        if (yields = builder.symbolTable.getSymbol('yields', blockName)) {
            var inner = new _glimmerRuntimeLibCompiledExpressionsHasBlock.CompiledGetBlockBySymbol(yields, blockName);
            return new _glimmerRuntimeLibCompiledExpressionsHasBlock.CompiledHasBlockParams(inner);
        } else if (partial = builder.symbolTable.getPartialArgs()) {
            var inner = new _glimmerRuntimeLibCompiledExpressionsHasBlock.CompiledInPartialGetBlock(partial, blockName);
            return new _glimmerRuntimeLibCompiledExpressionsHasBlock.CompiledHasBlockParams(inner);
        } else {
            throw new Error('[BUG] ${blockName} is not a valid block name.');
        }
    });

    function compileArgs(params, hash, builder) {
        var compiledParams = compileParams(params, builder);
        var compiledHash = compileHash(hash, builder);
        return _glimmerRuntimeLibCompiledExpressionsArgs.CompiledArgs.create(compiledParams, compiledHash, _glimmerRuntimeLibCompiledExpressionsArgs.EMPTY_BLOCKS);
    }

    function compileBlockArgs(params, hash, blocks, builder) {
        var compiledParams = compileParams(params, builder);
        var compiledHash = compileHash(hash, builder);
        return _glimmerRuntimeLibCompiledExpressionsArgs.CompiledArgs.create(compiledParams, compiledHash, blocks);
    }

    function compileBaselineArgs(args, builder) {
        var params = args[0];
        var hash = args[1];
        var _default = args[2];
        var inverse = args[3];

        return _glimmerRuntimeLibCompiledExpressionsArgs.CompiledArgs.create(compileParams(params, builder), compileHash(hash, builder), { default: _default, inverse: inverse });
    }

    function compileParams(params, builder) {
        if (!params || params.length === 0) return _glimmerRuntimeLibCompiledExpressionsArgs.COMPILED_EMPTY_POSITIONAL_ARGS;
        var compiled = params.map(function (p) {
            return expr(p, builder);
        });
        return _glimmerRuntimeLibCompiledExpressionsArgs.CompiledPositionalArgs.create(compiled);
    }
    function compileHash(hash, builder) {
        if (!hash) return _glimmerRuntimeLibCompiledExpressionsArgs.COMPILED_EMPTY_NAMED_ARGS;
        var keys = hash[0];
        var values = hash[1];

        if (keys.length === 0) return _glimmerRuntimeLibCompiledExpressionsArgs.COMPILED_EMPTY_NAMED_ARGS;
        var compiled = values.map(function (p) {
            return expr(p, builder);
        });
        return new _glimmerRuntimeLibCompiledExpressionsArgs.CompiledNamedArgs(keys, compiled);
    }
    function compileRef(parts, builder) {
        var head = parts[0];
        var local = undefined;
        if (head === null) {
            var inner = new _glimmerRuntimeLibCompiledExpressionsLookups.CompiledSelf();
            var path = parts.slice(1);
            return _glimmerRuntimeLibCompiledExpressionsLookups.default.create(inner, path);
        } else if (local = builder.symbolTable.getSymbol('local', head)) {
            var path = parts.slice(1);
            var inner = new _glimmerRuntimeLibCompiledExpressionsLookups.CompiledSymbol(local, head);
            return _glimmerRuntimeLibCompiledExpressionsLookups.default.create(inner, path);
        } else {
            var inner = new _glimmerRuntimeLibCompiledExpressionsLookups.CompiledSelf();
            return _glimmerRuntimeLibCompiledExpressionsLookups.default.create(inner, parts);
        }
    }

    var Blocks = (function () {
        function Blocks() {
            _classCallCheck(this, Blocks);

            this.names = _glimmerUtil.dict();
            this.funcs = [];
        }

        Blocks.prototype.add = function add(name, func) {
            this.funcs.push(func);
            this.names[name] = this.funcs.length - 1;
        };

        Blocks.prototype.addMissing = function addMissing(func) {
            this.missing = func;
        };

        Blocks.prototype.compile = function compile(sexp, builder) {
            // assert(sexp[1].length === 1, 'paths in blocks are not supported');
            var name = sexp[1][0];
            var index = this.names[name];
            if (index === undefined) {
                _glimmerUtil.assert(!!this.missing, name + ' not found, and no catch-all block handler was registered');
                var func = this.missing;
                var handled = func(sexp, builder);
                _glimmerUtil.assert(!!handled, name + ' not found, and the catch-all block handler didn\'t handle it');
            } else {
                var func = this.funcs[index];
                func(sexp, builder);
            }
        };

        return Blocks;
    })();

    exports.Blocks = Blocks;
    var BLOCKS = new Blocks();
    exports.BLOCKS = BLOCKS;

    var Inlines = (function () {
        function Inlines() {
            _classCallCheck(this, Inlines);

            this.names = _glimmerUtil.dict();
            this.funcs = [];
        }

        Inlines.prototype.add = function add(name, func) {
            this.funcs.push(func);
            this.names[name] = this.funcs.length - 1;
        };

        Inlines.prototype.addMissing = function addMissing(func) {
            this.missing = func;
        };

        Inlines.prototype.compile = function compile(sexp, builder) {
            var value = sexp[1];
            // TODO: Fix this so that expression macros can return
            // things like components, so that {{component foo}}
            // is the same as {{(component foo)}}
            if (!Array.isArray(value)) return ['expr', value];
            var path = undefined;
            var params = undefined;
            var hash = undefined;
            if (value[0] === 'helper') {
                path = value[1];
                params = value[2];
                hash = value[3];
            } else if (value[0] === 'unknown') {
                path = value[1];
                params = hash = null;
            } else {
                return ['expr', value];
            }
            if (path.length > 1 && !params && !hash) {
                return ['expr', value];
            }
            var name = path[0];
            var index = this.names[name];
            if (index === undefined && this.missing) {
                var func = this.missing;
                var returned = func(path, params, hash, builder);
                return returned === false ? ['expr', value] : returned;
            } else if (index !== undefined) {
                var func = this.funcs[index];
                var returned = func(path, params, hash, builder);
                return returned === false ? ['expr', value] : returned;
            } else {
                return ['expr', value];
            }
        };

        return Inlines;
    })();

    exports.Inlines = Inlines;
    var INLINES = new Inlines();
    exports.INLINES = INLINES;
    populateBuiltins(BLOCKS, INLINES);

    function populateBuiltins() {
        var blocks = arguments.length <= 0 || arguments[0] === undefined ? new Blocks() : arguments[0];
        var inlines = arguments.length <= 1 || arguments[1] === undefined ? new Inlines() : arguments[1];

        blocks.add('if', function (sexp, builder) {
            //        PutArgs
            //        Test(Environment)
            //        Enter(BEGIN, END)
            // BEGIN: Noop
            //        JumpUnless(ELSE)
            //        Evaluate(default)
            //        Jump(END)
            // ELSE:  Noop
            //        Evalulate(inverse)
            // END:   Noop
            //        Exit
            var params = sexp[2];
            var hash = sexp[3];
            var _default = sexp[4];
            var inverse = sexp[5];

            var args = compileArgs(params, hash, builder);
            builder.putArgs(args);
            builder.test('environment');
            builder.labelled(null, function (b) {
                if (_default && inverse) {
                    b.jumpUnless('ELSE');
                    b.evaluate(_default);
                    b.jump('END');
                    b.label('ELSE');
                    b.evaluate(inverse);
                } else if (_default) {
                    b.jumpUnless('END');
                    b.evaluate(_default);
                } else {
                    throw _glimmerUtil.unreachable();
                }
            });
        });
        blocks.add('unless', function (sexp, builder) {
            //        PutArgs
            //        Test(Environment)
            //        Enter(BEGIN, END)
            // BEGIN: Noop
            //        JumpUnless(ELSE)
            //        Evaluate(default)
            //        Jump(END)
            // ELSE:  Noop
            //        Evalulate(inverse)
            // END:   Noop
            //        Exit
            var params = sexp[2];
            var hash = sexp[3];
            var _default = sexp[4];
            var inverse = sexp[5];

            var args = compileArgs(params, hash, builder);
            builder.putArgs(args);
            builder.test('environment');
            builder.labelled(null, function (b) {
                if (_default && inverse) {
                    b.jumpIf('ELSE');
                    b.evaluate(_default);
                    b.jump('END');
                    b.label('ELSE');
                    b.evaluate(inverse);
                } else if (_default) {
                    b.jumpIf('END');
                    b.evaluate(_default);
                } else {
                    throw _glimmerUtil.unreachable();
                }
            });
        });
        blocks.add('with', function (sexp, builder) {
            //        PutArgs
            //        Test(Environment)
            //        Enter(BEGIN, END)
            // BEGIN: Noop
            //        JumpUnless(ELSE)
            //        Evaluate(default)
            //        Jump(END)
            // ELSE:  Noop
            //        Evalulate(inverse)
            // END:   Noop
            //        Exit
            var params = sexp[2];
            var hash = sexp[3];
            var _default = sexp[4];
            var inverse = sexp[5];

            var args = compileArgs(params, hash, builder);
            builder.putArgs(args);
            builder.test('environment');
            builder.labelled(null, function (b) {
                if (_default && inverse) {
                    b.jumpUnless('ELSE');
                    b.evaluate(_default);
                    b.jump('END');
                    b.label('ELSE');
                    b.evaluate(inverse);
                } else if (_default) {
                    b.jumpUnless('END');
                    b.evaluate(_default);
                } else {
                    throw _glimmerUtil.unreachable();
                }
            });
        });
        blocks.add('each', function (sexp, builder) {
            //         Enter(BEGIN, END)
            // BEGIN:  Noop
            //         PutArgs
            //         PutIterable
            //         JumpUnless(ELSE)
            //         EnterList(BEGIN2, END2)
            // ITER:   Noop
            //         NextIter(BREAK)
            //         EnterWithKey(BEGIN2, END2)
            // BEGIN2: Noop
            //         PushChildScope
            //         Evaluate(default)
            //         PopScope
            // END2:   Noop
            //         Exit
            //         Jump(ITER)
            // BREAK:  Noop
            //         ExitList
            //         Jump(END)
            // ELSE:   Noop
            //         Evalulate(inverse)
            // END:    Noop
            //         Exit
            var params = sexp[2];
            var hash = sexp[3];
            var _default = sexp[4];
            var inverse = sexp[5];

            var args = compileArgs(params, hash, builder);
            builder.labelled(args, function (b) {
                b.putIterator();
                if (inverse) {
                    b.jumpUnless('ELSE');
                } else {
                    b.jumpUnless('END');
                }
                b.iter(function (b) {
                    b.evaluate(_glimmerUtil.unwrap(_default));
                });
                if (inverse) {
                    b.jump('END');
                    b.label('ELSE');
                    b.evaluate(inverse);
                }
            });
        });
        return { blocks: blocks, inlines: inlines };
    }
});

enifed('@glimmer/runtime/lib/syntax/specialize', ['exports', '@glimmer/wire-format', '@glimmer/util'], function (exports, _glimmerWireFormat, _glimmerUtil) {
    'use strict';

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var Specialize = (function () {
        function Specialize() {
            _classCallCheck(this, Specialize);

            this.names = _glimmerUtil.dict();
            this.funcs = [];
        }

        Specialize.prototype.add = function add(name, func) {
            this.funcs.push(func);
            this.names[name] = this.funcs.length - 1;
        };

        Specialize.prototype.specialize = function specialize(sexp, table) {
            var name = sexp[0];
            var index = this.names[name];
            if (index === undefined) return sexp;
            var func = this.funcs[index];
            _glimmerUtil.assert(!!func, 'expected a specialization for ' + sexp[0]);
            return func(sexp, table);
        };

        return Specialize;
    })();

    exports.Specialize = Specialize;
    var SPECIALIZE = new Specialize();
    exports.SPECIALIZE = SPECIALIZE;
    var E = _glimmerWireFormat.Expressions;
    SPECIALIZE.add('append', function (sexp, _symbolTable) {
        var path = sexp[1];
        if (Array.isArray(path) && (E.isUnknown(path) || E.isGet(path))) {
            if (path[1].length !== 1) {
                return ['unoptimized-append', sexp[1], sexp[2]];
            }
        }
        return ['optimized-append', sexp[1], sexp[2]];
    });
    SPECIALIZE.add('dynamic-attr', function (sexp, _symbolTable) {
        return ['any-dynamic-attr', sexp[1], sexp[2], sexp[3], false];
    });
    SPECIALIZE.add('trusting-attr', function (sexp, _symbolTable) {
        return ['any-dynamic-attr', sexp[1], sexp[2], sexp[3], true];
    });
    SPECIALIZE.add('partial', function (sexp, _table) {
        var expression = sexp[1];
        if (typeof expression === 'string') {
            return ['static-partial', expression];
        } else {
            return ['dynamic-partial', expression];
        }
    });
});

enifed('@glimmer/runtime/lib/template', ['exports', '@glimmer/util', '@glimmer/runtime/lib/builder', '@glimmer/runtime/lib/vm', '@glimmer/runtime/lib/scanner'], function (exports, _glimmerUtil, _glimmerRuntimeLibBuilder, _glimmerRuntimeLibVm, _glimmerRuntimeLibScanner) {
    'use strict';

    exports.default = templateFactory;

    var clientId = 0;

    function templateFactory(_ref) {
        var templateId = _ref.id;
        var meta = _ref.meta;
        var block = _ref.block;

        var parsedBlock = undefined;
        var id = templateId || 'client-' + clientId++;
        var create = function (env, envMeta) {
            var newMeta = envMeta ? _glimmerUtil.assign({}, envMeta, meta) : meta;
            if (!parsedBlock) {
                parsedBlock = JSON.parse(block);
            }
            return template(parsedBlock, id, newMeta, env);
        };
        return { id: id, meta: meta, create: create };
    }

    function template(block, id, meta, env) {
        var scanner = new _glimmerRuntimeLibScanner.default(block, meta, env);
        var entryPoint = undefined;
        var asEntryPoint = function () {
            if (!entryPoint) entryPoint = scanner.scanEntryPoint();
            return entryPoint;
        };
        var layout = undefined;
        var asLayout = function () {
            if (!layout) layout = scanner.scanLayout();
            return layout;
        };
        var asPartial = function (symbols) {
            return scanner.scanPartial(symbols);
        };
        var render = function (self, appendTo, dynamicScope) {
            var elementStack = _glimmerRuntimeLibBuilder.ElementStack.forInitialRender(env, appendTo, null);
            var compiled = asEntryPoint().compile(env);
            var vm = _glimmerRuntimeLibVm.VM.initial(env, self, dynamicScope, elementStack, compiled.symbols);
            return vm.execute(compiled.slice);
        };
        return { id: id, meta: meta, _block: block, asEntryPoint: asEntryPoint, asLayout: asLayout, asPartial: asPartial, render: render };
    }
});

enifed('@glimmer/runtime/lib/upsert', ['exports', '@glimmer/util', '@glimmer/runtime/lib/bounds'], function (exports, _glimmerUtil, _glimmerRuntimeLibBounds) {
    'use strict';

    exports.isSafeString = isSafeString;
    exports.isNode = isNode;
    exports.isString = isString;
    exports.cautiousInsert = cautiousInsert;
    exports.trustingInsert = trustingInsert;

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function isSafeString(value) {
        return !!value && typeof value['toHTML'] === 'function';
    }

    function isNode(value) {
        return value !== null && typeof value === 'object' && typeof value['nodeType'] === 'number';
    }

    function isString(value) {
        return typeof value === 'string';
    }

    var Upsert = function Upsert(bounds) {
        _classCallCheck(this, Upsert);

        this.bounds = bounds;
    };

    exports.default = Upsert;

    function cautiousInsert(dom, cursor, value) {
        if (isString(value)) {
            return TextUpsert.insert(dom, cursor, value);
        }
        if (isSafeString(value)) {
            return SafeStringUpsert.insert(dom, cursor, value);
        }
        if (isNode(value)) {
            return NodeUpsert.insert(dom, cursor, value);
        }
        throw _glimmerUtil.unreachable();
    }

    function trustingInsert(dom, cursor, value) {
        if (isString(value)) {
            return HTMLUpsert.insert(dom, cursor, value);
        }
        if (isNode(value)) {
            return NodeUpsert.insert(dom, cursor, value);
        }
        throw _glimmerUtil.unreachable();
    }

    var TextUpsert = (function (_Upsert) {
        _inherits(TextUpsert, _Upsert);

        TextUpsert.insert = function insert(dom, cursor, value) {
            var textNode = dom.createTextNode(value);
            dom.insertBefore(cursor.element, textNode, cursor.nextSibling);
            var bounds = new _glimmerRuntimeLibBounds.SingleNodeBounds(cursor.element, textNode);
            return new TextUpsert(bounds, textNode);
        };

        function TextUpsert(bounds, textNode) {
            _classCallCheck(this, TextUpsert);

            _Upsert.call(this, bounds);
            this.textNode = textNode;
        }

        TextUpsert.prototype.update = function update(_dom, value) {
            if (isString(value)) {
                var textNode = this.textNode;

                textNode.nodeValue = value;
                return true;
            } else {
                return false;
            }
        };

        return TextUpsert;
    })(Upsert);

    var HTMLUpsert = (function (_Upsert2) {
        _inherits(HTMLUpsert, _Upsert2);

        function HTMLUpsert() {
            _classCallCheck(this, HTMLUpsert);

            _Upsert2.apply(this, arguments);
        }

        HTMLUpsert.insert = function insert(dom, cursor, value) {
            var bounds = dom.insertHTMLBefore(cursor.element, value, cursor.nextSibling);
            return new HTMLUpsert(bounds);
        };

        HTMLUpsert.prototype.update = function update(dom, value) {
            if (isString(value)) {
                var bounds = this.bounds;

                var parentElement = bounds.parentElement();
                var nextSibling = _glimmerRuntimeLibBounds.clear(bounds);
                this.bounds = dom.insertHTMLBefore(parentElement, nextSibling, value);
                return true;
            } else {
                return false;
            }
        };

        return HTMLUpsert;
    })(Upsert);

    var SafeStringUpsert = (function (_Upsert3) {
        _inherits(SafeStringUpsert, _Upsert3);

        function SafeStringUpsert(bounds, lastStringValue) {
            _classCallCheck(this, SafeStringUpsert);

            _Upsert3.call(this, bounds);
            this.lastStringValue = lastStringValue;
        }

        SafeStringUpsert.insert = function insert(dom, cursor, value) {
            var stringValue = value.toHTML();
            var bounds = dom.insertHTMLBefore(cursor.element, stringValue, cursor.nextSibling);
            return new SafeStringUpsert(bounds, stringValue);
        };

        SafeStringUpsert.prototype.update = function update(dom, value) {
            if (isSafeString(value)) {
                var stringValue = value.toHTML();
                if (stringValue !== this.lastStringValue) {
                    var bounds = this.bounds;

                    var parentElement = bounds.parentElement();
                    var nextSibling = _glimmerRuntimeLibBounds.clear(bounds);
                    this.bounds = dom.insertHTMLBefore(parentElement, nextSibling, stringValue);
                    this.lastStringValue = stringValue;
                }
                return true;
            } else {
                return false;
            }
        };

        return SafeStringUpsert;
    })(Upsert);

    var NodeUpsert = (function (_Upsert4) {
        _inherits(NodeUpsert, _Upsert4);

        function NodeUpsert() {
            _classCallCheck(this, NodeUpsert);

            _Upsert4.apply(this, arguments);
        }

        NodeUpsert.insert = function insert(dom, cursor, node) {
            dom.insertBefore(cursor.element, node, cursor.nextSibling);
            return new NodeUpsert(_glimmerRuntimeLibBounds.single(cursor.element, node));
        };

        NodeUpsert.prototype.update = function update(dom, value) {
            if (isNode(value)) {
                var bounds = this.bounds;

                var parentElement = bounds.parentElement();
                var nextSibling = _glimmerRuntimeLibBounds.clear(bounds);
                this.bounds = dom.insertNodeBefore(parentElement, value, nextSibling);
                return true;
            } else {
                return false;
            }
        };

        return NodeUpsert;
    })(Upsert);
});

enifed('@glimmer/runtime/lib/utils', ['exports', '@glimmer/util'], function (exports, _glimmerUtil) {
    'use strict';

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var EMPTY_ARRAY = _glimmerUtil.HAS_NATIVE_WEAKMAP ? Object.freeze([]) : [];
    exports.EMPTY_ARRAY = EMPTY_ARRAY;
    var EMPTY_DICT = _glimmerUtil.HAS_NATIVE_WEAKMAP ? Object.freeze(_glimmerUtil.dict()) : _glimmerUtil.dict();
    exports.EMPTY_DICT = EMPTY_DICT;

    var ListRange = (function () {
        function ListRange(list, start, end) {
            _classCallCheck(this, ListRange);

            this.list = list;
            this.start = start;
            this.end = end;
        }

        ListRange.prototype.at = function at(index) {
            if (index >= this.list.length) return null;
            return this.list[index];
        };

        ListRange.prototype.min = function min() {
            return this.start;
        };

        ListRange.prototype.max = function max() {
            return this.end;
        };

        return ListRange;
    })();

    exports.ListRange = ListRange;
});

enifed('@glimmer/runtime/lib/vm', ['exports', '@glimmer/runtime/lib/vm/append', '@glimmer/runtime/lib/vm/update', '@glimmer/runtime/lib/vm/render-result'], function (exports, _glimmerRuntimeLibVmAppend, _glimmerRuntimeLibVmUpdate, _glimmerRuntimeLibVmRenderResult) {
  'use strict';

  exports.VM = _glimmerRuntimeLibVmAppend.default;
  exports.PublicVM = _glimmerRuntimeLibVmAppend.PublicVM;
  exports.UpdatingVM = _glimmerRuntimeLibVmUpdate.default;
  exports.RenderResult = _glimmerRuntimeLibVmRenderResult.default;
});

enifed('@glimmer/runtime/lib/vm/append', ['exports', '@glimmer/runtime/lib/environment', '@glimmer/util', '@glimmer/reference', '@glimmer/runtime/lib/compiled/opcodes/vm', '@glimmer/runtime/lib/vm/update', '@glimmer/runtime/lib/vm/render-result', '@glimmer/runtime/lib/vm/frame', '@glimmer/runtime/lib/opcodes'], function (exports, _glimmerRuntimeLibEnvironment, _glimmerUtil, _glimmerReference, _glimmerRuntimeLibCompiledOpcodesVm, _glimmerRuntimeLibVmUpdate, _glimmerRuntimeLibVmRenderResult, _glimmerRuntimeLibVmFrame, _glimmerRuntimeLibOpcodes) {
    'use strict';

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var VM = (function () {
        function VM(env, scope, dynamicScope, elementStack) {
            _classCallCheck(this, VM);

            this.env = env;
            this.elementStack = elementStack;
            this.dynamicScopeStack = new _glimmerUtil.Stack();
            this.scopeStack = new _glimmerUtil.Stack();
            this.updatingOpcodeStack = new _glimmerUtil.Stack();
            this.cacheGroups = new _glimmerUtil.Stack();
            this.listBlockStack = new _glimmerUtil.Stack();
            this.frame = new _glimmerRuntimeLibVmFrame.FrameStack();
            this.env = env;
            this.constants = env.constants;
            this.elementStack = elementStack;
            this.scopeStack.push(scope);
            this.dynamicScopeStack.push(dynamicScope);
        }

        VM.initial = function initial(env, self, dynamicScope, elementStack, size) {
            var scope = _glimmerRuntimeLibEnvironment.Scope.root(self, size);
            return new VM(env, scope, dynamicScope, elementStack);
        };

        VM.prototype.capture = function capture() {
            return {
                env: this.env,
                scope: this.scope(),
                dynamicScope: this.dynamicScope(),
                frame: this.frame.capture()
            };
        };

        VM.prototype.goto = function goto(ip) {
            // assert(this.frame.getOps().contains(op), `Illegal jump to ${op.label}`);
            this.frame.goto(ip);
        };

        VM.prototype.beginCacheGroup = function beginCacheGroup() {
            this.cacheGroups.push(this.updating().tail());
        };

        VM.prototype.commitCacheGroup = function commitCacheGroup() {
            //        JumpIfNotModified(END)
            //        (head)
            //        (....)
            //        (tail)
            //        DidModify
            // END:   Noop
            var END = new _glimmerRuntimeLibCompiledOpcodesVm.LabelOpcode("END");
            var opcodes = this.updating();
            var marker = this.cacheGroups.pop();
            var head = marker ? opcodes.nextNode(marker) : opcodes.head();
            var tail = opcodes.tail();
            var tag = _glimmerReference.combineSlice(new _glimmerUtil.ListSlice(head, tail));
            var guard = new _glimmerRuntimeLibCompiledOpcodesVm.JumpIfNotModifiedOpcode(tag, END);
            opcodes.insertBefore(guard, head);
            opcodes.append(new _glimmerRuntimeLibCompiledOpcodesVm.DidModifyOpcode(guard));
            opcodes.append(END);
        };

        VM.prototype.enter = function enter(sliceId) {
            var updating = new _glimmerUtil.LinkedList();
            var tracker = this.stack().pushUpdatableBlock();
            var state = this.capture();
            var slice = this.constants.getSlice(sliceId);
            var tryOpcode = new _glimmerRuntimeLibVmUpdate.TryOpcode(slice, state, tracker, updating);
            this.didEnter(tryOpcode, updating);
        };

        VM.prototype.enterWithKey = function enterWithKey(key, ops) {
            var updating = new _glimmerUtil.LinkedList();
            var tracker = this.stack().pushUpdatableBlock();
            var state = this.capture();
            var tryOpcode = new _glimmerRuntimeLibVmUpdate.TryOpcode(ops, state, tracker, updating);
            this.listBlock().map[key] = tryOpcode;
            this.didEnter(tryOpcode, updating);
        };

        VM.prototype.enterList = function enterList(ops) {
            var updating = new _glimmerUtil.LinkedList();
            var tracker = this.stack().pushBlockList(updating);
            var state = this.capture();
            var artifacts = this.frame.getIterator().artifacts;
            var opcode = new _glimmerRuntimeLibVmUpdate.ListBlockOpcode(ops, state, tracker, updating, artifacts);
            this.listBlockStack.push(opcode);
            this.didEnter(opcode, updating);
        };

        VM.prototype.didEnter = function didEnter(opcode, updating) {
            this.updateWith(opcode);
            this.updatingOpcodeStack.push(updating);
        };

        VM.prototype.exit = function exit() {
            this.stack().popBlock();
            this.updatingOpcodeStack.pop();
            var parent = this.updating().tail();
            parent.didInitializeChildren();
        };

        VM.prototype.exitList = function exitList() {
            this.exit();
            this.listBlockStack.pop();
        };

        VM.prototype.updateWith = function updateWith(opcode) {
            this.updating().append(opcode);
        };

        VM.prototype.listBlock = function listBlock() {
            return _glimmerUtil.expect(this.listBlockStack.current, 'expected a list block');
        };

        VM.prototype.updating = function updating() {
            return _glimmerUtil.expect(this.updatingOpcodeStack.current, 'expected updating opcode on the updating opcode stack');
        };

        VM.prototype.stack = function stack() {
            return this.elementStack;
        };

        VM.prototype.scope = function scope() {
            return _glimmerUtil.expect(this.scopeStack.current, 'expected scope on the scope stack');
        };

        VM.prototype.dynamicScope = function dynamicScope() {
            return _glimmerUtil.expect(this.dynamicScopeStack.current, 'expected dynamic scope on the dynamic scope stack');
        };

        VM.prototype.pushFrame = function pushFrame(block, args, callerScope) {
            this.frame.push(block.slice);
            if (args) this.frame.setArgs(args);
            if (args && args.blocks) this.frame.setBlocks(args.blocks);
            if (callerScope) this.frame.setCallerScope(callerScope);
        };

        VM.prototype.pushComponentFrame = function pushComponentFrame(layout, args, callerScope, component, manager, shadow) {
            this.frame.push(layout.slice, component, manager, shadow);
            if (args) this.frame.setArgs(args);
            if (args && args.blocks) this.frame.setBlocks(args.blocks);
            if (callerScope) this.frame.setCallerScope(callerScope);
        };

        VM.prototype.pushEvalFrame = function pushEvalFrame(slice) {
            this.frame.push(slice);
        };

        VM.prototype.pushChildScope = function pushChildScope() {
            this.scopeStack.push(this.scope().child());
        };

        VM.prototype.pushCallerScope = function pushCallerScope() {
            this.scopeStack.push(_glimmerUtil.expect(this.scope().getCallerScope(), 'pushCallerScope is called when a caller scope is present'));
        };

        VM.prototype.pushDynamicScope = function pushDynamicScope() {
            var child = this.dynamicScope().child();
            this.dynamicScopeStack.push(child);
            return child;
        };

        VM.prototype.pushRootScope = function pushRootScope(self, size) {
            var scope = _glimmerRuntimeLibEnvironment.Scope.root(self, size);
            this.scopeStack.push(scope);
            return scope;
        };

        VM.prototype.popScope = function popScope() {
            this.scopeStack.pop();
        };

        VM.prototype.popDynamicScope = function popDynamicScope() {
            this.dynamicScopeStack.pop();
        };

        VM.prototype.newDestroyable = function newDestroyable(d) {
            this.stack().newDestroyable(d);
        };

        /// SCOPE HELPERS

        VM.prototype.getSelf = function getSelf() {
            return this.scope().getSelf();
        };

        VM.prototype.referenceForSymbol = function referenceForSymbol(symbol) {
            return this.scope().getSymbol(symbol);
        };

        VM.prototype.getArgs = function getArgs() {
            return this.frame.getArgs();
        };

        /// EXECUTION

        VM.prototype.resume = function resume(opcodes, frame) {
            return this.execute(opcodes, function (vm) {
                return vm.frame.restore(frame);
            });
        };

        VM.prototype.execute = function execute(opcodes, initialize) {
            _glimmerUtil.LOGGER.debug("[VM] Begin program execution");
            var elementStack = this.elementStack;
            var frame = this.frame;
            var updatingOpcodeStack = this.updatingOpcodeStack;
            var env = this.env;

            elementStack.pushSimpleBlock();
            updatingOpcodeStack.push(new _glimmerUtil.LinkedList());
            frame.push(opcodes);
            if (initialize) initialize(this);
            var opcode = undefined;
            while (frame.hasOpcodes()) {
                if (opcode = frame.nextStatement(this.env)) {
                    _glimmerUtil.LOGGER.trace(opcode);
                    _glimmerRuntimeLibOpcodes.APPEND_OPCODES.evaluate(this, opcode);
                }
            }
            _glimmerUtil.LOGGER.debug("[VM] Completed program execution");
            return new _glimmerRuntimeLibVmRenderResult.default(env, _glimmerUtil.expect(updatingOpcodeStack.pop(), 'there should be a final updating opcode stack'), elementStack.popBlock());
        };

        VM.prototype.evaluateOpcode = function evaluateOpcode(opcode) {
            _glimmerRuntimeLibOpcodes.APPEND_OPCODES.evaluate(this, opcode);
        };

        // Make sure you have opcodes that push and pop a scope around this opcode
        // if you need to change the scope.

        VM.prototype.invokeBlock = function invokeBlock(block, args) {
            var compiled = block.compile(this.env);
            this.pushFrame(compiled, args);
        };

        VM.prototype.invokePartial = function invokePartial(block) {
            var compiled = block.compile(this.env);
            this.pushFrame(compiled);
        };

        VM.prototype.invokeLayout = function invokeLayout(args, layout, callerScope, component, manager, shadow) {
            this.pushComponentFrame(layout, args, callerScope, component, manager, shadow);
        };

        VM.prototype.evaluateOperand = function evaluateOperand(expr) {
            this.frame.setOperand(expr.evaluate(this));
        };

        VM.prototype.evaluateArgs = function evaluateArgs(args) {
            var evaledArgs = this.frame.setArgs(args.evaluate(this));
            this.frame.setOperand(evaledArgs.positional.at(0));
        };

        VM.prototype.bindPositionalArgs = function bindPositionalArgs(symbols) {
            var args = _glimmerUtil.expect(this.frame.getArgs(), 'bindPositionalArgs assumes a previous setArgs');
            var positional = args.positional;

            var scope = this.scope();
            for (var i = 0; i < symbols.length; i++) {
                scope.bindSymbol(symbols[i], positional.at(i));
            }
        };

        VM.prototype.bindNamedArgs = function bindNamedArgs(names, symbols) {
            var args = _glimmerUtil.expect(this.frame.getArgs(), 'bindNamedArgs assumes a previous setArgs');
            var scope = this.scope();
            var named = args.named;

            for (var i = 0; i < names.length; i++) {
                var _name = this.constants.getString(names[i]);
                scope.bindSymbol(symbols[i], named.get(_name));
            }
        };

        VM.prototype.bindBlocks = function bindBlocks(names, symbols) {
            var blocks = this.frame.getBlocks();
            var scope = this.scope();
            for (var i = 0; i < names.length; i++) {
                var _name2 = this.constants.getString(names[i]);
                scope.bindBlock(symbols[i], blocks && blocks[_name2] || null);
            }
        };

        VM.prototype.bindPartialArgs = function bindPartialArgs(symbol) {
            var args = _glimmerUtil.expect(this.frame.getArgs(), 'bindPartialArgs assumes a previous setArgs');
            var scope = this.scope();
            _glimmerUtil.assert(args, "Cannot bind named args");
            scope.bindPartialArgs(symbol, args);
        };

        VM.prototype.bindCallerScope = function bindCallerScope() {
            var callerScope = this.frame.getCallerScope();
            var scope = this.scope();
            _glimmerUtil.assert(callerScope, "Cannot bind caller scope");
            scope.bindCallerScope(callerScope);
        };

        VM.prototype.bindDynamicScope = function bindDynamicScope(names) {
            var args = _glimmerUtil.expect(this.frame.getArgs(), 'bindDynamicScope assumes a previous setArgs');
            var scope = this.dynamicScope();
            _glimmerUtil.assert(args, "Cannot bind dynamic scope");
            for (var i = 0; i < names.length; i++) {
                var _name3 = this.constants.getString(names[i]);
                scope.set(_name3, args.named.get(_name3));
            }
        };

        return VM;
    })();

    exports.default = VM;
});

enifed('@glimmer/runtime/lib/vm/frame', ['exports', '@glimmer/util'], function (exports, _glimmerUtil) {
    'use strict';

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var CapturedFrame = function CapturedFrame(operand, args, condition) {
        _classCallCheck(this, CapturedFrame);

        this.operand = operand;
        this.args = args;
        this.condition = condition;
    };

    exports.CapturedFrame = CapturedFrame;

    var Frame = (function () {
        function Frame(ops) {
            var component = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
            var manager = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
            var shadow = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

            _classCallCheck(this, Frame);

            this.ops = ops;
            this.component = component;
            this.manager = manager;
            this.shadow = shadow;
            this.operand = null;
            this.immediate = null;
            this.args = null;
            this.callerScope = null;
            this.blocks = null;
            this.condition = null;
            this.iterator = null;
            this.key = null;
            this.ip = ops[0];
        }

        Frame.prototype.capture = function capture() {
            return new CapturedFrame(this.operand, this.args, this.condition);
        };

        Frame.prototype.restore = function restore(frame) {
            this.operand = frame['operand'];
            this.args = frame['args'];
            this.condition = frame['condition'];
        };

        return Frame;
    })();

    var FrameStack = (function () {
        function FrameStack() {
            _classCallCheck(this, FrameStack);

            this.frames = [];
            this.frame = null;
        }

        FrameStack.prototype.push = function push(ops) {
            var component = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
            var manager = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
            var shadow = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

            var frame = this.frame === null ? this.frame = 0 : ++this.frame;
            if (this.frames.length <= frame) {
                this.frames.push(null);
            }
            this.frames[frame] = new Frame(ops, component, manager, shadow);
        };

        FrameStack.prototype.pop = function pop() {
            var frames = this.frames;
            var frame = this.frame;

            frames[_glimmerUtil.expect(frame, 'only pop after pushing')] = null;
            this.frame = frame === 0 ? null : frame - 1;
        };

        FrameStack.prototype.capture = function capture() {
            return this.currentFrame.capture();
        };

        FrameStack.prototype.restore = function restore(frame) {
            this.currentFrame.restore(frame);
        };

        FrameStack.prototype.getOps = function getOps() {
            return this.currentFrame.ops;
        };

        FrameStack.prototype.getCurrent = function getCurrent() {
            return this.currentFrame.ip;
        };

        FrameStack.prototype.setCurrent = function setCurrent(ip) {
            return this.currentFrame.ip = ip;
        };

        FrameStack.prototype.getOperand = function getOperand() {
            return _glimmerUtil.unwrap(this.currentFrame.operand);
        };

        FrameStack.prototype.setOperand = function setOperand(operand) {
            return this.currentFrame.operand = operand;
        };

        FrameStack.prototype.getImmediate = function getImmediate() {
            return this.currentFrame.immediate;
        };

        FrameStack.prototype.setImmediate = function setImmediate(value) {
            return this.currentFrame.immediate = value;
        };

        // FIXME: These options are required in practice by the existing code, but
        // figure out why.

        FrameStack.prototype.getArgs = function getArgs() {
            return this.currentFrame.args;
        };

        FrameStack.prototype.setArgs = function setArgs(args) {
            return this.currentFrame.args = args;
        };

        FrameStack.prototype.getCondition = function getCondition() {
            return _glimmerUtil.unwrap(this.currentFrame.condition);
        };

        FrameStack.prototype.setCondition = function setCondition(condition) {
            return this.currentFrame.condition = condition;
        };

        FrameStack.prototype.getIterator = function getIterator() {
            return _glimmerUtil.unwrap(this.currentFrame.iterator);
        };

        FrameStack.prototype.setIterator = function setIterator(iterator) {
            return this.currentFrame.iterator = iterator;
        };

        FrameStack.prototype.getKey = function getKey() {
            return this.currentFrame.key;
        };

        FrameStack.prototype.setKey = function setKey(key) {
            return this.currentFrame.key = key;
        };

        FrameStack.prototype.getBlocks = function getBlocks() {
            return _glimmerUtil.unwrap(this.currentFrame.blocks);
        };

        FrameStack.prototype.setBlocks = function setBlocks(blocks) {
            return this.currentFrame.blocks = blocks;
        };

        FrameStack.prototype.getCallerScope = function getCallerScope() {
            return _glimmerUtil.unwrap(this.currentFrame.callerScope);
        };

        FrameStack.prototype.setCallerScope = function setCallerScope(callerScope) {
            return this.currentFrame.callerScope = callerScope;
        };

        FrameStack.prototype.getComponent = function getComponent() {
            return _glimmerUtil.unwrap(this.currentFrame.component);
        };

        FrameStack.prototype.getManager = function getManager() {
            return _glimmerUtil.unwrap(this.currentFrame.manager);
        };

        FrameStack.prototype.getShadow = function getShadow() {
            return this.currentFrame.shadow;
        };

        FrameStack.prototype.goto = function goto(ip) {
            this.setCurrent(ip);
        };

        FrameStack.prototype.hasOpcodes = function hasOpcodes() {
            return this.frame !== null;
        };

        FrameStack.prototype.nextStatement = function nextStatement(env) {
            var ip = this.frames[_glimmerUtil.unwrap(this.frame)].ip;
            var ops = this.getOps();
            if (ip <= ops[1]) {
                var program = env.program;
                this.setCurrent(ip + 4);
                return program.opcode(ip);
            } else {
                this.pop();
                return null;
            }
        };

        _createClass(FrameStack, [{
            key: 'currentFrame',
            get: function () {
                return this.frames[_glimmerUtil.unwrap(this.frame)];
            }
        }]);

        return FrameStack;
    })();

    exports.FrameStack = FrameStack;
});

enifed('@glimmer/runtime/lib/vm/render-result', ['exports', '@glimmer/runtime/lib/bounds', '@glimmer/runtime/lib/vm/update'], function (exports, _glimmerRuntimeLibBounds, _glimmerRuntimeLibVmUpdate) {
    'use strict';

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var RenderResult = (function () {
        function RenderResult(env, updating, bounds) {
            _classCallCheck(this, RenderResult);

            this.env = env;
            this.updating = updating;
            this.bounds = bounds;
        }

        RenderResult.prototype.rerender = function rerender() {
            var _ref = arguments.length <= 0 || arguments[0] === undefined ? { alwaysRevalidate: false } : arguments[0];

            var _ref$alwaysRevalidate = _ref.alwaysRevalidate;
            var alwaysRevalidate = _ref$alwaysRevalidate === undefined ? false : _ref$alwaysRevalidate;
            var env = this.env;
            var updating = this.updating;

            var vm = new _glimmerRuntimeLibVmUpdate.default(env, { alwaysRevalidate: alwaysRevalidate });
            vm.execute(updating, this);
        };

        RenderResult.prototype.parentElement = function parentElement() {
            return this.bounds.parentElement();
        };

        RenderResult.prototype.firstNode = function firstNode() {
            return this.bounds.firstNode();
        };

        RenderResult.prototype.lastNode = function lastNode() {
            return this.bounds.lastNode();
        };

        RenderResult.prototype.opcodes = function opcodes() {
            return this.updating;
        };

        RenderResult.prototype.handleException = function handleException() {
            throw "this should never happen";
        };

        RenderResult.prototype.destroy = function destroy() {
            this.bounds.destroy();
            _glimmerRuntimeLibBounds.clear(this.bounds);
        };

        return RenderResult;
    })();

    exports.default = RenderResult;
});

enifed('@glimmer/runtime/lib/vm/update', ['exports', '@glimmer/runtime/lib/bounds', '@glimmer/runtime/lib/builder', '@glimmer/util', '@glimmer/reference', '@glimmer/runtime/lib/compiled/expressions/args', '@glimmer/runtime/lib/opcodes', '@glimmer/runtime/lib/vm/append'], function (exports, _glimmerRuntimeLibBounds, _glimmerRuntimeLibBuilder, _glimmerUtil, _glimmerReference, _glimmerRuntimeLibCompiledExpressionsArgs, _glimmerRuntimeLibOpcodes, _glimmerRuntimeLibVmAppend) {
    'use strict';

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var UpdatingVM = (function () {
        function UpdatingVM(env, _ref) {
            var _ref$alwaysRevalidate = _ref.alwaysRevalidate;
            var alwaysRevalidate = _ref$alwaysRevalidate === undefined ? false : _ref$alwaysRevalidate;

            _classCallCheck(this, UpdatingVM);

            this.frameStack = new _glimmerUtil.Stack();
            this.env = env;
            this.constants = env.constants;
            this.dom = env.getDOM();
            this.alwaysRevalidate = alwaysRevalidate;
        }

        UpdatingVM.prototype.execute = function execute(opcodes, handler) {
            var frameStack = this.frameStack;

            this.try(opcodes, handler);
            while (true) {
                if (frameStack.isEmpty()) break;
                var opcode = this.frame.nextStatement();
                if (opcode === null) {
                    this.frameStack.pop();
                    continue;
                }
                _glimmerUtil.LOGGER.debug('[VM] OP ' + opcode.type);
                _glimmerUtil.LOGGER.trace(opcode);
                opcode.evaluate(this);
            }
        };

        UpdatingVM.prototype.goto = function goto(op) {
            this.frame.goto(op);
        };

        UpdatingVM.prototype.try = function _try(ops, handler) {
            this.frameStack.push(new UpdatingVMFrame(this, ops, handler));
        };

        UpdatingVM.prototype.throw = function _throw() {
            this.frame.handleException();
            this.frameStack.pop();
        };

        UpdatingVM.prototype.evaluateOpcode = function evaluateOpcode(opcode) {
            opcode.evaluate(this);
        };

        _createClass(UpdatingVM, [{
            key: 'frame',
            get: function () {
                return _glimmerUtil.expect(this.frameStack.current, 'bug: expected a frame');
            }
        }]);

        return UpdatingVM;
    })();

    exports.default = UpdatingVM;

    var BlockOpcode = (function (_UpdatingOpcode) {
        _inherits(BlockOpcode, _UpdatingOpcode);

        function BlockOpcode(ops, state, bounds, children) {
            _classCallCheck(this, BlockOpcode);

            _UpdatingOpcode.call(this);
            this.ops = ops;
            this.type = "block";
            this.next = null;
            this.prev = null;
            var env = state.env;
            var scope = state.scope;
            var dynamicScope = state.dynamicScope;
            var frame = state.frame;

            this.children = children;
            this.env = env;
            this.scope = scope;
            this.dynamicScope = dynamicScope;
            this.frame = frame;
            this.bounds = bounds;
        }

        BlockOpcode.prototype.parentElement = function parentElement() {
            return this.bounds.parentElement();
        };

        BlockOpcode.prototype.firstNode = function firstNode() {
            return this.bounds.firstNode();
        };

        BlockOpcode.prototype.lastNode = function lastNode() {
            return this.bounds.lastNode();
        };

        BlockOpcode.prototype.evaluate = function evaluate(vm) {
            vm.try(this.children, null);
        };

        BlockOpcode.prototype.destroy = function destroy() {
            this.bounds.destroy();
        };

        BlockOpcode.prototype.didDestroy = function didDestroy() {
            this.env.didDestroy(this.bounds);
        };

        BlockOpcode.prototype.toJSON = function toJSON() {
            var details = _glimmerUtil.dict();
            details["guid"] = '' + this._guid;
            return {
                guid: this._guid,
                type: this.type,
                details: details,
                children: this.children.toArray().map(function (op) {
                    return op.toJSON();
                })
            };
        };

        return BlockOpcode;
    })(_glimmerRuntimeLibOpcodes.UpdatingOpcode);

    exports.BlockOpcode = BlockOpcode;

    var TryOpcode = (function (_BlockOpcode) {
        _inherits(TryOpcode, _BlockOpcode);

        function TryOpcode(ops, state, bounds, children) {
            _classCallCheck(this, TryOpcode);

            _BlockOpcode.call(this, ops, state, bounds, children);
            this.type = "try";
            this.tag = this._tag = new _glimmerReference.UpdatableTag(_glimmerReference.CONSTANT_TAG);
        }

        TryOpcode.prototype.didInitializeChildren = function didInitializeChildren() {
            this._tag.update(_glimmerReference.combineSlice(this.children));
        };

        TryOpcode.prototype.evaluate = function evaluate(vm) {
            vm.try(this.children, this);
        };

        TryOpcode.prototype.handleException = function handleException() {
            var env = this.env;
            var scope = this.scope;
            var ops = this.ops;
            var dynamicScope = this.dynamicScope;
            var frame = this.frame;

            var elementStack = _glimmerRuntimeLibBuilder.ElementStack.resume(this.env, this.bounds, this.bounds.reset(env));
            var vm = new _glimmerRuntimeLibVmAppend.default(env, scope, dynamicScope, elementStack);
            var result = vm.resume(ops, frame);
            this.children = result.opcodes();
            this.didInitializeChildren();
        };

        TryOpcode.prototype.toJSON = function toJSON() {
            var json = _BlockOpcode.prototype.toJSON.call(this);
            var details = json["details"];
            if (!details) {
                details = json["details"] = {};
            }
            return _BlockOpcode.prototype.toJSON.call(this);
        };

        return TryOpcode;
    })(BlockOpcode);

    exports.TryOpcode = TryOpcode;

    var ListRevalidationDelegate = (function () {
        function ListRevalidationDelegate(opcode, marker) {
            _classCallCheck(this, ListRevalidationDelegate);

            this.opcode = opcode;
            this.marker = marker;
            this.didInsert = false;
            this.didDelete = false;
            this.map = opcode.map;
            this.updating = opcode['children'];
        }

        ListRevalidationDelegate.prototype.insert = function insert(key, item, memo, before) {
            var map = this.map;
            var opcode = this.opcode;
            var updating = this.updating;

            var nextSibling = null;
            var reference = null;
            if (before) {
                reference = map[before];
                nextSibling = reference['bounds'].firstNode();
            } else {
                nextSibling = this.marker;
            }
            var vm = opcode.vmForInsertion(nextSibling);
            var tryOpcode = null;
            vm.execute(opcode.ops, function (vm) {
                vm.frame.setArgs(_glimmerRuntimeLibCompiledExpressionsArgs.EvaluatedArgs.positional([item, memo]));
                vm.frame.setOperand(item);
                vm.frame.setCondition(new _glimmerReference.ConstReference(true));
                vm.frame.setKey(key);
                var state = vm.capture();
                var tracker = vm.stack().pushUpdatableBlock();
                tryOpcode = new TryOpcode(opcode.ops, state, tracker, vm.updating());
            });
            tryOpcode.didInitializeChildren();
            updating.insertBefore(tryOpcode, reference);
            map[key] = tryOpcode;
            this.didInsert = true;
        };

        ListRevalidationDelegate.prototype.retain = function retain(_key, _item, _memo) {};

        ListRevalidationDelegate.prototype.move = function move(key, _item, _memo, before) {
            var map = this.map;
            var updating = this.updating;

            var entry = map[key];
            var reference = map[before] || null;
            if (before) {
                _glimmerRuntimeLibBounds.move(entry, reference.firstNode());
            } else {
                _glimmerRuntimeLibBounds.move(entry, this.marker);
            }
            updating.remove(entry);
            updating.insertBefore(entry, reference);
        };

        ListRevalidationDelegate.prototype.delete = function _delete(key) {
            var map = this.map;

            var opcode = map[key];
            opcode.didDestroy();
            _glimmerRuntimeLibBounds.clear(opcode);
            this.updating.remove(opcode);
            delete map[key];
            this.didDelete = true;
        };

        ListRevalidationDelegate.prototype.done = function done() {
            this.opcode.didInitializeChildren(this.didInsert || this.didDelete);
        };

        return ListRevalidationDelegate;
    })();

    var ListBlockOpcode = (function (_BlockOpcode2) {
        _inherits(ListBlockOpcode, _BlockOpcode2);

        function ListBlockOpcode(ops, state, bounds, children, artifacts) {
            _classCallCheck(this, ListBlockOpcode);

            _BlockOpcode2.call(this, ops, state, bounds, children);
            this.type = "list-block";
            this.map = _glimmerUtil.dict();
            this.lastIterated = _glimmerReference.INITIAL;
            this.artifacts = artifacts;
            var _tag = this._tag = new _glimmerReference.UpdatableTag(_glimmerReference.CONSTANT_TAG);
            this.tag = _glimmerReference.combine([artifacts.tag, _tag]);
        }

        ListBlockOpcode.prototype.didInitializeChildren = function didInitializeChildren() {
            var listDidChange = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

            this.lastIterated = this.artifacts.tag.value();
            if (listDidChange) {
                this._tag.update(_glimmerReference.combineSlice(this.children));
            }
        };

        ListBlockOpcode.prototype.evaluate = function evaluate(vm) {
            var artifacts = this.artifacts;
            var lastIterated = this.lastIterated;

            if (!artifacts.tag.validate(lastIterated)) {
                var bounds = this.bounds;
                var dom = vm.dom;

                var marker = dom.createComment('');
                dom.insertAfter(bounds.parentElement(), marker, _glimmerUtil.expect(bounds.lastNode(), "can't insert after an empty bounds"));
                var target = new ListRevalidationDelegate(this, marker);
                var synchronizer = new _glimmerReference.IteratorSynchronizer({ target: target, artifacts: artifacts });
                synchronizer.sync();
                this.parentElement().removeChild(marker);
            }
            // Run now-updated updating opcodes
            _BlockOpcode2.prototype.evaluate.call(this, vm);
        };

        ListBlockOpcode.prototype.vmForInsertion = function vmForInsertion(nextSibling) {
            var env = this.env;
            var scope = this.scope;
            var dynamicScope = this.dynamicScope;

            var elementStack = _glimmerRuntimeLibBuilder.ElementStack.forInitialRender(this.env, this.bounds.parentElement(), nextSibling);
            return new _glimmerRuntimeLibVmAppend.default(env, scope, dynamicScope, elementStack);
        };

        ListBlockOpcode.prototype.toJSON = function toJSON() {
            var json = _BlockOpcode2.prototype.toJSON.call(this);
            var map = this.map;
            var inner = Object.keys(map).map(function (key) {
                return JSON.stringify(key) + ': ' + map[key]._guid;
            }).join(", ");
            var details = json["details"];
            if (!details) {
                details = json["details"] = {};
            }
            details["map"] = '{' + inner + '}';
            return json;
        };

        return ListBlockOpcode;
    })(BlockOpcode);

    exports.ListBlockOpcode = ListBlockOpcode;

    var UpdatingVMFrame = (function () {
        function UpdatingVMFrame(vm, ops, exceptionHandler) {
            _classCallCheck(this, UpdatingVMFrame);

            this.vm = vm;
            this.ops = ops;
            this.exceptionHandler = exceptionHandler;
            this.vm = vm;
            this.ops = ops;
            this.current = ops.head();
        }

        UpdatingVMFrame.prototype.goto = function goto(op) {
            this.current = op;
        };

        UpdatingVMFrame.prototype.nextStatement = function nextStatement() {
            var current = this.current;
            var ops = this.ops;

            if (current) this.current = ops.nextNode(current);
            return current;
        };

        UpdatingVMFrame.prototype.handleException = function handleException() {
            if (this.exceptionHandler) {
                this.exceptionHandler.handleException();
            }
        };

        return UpdatingVMFrame;
    })();
});

// Tags
//# sourceMappingURL=glimmer-runtime.amd.map
