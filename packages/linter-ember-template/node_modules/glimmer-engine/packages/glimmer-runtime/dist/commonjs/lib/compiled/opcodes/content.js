"use strict";
const upsert_1 = require("../../upsert");
const interfaces_1 = require("../../component/interfaces");
const opcodes_1 = require("../../opcodes");
const expressions_1 = require("../expressions");
const update_1 = require("../../vm/update");
const glimmer_reference_1 = require("glimmer-reference");
const glimmer_util_1 = require("glimmer-util");
const bounds_1 = require("../../bounds");
const builder_1 = require("../../builder");
const builder_2 = require("./builder");
const references_1 = require("../../references");
const builder_3 = require("../../builder");
const opcodes_2 = require("../../opcodes");
opcodes_2.APPEND_OPCODES.add('DynamicContent', (vm, append) => {
    let opcode = vm.constants.getOther(append);
    opcode.evaluate(vm);
});
function isEmpty(value) {
    return value === null || value === undefined || typeof value['toString'] !== 'function';
}
function normalizeTextValue(value) {
    if (isEmpty(value)) {
        return '';
    }
    return String(value);
}
exports.normalizeTextValue = normalizeTextValue;
function normalizeTrustedValue(value) {
    if (isEmpty(value)) {
        return '';
    }
    if (upsert_1.isString(value)) {
        return value;
    }
    if (upsert_1.isSafeString(value)) {
        return value.toHTML();
    }
    if (upsert_1.isNode(value)) {
        return value;
    }
    return String(value);
}
function normalizeValue(value) {
    if (isEmpty(value)) {
        return '';
    }
    if (upsert_1.isString(value)) {
        return value;
    }
    if (upsert_1.isSafeString(value) || upsert_1.isNode(value)) {
        return value;
    }
    return String(value);
}
class AppendDynamicOpcode {
    evaluate(vm) {
        let reference = vm.frame.getOperand();
        let normalized = this.normalize(reference);
        let value, cache;
        if (glimmer_reference_1.isConst(reference)) {
            value = normalized.value();
        }
        else {
            cache = new glimmer_reference_1.ReferenceCache(normalized);
            value = cache.peek();
        }
        let stack = vm.stack();
        let upsert = this.insert(vm.env.getAppendOperations(), stack, value);
        let bounds = new builder_1.Fragment(upsert.bounds);
        stack.newBounds(bounds);
        if (cache /* i.e. !isConst(reference) */) {
            vm.updateWith(this.updateWith(vm, reference, cache, bounds, upsert));
        }
    }
}
exports.AppendDynamicOpcode = AppendDynamicOpcode;
class GuardedAppendOpcode extends AppendDynamicOpcode {
    constructor(expression, symbolTable) {
        super();
        this.expression = expression;
        this.symbolTable = symbolTable;
        this.deopted = null;
    }
    evaluate(vm) {
        if (this.deopted) {
            vm.pushEvalFrame(this.deopted);
        }
        else {
            vm.evaluateOperand(this.expression);
            let value = vm.frame.getOperand().value();
            if (interfaces_1.isComponentDefinition(value)) {
                vm.pushEvalFrame(this.deopt(vm.env));
            }
            else {
                super.evaluate(vm);
            }
        }
    }
    deopt(env) {
        // At compile time, we determined that this append callsite might refer
        // to a local variable/property lookup that resolves to a component
        // definition at runtime.
        //
        // We could have eagerly compiled this callsite into something like this:
        //
        //   {{#if (is-component-definition foo)}}
        //     {{component foo}}
        //   {{else}}
        //     {{foo}}
        //   {{/if}}
        //
        // However, in practice, there might be a large amout of these callsites
        // and most of them would resolve to a simple value lookup. Therefore, we
        // tried to be optimistic and assumed that the callsite will resolve to
        // appending a simple value.
        //
        // However, we have reached here because at runtime, the guard conditional
        // have detected that this callsite is indeed referring to a component
        // definition object. Since this is likely going to be true for other
        // instances of the same callsite, it is now appropiate to deopt into the
        // expanded version that handles both cases. The compilation would look
        // like this:
        //
        //               PutValue(expression)
        //               Test(is-component-definition)
        //               Enter(BEGIN, END)
        //   BEGIN:      Noop
        //               JumpUnless(VALUE)
        //               PutDynamicComponentDefinitionOpcode
        //               OpenComponent
        //               CloseComponent
        //               Jump(END)
        //   VALUE:      Noop
        //               OptimizedAppend
        //   END:        Noop
        //               Exit
        //
        // Keep in mind that even if we *don't* reach here at initial render time,
        // it is still possible (although quite rare) that the simple value we
        // encounter during initial render could later change into a component
        // definition object at update time. That is handled by the "lazy deopt"
        // code on the update side (scroll down for the next big block of comment).
        let dsl = new builder_2.default(this.symbolTable, env);
        dsl.putValue(this.expression);
        dsl.test(IsComponentDefinitionReference.create);
        dsl.labelled(null, (dsl, _BEGIN, END) => {
            dsl.jumpUnless('VALUE');
            dsl.putDynamicComponentDefinition();
            dsl.openComponent(expressions_1.CompiledArgs.empty());
            dsl.closeComponent();
            dsl.jump(END);
            dsl.label('VALUE');
            dsl.dynamicContent(new this.AppendOpcode());
        });
        let deopted = this.deopted = dsl.toOpSeq();
        // From this point on, we have essentially replaced ourselves with a new set
        // of opcodes. Since we will always be executing the new/deopted code, it's
        // a good idea (as a pattern) to null out any unneeded fields here to avoid
        // holding on to unneeded/stale objects:
        // QUESTION: Shouldn't this whole object be GCed? If not, why not?
        this.expression = null;
        return deopted;
    }
}
exports.GuardedAppendOpcode = GuardedAppendOpcode;
class IsComponentDefinitionReference extends references_1.ConditionalReference {
    static create(inner) {
        return new IsComponentDefinitionReference(inner);
    }
    toBool(value) {
        return interfaces_1.isComponentDefinition(value);
    }
}
class UpdateOpcode extends opcodes_1.UpdatingOpcode {
    constructor(cache, bounds, upsert) {
        super();
        this.cache = cache;
        this.bounds = bounds;
        this.upsert = upsert;
        this.tag = cache.tag;
    }
    evaluate(vm) {
        let value = this.cache.revalidate();
        if (glimmer_reference_1.isModified(value)) {
            let { bounds, upsert } = this;
            let { dom } = vm;
            if (!this.upsert.update(dom, value)) {
                let cursor = new bounds_1.Cursor(bounds.parentElement(), bounds_1.clear(bounds));
                upsert = this.upsert = this.insert(vm.env.getAppendOperations(), cursor, value);
            }
            bounds.update(upsert.bounds);
        }
    }
    toJSON() {
        let { _guid: guid, type, cache } = this;
        return {
            guid,
            type,
            details: { lastValue: JSON.stringify(cache.peek()) }
        };
    }
}
class GuardedUpdateOpcode extends UpdateOpcode {
    constructor(reference, cache, bounds, upsert, appendOpcode, state) {
        super(cache, bounds, upsert);
        this.reference = reference;
        this.appendOpcode = appendOpcode;
        this.state = state;
        this.deopted = null;
        this.tag = this._tag = new glimmer_reference_1.UpdatableTag(this.tag);
    }
    evaluate(vm) {
        if (this.deopted) {
            vm.evaluateOpcode(this.deopted);
        }
        else {
            if (interfaces_1.isComponentDefinition(this.reference.value())) {
                this.lazyDeopt(vm);
            }
            else {
                super.evaluate(vm);
            }
        }
    }
    lazyDeopt(vm) {
        // Durign initial render, we know that the reference does not contain a
        // component definition, so we optimistically assumed that this append
        // is just a normal append. However, at update time, we discovered that
        // the reference has switched into containing a component definition, so
        // we need to do a "lazy deopt", simulating what would have happened if
        // we had decided to perform the deopt in the first place during initial
        // render.
        //
        // More concretely, we would have expanded the curly into a if/else, and
        // based on whether the value is a component definition or not, we would
        // have entered either the dynamic component branch or the simple value
        // branch.
        //
        // Since we rendered a simple value during initial render (and all the
        // updates up until this point), we need to pretend that the result is
        // produced by the "VALUE" branch of the deopted append opcode:
        //
        //   Try(BEGIN, END)
        //     Assert(IsComponentDefinition, expected=false)
        //     OptimizedUpdate
        //
        // In this case, because the reference has switched from being a simple
        // value into a component definition, what would have happened is that
        // the assert would throw, causing the Try opcode to teardown the bounds
        // and rerun the original append opcode.
        //
        // Since the Try opcode would have nuked the updating opcodes anyway, we
        // wouldn't have to worry about simulating those. All we have to do is to
        // execute the Try opcode and immediately throw.
        let { bounds, appendOpcode, state } = this;
        let appendOps = appendOpcode.deopt(vm.env);
        let enter = glimmer_util_1.expect(appendOps[2], 'hardcoded deopt logic');
        let ops = vm.constants.getSlice(enter.data[0]);
        let tracker = new builder_3.UpdatableBlockTracker(bounds.parentElement());
        tracker.newBounds(this.bounds);
        let children = new glimmer_util_1.LinkedList();
        state.frame['condition'] = IsComponentDefinitionReference.create(glimmer_util_1.expect(state.frame['operand'], 'operand should be populated'));
        let deopted = this.deopted = new update_1.TryOpcode(ops, state, tracker, children);
        this._tag.update(deopted.tag);
        vm.evaluateOpcode(deopted);
        vm.throw();
        // From this point on, we have essentially replaced ourselve with a new
        // opcode. Since we will always be executing the new/deopted code, it's a
        // good idea (as a pattern) to null out any unneeded fields here to avoid
        // holding on to unneeded/stale objects:
        // QUESTION: Shouldn't this whole object be GCed? If not, why not?
        this._tag = null;
        this.reference = null;
        this.cache = null;
        this.bounds = null;
        this.upsert = null;
        this.appendOpcode = null;
        this.state = null;
    }
    toJSON() {
        let { _guid: guid, type, deopted } = this;
        if (deopted) {
            return {
                guid,
                type,
                deopted: true,
                children: [deopted.toJSON()]
            };
        }
        else {
            return super.toJSON();
        }
    }
}
class OptimizedCautiousAppendOpcode extends AppendDynamicOpcode {
    constructor() {
        super(...arguments);
        this.type = 'optimized-cautious-append';
    }
    normalize(reference) {
        return glimmer_reference_1.map(reference, normalizeValue);
    }
    insert(dom, cursor, value) {
        return upsert_1.cautiousInsert(dom, cursor, value);
    }
    updateWith(_vm, _reference, cache, bounds, upsert) {
        return new OptimizedCautiousUpdateOpcode(cache, bounds, upsert);
    }
}
exports.OptimizedCautiousAppendOpcode = OptimizedCautiousAppendOpcode;
class OptimizedCautiousUpdateOpcode extends UpdateOpcode {
    constructor() {
        super(...arguments);
        this.type = 'optimized-cautious-update';
    }
    insert(dom, cursor, value) {
        return upsert_1.cautiousInsert(dom, cursor, value);
    }
}
class GuardedCautiousAppendOpcode extends GuardedAppendOpcode {
    constructor() {
        super(...arguments);
        this.type = 'guarded-cautious-append';
        this.AppendOpcode = OptimizedCautiousAppendOpcode;
    }
    normalize(reference) {
        return glimmer_reference_1.map(reference, normalizeValue);
    }
    insert(dom, cursor, value) {
        return upsert_1.cautiousInsert(dom, cursor, value);
    }
    updateWith(vm, reference, cache, bounds, upsert) {
        return new GuardedCautiousUpdateOpcode(reference, cache, bounds, upsert, this, vm.capture());
    }
}
exports.GuardedCautiousAppendOpcode = GuardedCautiousAppendOpcode;
class GuardedCautiousUpdateOpcode extends GuardedUpdateOpcode {
    constructor() {
        super(...arguments);
        this.type = 'guarded-cautious-update';
    }
    insert(dom, cursor, value) {
        return upsert_1.cautiousInsert(dom, cursor, value);
    }
}
class OptimizedTrustingAppendOpcode extends AppendDynamicOpcode {
    constructor() {
        super(...arguments);
        this.type = 'optimized-trusting-append';
    }
    normalize(reference) {
        return glimmer_reference_1.map(reference, normalizeTrustedValue);
    }
    insert(dom, cursor, value) {
        return upsert_1.trustingInsert(dom, cursor, value);
    }
    updateWith(_vm, _reference, cache, bounds, upsert) {
        return new OptimizedTrustingUpdateOpcode(cache, bounds, upsert);
    }
}
exports.OptimizedTrustingAppendOpcode = OptimizedTrustingAppendOpcode;
class OptimizedTrustingUpdateOpcode extends UpdateOpcode {
    constructor() {
        super(...arguments);
        this.type = 'optimized-trusting-update';
    }
    insert(dom, cursor, value) {
        return upsert_1.trustingInsert(dom, cursor, value);
    }
}
class GuardedTrustingAppendOpcode extends GuardedAppendOpcode {
    constructor() {
        super(...arguments);
        this.type = 'guarded-trusting-append';
        this.AppendOpcode = OptimizedTrustingAppendOpcode;
    }
    normalize(reference) {
        return glimmer_reference_1.map(reference, normalizeTrustedValue);
    }
    insert(dom, cursor, value) {
        return upsert_1.trustingInsert(dom, cursor, value);
    }
    updateWith(vm, reference, cache, bounds, upsert) {
        return new GuardedTrustingUpdateOpcode(reference, cache, bounds, upsert, this, vm.capture());
    }
}
exports.GuardedTrustingAppendOpcode = GuardedTrustingAppendOpcode;
class GuardedTrustingUpdateOpcode extends GuardedUpdateOpcode {
    constructor() {
        super(...arguments);
        this.type = 'trusting-update';
    }
    insert(dom, cursor, value) {
        return upsert_1.trustingInsert(dom, cursor, value);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYi9jb21waWxlZC9vcGNvZGVzL2NvbnRlbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLHlDQVdzQjtBQUN0QiwyREFBbUU7QUFFbkUsMkNBQTJEO0FBQzNELGdEQUFrRTtBQUVsRSw0Q0FBcUQ7QUFDckQseURBQXNHO0FBQ3RHLCtDQUF5RTtBQUN6RSx5Q0FBNkM7QUFDN0MsMkNBQXlDO0FBQ3pDLHVDQUF5QztBQUN6QyxpREFBd0Q7QUFFeEQsMkNBQXNEO0FBRXRELDJDQUE2RDtBQUU3RCx3QkFBYyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLEVBQUUsRUFBRSxNQUFNO0lBQzlDLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBbUMsQ0FBQztJQUM3RSxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3RCLENBQUMsQ0FBQyxDQUFDO0FBRUgsaUJBQWlCLEtBQWE7SUFDNUIsTUFBTSxDQUFDLEtBQUssS0FBSyxJQUFJLElBQUksS0FBSyxLQUFLLFNBQVMsSUFBSSxPQUFPLEtBQUssQ0FBQyxVQUFVLENBQUMsS0FBSyxVQUFVLENBQUM7QUFDMUYsQ0FBQztBQUVELDRCQUFtQyxLQUFhO0lBQzlDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbkIsTUFBTSxDQUFDLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFDRCxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3ZCLENBQUM7QUFMRCxnREFLQztBQUVELCtCQUErQixLQUFhO0lBQzFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbkIsTUFBTSxDQUFDLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFDRCxF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