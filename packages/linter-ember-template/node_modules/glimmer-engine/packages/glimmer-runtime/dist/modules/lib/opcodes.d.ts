import { Opaque, Option, Dict, Slice as ListSlice } from 'glimmer-util';
import { RevisionTag, VersionedPathReference } from 'glimmer-reference';
import { VM, UpdatingVM } from './vm';
import { CompiledExpression, CompiledArgs } from './compiled/expressions';
import { Slice } from './compiled/opcodes/builder';
import { InlineBlock } from './scanner';
export interface OpcodeJSON {
    type: number | string;
    guid?: Option<number>;
    deopted?: boolean;
    args?: string[];
    details?: Dict<Option<string>>;
    children?: OpcodeJSON[];
}
export declare function pretty(json: OpcodeJSON): string;
export declare function defaultToJSON(opcode: AppendOpcode): OpcodeJSON;
export declare type OpcodeName = "PushChildScope" | "PopScope" | "PushDynamicScope" | "PopDynamicScope" | "Put" | "EvaluatePut" | "PutArgs" | "BindPositionalArgs" | "BindNamedArgs" | "BindBlocks" | "BindPartialArgs" | "BindCallerScope" | "BindDynamicScope" | "Enter" | "Exit" | "Evaluate" | "Jump" | "JumpIf" | "JumpUnless" | "Test" | "OpenBlock" | "CloseBlock" | "PutDynamicComponent" | "PutComponent" | "OpenComponent" | "DidCreateElement" | "ShadowAttributes" | "DidRenderLayout" | "CloseComponent" | "Text" | "Comment" | "DynamicContent" | "OpenElement" | "PushRemoteElement" | "PopRemoteElement" | "OpenComponentElement" | "OpenDynamicElement" | "FlushElement" | "CloseElement" | "PopElement" | "StaticAttr" | "Modifier" | "DynamicAttrNS" | "DynamicAttr" | "PutIterator" | "EnterList" | "ExitList" | "EnterWithKey" | "NextIter" | "PutDynamicPartial" | "PutPartial" | "EvaluatePartial";
export declare type ConstantType = 'slice' | 'block' | 'reference' | 'string' | 'number' | 'expression';
export declare type ConstantReference = number;
export declare type ConstantString = number;
export declare type ConstantExpression = number;
export declare type ConstantSlice = number;
export declare type ConstantBlock = number;
export declare type ConstantFunction = number;
export declare type ConstantArray = number;
export declare type ConstantOther = number;
export declare class Constants {
    private references;
    private strings;
    private expressions;
    private arrays;
    private slices;
    private blocks;
    private functions;
    private others;
    NULL_REFERENCE: number;
    UNDEFINED_REFERENCE: number;
    constructor();
    getReference<T extends Opaque>(value: ConstantReference): VersionedPathReference<T>;
    reference(value: VersionedPathReference<Opaque>): ConstantReference;
    getString(value: ConstantString): string;
    string(value: string): ConstantString;
    getExpression<T>(value: ConstantExpression): T;
    expression(value: CompiledExpression<Opaque> | CompiledArgs): ConstantExpression;
    getArray(value: ConstantArray): number[];
    array(values: number[]): ConstantArray;
    getSlice(value: ConstantSlice): Slice;
    slice(slice: Slice): ConstantSlice;
    getBlock(value: ConstantBlock): InlineBlock;
    block(block: InlineBlock): ConstantBlock;
    getFunction<T extends Function>(value: ConstantFunction): T;
    function(f: Function): ConstantFunction;
    getOther<T>(value: ConstantOther): T;
    other(other: Opaque): ConstantOther;
}
export declare type Operand1 = number;
export declare type Operand2 = number;
export declare type Operand3 = number;
export declare type AppendOpcodeData = [Operand1, Operand2, Operand3];
export declare type OpcodeToJSON = (data: AppendOpcode, constants: Constants) => OpcodeJSON;
export declare type EvaluateOpcode<T extends AppendOpcodeData> = (vm: VM, op1: Operand1, op2: Operand2, op3: Operand3) => void;
export declare class AppendOpcodes {
    private map;
    private names;
    private evaluateOpcode;
    add<Name extends OpcodeName>(name: Name, evaluate: EvaluateOpcode<AppendOpcodeData>): void;
    construct<Name extends OpcodeName>(name: Name, debug: Option<Object>, op1?: Operand1, op2?: Operand2, op3?: Operand3): AppendOpcode;
    evaluate(vm: VM, {type, data}: AppendOpcode): void;
}
export interface AppendOpcode {
    type: number;
    data: AppendOpcodeData;
    name: OpcodeName;
    debug: Option<Object>;
}
export declare const APPEND_OPCODES: AppendOpcodes;
export declare abstract class AbstractOpcode {
    type: string;
    _guid: number;
    constructor();
    toJSON(): OpcodeJSON;
}
export interface Slice {
    ops: AppendOpcode[];
    start: number;
    end: number;
}
export declare abstract class UpdatingOpcode extends AbstractOpcode {
    tag: RevisionTag;
    next: Option<UpdatingOpcode>;
    prev: Option<UpdatingOpcode>;
    abstract evaluate(vm: UpdatingVM): void;
}
export declare type UpdatingOpSeq = ListSlice<UpdatingOpcode>;
export declare function inspect(opcodes: ReadonlyArray<AbstractOpcode>): string;
