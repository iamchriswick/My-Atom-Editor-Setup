export declare type GlimmerObjectClass = typeof GlimmerObject;
export interface Constructor<T extends GlimmerObject> {
    new (...args: any[]): T;
    prototype: T;
}
export interface GlimmerClass<Extensions extends GlimmerObject> extends Constructor<Extensions> {
    new (...args: any[]): Extensions;
    create<Extensions, CreateOptions, T extends typeof GlimmerObject>(this: T & GlimmerClass<Extensions>, properties?: CreateOptions): Extensions & CreateOptions & GlimmerObject;
    extend<Original extends GlimmerObject, Extensions extends GlimmerObject>(this: GlimmerClass<Original>, extensions?: Extensions): GlimmerClass<Original & Extensions>;
}
export declare abstract class GlimmerObjectBase<Extensions> {
}
export default class GlimmerObject {
    static create<Extensions extends GlimmerObject, CreateOptions extends GlimmerObject, T extends typeof GlimmerObject>(this: GlimmerClass<Extensions>, properties?: CreateOptions): Extensions & CreateOptions & GlimmerObject;
    static extend<Original extends GlimmerObject, Extensions extends GlimmerObject>(this: GlimmerClass<Original>, extensions?: Extensions): GlimmerClass<Original & Extensions & GlimmerObject>;
    constructor(properties?: Object);
}
/**
 * Adapter for TypeScript.
 *
 * A shim library could just declare the variable as the type
 * GlimmerClass<FirstInstance>. The key point is that shimming
 * between the two worlds requires writing a static interface
 * definition, as TypeScript isn't willing to treat the dynamic
 * intersection as a valid constructor return type.
 *
 * This function is a noop and is used like this:
 *
 * ```ts
 * // in one file
 * let Person = GlimmerObject.extend({
 *   named: 'Dan'
 * });
 *
 *
 * // in a TypeScript wrapper file
 * import { Person as OriginalPerson } from 'original-definition';
 *
 * interface PersonInstance {
 *   named: string
 * }
 *
 * export let Person = classof<PersonInstance>(OriginalPerson);
 *
 * // in a subclassing file
 * import { Person } from 'wrapped-definition';
 *
 * class FancyPerson extends Person {
 *   salutation: string;
 *
 *   fullName() {
 *     return `${this.salutation} ${this.named}`;
 *   }
 * }
 *
 * FancyPerson.create({ name: 'Tom Dale', salutation: 'Mr.' }).fullName();
 * // typechecks and returns 'Mr. Tom Dale'
 * ```
*/
export declare function classof<T>(klass: any): GlimmerClass<T>;
